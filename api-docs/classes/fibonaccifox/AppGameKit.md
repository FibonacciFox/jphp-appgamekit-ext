# AppGameKit

- **класс** `AppGameKit` (`fibonaccifox\AppGameKit`)
- **исходники** `php/fibonaccifox/AppGameKit.php`

**Описание**

Класс описания методов, реализованных в AppGameKit для <b>x64</b> и <b>x86</b>.

---

# Методы

<a name="method-__construct"></a>

### __construct()
```php
__construct(): void
```

---

<a name="method-getpath"></a>

### getPath()
```php
getPath(string $fileName): string
```
Возвращает преобразованный путь для загрузки файлов в AppGameKit

---

<a name="method-updatewindow"></a>

### UpdateWindow()
```php
UpdateWindow(): void
```
Обновить окно Windows

---

<a name="method-showwindow"></a>

### ShowWindow()
```php
ShowWindow(): void
```
Показать окно Windows

---

<a name="method-initgl"></a>

### InitGL()
```php
InitGL(int $hWnd): void
```
Инициализируем OpenGL и отрисовываем в стороннее окно

---

<a name="method-init"></a>

### Init()
```php
Init(): void
```
Инициализируем AppGameKit

---

<a name="method-acosrad"></a>

### ACosRad()
```php
ACosRad(float $a): float
```
Возвращает арккосинус значения в радианах.

---

<a name="method-arcreateanchorfromhittest"></a>

### ARCreateAnchorFromHitTest()
```php
ARCreateAnchorFromHitTest(int $index): int
```
Создает якорь из заданного результата теста попадания, который может быть использован для отслеживания точки в реальном мире с течением времени. Якоря автоматически регулируют свое положение, чтобы попытаться оставаться неподвижными в точке, обнаруженной в реальном мире, это позволяет разместить объект там, не дрейфуя слишком сильно. Возвращает идентификатор, который вы можете использовать для ссылки на этот якорь позже. Результат теста попадания не обязательно должен существовать после создания из него якоря, после этого вы можете безопасно очистить результаты теста попадания. Якорь будет сохраняться и использовать некоторые ресурсы отслеживания до тех пор, пока вы специально не удалите его с помощью ARDeleteAnchor или не уничтожите сеанс AR.

---

<a name="method-acos"></a>

### ACos()
```php
ACos(float $a): float
```
Возвращает арккосинус значения в градусах.

---

<a name="method-arcreateanchorfromplane"></a>

### ARCreateAnchorFromPlane()
```php
ARCreateAnchorFromPlane(int $index): int
```
Создает якорь из центра данной плоскости, который может быть использован для отслеживания точки в реальном мире с течением времени. Якоря автоматически корректируют свое положение, чтобы попытаться оставаться неподвижными в точке, обнаруженной в реальном мире, это позволяет разместить объект там, не дрейфуя слишком сильно. Возвращает идентификатор, который вы можете использовать для ссылки на этот якорь позже. Результат плоскости не обязательно должен существовать после создания из него якоря, после этого вы можете смело вызывать ARGetPlanesFinish. Якорь будет сохраняться и использовать некоторые ресурсы отслеживания до тех пор, пока вы специально не удалите его с помощью ARDeleteAnchor или не уничтожите сеанс AR.

---

<a name="method-arcontrolcamera"></a>

### ARControlCamera()
```php
ARControlCamera(): void
```
Это необязательная команда, которая сбросит камеру на заданные значения AR. Это может быть полезно, если вы измените положение или поворот камеры, но затем захотите узнать значения AR для этих настроек. Вам не нужно вызывать эту команду, так как значения будут сброшены до значений AR при рендеринге или синхронизации в любом случае.

---

<a name="method-writestring2"></a>

### WriteString2()
```php
WriteString2(int $iFileID, string $str): void
```
Записывает строку в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут прочитаны с помощью ReadString2. Для создания удобочитаемых файлов используйте WriteLine Это использует другой метод от WriteString, который будет быстрее для чтения AGK позже, но он не совместим с ReadString, вы должны использовать ReadString2 для чтения строк, написанных с помощью WriteString2

---

<a name="method-writeline"></a>

### WriteLine()
```php
WriteLine(int $iFileID, string $str): void
```
Записывает завершенную строку CR(\n) в данный файл, который должен быть открыт для записи.

---

<a name="method-writestring"></a>

### WriteString()
```php
WriteString(int $iFileID, string $str): void
```
Записывает строку с нулевым завершением в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут прочитаны с помощью ReadString. Для создания удобочитаемых файлов используйте WriteLine

---

<a name="method-writefloat"></a>

### WriteFloat()
```php
WriteFloat(int $iFileID, float $f): void
```
Записывает 4-байтовый поплавок в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут прочитаны с помощью ReadFloat. Для создания удобочитаемых файлов используйте WriteLine

---

<a name="method-writeinteger"></a>

### WriteInteger()
```php
WriteInteger(int $iFileID, int $i): void
```
Записывает 4-байтовое целое число в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут прочитаны с помощью ReadInteger. Для создания удобочитаемых файлов используйте WriteLine

---

<a name="method-writebyte"></a>

### WriteByte()
```php
WriteByte(int $iFileID, int $b): void
```
Записывает 1-байтовое целое число без знака (0-255) в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут считываться с помощью ReadByte. Для создания удобочитаемых файлов используйте WriteLine

---

<a name="method-worldtoscreeny"></a>

### WorldToScreenY()
```php
WorldToScreenY(float $y): float
```
Преобразует мировую координату Y в координату экрана Y на основе текущего смещения вида и масштабирования. Когда SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен на 20 пикселей вниз, объект на уровне 0,0 в мире появится на уровне -20 (вне экрана) над экраном.

---

<a name="method-viewfile"></a>

### ViewFile()
```php
ViewFile(string $szFilename): void
```
Открывает данный файл во внешнем приложении, подходящем для его типа файла. Как правило, это приложение по умолчанию, выбранное пользователем. Файл должен быть в вашей папке для чтения или записи, вы должны указать имя файла, как если бы вы загружали файл. В настоящее время это работает только на Windows, iOS и Android.

---

<a name="method-worldtoscreenx"></a>

### WorldToScreenX()
```php
WorldToScreenX(float $x): float
```
Преобразует мировую координату X в координату экрана X на основе текущего смещения вида и масштабирования. Когда SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен на 20 пикселей вправо, объект на 0,0 в мире появится на -20 (вне экрана) слева.

---

<a name="method-vibratedevice"></a>

### VibrateDevice()
```php
VibrateDevice(float $seconds): void
```
Вибрирует устройство в течение заданного количества секунд. Работает на iOS и Android. Обратите внимание, что на iOS значение длины игнорируется и происходит только короткая вибрация, это связано с ограничениями Apple.

---

<a name="method-val"></a>

### Val()
```php
Val(string $str, int $base): int
```
Преобразует строку в целое значение. Например, Val("10") вернет значение 10.

---

<a name="method-valfloat"></a>

### ValFloat()
```php
ValFloat(string $str): float
```
Преобразует строку в значение с плавающей запятой. Например, ValFloat("1.045") вернет значение 1.045

---

<a name="method-usenewdefaultfonts"></a>

### UseNewDefaultFonts()
```php
UseNewDefaultFonts(int $mode): void
```
Начиная с версии 2.0.20 AGK имеет новую систему шрифтов, которая может отображать больше символов и отображать символы более плавно, однако для сохранения обратной совместимости она по умолчанию отключена. Чтобы использовать новую систему, установите для этой команды значение 1. Это влияет только на шрифт по умолчанию, если вы его сами не установили.

---

<a name="method-upper"></a>

### Upper()
```php
Upper(string $strin): string
```
Преобразует строку в символы верхнего регистра.

---

<a name="method-updatetweensprite"></a>

### UpdateTweenSprite()
```php
UpdateTweenSprite(int $tweenID, int $spriteID, float $fTime): void
```
Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже запущена на данном спрайте с помощью PlayTweenSprite, иначе ничего не произойдет. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.

---

<a name="method-updatetweentext"></a>

### UpdateTweenText()
```php
UpdateTweenText(int $tweenID, int $textID, float $fTime): void
```
Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже запущена на данном тексте с помощью PlayTweenText, иначе ничего не произойдет. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.

---

<a name="method-updatetweenchar"></a>

### UpdateTweenChar()
```php
UpdateTweenChar(int $tweenID, int $textID, int $charID, float $fTime): void
```
Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Твин должен быть уже запущен на данном персонаже с помощью PlayTweenChar, иначе ничего не произойдет. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.

---

<a name="method-updatetweenobject"></a>

### UpdateTweenObject()
```php
UpdateTweenObject(int $tweenID, int $objectID, float $fTime): void
```
Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже запущена на данном объекте с помощью PlayTweenObject, иначе ничего не произойдет. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.

---

<a name="method-updatetweencamera"></a>

### UpdateTweenCamera()
```php
UpdateTweenCamera(int $tweenID, int $cameraID, float $fTime): void
```
Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже запущена на данной камере с помощью PlayTweenCamera, иначе ничего не произойдет. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.

---

<a name="method-updatetweencustom"></a>

### UpdateTweenCustom()
```php
UpdateTweenCustom(int $tweenID, float $fTime): void
```
Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.

---

<a name="method-updatetweenchain"></a>

### UpdateTweenChain()
```php
UpdateTweenChain(int $chainID, float $fTime): void
```
Обновляет заданную цепочку твинов. Значение времени позволяет вам контролировать, как быстро продвигается цепочка, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что цепочка и подростки, которых она содержит, будут играть в обратном порядке, пока не достигнут начальной точки, однако она не перестанет играть, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную.

---

<a name="method-updateparticles"></a>

### UpdateParticles()
```php
UpdateParticles(int $ID, float $time): void
```
Немедленно опережает излучатель частиц на заданное количество времени. Если вы хотите продвинуть высокочастотный излучатель на большой промежуток времени, такой как 1 секунда, вы должны вызвать эту команду несколько раз с небольшим значением времени, таким как 0,02, чтобы она создавала новые частицы партиями и равномерно распределяла их. Вызов его один раз с большим временным значением 1 секунда создал бы огромную партию частиц сразу и переместил бы их вместе как каплю вместо того, чтобы распространять их.

---

<a name="method-updatedevicesize"></a>

### UpdateDeviceSize()
```php
UpdateDeviceSize(int $w, int $h): void
```
Если по какой-либо причине размеры устройства могут измениться (например, изменение ориентации приводит к повороту видового пространства на новый размер), вызовите эту функцию для обновления внутренних значений.

---

<a name="method-update3dphysicspickjoint"></a>

### Update3DPhysicsPickJoint()
```php
Update3DPhysicsPickJoint(int $jointID, int $positionVec3): void
```
Устанавливает новое положение соединения кирки.

---

<a name="method-update3d"></a>

### Update3D()
```php
Update3D(float $time): void
```
Звонил автоматически. Это расширенная команда для управления процессом обновления. Обычно Update вызывает это и Update2D (), чтобы обновить все в мире. Эта команда обновляет только 3D - объекты, такие как 3D-модели.

---

<a name="method-updatealltweens"></a>

### UpdateAllTweens()
```php
UpdateAllTweens(float $fTime): void
```
Обновления всех подростков начались на отдельных предметах и цепочках. Значение времени позволяет вам контролировать, как быстро продвигаются подростки, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что любые играющие подростки будут играть в обратном порядке, пока не достигнут своих начальных точек, однако они не прекратят играть, когда достигнут начала, и вместо этого будут ждать, пока время снова станет положительным, или ждать, пока вы остановите их вручную.

---

<a name="method-update2d"></a>

### Update2D()
```php
Update2D(float $time): void
```
Звонил автоматически. Это расширенная команда для управления процессом обновления. Обычно Update вызывает это и Update3D (), чтобы обновить все в мире. Эта команда обновляет только 2D-объекты, такие как спрайты и текст.

---

<a name="method-tweensmooth1"></a>

### TweenSmooth1()
```php
TweenSmooth1(): int
```
Использует плавную кривую для перемещения от начала до конца, это позволяет избежать внезапного старта и остановки. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 1.

---

<a name="method-tweensmooth2"></a>

### TweenSmooth2()
```php
TweenSmooth2(): int
```
Использует плавную кривую для перемещения от начала до конца, похожую на TweenSmooth1, но более преувеличенную. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 2.

---

<a name="method-update"></a>

### Update()
```php
Update(float $time): void
```
Обновляет все 2D и 3D объекты в зависимости от заданного времени, анимации, физики и т. Д. Если время равно 0, то для пошагового моделирования используется время последнего кадра. Если вы уже назвали StepPhysics этим фреймом, он не будет вызван снова для этого фрейма. Вызываемый автоматически Sync, вы можете использовать Sync или Update(), Render(), Swap() для ручной синхронизации. Если вы хотите иметь больше контроля, вы можете разбить это дальше, заменив Update на Update2D, Update3D()

---

<a name="method-tweenovershoot"></a>

### TweenOvershoot()
```php
TweenOvershoot(): int
```
Использует эластичный аффект в конце интерполяции. Это единственный метод интерполяции, который превышает заданный диапазон и не подходит для цветов. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 8.

---

<a name="method-tweenlinear"></a>

### TweenLinear()
```php
TweenLinear(): int
```
Использует линейную интерполяцию для перемещения от начала к концу, это самая простая форма интерполяции. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 0.

---

<a name="method-tweeneaseout2"></a>

### TweenEaseOut2()
```php
TweenEaseOut2(): int
```
Использует плавную кривую для движения к концу, похожую на TweenEaseOut1, но более преувеличенную. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 6.

---

<a name="method-tweeneasein2"></a>

### TweenEaseIn2()
```php
TweenEaseIn2(): int
```
Использует плавную кривую для перемещения с самого начала, аналогичную TweenEaseIn1, но более преувеличенную. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 4.

---

<a name="method-tweeneaseout1"></a>

### TweenEaseOut1()
```php
TweenEaseOut1(): int
```
Использует плавную кривую для движения к концу, это позволяет избежать внезапной остановки, но все равно начинается резко. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 5.

---

<a name="method-update3dparticles"></a>

### Update3DParticles()
```php
Update3DParticles(int $ID, float $time): void
```
Немедленно опережает излучатель частиц на заданное количество времени. Если вы хотите продвинуть высокочастотный излучатель на большой промежуток времени, такой как 1 секунда, вы должны вызвать эту команду несколько раз с небольшим значением времени, таким как 0,02, чтобы она создавала новые частицы партиями и равномерно распределяла их. Вызов его один раз с большим временным значением 1 секунда создал бы огромную партию частиц сразу и переместил бы их вместе как каплю вместо того, чтобы распространять их.

---

<a name="method-tweeneasein1"></a>

### TweenEaseIn1()
```php
TweenEaseIn1(): int
```
Использует плавную кривую для движения с самого начала, это позволяет избежать внезапного старта, но все равно резко заканчивается. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 3.

---

<a name="method-truncatestring"></a>

### TruncateString()
```php
TruncateString(string $str, string $character): string
```
Возвращает строку со всеми символами, удаленными после заданного символа. Исходная строка не изменяется, и возвращается новая строка с удаленными символами. Это поиск в обратном направлении от конца строки к началу и при первом появлении символа удаляет его и все, что после него. Обратите внимание, что если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-trunc"></a>

### Trunc()
```php
Trunc(float $a): int
```
Возвращает целочисленную часть значения с плавающей запятой без округления в любом случае.

---

<a name="method-tweenbounce"></a>

### TweenBounce()
```php
TweenBounce(): int
```
Использует эффект отскока в конце интерполяции. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 7.

---

<a name="method-timer"></a>

### Timer()
```php
Timer(): float
```
Получите количество секунд и долей секунд с момента запуска приложения. Точность до миллисекунд, но из-за неточностей с плавающей запятой чем дольше работает приложение, тем менее точным оно становится. Более конкретно, значение времени имеет около 7 значимых цифр точности, так что по мере увеличения числа секунд количество десятичных знаков уменьшается. Если вам нужно только время до ближайшей секунды, то это значение будет хорошо примерно до 16 000 000 секунд.  Вызов этой команды внутренне вызовет системный вызов, чтобы получить количество прошедшего времени, поэтому он будет меняться каждый раз, когда вы его вызываете.

---

<a name="method-terminateapp"></a>

### TerminateApp()
```php
TerminateApp(int $appID): void
```
Немедленно завершает работу указанного приложения. Это следует использовать только в крайних случаях, так как приложение не имеет возможности очистить или закончить то, что оно делает.

---

<a name="method-texttospeechsetup"></a>

### TextToSpeechSetup()
```php
TextToSpeechSetup(): void
```
Инициализирует механизм преобразования текста в речь на устройстве, чтобы он мог воспроизводить звук. Обратите внимание, что это может быть не сразу, вы должны проверить GetTextToSpeechReady, чтобы увидеть, закончил ли он настройку. Вызов других команд преобразования текста в речь, когда он не готов, будет проигнорирован.  В настоящее время работает только на iOS и Android.

---

<a name="method-trimstring"></a>

### TrimString()
```php
TrimString(string $str, string $chars): string
```
Возвращает строку со всеми символами в "символах", удаленными из концов строки. Исходная строка не изменяется, и возвращается новая строка с удаленными символами. Это можно использовать для удаления лишних пробелов с концов входной строки. Обратите внимание, что если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-tanrad"></a>

### TanRad()
```php
TanRad(float $a): float
```
Возвращает тангенс значения в радианах.

---

<a name="method-tan"></a>

### Tan()
```php
Tan(float $a): float
```
Возвращает тангенс значения в градусах.

---

<a name="method-sync"></a>

### Sync()
```php
Sync(): void
```
Обновляет сцену с последней информацией, рисует все спрайты, обновляет глобальные объекты и меняет местами backbuffer в поле зрения. Не рисует спрайты, созданные с помощью указателей на уровне 2, вы должны нарисовать их вручную, вызвав функцию рисования спрайта или назначив их менеджеру спрайтов для пакетного рисования.

---

<a name="method-swap"></a>

### Swap()
```php
Swap(): void
```
Выводит задний буфер на экран и очищает задний буфер для следующего кадра, обновляет глобальные временные переменные. Вызываемый автоматически Sync, вы можете использовать Sync или Update, Render, Swap один за другим для ручной синхронизации.

---

<a name="method-stripstring"></a>

### StripString()
```php
StripString(string $str, string $chars): string
```
Возвращает строку, из которой удалены все символы в "символах". Исходная строка не изменяется, и возвращается новая строка с удаленными символами. Например, StripString("my string", "yn") вернет "m strig". Обратите внимание, что если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-stringtobase64"></a>

### StringToBase64()
```php
StringToBase64(string $input): string
```
Преобразует строку UTF-8 в строку Base64. Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-stopvideo"></a>

### StopVideo()
```php
StopVideo(): void
```
Останавливает видео и удаляет его из поля зрения, используя playVideo, чтобы запустить его с самого начала.

---

<a name="method-stoptweentext"></a>

### StopTweenText()
```php
StopTweenText(int $tweenID, int $textID): void
```
Останавливает данный идентификатор анимации, если он воспроизводится на данном текстовом объекте. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если текст был в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.

---

<a name="method-str"></a>

### Str()
```php
Str(int $valueInt): string
```
Преобразует значение в строку, если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-stoptweensprite"></a>

### StopTweenSprite()
```php
StopTweenSprite(int $tweenID, int $spriteID): void
```
Останавливает данный идентификатор анимации, если он воспроизводится на данном спрайте. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если спрайт находился в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.

---

<a name="method-stoptweenobject"></a>

### StopTweenObject()
```php
StopTweenObject(int $tweenID, int $objectID): void
```
Останавливает данный идентификатор анимации, если он воспроизводится на данном объекте. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если объект находился в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.

---

<a name="method-stoptweenchain"></a>

### StopTweenChain()
```php
StopTweenChain(int $chainID): void
```
Останавливает данную цепь. Если элемент находился в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу. Воспроизведение цепочки снова запустит ее с самого начала.

---

<a name="method-stoptweencustom"></a>

### StopTweenCustom()
```php
StopTweenCustom(int $tweenID): void
```
Останавливает данный пользовательский идентификатор анимации, если он воспроизводится. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если твин был в середине интерполяции, его значения останутся на своих текущих значениях, он не будет переходить к концу или возвращаться к началу.

---

<a name="method-stoptweenchar"></a>

### StopTweenChar()
```php
StopTweenChar(int $tweenID, int $textID, int $charID): void
```
Останавливает данный идентификатор анимации, если он воспроизводится на заданном символе текстового объекта. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если символ находился в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.

---

<a name="method-stoptweencamera"></a>

### StopTweenCamera()
```php
StopTweenCamera(int $tweenID, int $cameraID): void
```
Останавливает данный идентификатор анимации, если он воспроизводится на данной камере. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если камера находилась в середине интерполяции, она останется в своем текущем положении, она не будет переходить к концу или возвращаться к началу.

---

<a name="method-stoptextinput"></a>

### StopTextInput()
```php
StopTextInput(): void
```
Эта команда останавливает и скрывает любое приглашение ввода текста, ранее запущенное с помощью команды StartTextInput.

---

<a name="method-stopsoundrecording"></a>

### StopSoundRecording()
```php
StopSoundRecording(): void
```
Еще не функционирует.

---

<a name="method-stopsprite"></a>

### StopSprite()
```php
StopSprite(int $iSpriteIndex): void
```
Останавливает анимацию спрайта, сохраняя значения, используемые для его настройки.

---

<a name="method-stopsoundinstance"></a>

### StopSoundInstance()
```php
StopSoundInstance(int $iID): void
```
Останавливает текущий экземпляр, если он еще этого не сделал. При этом экземпляр удаляется, и его идентификатор больше не может быть использован. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.

---

<a name="method-stopspeaking"></a>

### StopSpeaking()
```php
StopSpeaking(): void
```
Немедленно останавливает любой произносимый текст и удаляет все элементы из очереди.  В настоящее время работает только на iOS и Android.

---

<a name="method-stopsound"></a>

### StopSound()
```php
StopSound(int $iID): void
```
Остановите звук, воспроизводимый в данный момент на указанном звуковом номере.

---

<a name="method-stopscreenrecording"></a>

### StopScreenRecording()
```php
StopScreenRecording(): void
```
Останавливает любую текущую запись экрана. Если запись уже остановлена, то это не имеет никакого эффекта. В iOS это предложит пользователю отредактировать и/или сохранить видео, а также отказаться от него. На Android пользователь не видит никаких изменений, и видео молча сохраняется в фоновом режиме.

---

<a name="method-stopobjectanimation"></a>

### StopObjectAnimation()
```php
StopObjectAnimation(int $objID): void
```
Останавливает любую анимацию, которая в данный момент воспроизводится на объекте, и оставляет кости в их текущем положении. Если объект в данный момент находится в подростковом возрасте, то анимация также будет остановлена с костями, оставленными в середине анимации.

---

<a name="method-stopskeleton2danimation"></a>

### StopSkeleton2DAnimation()
```php
StopSkeleton2DAnimation(int $iSkeleton): void
```
Остановите оживление скелета

---

<a name="method-stopmusic"></a>

### StopMusic()
```php
StopMusic(): void
```
Останавливает любое воспроизведение музыки, после чего музыка может быть перезапущена только вызовом PlayMusic.

---

<a name="method-step3dphysicsworld"></a>

### Step3DPhysicsWorld()
```php
Step3DPhysicsWorld(): void
```
Вызовите перед командой Sync() в нижней части цикла. Это шагнет в мир физики. Сохраняет физику постоянной независимо от частоты кадров. Не вызывая эту команду, вы приостановите действие физического мира.

---

<a name="method-stepphysics"></a>

### StepPhysics()
```php
StepPhysics(float $time): void
```
Шагает физическое моделирование на определенное количество времени. Это значение времени выражается в секундах и может включать доли секунд. Шаговое моделирование физики на большое значение времени (больше, чем, скажем, 0,1) может привести к неопределенному поведению и движению физических объектов друг через друга. Не требуется, чтобы вы вызывали эту команду в своем игровом цикле, если вы ее не вызываете, Sync или Update вызовут ее для вас с последним временем кадра, чтобы позволить физическому моделированию догнать вас в реальном времени. Если вы действительно вызываете StepPhysics, то он не будет вызван для вас синхронизацией или обновлением для этого кадра, это позволяет вам сделать свой собственный физический хронометраж, если вы предпочитаете. При использовании фиксированного временного шага каждый кадр ваша физика будет работать точно так же на всех устройствах и во всех частотах кадров, но снижение fps приведет к тому, что физика будет идти медленнее, так как она всегда будет шагать одно и то же количество времени, независимо от того, был ли кадр быстрым или медленным. Использование переменного шага для каждого кадра позволит физике двигаться с одинаковой скоростью независимо от частоты кадров, но она больше не будет детерминированной между устройствами и различными частотами кадров. Например, если ваша игра зависит от физического объекта, падающего и подпрыгивающего на одну и ту же высоту каждый раз, когда он запускается, то вы должны использовать фиксированный временной шаг. Если положение физических объектов не важно для вашей игровой логики, то переменный временной шаг может быть лучшим.

---

<a name="method-stopmusicogg"></a>

### StopMusicOGG()
```php
StopMusicOGG(int $musicID): void
```
Останавливает музыкальный файл и сбрасывает его положение в начало файла.

---

<a name="method-stopgpstracking"></a>

### StopGPSTracking()
```php
StopGPSTracking(): void
```
Останавливает обновление местоположения GPS, используйте это для экономии заряда батареи, когда вам больше не нужно местоположение.

---

<a name="method-starttextinput"></a>

### StartTextInput()
```php
StartTextInput(): void
```
Эта команда выводит текстовое приглашение ввода над вашим приложением, в то время как ваше приложение продолжает работать в фоновом режиме. Допустимыми символами являются значения ASCII в диапазоне от 32 до 126 включительно, если только вы не активировали новые шрифты по умолчанию с помощью UseNewDefaultFonts, и в этом случае можно использовать любые символы Unicode. Если для ввода текста на этом устройстве требуется виртуальная клавиатура, то она будет отображаться поверх вашего приложения. Вы не можете предполагать, что какая-либо часть вашего приложения будет видна во время ввода текста, хотя ваш код будет продолжать работать. Когда пользователь закончит ввод текста, GetTextInputCompleted вернет 1, а GetTextInputCancelled сообщит вам, завершил ли он ввод текста или отменил его. На клавиатурных устройствах отмена производится с помощью клавиши escape, а завершение-с помощью клавиши enter. В случае успеха вы можете получить введенный текст с помощью GetTextInput.

---

<a name="method-startscreenrecording"></a>

### StartScreenRecording()
```php
StartScreenRecording(string $szFilename, int $microphone): void
```
Начинает запись экрана и сохранение его в файл. В настоящее время поддерживается только на iOS 9.0 и выше и Android 5.0 и выше. В iOS имя файла игнорируется, так как устройство всегда сохраняет запись в фотопленке. На Android параметр микрофона может быть установлен в 1 для записи звука с микрофона устройства во время записи. Значение 0 приведет к созданию бесшумного видео, так как Android не поддерживает запись звука непосредственно из приложения. Однако аудиовыход из приложения может быть слышен через микрофон при использовании режима 1. Запись через микрофон требует, чтобы вы включили разрешение "RecordAudio" при экспорте вашего APK.  В iOS значение микрофона 1 будет записывать как аудиовыход приложения, так и микрофон, а значение 0 будет записывать только звук приложения. На Android 6 и ниже запись может прекратиться в любое время, например, если приложение отправлено в фоновый режим или активировано другое действие, например покупка в приложении. На Android 7 и выше запись будет приостановлена, когда приложение находится в фоновом режиме, и возобновлена, когда приложение возобновится. На iOS запись будет продолжаться после таких перерывов до тех пор, пока не будет вызвана функция StopScreenRecording.

---

<a name="method-sqrt"></a>

### Sqrt()
```php
Sqrt(float $a): float
```
Возвращает квадратный корень из значения с плавающей запятой.

---

<a name="method-spriteraycastsingle"></a>

### SpriteRayCastSingle()
```php
SpriteRayCastSingle(int $sprite, float $x, float $y, float $x2, float $y2): int
```
Бросает луч через определенный спрайт (может быть физический или не физический) и сохраняет результат любого пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Эта функция уникальна тем, что она также работает со всеми спрайтами, даже с теми, у которых не включена физика, но спрайту должна быть назначена форма с помощью одной из команд sprite shape. Возвращает 1, если произошло столкновение, и 0, если нет.

---

<a name="method-spriteraycastgroup"></a>

### SpriteRayCastGroup()
```php
SpriteRayCastGroup(int $group, float $x, float $y, float $x2, float $y2): int
```
Бросает луч через все спрайты, которые имеют форму (включая физические спрайты), и сохраняет результат любого пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Физические спрайты будут использовать только основную форму, назначенную спрайту с помощью SetSpriteShape, чтобы проверить, что составные формы используют PhysicsRayCast. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Спрайтам должна быть назначена форма с помощью одной из команд sprite shape, иначе она не будет включена в результаты столкновения. Эта функция медленнее, чем физические лучи, поскольку она не может использовать оптимизированные структуры, которые представляют, где находятся спрайты в мире относительно луча. Эта функция фильтрует проверяемые спрайты, поэтому проверяются только спрайты определенной группы. По умолчанию спрайты создаются в группе 0. Эта функция может отслеживать только спрайты, созданные с помощью CreateSprite, если вы вручную выделили память для спрайтов, вам нужно будет циклически просматривать список спрайтов с помощью SpriteRayCastSingle или использовать физическую версию. Возвращает 1, если произошло столкновение, и 0, если нет.

---

<a name="method-startgpstracking"></a>

### StartGPSTracking()
```php
StartGPSTracking(): void
```
Запускает процесс получения местоположения GPS, если это возможно, на текущем устройстве. Это может вызвать запрос разрешения на некоторых платформах при первом вызове. Если пользователь отказывает в разрешении, то GetGPSSensorExists может вернуть 0 с этого момента. Вы должны вызывать эту команду только тогда, когда пользователь выполняет действие, которое, как он знает, потребует определения местоположения, в противном случае он может отклонить его и никогда больше не получить запрос (ему придется войти в настройки своего устройства, чтобы включить его). Эта команда будет потреблять много энергии батареи, поэтому используйте StopGPSTracking, когда вам больше не нужно местоположение. Эта команда работает на iOS, Android, Mac и Windows 7 и выше. Вызов этой команды может занять некоторое время, чтобы получить точное местоположение от GetRawGPSLatitude и GetRawGPSLongitude.

---

<a name="method-spriteraycast"></a>

### SpriteRayCast()
```php
SpriteRayCast(float $x, float $y, float $x2, float $y2): int
```
Бросает луч через все спрайты, имеющие форму (включая физические спрайты), и сохраняет результат любого пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Физические спрайты будут использовать только основную форму, назначенную спрайту с помощью SetSpriteShape, чтобы проверить, что составные формы используют PhysicsRayCast. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Спрайтам должна быть назначена форма с помощью одной из команд sprite shape, иначе она не будет включена в результаты столкновения. Эта функция медленнее, чем физика только лучей, поскольку она не может использовать оптимизированные структуры, которые представляют, где находятся спрайты в мире относительно луча. Эта функция может отслеживать только спрайты, созданные с помощью CreateSprite, если вы вручную выделили память для спрайтов, вам нужно будет циклически просматривать список спрайтов с помощью SpriteRayCastSingle или использовать физическую версию. Возвращает 1, если произошло столкновение, и 0, если нет.

---

<a name="method-spherecast3dphysicsobject"></a>

### SphereCast3DPhysicsObject()
```php
SphereCast3DPhysicsObject(int $objID, int $rayID, int $fromVec3ID, int $toVec3ID, float $radius): int
```
Отбрасывает форму столкновения сфер по длине луча. Возвращает 1, если указанный объект был поражен, и 0, если он не был поражен.

---

<a name="method-spherecast3dphysics"></a>

### SphereCast3DPhysics()
```php
SphereCast3DPhysics(int $rayID, int $fromVec3ID, int $toVec3ID, float $radius): void
```
Отбрасывает форму столкновения сфер по длине луча.

---

<a name="method-speak"></a>

### Speak()
```php
Speak(string $text, int $delay): void
```
Ставит данный текст в очередь для произнесения. Если какой - то текст уже произносится, то данный текст будет произнесен после окончания текущей речи. Эта команда может быть вызвана несколько раз в быстрой последовательности, чтобы поставить в очередь много текста. Вы можете вызвать IsSpeaking, чтобы проверить, когда очередь пуста и весь текст был произнесен или отменен. Обратите внимание, что при первом вызове этой команды может возникнуть задержка при установке незнакомого языка с помощью SetSpeechLanguage. Например, использование французского языка на устройстве, настроенном для английского языка, попытается загрузить движок французского языка, прежде чем начать говорить текст.  Если приложение будет отправлено в фоновый режим, то речь остановится, и весь текст будет удален из очереди.  Вы можете указать необязательную задержку в миллисекундах, чтобы устройство подождало, прежде чем начать произносить текст.  В настоящее время работает только на iOS и Android.

---

<a name="method-spriteraycastcategory"></a>

### SpriteRayCastCategory()
```php
SpriteRayCastCategory(int $category, float $x, float $y, float $x2, float $y2): int
```
Бросает луч через все спрайты, которые имеют форму (включая физические спрайты), и сохраняет результат любого пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Физические спрайты будут использовать только основную форму, назначенную спрайту с помощью SetSpriteShape, чтобы проверить, что составные формы используют PhysicsRayCast. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Спрайтам должна быть назначена форма с помощью одной из команд sprite shape, иначе она не будет включена в результаты столкновения. Эта функция медленнее, чем физические лучи, поскольку она не может использовать оптимизированные структуры, которые представляют, где находятся спрайты в мире относительно луча. Эта функция фильтрует проверяемые спрайты, поэтому проверяются только спрайты определенных категорий. Параметр category - это побитовое поле, которое использует младшие 16 битов для представления каждой из возможных 16 категорий, используемых при настройке спрайта. Значение по умолчанию all 1s означает, что все категории будут включены, тогда как значение all 0s означает, что никакие категории не будут включены. Вы можете установить отдельные биты, чтобы установить, какие из них должны быть проверены. Эта функция может отслеживать только спрайты, созданные с помощью CreateSprite, если вы вручную выделили память для спрайтов, вам нужно будет циклически просматривать список спрайтов с помощью SpriteRayCastSingle или использовать физическую версию. Возвращает 1, если произошло столкновение, и 0, если нет.

---

<a name="method-stand3dphysicscharactercontroller"></a>

### Stand3DPhysicsCharacterController()
```php
Stand3DPhysicsCharacterController(int $objID): void
```
Стоит контроллер

---

<a name="method-sleep"></a>

### Sleep()
```php
Sleep(int $milliseconds): void
```
Приостановите работу приложения на определенное количество миллисекунд. Не рекомендуется использовать эту команду для приостановки приложения более чем на один кадр (примерно 17 миллисекунд).

---

<a name="method-sin"></a>

### Sin()
```php
Sin(float $a): float
```
Возвращает синус значения в градусах.

---

<a name="method-spaces"></a>

### Spaces()
```php
Spaces(int $length): string
```
Создает строку пробелов, равную переданной длине.

---

<a name="method-showrewardadchartboost"></a>

### ShowRewardAdChartboost()
```php
ShowRewardAdChartboost(): void
```
Создает полноэкранную видеорекламу вознаграждения для получения дохода с помощью Chartboost. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetChartboostDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается загрузить объявление при следующем вызове этой команды. Для Chartboost вы должны запустить процесс кэширования вручную с помощью CacheRewardAdChartboost, вам нужно только вызвать его один раз. После показа видеорекламы с вознаграждением новая видеореклама будет автоматически кэширована. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetRewardAdLoadedChartboost. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено. Проверьте GetRewardAdRewardedChartboost, чтобы узнать, завершил ли пользователь просмотр объявления о вознаграждении и должен ли он быть вознагражден. Он будет установлен в 0, когда вы вызовете эту команду, а затем установлен в 1, когда они закончат просмотр

---

<a name="method-sinrad"></a>

### SinRad()
```php
SinRad(float $a): float
```
Возвращает синус значения в радианах.

---

<a name="method-simplifypath"></a>

### SimplifyPath()
```php
SimplifyPath(string $szPath): string
```
Удаляет любые вхождения ../ or ..\ и соответствующим образом сокращает путь, удаляя папки. Также заменяет все задние косые черты на передние косые черты, так как передние косые черты будут работать на любой платформе. Это работает как с относительными, так и с абсолютными путями, если путь абсолютен, то все вхождения ../ будут удалены, даже если их слишком много. Если путь относителен, то любые вхождения../, которые запускают путь, не будут удалены. Например, относительный путь "../../MyFile.txt" не может быть упрощено далее, в то время как "C:/../../MyFile.txt" будет преобразован в "C:/MyFile.txt". Путь может начинаться с префикса "raw:" или нет, принимаются оба варианта. Если вы используете эту функцию в Tier 2, то вы должны удалить возвращаемую строку с помощью agk::DeleteString (), когда закончите с ней.

---

<a name="method-showrewardadadmob"></a>

### ShowRewardAdAdMob()
```php
ShowRewardAdAdMob(): void
```
Создает полноэкранную видеорекламу вознаграждения для получения дохода с помощью AdMob. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetAdMobRewardAdDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetRewardAdLoadedAdMob. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено. Проверьте GetRewardAdRewardedAdMob, чтобы узнать, завершил ли пользователь просмотр объявления о вознаграждении и должен ли он быть вознагражден. Он будет установлен в 0, когда вы вызовете эту команду, а затем установлен в 1, когда они закончат просмотр

---

<a name="method-showimagecapturescreen"></a>

### ShowImageCaptureScreen()
```php
ShowImageCaptureScreen(): int
```
Эта функция устарела, вместо нее используйте SetDeviceCameraToImage. Предоставляет пользователю возможность сделать снимок с помощью камеры устройства, если таковая имеется. Если устройство не имеет камеры или иным образом не может быть использовано, это вернет 0, и ваше приложение будет продолжать работать в обычном режиме. Это не сразу захватывает изображение, в зависимости от платформы ваше приложение может продолжать работать в фоновом режиме, пока пользователь делает снимок, или оно может приостановить выполнение во время съемки. В любом случае вы должны предположить, что ваше приложение продолжает работать, но больше не видно, используйте IsCapturingImage, чтобы проверить, когда пользователь возвращается из процесса захвата изображения, и GetCapturedImage, чтобы обнаружить результат этого процесса. В настоящее время это не работает на Mac.

---

<a name="method-showfullscreenadvertamazon"></a>

### ShowFullscreenAdvertAmazon()
```php
ShowFullscreenAdvertAmazon(): void
```
Создает полноэкранную (интерстициальную) рекламу для получения дохода с помощью Amazon Ads. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetAmazonAdDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetFullscreenAdvertLoadedAmazon. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено.

---

<a name="method-showfullscreenadvertchartboost"></a>

### ShowFullscreenAdvertChartboost()
```php
ShowFullscreenAdvertChartboost(): void
```
Создает полноэкранную (интерстициальную) рекламу для получения дохода с помощью Chartboost. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetChartboostDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetFullscreenAdvertLoadedChartboost. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено.

---

<a name="method-showfullscreenadvertadmob"></a>

### ShowFullscreenAdvertAdMob()
```php
ShowFullscreenAdvertAdMob(): void
```
Создает полноэкранную (интерстициальную) рекламу для получения дохода с помощью AdMob. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetAdMobDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetFullscreenAdvertLoadedAdMob. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено.

---

<a name="method-showchooseimagescreen"></a>

### ShowChooseImageScreen()
```php
ShowChooseImageScreen(): int
```
Предоставляет пользователю возможность выбрать изображение, хранящееся на его текущей платформе, например фотографию на телефоне или изображение, сохраненное на ПК. Это не сразу захватывает изображение, в зависимости от платформы ваше приложение может продолжать работать в фоновом режиме, пока пользователь выбирает изображение, или оно может приостановить выполнение, пока выбирается изображение. В любом случае вы должны предположить, что ваше приложение продолжает работать, но больше не видно, использовать IsChoosingImage, чтобы проверить, когда пользователь возвращается из процесса выбора изображения, и GetChosenImage, чтобы обнаружить результат этого процесса. Эта функция возвращает 1, если ей удалось отобразить экран выбора, и 0 в противном случае.

---

<a name="method-sharetext"></a>

### ShareText()
```php
ShareText(string $szText): void
```
Отправляет данный текст в операционную систему, которая затем спросит пользователя, как он хочет поделиться этим текстом, например, через Facebook, Twitter и т. Д. Это работает только на iOS и Android.

---

<a name="method-sharesnapchatimage"></a>

### ShareSnapChatImage()
```php
ShareSnapChatImage(string $imageFile, string $stickerFile, string $caption, string $url): void
```
Отправляет указанное изображение в приложение SnapChat на текущем устройстве вместе с дополнительным файлом стикера, подписью и URL-адресом. Затем пользователь может изменить изображение с помощью приложения SnapChat и решить, стоит ли делиться им с друзьями. Если у пользователя не установлено приложение SnapChat, то вместо него на странице приложения SnapChat будет открыт магазин приложений. Эта команда будет работать только на Android и iOS 10 или выше

---

<a name="method-shareimage"></a>

### ShareImage()
```php
ShareImage(string $szFilename): void
```
Отправляет данное изображение в операционную систему, которая затем спросит пользователя, как он хочет поделиться этим изображением, например, через Facebook, Twitter и т. Д. Файл должен быть в вашей папке для чтения или записи, или вы можете использовать путь "raw:" для загрузки из любого места, вы должны указать имя файла, как если бы вы загружали файл. Это работает только на iOS и Android.

---

<a name="method-sharefile"></a>

### ShareFile()
```php
ShareFile(string $szFilename): void
```
Отправляет данный файл в операционную систему, которая затем спросит пользователя, как он хочет поделиться им, например, по электронной почте, NFC и т. Д. Файл может находиться в вашей папке для чтения или записи, или вы можете использовать путь "raw:" для загрузки из любого места, вы должны указать имя файла, как если бы вы загружали файл. Это работает только на iOS и Android.

---

<a name="method-shareimageandtext"></a>

### ShareImageAndText()
```php
ShareImageAndText(string $szFilename, string $szText): void
```
Отправляет данное изображение и текст в операционную систему, которая затем спросит пользователя, как он хочет поделиться текстом, например, через Facebook, Twitter и т. Д. Файл изображения должен находиться в вашей папке для чтения или записи, или вы можете использовать путь "raw:" для загрузки из любого места, вы должны указать имя файла, как если бы вы загружали файл. Это работает только на iOS и Android.

---

<a name="method-sha512"></a>

### Sha512()
```php
Sha512(string $str): string
```
Хэширует строку с помощью алгоритма SHA512 для получения 64-символьной шестнадцатеричной строки. Это односторонняя хэш-функция, которая может использоваться с солением (добавлением секретной строки) для паролей или обнаружения несанкционированного доступа к параметрам, передаваемым серверу. Если вы вызываете эту функцию из уровня 2, то вы должны удалить возвращаемую строку с помощью agk::DeleteString, когда закончите с ней.

---

<a name="method-sha256"></a>

### Sha256()
```php
Sha256(string $str): string
```
Хэширует строку с помощью алгоритма SHA256 для получения 32-символьной шестнадцатеричной строки. Это односторонняя хэш-функция, которая может использоваться с солением (добавлением секретной строки) для паролей или обнаружения несанкционированного доступа к параметрам, передаваемым серверу. Если вы вызываете эту функцию из уровня 2, то вы должны удалить возвращаемую строку с помощью agk::DeleteString, когда закончите с ней.

---

<a name="method-sha1"></a>

### Sha1()
```php
Sha1(string $str): string
```
Хэширует строку с помощью алгоритма SHA1 для получения 40-символьной шестнадцатеричной строки. Это односторонняя хэш-функция, которая может использоваться с солением (добавлением секретной строки) для паролей или обнаружения несанкционированного доступа к параметрам, передаваемым серверу. Если вы вызываете эту функцию из уровня 2, то вы должны удалить возвращаемую строку с помощью agk::DeleteString с помощью DeleteString (), когда закончите с ней.

---

<a name="method-setupclouddata"></a>

### SetupCloudData()
```php
SetupCloudData(string $reserved): void
```
Настраивает устройство на использование облачных данных на совместимых платформах, в настоящее время эту функцию поддерживают только Android и iOS. Облачные данные можно использовать для совместного использования настроек на нескольких устройствах, работающих под управлением одного и того же приложения. Например, сохранение некоторых настроек приложения или прогресса на одном устройстве с помощью команд облачных данных сделает их доступными (через короткий промежуток времени) на всех других устройствах на той же платформе. Обратите внимание, что данные не пересекаются с платформами, поэтому данные, сохраненные на iOS, недоступны на Android, а данные, сохраненные на Android, недоступны на iOS.  В iOS это использует iCloud Drive для хранения данных, поэтому пользователь должен войти в iCloud и включить iCloud Drive, вы можете определить, были ли они сделаны с помощью GetCloudDataAllowed. Вы также должны добавить iCloud в свой профиль подготовки, но вам не нужно создавать какие-либо контейнеры. Этот профиль подготовки необходимо использовать при экспорте приложения. На iOS вы ограничены 1 МБ памяти.  На Android это использует Android Drive AppData, поэтому пользователь должен войти в систему с учетной записью Google на устройстве. Вы также должны добавить проект Google API для вашего приложения здесь https: console.developers.google.com и создайте идентификатор клиента OAuth в разделе учетные данные. Скажите ему, что запрос исходит от Android, дайте ему имя по вашему выбору и назовите имя пакета вашего приложения. Вам нужно будет дать ему SHA-1 fignerprint файла хранилища ключей, который вы будете использовать для подписи вашего APK, это делается для того, чтобы он мог проверить, что только APKS, подписанные вами, могут использовать сгенерированный идентификатор клиента OAuth. Программа "keytool" является частью Java Development Kit (JDK). После создания вам не нужно ничего делать с токеном OAuth, он будет использоваться автоматически при вызове команд облачных данных. На Android любые данные, которые вы храните, будут засчитываться в лимит хранения Google Диска пользователя, они не могут получить доступ к файлам, хранящимся в вашем приложении, но они могут очистить данные приложения в настройках своего диска.  Широковещательные приложения будут использовать хранилище данных AGK Player и совместно использовать переменные во всех ваших широковещательных приложениях, поэтому будьте осторожны с перезаписью значений, если два ваших приложения имеют одно и то же имя переменной. Данные, которые вы храните в хранилище данных AGK Player, будут видны только вам и вашим устройствам.  Эта команда должна быть вызвана перед любыми другими командами облачных данных, кроме GetCloudDataAllowed, которые могут быть вызваны в любое время. На Android вы должны спросить пользователя, хочет ли он хранить данные на своем диске, прежде чем вызывать setup, так как эта команда может попросить пользователя войти в свой аккаунт Google.

---

<a name="method-setwindowtitle"></a>

### SetWindowTitle()
```php
SetWindowTitle(string $szTitle): void
```
Задает заголовок окна для тех платформ, которые работают в окне (например, Windows, Mac).

---

<a name="method-setwindowsize"></a>

### SetWindowSize()
```php
SetWindowSize(int $width, int $height, int $fullscreen): void
```
Это устанавливает размер окна для платформ, которые его поддерживают, таких как Windows и Mac. Это не повлияет на мобильные устройства. В полноэкранном режиме ширина и высота будут игнорироваться, а разрешение рабочего стола будет использоваться. По умолчанию размер окна будет отрегулирован таким образом, чтобы он всегда помещался на экране, в том числе освобождая место для панели задач в Windows. Это означает, что ваш конечный размер окна может быть немного меньше, чем выбранный вами размер. Вы можете переопределить это, установив параметр allowOverSized равным 1, который удалит все проверки границ и позволит вам создавать окна размером больше текущего экрана. Если параметр fullscreen установлен в 1, то параметр allowOverSized не имеет никакого эффекта.

---

<a name="method-setwindowposition"></a>

### SetWindowPosition()
```php
SetWindowPosition(int $x, int $y): void
```
Это устанавливает положение окна для платформ, которые его поддерживают, таких как Windows и Mac. Если окно в данный момент полноэкранное, то это никак не повлияет. Это не повлияет на мобильные устройства.

---

<a name="method-setvirtualresolution"></a>

### SetVirtualResolution()
```php
SetVirtualResolution(int $iWidth, int $iHeight): void
```
Подход по умолчанию для системы координат в AGK заключается в использовании процентной системы, где 0,0 представляет верхний левый угол, а 100,100-нижний правый. Альтернативный подход заключается в обработке платформы с фиксированным разрешением, например 320 x 480. Любые платформы, которые не соответствуют этому разрешению, будут масштабированы, чтобы максимально соответствовать черным границам, где это необходимо.

---

<a name="method-setwindowallowresize"></a>

### SetWindowAllowResize()
```php
SetWindowAllowResize(int $mode): void
```
Это устанавливает окно устанавливает, разрешено ли пользователю изменять размер окна, по умолчанию это значение равно 0

---

<a name="method-setvirtualjoystickvisible"></a>

### SetVirtualJoystickVisible()
```php
SetVirtualJoystickVisible(int $index, int $visible): void
```
Устанавливает, виден ли джойстик на экране, это не влияет на его способность принимать ввод, используйте SetVirtualJoystickActive, чтобы повлиять на то, будет ли виртуальный джойстик принимать ввод. Невидимый джойстик все еще может быть активен.

---

<a name="method-setvirtualjoysticksize"></a>

### SetVirtualJoystickSize()
```php
SetVirtualJoystickSize(int $index, float $size): void
```
Задает диаметр виртуального джойстика в экранных координатах. Изменение размера виртуального джойстика во время его использования изменит текущие возвращаемые значения X и Y.

---

<a name="method-setvirtualjoystickposition"></a>

### SetVirtualJoystickPosition()
```php
SetVirtualJoystickPosition(int $index, float $x, float $y): void
```
Задает положение виртуального джойстика в экранных координатах. Вы можете использовать GetVirtualWidth и GetVirtualHeight, чтобы найти текущие границы экрана. Джойстик будет центрирован в заданном положении x и y. Перемещение виртуального джойстика во время его использования изменит текущие возвращаемые значения X и Y.

---

<a name="method-setvirtualjoystickimageinner"></a>

### SetVirtualJoystickImageInner()
```php
SetVirtualJoystickImageInner(int $index, int $imageID): void
```
Устанавливает изображение, используемое внутренней (подвижной) частью джойстика. Вы можете использовать идентификатор изображения 0, чтобы вернуть его к изображению по умолчанию.

---

<a name="method-setvirtualjoystickdeadzone"></a>

### SetVirtualJoystickDeadZone()
```php
SetVirtualJoystickDeadZone(float $threshold): void
```
Устанавливает мертвую зону для всех виртуальных джойстиков так, чтобы любое значение X или Y ниже заданного порога возвращало 0. Это значение должно быть между 0 и 1, по умолчанию оно равно 0,15.

---

<a name="method-setvirtualjoystickimageouter"></a>

### SetVirtualJoystickImageOuter()
```php
SetVirtualJoystickImageOuter(int $index, int $imageID): void
```
Устанавливает изображение, используемое внешней (фиксированной) частью джойстика. Вы можете использовать идентификатор изображения 0, чтобы вернуть его к изображению по умолчанию.

---

<a name="method-setvirtualjoystickalpha"></a>

### SetVirtualJoystickAlpha()
```php
SetVirtualJoystickAlpha(int $index, int $alpha1, int $alpha2): void
```
Устанавливает прозрачность виртуального джойстика на экране. Виртуальный джойстик состоит из двух частей: внутренней подвижной части и внешней статической части. Alpha1 устанавливает прозрачность внешней части в диапазоне 0-255, при этом 255 полностью непрозрачны. Alpha2 устанавливает прозрачность внутренней части в диапазоне 0-255.

---

<a name="method-setvirtualjoystickactive"></a>

### SetVirtualJoystickActive()
```php
SetVirtualJoystickActive(int $index, int $active): void
```
Устанавливает, будет ли джойстик захватывать события мыши и касания. Если установлено значение 0, то он не будет захватывать входные данные и не будет обновлять свои значения X и Y, они вернутся к 0. Это не повлияет на видимость виртуального джойстика, используйте SetVirtualJoystickVisible, чтобы изменить его видимость.

---

<a name="method-setvirtualbuttontext"></a>

### SetVirtualButtonText()
```php
SetVirtualButtonText(int $index, string $str): void
```
Устанавливает текст, отображаемый в центре кнопки.

---

<a name="method-setvirtualbuttonvisible"></a>

### SetVirtualButtonVisible()
```php
SetVirtualButtonVisible(int $index, int $visible): void
```
Устанавливает, виден ли виртуальный объект на экране, это не влияет на его способность принимать ввод, используйте SetVirtualButtonActive, чтобы повлиять на то, будет ли виртуальная кнопка принимать ввод. Невидимая кнопка все еще может быть активна.

---

<a name="method-setvirtualbuttonsize"></a>

### SetVirtualButtonSize()
```php
SetVirtualButtonSize(int $index, float $size): void
```
Задает размер виртуальной кнопки в координатах экрана.

---

<a name="method-setvirtualbuttonimageup"></a>

### SetVirtualButtonImageUp()
```php
SetVirtualButtonImageUp(int $index, int $imageID): void
```
Устанавливает изображение, используемое кнопкой, когда она не нажата. Вы можете использовать идентификатор изображения 0, чтобы вернуть его к изображению по умолчанию.

---

<a name="method-setvirtualbuttonimagedown"></a>

### SetVirtualButtonImageDown()
```php
SetVirtualButtonImageDown(int $index, int $imageID): void
```
Устанавливает изображение, используемое кнопкой при ее нажатии. Вы можете использовать идентификатор изображения 0, чтобы вернуть его к изображению по умолчанию.

---

<a name="method-setvirtualbuttoncolor"></a>

### SetVirtualButtonColor()
```php
SetVirtualButtonColor(int $index, int $red, int $green, int $blue): void
```
Устанавливает цвет виртуальной кнопки по заданному индексу. По умолчанию кнопки имеют оттенки серого, так что они могут принимать различные цвета. Цвета должны быть указаны в диапазоне 0-255.

---

<a name="method-setvirtualbuttonposition"></a>

### SetVirtualButtonPosition()
```php
SetVirtualButtonPosition(int $index, float $x, float $y): void
```
Задает положение виртуальной кнопки в координатах экрана. Вы можете использовать GetVirtualWidth и GetVirtualHeight, чтобы найти текущие границы экрана. Кнопка будет центрирована по заданным координатам x и y.

---

<a name="method-setvirtualbuttonalpha"></a>

### SetVirtualButtonAlpha()
```php
SetVirtualButtonAlpha(int $index, int $alpha): void
```
Устанавливает прозрачность виртуальной кнопки по заданному индексу. Альфа-значение должно находиться в диапазоне 0-255, где 255 полностью непрозрачно.

---

<a name="method-setvirtualbuttonactive"></a>

### SetVirtualButtonActive()
```php
SetVirtualButtonActive(int $index, int $active): void
```
Устанавливает, будет ли виртуальный захватывать события мыши и касания. Если установлено значение 0, он не будет захватывать входные данные и не будет обновлять свое нажатое состояние, он вернется к 0 (вверх). Это не повлияет на видимость виртуальной кнопки, используйте SetVirtualButtonVisible, чтобы изменить ее видимость.

---

<a name="method-setviewzoommode"></a>

### SetViewZoomMode()
```php
SetViewZoomMode(int $mode): void
```
Устанавливает режим масштабирования из верхнего левого угла или по центру. По умолчанию вид масштабируется из левого верхнего угла, сохраняя смещение видов в мировых координатах. Например, вид со смещением 20,20 будет сохранять свой верхний левый угол на уровне 20,20 в мировых координатах независимо от того, какое значение масштабирования задано. Однако центрированный зум сохраняет центр вида неподвижным, одновременно масштабируя все остальное вокруг него, что затрудняет оценку значения смещения. В этом режиме верхний левый угол будет находиться только на уровне 20,20, когда значение масштабирования равно 1,0, для других значений масштабирования верхний левый угол будет масштабирован в сторону от точки смещения. Например, предположим, что размер мира составляет 100 100 единиц, уровень масштабирования-1,0, а смещение вида-0,0. Вид будет отображать мировые координаты от 0,0 (в верхнем левом углу) до 100,100 (в нижнем правом углу), со значением масштабирования 2,0 и верхним левым масштабированием вид теперь будет показывать мировые координаты от 0,0 до 50,50 в том же пространстве, что делает все больше. При центрированном масштабировании вид вместо этого будет показывать от 25,25 до 75,75, сохраняя центр вида над точкой 50,50 в мировых координатах.

---

<a name="method-setviewzoom"></a>

### SetViewZoom()
```php
SetViewZoom(float $zoom): void
```
Масштабирование видового экрана относительно окружающего мира, например, масштабирование вида 2.0 удвоит размер всего, что в данный момент находится в поле зрения. Значение 1.0 возвращает все к нормальному размеру. Использование этой команды автоматически отключит четыре физические стены, окружающие экран. Вы также можете зафиксировать спрайты на экране, чтобы они не меняли размер, используя FixSpriteToScreen. Эта команда может масштабироваться либо в направлении верхнего левого угла вида, либо в направлении центра вида, см.

---

<a name="method-setvideovolume"></a>

### SetVideoVolume()
```php
SetVideoVolume(float $volume): void
```
Устанавливает громкость видео от 0 (приглушенный звук) до 100 (полная громкость)

---

<a name="method-setvideoposition"></a>

### SetVideoPosition()
```php
SetVideoPosition(float $seconds): void
```
Ищет видео в заданной позиции. Это не гарантирует 100% точности, устройство может выбрать поиск ближайшего ключевого кадра, который может быть до 10 секунд до или после выбранного вами времени.

---

<a name="method-setviewoffset"></a>

### SetViewOffset()
```php
SetViewOffset(float $x, float $y): void
```
Смещение видового экрана относительно окружающего мира, например, смещение вида 0,20 переместит экран вниз на 20 пикселей, показывая любой спрайт, который ранее был расположен чуть ниже нижней части экрана. Это может быть полезно для прокрутки игр, где вы хотите переместить вид через уровень. Использование этой команды автоматически отключит четыре физические стены, окружающие экран. Вы также можете закрепить спрайты на экране так, чтобы они двигались вместе с ним, используя FixSpriteToScreen. Значения смещения вида позиционируют верхний левый угол вида в мире, в то время как SetViewZoom определяет, какую часть мира может видеть вид.

---

<a name="method-setvideodimensions"></a>

### SetVideoDimensions()
```php
SetVideoDimensions(float $x, float $y, float $width, float $height): void
```
Устанавливает ширину, высоту и положение видео во время его воспроизведения. Может быть вызван до или во время воспроизведения. Координаты находятся в координатах экрана AGK, основанных на выбранном вами виртуальном разрешении. Соотношение сторон не сохраняется и будет растянуто в соответствии с выбранными вами размерами. Чтобы найти фактический размер видео в пикселях, используйте GetVideoWidth и GetVideoHeight. Исключением из этого правила являются окна, которые всегда сохраняют соотношение сторон исходного видео и добавляют черные границы там, где это необходимо.

---

<a name="method-setvector3"></a>

### SetVector3()
```php
SetVector3(int $vectorID, float $x, float $y, float $z): void
```
Заполняет указанный вектор.

---

<a name="method-setvsync"></a>

### SetVSync()
```php
SetVSync(int $mode): void
```
Устанавливает, следует ли включать или выключать вертикальную синхронизацию. Это предпочтительный метод ограничения частоты кадров, поскольку он будет связывать частоту кадров с частотой обновления монитора и избегать разрыва или заикания. Использование этой команды с режимом 1 переопределит любую заданную в данный момент частоту обновления из SetSyncRate, в противном случае эти две команды будут бороться друг с другом за контроль частоты кадров, вместо этого AGK будет использовать частоту обновления VSync, которая обычно составляет 60 кадров в секунду, но зависит от монитора. В Linux, Mac и HTML5 вы можете использовать значение больше 1 для пропуска обновлений, например, если частота обновления монитора составляет 60 Гц, то значение режима 1 ограничит приложение до 60 кадров в секунду, но значение режима 2 пропустит каждое другое обновление, которое ограничит приложение до 30 кадров в секунду.

---

<a name="method-settweentexty"></a>

### SetTweenTextY()
```php
SetTweenTextY(int $tweenID, float $beginY, float $endY, int $interpolation): void
```
Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweentextx"></a>

### SetTweenTextX()
```php
SetTweenTextX(int $tweenID, float $beginX, float $endX, int $interpolation): void
```
Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweentextsize"></a>

### SetTweenTextSize()
```php
SetTweenTextSize(int $tweenID, float $beginS, float $endS, int $interpolation): void
```
Задает параметр Размера заданного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweentextspacing"></a>

### SetTweenTextSpacing()
```php
SetTweenTextSpacing(int $tweenID, float $beginSP, float $endSP, int $interpolation): void
```
Задает параметр Интервала для заданного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweentextred"></a>

### SetTweenTextRed()
```php
SetTweenTextRed(int $tweenID, int $beginR, int $endR, int $interpolation): void
```
Задает красный параметр заданного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweentextblue"></a>

### SetTweenTextBlue()
```php
SetTweenTextBlue(int $tweenID, int $beginB, int $endB, int $interpolation): void
```
Устанавливает синий параметр данного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweentextlinespacing"></a>

### SetTweenTextLineSpacing()
```php
SetTweenTextLineSpacing(int $tweenID, float $beginLSP, float $endLSP, int $interpolation): void
```
Задает параметр межстрочного интервала для данного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweentextgreen"></a>

### SetTweenTextGreen()
```php
SetTweenTextGreen(int $tweenID, int $beginG, int $endG, int $interpolation): void
```
Задает зеленый параметр заданного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweentextangle"></a>

### SetTweenTextAngle()
```php
SetTweenTextAngle(int $tweenID, float $beginA, float $endA, int $interpolation): void
```
Задает параметр угла заданного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweentextalpha"></a>

### SetTweenTextAlpha()
```php
SetTweenTextAlpha(int $tweenID, int $beginA, int $endA, int $interpolation): void
```
Задает альфа - параметр данного идентификатора tween ID. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspriteybyoffset"></a>

### SetTweenSpriteYByOffset()
```php
SetTweenSpriteYByOffset(int $tweenID, float $beginY, float $endY, int $interpolation): void
```
Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Это изменяет положение спрайта, используя его точку смещения, обычно центр спрайта. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspritey"></a>

### SetTweenSpriteY()
```php
SetTweenSpriteY(int $tweenID, float $beginY, float $endY, int $interpolation): void
```
Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Это изменяет положение спрайта, используя его верхний левый угол. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspritexbyoffset"></a>

### SetTweenSpriteXByOffset()
```php
SetTweenSpriteXByOffset(int $tweenID, float $beginX, float $endX, int $interpolation): void
```
Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Это изменяет положение спрайта, используя его точку смещения, обычно центр спрайта. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspritex"></a>

### SetTweenSpriteX()
```php
SetTweenSpriteX(int $tweenID, float $beginX, float $endX, int $interpolation): void
```
Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Это изменяет положение спрайта, используя его верхний левый угол. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspritesizey"></a>

### SetTweenSpriteSizeY()
```php
SetTweenSpriteSizeY(int $tweenID, float $beginSY, float $endSY, int $interpolation): void
```
Задает параметр sizeY для данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspritered"></a>

### SetTweenSpriteRed()
```php
SetTweenSpriteRed(int $tweenID, int $beginR, int $endR, int $interpolation): void
```
Задает красный параметр заданного идентификатора анимации. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Tween-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspritesizex"></a>

### SetTweenSpriteSizeX()
```php
SetTweenSpriteSizeX(int $tweenID, float $beginSX, float $endSX, int $interpolation): void
```
Задает параметр sizeX для данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspritegreen"></a>

### SetTweenSpriteGreen()
```php
SetTweenSpriteGreen(int $tweenID, int $beginG, int $endG, int $interpolation): void
```
Задает зеленый параметр заданного идентификатора анимации. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspriteblue"></a>

### SetTweenSpriteBlue()
```php
SetTweenSpriteBlue(int $tweenID, int $beginB, int $endB, int $interpolation): void
```
Устанавливает синий параметр данного идентификатора анимации. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspriteangle"></a>

### SetTweenSpriteAngle()
```php
SetTweenSpriteAngle(int $tweenID, float $beginA, float $endA, int $interpolation): void
```
Задает параметр угла заданного идентификатора анимации. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenspritealpha"></a>

### SetTweenSpriteAlpha()
```php
SetTweenSpriteAlpha(int $tweenID, int $beginA, int $endA, int $interpolation): void
```
Задает альфа - параметр данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectz"></a>

### SetTweenObjectZ()
```php
SetTweenObjectZ(int $tweenID, float $beginZ, float $endZ, int $interpolation): void
```
Задает параметр Z заданного идентификатора tween ID. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjecty"></a>

### SetTweenObjectY()
```php
SetTweenObjectY(int $tweenID, float $beginY, float $endY, int $interpolation): void
```
Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectx"></a>

### SetTweenObjectX()
```php
SetTweenObjectX(int $tweenID, float $beginX, float $endX, int $interpolation): void
```
Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectscalez"></a>

### SetTweenObjectScaleZ()
```php
SetTweenObjectScaleZ(int $tweenID, float $beginSZ, float $endSZ, int $interpolation): void
```
Задает параметр scaleZ для данного идентификатора tween ID. Шкала абсолютна, поэтому значение 1.0 будет нормальным размером, в то время как 2.0 будет в два раза больше. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectscaley"></a>

### SetTweenObjectScaleY()
```php
SetTweenObjectScaleY(int $tweenID, float $beginSY, float $endSY, int $interpolation): void
```
Задает параметр scaleY для данного идентификатора tween ID. Шкала абсолютна, поэтому значение 1.0 будет нормальным размером, в то время как 2.0 будет в два раза больше. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectscalex"></a>

### SetTweenObjectScaleX()
```php
SetTweenObjectScaleX(int $tweenID, float $beginSX, float $endSX, int $interpolation): void
```
Задает параметр scaleX для данного идентификатора tween ID. Шкала абсолютна, поэтому значение 1.0 будет нормальным размером, в то время как 2.0 будет в два раза больше. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectred"></a>

### SetTweenObjectRed()
```php
SetTweenObjectRed(int $tweenID, int $beginR, int $endR, int $interpolation): void
```
Устанавливает красный параметр данного идентификатора анимации в диапазоне от 0 до 255. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectgreen"></a>

### SetTweenObjectGreen()
```php
SetTweenObjectGreen(int $tweenID, int $beginG, int $endG, int $interpolation): void
```
Устанавливает зеленый параметр данного идентификатора анимации в диапазоне от 0 до 255. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectblue"></a>

### SetTweenObjectBlue()
```php
SetTweenObjectBlue(int $tweenID, int $beginB, int $endB, int $interpolation): void
```
Устанавливает синий параметр данного идентификатора анимации в диапазоне от 0 до 255. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectanglez"></a>

### SetTweenObjectAngleZ()
```php
SetTweenObjectAngleZ(int $tweenID, float $beginAZ, float $endAZ, int $interpolation): void
```
Задает параметр Euler AngleZ заданного идентификатора tween ID. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectangley"></a>

### SetTweenObjectAngleY()
```php
SetTweenObjectAngleY(int $tweenID, float $beginAY, float $endAY, int $interpolation): void
```
Задает параметр Euler angleY данного идентификатора tween. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectanglex"></a>

### SetTweenObjectAngleX()
```php
SetTweenObjectAngleX(int $tweenID, float $beginAX, float $endAX, int $interpolation): void
```
Задает параметр Euler AngleX заданного идентификатора tween ID. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenobjectalpha"></a>

### SetTweenObjectAlpha()
```php
SetTweenObjectAlpha(int $tweenID, int $beginA, int $endA, int $interpolation): void
```
Устанавливает альфа - параметр данного идентификатора tween ID в диапазоне от 0 до 255. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenduration"></a>

### SetTweenDuration()
```php
SetTweenDuration(int $tweenID, float $duration): void
```
Изменяет продолжительность анимации после ее создания. Если анимация выполняется в данный момент или является частью цепочки, которая выполняется в данный момент, то изменение ее продолжительности может привести к неожиданным результатам.

---

<a name="method-settweencustominteger3"></a>

### SetTweenCustomInteger3()
```php
SetTweenCustomInteger3(int $tweenID, int $begin, int $end, int $interpolation): void
```
Задает третье целочисленное значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencustominteger4"></a>

### SetTweenCustomInteger4()
```php
SetTweenCustomInteger4(int $tweenID, int $begin, int $end, int $interpolation): void
```
Задает четвертое целочисленное значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencustominteger2"></a>

### SetTweenCustomInteger2()
```php
SetTweenCustomInteger2(int $tweenID, int $begin, int $end, int $interpolation): void
```
Задает второе целочисленное значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencustominteger1"></a>

### SetTweenCustomInteger1()
```php
SetTweenCustomInteger1(int $tweenID, int $begin, int $end, int $interpolation): void
```
Задает первое целочисленное значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencustomfloat4"></a>

### SetTweenCustomFloat4()
```php
SetTweenCustomFloat4(int $tweenID, float $begin, float $end, int $interpolation): void
```
Устанавливает четвертое плавающее значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencustomfloat2"></a>

### SetTweenCustomFloat2()
```php
SetTweenCustomFloat2(int $tweenID, float $begin, float $end, int $interpolation): void
```
Устанавливает второе плавающее значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencustomfloat3"></a>

### SetTweenCustomFloat3()
```php
SetTweenCustomFloat3(int $tweenID, float $begin, float $end, int $interpolation): void
```
Устанавливает третье плавающее значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencustomfloat1"></a>

### SetTweenCustomFloat1()
```php
SetTweenCustomFloat1(int $tweenID, float $begin, float $end, int $interpolation): void
```
Устанавливает первое плавающее значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenchary"></a>

### SetTweenCharY()
```php
SetTweenCharY(int $tweenID, float $beginY, float $endY, int $interpolation): void
```
Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Позиции символов ar относительно родительского текстового объекта. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencharx"></a>

### SetTweenCharX()
```php
SetTweenCharX(int $tweenID, float $beginX, float $endX, int $interpolation): void
```
Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Позиции символов ar относительно родительского текстового объекта. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenchargreen"></a>

### SetTweenCharGreen()
```php
SetTweenCharGreen(int $tweenID, int $beginG, int $endG, int $interpolation): void
```
Задает зеленый параметр заданного идентификатора анимации. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencharblue"></a>

### SetTweenCharBlue()
```php
SetTweenCharBlue(int $tweenID, int $beginB, int $endB, int $interpolation): void
```
Устанавливает синий параметр данного идентификатора анимации. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencharred"></a>

### SetTweenCharRed()
```php
SetTweenCharRed(int $tweenID, int $beginR, int $endR, int $interpolation): void
```
Задает красный параметр заданного идентификатора анимации. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencharangle"></a>

### SetTweenCharAngle()
```php
SetTweenCharAngle(int $tweenID, float $beginA, float $endA, int $interpolation): void
```
Задает параметр угла заданного идентификатора анимации. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencharalpha"></a>

### SetTweenCharAlpha()
```php
SetTweenCharAlpha(int $tweenID, int $beginA, int $endA, int $interpolation): void
```
Задает альфа - параметр данного идентификатора tween ID. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweenchaintime"></a>

### SetTweenChainTime()
```php
SetTweenChainTime(int $chainID, float $time): void
```
Перескакивает цепочку твинов в заданное положение в своей временной линии. Если в данный момент воспроизводится цепочка твинов, то интерполяция оценит заданное значение времени и обновит необходимые объекты. Если цепочка tween не воспроизводится, то эта команда не имеет никакого эффекта, так как вызов PlayTweenChain сбрасывает время до 0. Если время случайно падает на задержку между подростками, то интерполяция останется неизменной до тех пор, пока задержка не будет пройдена.

---

<a name="method-settweencameraz"></a>

### SetTweenCameraZ()
```php
SetTweenCameraZ(int $tweenID, float $beginZ, float $endZ, int $interpolation): void
```
Задает параметр Z заданного идентификатора tween ID. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencamerax"></a>

### SetTweenCameraX()
```php
SetTweenCameraX(int $tweenID, float $beginX, float $endX, int $interpolation): void
```
Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencameray"></a>

### SetTweenCameraY()
```php
SetTweenCameraY(int $tweenID, float $beginY, float $endY, int $interpolation): void
```
Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencamerafov"></a>

### SetTweenCameraFOV()
```php
SetTweenCameraFOV(int $tweenID, float $beginF, float $endF, int $interpolation): void
```
Задает параметр Поля зрения заданного идентификатора анимации. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencameraanglez"></a>

### SetTweenCameraAngleZ()
```php
SetTweenCameraAngleZ(int $tweenID, float $beginAZ, float $endAZ, int $interpolation): void
```
Задает параметр Euler AngleZ заданного идентификатора tween ID. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencameraangley"></a>

### SetTweenCameraAngleY()
```php
SetTweenCameraAngleY(int $tweenID, float $beginAY, float $endAY, int $interpolation): void
```
Задает параметр Euler angleY данного идентификатора tween. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settweencameraanglex"></a>

### SetTweenCameraAngleX()
```php
SetTweenCameraAngleX(int $tweenID, float $beginAX, float $endAX, int $interpolation): void
```
Задает параметр Euler AngleX заданного идентификатора tween ID. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению

---

<a name="method-settransitionmode"></a>

### SetTransitionMode()
```php
SetTransitionMode(int $mode): void
```
Эта команда устарела, переходы ориентации теперь контролируются устройством.

---

<a name="method-settextx"></a>

### SetTextX()
```php
SetTextX(int $iTextIndex, float $fX): void
```
Обновляет положение X текстового объекта в мировых координатах, по умолчанию текст позиционируется с помощью его верхнего левого угла. При использовании выравнивания по правому краю текст позиционируется с помощью его верхнего правого угла. При использовании выравнивания по центру текст позиционируется с помощью точки на полпути вдоль его верхнего края.

---

<a name="method-settexty"></a>

### SetTextY()
```php
SetTextY(int $iTextIndex, float $fY): void
```
Обновляет положение Y текстового объекта в мировых координатах, по умолчанию текст позиционируется с помощью его верхнего левого угла. При использовании выравнивания по правому краю текст позиционируется с помощью его верхнего правого угла. При использовании выравнивания по центру текст позиционируется с помощью точки на полпути вдоль его верхнего края.

---

<a name="method-settextvisible"></a>

### SetTextVisible()
```php
SetTextVisible(int $iTextIndex, int $bVisible): void
```
Задает, будет ли текст отрисовываться во время обновления экрана.

---

<a name="method-settexttransparency"></a>

### SetTextTransparency()
```php
SetTextTransparency(int $iTextIndex, int $mode): void
```
Установите прозрачность текста на определенную настройку с выбором без прозрачности, альфа-прозрачности и аддитивного смешивания. По умолчанию текст создается с альфа-прозрачностью.

---

<a name="method-settextstring"></a>

### SetTextString()
```php
SetTextString(int $iTextIndex, string $string): void
```
Обновляет строку текстового объекта, новый текст будет отображаться при следующем обновлении экрана.

---

<a name="method-settextspacing"></a>

### SetTextSpacing()
```php
SetTextSpacing(int $iTextIndex, float $fSpacing): void
```
Устанавливает интервал между буквами. Значение 0 не создает зазора между ограничивающими буквами, положительное значение увеличивает этот зазор, отрицательное значение перекрывает буквы. Если каждый символ построен с некоторым пробелом по обе стороны от него в изображении шрифта, то это значение интервала по умолчанию, и эта команда будет увеличивать или уменьшать расстояние от него.

---

<a name="method-settextsize"></a>

### SetTextSize()
```php
SetTextSize(int $iTextIndex, float $fSize): void
```
Устанавливает размер текстового объекта, по умолчанию 4. Это значение представляет высоту каждого символа в мировых единицах. Ширина каждого символа зависит от шрифта и рассчитывается в соответствии с заданным размером.

---

<a name="method-settextscissor"></a>

### SetTextScissor()
```php
SetTextScissor(int $iTextIndex, float $x, float $y, float $x2, float $y2): void
```
При рисовании текст привязывается к указанным мировым координатам. Используйте значения 0,0,0,0 для отключения текстовых ножниц

---

<a name="method-settextmaxwidth"></a>

### SetTextMaxWidth()
```php
SetTextMaxWidth(int $iTextIndex, float $width): void
```
Задает максимальную ширину, которую текстовый объект будет использовать для рисования, любые символы, выходящие за пределы этого значения, будут переноситься на новую строку.

---

<a name="method-settextposition"></a>

### SetTextPosition()
```php
SetTextPosition(int $iTextIndex, float $fX, float $fY): void
```
Обновляет положение текстового объекта в мировых координатах, по умолчанию текст позиционируется с помощью его верхнего левого угла. При использовании выравнивания по правому краю текст позиционируется с помощью его верхнего правого угла. При использовании выравнивания по центру текст позиционируется с помощью точки на полпути вдоль его верхнего края.

---

<a name="method-settextlinespacing"></a>

### SetTextLineSpacing()
```php
SetTextLineSpacing(int $iTextIndex, float $fSpacing): void
```
Задает интервал между строками текста. Значение 0 не создает зазора между линиями, положительное значение увеличивает этот зазор, отрицательное значение перекрывает линии. Если каждый символ построен с некоторым пробелом над и под ним в изображении шрифта, то это значение интервала по умолчанию, и эта команда увеличит или уменьшит расстояние от него.

---

<a name="method-settextinputmaxchars"></a>

### SetTextInputMaxChars()
```php
SetTextInputMaxChars(int $max): void
```
Задает максимальное количество символов, которое может быть введено в полноэкранное поле редактирования. Используйте 0 для неограниченного количества.

---

<a name="method-settextextendedfontimage"></a>

### SetTextExtendedFontImage()
```php
SetTextExtendedFontImage(int $iTextIndex, int $iImageID): void
```
Задает расширенный шрифт, используемый для этого текстового объекта. Расширенный шрифт предназначен для нестандартных символов выше значения ascii 127 и может быть установлен отдельно для стандартных символов, так что вы можете иметь несколько изображений для расширенного набора и базовое изображение для обычных символов шрифта. AGK имеет встроенный расширенный шрифт, который он использует для текстовых объектов с символами от 128 до 255, эта команда позволяет переопределить его. Если вы устанавливаете все свои текстовые объекты на один и тот же расширенный шрифт, вам следует использовать вместо этого SetTextDefaultExtendedFontImage, так как это сэкономит некоторое время обработки. Изображение должно содержать все белые символы, окруженные прозрачным альфа-каналом. Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB. Изображение шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины изображение шрифта должно быть выложено в сетку из 16 символов поперек и 8 символов вниз, начиная с символа ascii 32 (пробел) в левом верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 127 (DEL) в правом нижнем углу. Ширина изображения должна быть кратна 16, а высота изображения-6. Для переменной ширины изображение должно быть текстурой атласа, сопровождаемой subimages.txt файл, в котором указано расположение каждого символа на изображении. AGK будет искать изображения "32" до "127" включительно в файле подизображений, и любые не найденные будут по умолчанию использовать символ пробела (32). Символы переменной высоты не поддерживаются, и все символы должны быть одинаковой высоты с любым необходимым заполнением, включенным в изображение шрифта. Если этот текстовый объект использует шрифт TrueType, то эта команда не влияет, шрифт TrueType обрабатывает как обычные, так и расширенные символы (unicode).

---

<a name="method-settextfont"></a>

### SetTextFont()
```php
SetTextFont(int $iTextIndex, int $iFontID): void
```
Задает шрифт TrueType, используемый для этого текстового объекта. Шрифт должен быть загружен с помощью LoadFont из файла шрифтов TrueType. Это отличается от старых растровых шрифтов тем, что он поддерживает символы юникода, и символы обычно появляются более четкими на экране всех размеров.  Обратите внимание, что изменение размера текстового объекта, использующего шрифт TrueType, приведет к перерисовке всех символов из файла шрифта на изображение для рисования, для больших размеров текста с использованием сотен различных символов юникода это может быть медленным процессом, но при нормальном использовании он обычно не заметен.  Недавно использованные размеры сохраняются в течение короткого периода времени, поэтому, если вы часто переключаетесь между двумя или тремя размерами текста, вам не нужно будет перерисовывать его, и это будет быстрее.  Используйте идентификатор шрифта 0, чтобы использовать встроенный шрифт TrueType, поддерживающий широкий диапазон символов unicode.

---

<a name="method-settextfontimage"></a>

### SetTextFontImage()
```php
SetTextFontImage(int $iTextIndex, int $iImageID): void
```
Устанавливает шрифт, используемый для этого текстового объекта. AGK имеет встроенный шрифт, который он использует для текстовых объектов, это позволяет вам переопределить его. Если вы устанавливаете все свои текстовые объекты на один и тот же шрифт, вам следует использовать вместо этого SetTextDefaultFontImage, так как это сэкономит некоторое время обработки. Изображение должно содержать все белые символы, окруженные прозрачным альфа-каналом. Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB. Изображение шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины изображение шрифта должно быть выложено в сетку из 16 символов поперек и 6 символов вниз, начиная с символа ascii 32 (пробел) в левом верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 127 (DEL) в правом нижнем углу. Ширина изображения должна быть кратна 16, а высота изображения-6. Для переменной ширины изображение должно быть текстурой атласа, сопровождаемой subimages.txt файл, в котором указано расположение каждого символа на изображении. AGK будет искать изображения "32" до "127" включительно в файле подизображений, и любые не найденные будут по умолчанию использовать символ пробела (32). Символы переменной высоты не поддерживаются, и все символы должны быть одинаковой высоты с любым необходимым заполнением, включенным в изображение шрифта. Начиная с версии 2.0.20 вы можете использовать SetTextFont для использования шрифтов TrueType вместо растровых шрифтов. Вы должны выбрать один или другой, установка растрового шрифта удалит шрифт Truetype, а установка шрифта TrueType удалит растровый шрифт.

---

<a name="method-settextdepth"></a>

### SetTextDepth()
```php
SetTextDepth(int $iTextIndex, int $iDepth): void
```
Устанавливает порядок рисования текста между 0-10000, 0 - передняя часть экрана, 10000 - задняя. Все, что больше 10000, приведет к тому, что текст будет вырезан из поля зрения. По умолчанию текст установлен на глубину 9 и отображается выше всех других спрайтов в сцене, установка большей глубины приведет к сортировке текста в прозрачный список порядка рисования, что может снизить производительность. Используйте глубину 0 для достижения наилучшей производительности.

---

<a name="method-settextdefaultmagfilter"></a>

### SetTextDefaultMagFilter()
```php
SetTextDefaultMagFilter(int $mode): void
```
Устанавливает фильтр изображений для всех текстовых объектов и функций печати, использующих шрифт по умолчанию, когда текстовое изображение больше занимаемого им пространства экрана. Ближайшая фильтрация выбирает ближайший пиксель для отображения и может выглядеть блочной. Линейная фильтрация смешивает 4 ближайших пикселя и может выглядеть размытой.

---

<a name="method-settextdefaultminfilter"></a>

### SetTextDefaultMinFilter()
```php
SetTextDefaultMinFilter(int $mode): void
```
Устанавливает фильтр изображения для всех текстовых объектов и функций печати, использующих шрифт по умолчанию, когда текстовое изображение меньше занимаемого им пространства экрана. Ближайшая фильтрация выбирает ближайший пиксель для отображения и может выглядеть блочной. Линейная фильтрация смешивает 4 ближайших пикселя и может выглядеть размытой.

---

<a name="method-settextdefaultextendedfontimage"></a>

### SetTextDefaultExtendedFontImage()
```php
SetTextDefaultExtendedFontImage(int $iImageID): void
```
Устанавливает расширенный шрифт по умолчанию для текстовых объектов. Расширенный шрифт предназначен для нестандартных символов выше значения ascii 127 и может быть установлен отдельно для стандартных символов, так что вы можете иметь несколько изображений для расширенного набора и базовое изображение для обычных символов шрифта. AGK имеет встроенный расширенный шрифт для символов от 128 до 255, который он использует для текстовых объектов, что позволяет переопределить его. Если вы решите переопределить его, вы должны сделать это перед созданием любых текстовых объектов. Вы можете установить шрифт для каждого текста с помощью Settextendedfontimage. Изображение должно содержать все белые символы, окруженные прозрачным альфа-каналом. Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB. Расширенное изображение шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины изображение шрифта должно быть выложено в сетку из 16 символов поперек и 8 символов вниз, начиная с символа ascii 128 в левом верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 255 в правом нижнем углу. Ширина изображения должна быть кратна 16, а высота-8. Для переменной ширины изображение должно быть текстурой атласа, сопровождаемой subimages.txt файл, в котором указано расположение каждого символа на изображении. AGK будет искать изображения "128" до "255" включительно в файле подизображений, а любые не найденные будут по умолчанию использовать символ пробела (32).

---

<a name="method-settextdefaultfontimage"></a>

### SetTextDefaultFontImage()
```php
SetTextDefaultFontImage(int $iImageID): void
```
Устанавливает шрифт по умолчанию для текстовых объектов. AGK имеет встроенный шрифт, который он использует для текстовых объектов, это позволяет вам переопределить его. Если вы решите переопределить его, вы должны сделать это перед созданием любых текстовых объектов. Вы можете установить шрифт для каждого текста с помощью SetTextFontImage. Изображение должно содержать все белые символы, окруженные прозрачным альфа-каналом. Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB. Изображение шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины изображение шрифта должно быть выложено в сетку из 16 символов поперек и 6 символов вниз, начиная с символа ascii 32 (пробел) в левом верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 127 (DEL) в правом нижнем углу. Ширина изображения должна быть кратна 16, а высота изображения-6. Для переменной ширины изображение должно быть текстурой атласа, сопровождаемой subimages.txt файл, в котором указано расположение каждого символа на изображении. AGK будет искать изображения "32" до "127" включительно в файле подизображений, и любые не найденные будут по умолчанию использовать символ пробела (32).

---

<a name="method-settextcolorgreen"></a>

### SetTextColorGreen()
```php
SetTextColorGreen(int $iTextIndex, int $iGreen): void
```
Установите зеленый компонент цвета текста. Значение должно находиться в диапазоне 0-255.

---

<a name="method-settextcolorred"></a>

### SetTextColorRed()
```php
SetTextColorRed(int $iTextIndex, int $iRed): void
```
Установите красный компонент цвета текста. Значение должно находиться в диапазоне 0-255.

---

<a name="method-settextcolorblue"></a>

### SetTextColorBlue()
```php
SetTextColorBlue(int $iTextIndex, int $iBlue): void
```
Установите синий компонент цвета текста. Значение должно находиться в диапазоне 0-255.

---

<a name="method-settextcoloralpha"></a>

### SetTextColorAlpha()
```php
SetTextColorAlpha(int $iTextIndex, int $iAlpha): void
```
Установите альфа-компонент цвета текста. Значение должно находиться в диапазоне 0-255.

---

<a name="method-settextcolor"></a>

### SetTextColor()
```php
SetTextColor(int $iTextIndex, int $iRed, int $iGreen, int $iBlue, int $iAlpha): void
```
Установите цвет текста, значения должны быть в диапазоне 0-255. Это приведет к тому, что все символы в тексте будут иметь этот цвет. Вы можете установить отдельные символы с помощью SetTextCharColor.

---

<a name="method-settextcharx"></a>

### SetTextCharX()
```php
SetTextCharX(int $iTextIndex, int $iCharIndex, float $x): void
```
Установите положение X отдельного символа относительно позиции текста, установленной ранее. Символ будет расположен в верхнем левом углу. При вызове любой из следующих команд положение всех символов будет сброшено на прямую линию: SetTextPosition, SetTextX, SetTextY, setTextSize, SetTextSpacing, SetTextAlignment. Позиционирование символов внутри текстового объекта более эффективно, чем позиционирование множества небольших текстовых объектов, каждый из которых содержит символ, поскольку все символы могут быть нарисованы в одном вызове рисования.

---

<a name="method-settextchary"></a>

### SetTextCharY()
```php
SetTextCharY(int $iTextIndex, int $iCharIndex, float $y): void
```
Установите положение Y отдельного символа относительно позиции текста, установленной ранее. Символ будет расположен в верхнем левом углу. При вызове любой из следующих команд положение всех символов будет сброшено на прямую линию: SetTextPosition, SetTextX, SetTextY, setTextSize, SetTextSpacing, SetTextAlignment. Позиционирование символов внутри текстового объекта более эффективно, чем позиционирование множества небольших текстовых объектов, каждый из которых содержит символ, поскольку все символы могут быть нарисованы в одном вызове рисования.

---

<a name="method-settextcharcolorred"></a>

### SetTextCharColorRed()
```php
SetTextCharColorRed(int $iTextIndex, int $iCharIndex, int $red): void
```
Задает красный компонент заданного цвета символов. Использование команды SetTextColor переопределит это. Значения должны находиться в диапазоне 0-255.

---

<a name="method-settextcharposition"></a>

### SetTextCharPosition()
```php
SetTextCharPosition(int $iTextIndex, int $iCharIndex, float $x, float $y): void
```
Установите положение отдельного символа относительно позиции текста, заданной ранее. Символ будет расположен в верхнем левом углу. При вызове любой из следующих команд положение всех символов будет сброшено на прямую линию: SetTextPosition, SetTextX, SetTextY, setTextSize, SetTextSpacing, SetTextAlignment. Позиционирование символов внутри текстового объекта более эффективно, чем позиционирование множества небольших текстовых объектов, каждый из которых содержит символ, поскольку все символы могут быть нарисованы в одном вызове рисования.

---

<a name="method-settextcharcolorgreen"></a>

### SetTextCharColorGreen()
```php
SetTextCharColorGreen(int $iTextIndex, int $iCharIndex, int $green): void
```
Устанавливает зеленый компонент цвета указанного символа. Использование команды SetTextColor переопределит это. Значения должны находиться в диапазоне 0-255.

---

<a name="method-settextcharcolorblue"></a>

### SetTextCharColorBlue()
```php
SetTextCharColorBlue(int $iTextIndex, int $iCharIndex, int $blue): void
```
Устанавливает синий компонент цвета указанного символа. Использование команды SetTextColor переопределит это. Значения должны находиться в диапазоне 0-255.

---

<a name="method-settextcharcolor"></a>

### SetTextCharColor()
```php
SetTextCharColor(int $iTextIndex, int $iCharIndex, int $red, int $green, int $blue, int $alpha): void
```
Задает цвет указанного символа. Использование команды SetTextColor переопределит это. Значения должны находиться в диапазоне 0-255.

---

<a name="method-settextcharcoloralpha"></a>

### SetTextCharColorAlpha()
```php
SetTextCharColorAlpha(int $iTextIndex, int $iCharIndex, int $alpha): void
```
Задает альфа-компонент цвета указанного символа. Использование команды SetTextColor переопределит это. Значения должны находиться в диапазоне 0-255.

---

<a name="method-settextcharanglerad"></a>

### SetTextCharAngleRad()
```php
SetTextCharAngleRad(int $iTextIndex, int $iCharIndex, float $angle): void
```
Установите угол отдельного символа в радианах по часовой стрелке. Персонаж будет вращаться вокруг своего центра. Если какая - либо из следующих команд будет вызвана, то вращение всех символов будет сброшено: SetTextPosition, SetTextX, Settextty, setTextSize, SetTextSpacing, SetTextAlignment.

---

<a name="method-settextcharbold"></a>

### SetTextCharBold()
```php
SetTextCharBold(int $iTextIndex, int $iCharIndex, int $bold): void
```
Задает символу полужирный стиль. Это применимо только в том случае, если текст использует шрифт TrueType, установленный с помощью SetTextFont. Если вы используете SetTextString, то этот параметр будет сброшен на 0. Вы можете использовать SetTextBold, чтобы установить всю строку жирным шрифтом.

---

<a name="method-settextcharangle"></a>

### SetTextCharAngle()
```php
SetTextCharAngle(int $iTextIndex, int $iCharIndex, float $angle): void
```
Установите угол наклона отдельного символа в градусах по часовой стрелке. Персонаж будет вращаться вокруг своего центра. Если какая - либо из следующих команд будет вызвана, то вращение всех символов будет сброшено: SetTextPosition, SetTextX, Settextty, setTextSize, SetTextSpacing, SetTextAlignment.

---

<a name="method-settextanglerad"></a>

### SetTextAngleRad()
```php
SetTextAngleRad(int $iTextIndex, float $fAngleRad): void
```
Обновляет угол наклона текста. Если текст выровнен по левому краю, то он будет вращаться вокруг своего верхнего левого угла. При использовании выравнивания по центру он будет вращаться вокруг точки на полпути вдоль своего верхнего края. При использовании правого выравнивания он будет вращаться вокруг своего верхнего восьмого угла.

---

<a name="method-settextbold"></a>

### SetTextBold()
```php
SetTextBold(int $iTextIndex, int $bold): void
```
Устанавливает все символы в тексте полужирным шрифтом независимо от текущего состояния SetTextCharBold. Этот параметр будет оставаться активным до тех пор, пока он не будет изменен, установка новой текстовой строки не изменит его.

---

<a name="method-settextangle"></a>

### SetTextAngle()
```php
SetTextAngle(int $iTextIndex, float $fAngle): void
```
Обновляет угол наклона текста. Если текст выровнен по левому краю, то он будет вращаться вокруг своего верхнего левого угла. При использовании выравнивания по центру он будет вращаться вокруг точки на полпути вдоль своего верхнего края. При использовании правого выравнивания он будет вращаться вокруг своего верхнего восьмого угла.

---

<a name="method-settextalignment"></a>

### SetTextAlignment()
```php
SetTextAlignment(int $iTextIndex, int $iMode): void
```
Устанавливает, как текст должен быть расположен на экране. Выравнивание по левому краю позиционирует текст, используя его верхний левый угол, выравнивание по правому краю позиционирует его, используя его верхний правый угол, а центр позиционирует его, используя точку на полпути вдоль его верхнего края.

---

<a name="method-setsyncrate"></a>

### SetSyncRate()
```php
SetSyncRate(float $fps, int $mode): void
```
Устанавливает желаемую скорость, с которой кадры будут выводиться на экран, в кадрах в секунду (fps). Кроме того, есть два режима на выбор, которые могут ограничить процессор, первый (mode=0) спит приложение между кадрами, чтобы сэкономить процессор и время автономной работы, где это возможно. Второй (mode=1) использует непрерывный цикл для проверки времени перед следующим кадром, который может быть более точным, но перегружает процессор. Предпочтительным методом ограничения частоты кадров является SetVSync (), который устанавливает частоту обновления на частоту обновления монитора и предотвращает разрыв экрана или заикание. Использование SetSyncRate автоматически отключит VSync, так как две команды будут бороться друг с другом за контроль частоты кадров. Используйте fps 0, чтобы удалить все ограничения и нарисовать кадры как можно быстрее. Это может быть до тысячи кадров в секунду на самых мощных видеокартах. Обратите внимание, что в HTML5 использование SetSyncRate крайне не рекомендуется, так как он использует функцию Javascript setTimeout для синхронизации, что может привести к неточной частоте кадров и заиканию. В HTML5 предпочтительным методом управления частотой кадров является SetVSync.

---

<a name="method-setsuncolor"></a>

### SetSunColor()
```php
SetSunColor(int $red, int $green, int $blue): void
```
Устанавливает новый цвет для глобального направленного света. Значения должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать свет.

---

<a name="method-setsundirection"></a>

### SetSunDirection()
```php
SetSunDirection(float $vx, float $vy, float $vz): void
```
Задает направление для глобального направленного света.

---

<a name="method-setsunactive"></a>

### SetSunActive()
```php
SetSunActive(int $active): void
```
Устанавливает, светит ли глобальный направленный свет или нет.

---

<a name="method-setspritey"></a>

### SetSpriteY()
```php
SetSpriteY(int $iSpriteIndex, float $fY): void
```
Немедленно позиционирует указанный спрайт в заданные мировые координаты Y. Мировая система координат по умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно изменить с помощью SetVirtualResolution). Эта команда позиционирует спрайт в верхнем левом углу.

---

<a name="method-setspritex"></a>

### SetSpriteX()
```php
SetSpriteX(int $iSpriteIndex, float $fX): void
```
Немедленно помещает указанный спрайт в заданные мировые координаты X. Мировая система координат по умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно изменить с помощью SetVirtualResolution). Эта команда позиционирует спрайт в верхнем левом углу.

---

<a name="method-setspriteuvscale"></a>

### SetSpriteUVScale()
```php
SetSpriteUVScale(int $iSpriteIndex, float $scaleU, float $scaleV): void
```
Масштабирует УФ-координаты спрайтов на заданную величину. Спрайт с УФ-масштабированием на 2 сделает его текстуру вдвое больше обычной. УФ-шкала не влияет на УФ-смещение, выбранное с помощью SetSpriteUVOffset, так что смещение 0,5 в направлении U всегда будет начинать выборку на полпути по текстуре, шкала определяет, как далеко спрайт продолжает выборку. Таким образом, при смещении 0,5 шкала 2 сделает выборку спрайта от 0,5 до 1 вместо 0,5 до 1,5. По умолчанию спрайт настроен на использование УФ-координат от 0,0 до 1,1, используя полное доступное ему изображение. Однако есть несколько случаев, когда это изменяется AGK, чтобы скрыть определенные ограничения. Если текстура, назначенная спрайту, не имеет степени 2 ширины или высоты, изображение увеличивается в размере до тех пор, пока оно не станет степенью 2 размера, а УФ-координаты для спрайта уменьшаются так, что спрайт использует только ту часть текстуры, которая содержит исходное изображение. Это происходит потому, что большинство мобильных платформ не поддерживают текстуры, которые не являются силой 2 ширины или высоты. Поэтому смещение УФ-координат спрайта в этом случае сместит использование спрайтом текстуры в неопределенную часть, которая используется в качестве отступа. Кроме того, если спрайт использует изображение, принадлежащее текстуре атласа, УФ-координаты спрайта будут установлены таким образом, чтобы он использовал только ту часть текстуры, которая содержит назначенное ему изображение. Смещение УФ-координат в этом случае сместит использование спрайтом текстуры на другие изображения, которые являются частью текстуры атласа. То же самое можно сказать и о спрайтах, использующих анимацию, содержащуюся в одной текстуре, используя SetSpriteAnimation. Из-за этих возможностей рекомендуется изменять УФ-координаты только на спрайтах, использующих целые изображения (а не текстуры атласа) и имеющих степень 2 размера как по ширине, так и по высоте. С этими ограничениями можно использовать УФ-значения вне 0-1 для успешного зажима или повторения текстуры.

---

<a name="method-setspritevisible"></a>

### SetSpriteVisible()
```php
SetSpriteVisible(int $iSpriteIndex, int $bVisible): void
```
Задает, виден ли этот спрайт во время рисования. Он все еще может обновлять свою анимацию и физику, которые управляются SetSpriteActive.

---

<a name="method-setspriteuvoffset"></a>

### SetSpriteUVOffset()
```php
SetSpriteUVOffset(int $iSpriteIndex, float $u, float $v): void
```
Смещает УФ - координаты спрайтов на заданную величину. Например, смещение на 0,5 в направлении U заставит спрайт начать выборку текстуры посередине верхней части текстуры, а не в верхнем левом углу, как обычно. Значения UV вне диапазона 0,0 (вверху слева) и 1,1 (внизу справа) могут либо обернуть, либо зажать текстуру, что определяется изображением, назначенным спрайту с помощью SetImageWrapU и SetImageWrapV. Зажим или обертывание не могут быть установлены на основе каждого спрайта. По умолчанию спрайт настроен на использование УФ-координат от 0,0 до 1,1, используя полное доступное ему изображение. Однако есть несколько случаев, когда это изменяется AGK, чтобы скрыть определенные ограничения. Если текстура, назначенная спрайту, не имеет степени 2 ширины или высоты, изображение увеличивается в размере до тех пор, пока оно не станет степенью 2 размера, а УФ-координаты для спрайта уменьшаются так, что спрайт использует только ту часть текстуры, которая содержит исходное изображение. Это происходит потому, что большинство мобильных платформ не поддерживают текстуры, которые не являются силой 2 ширины или высоты. Поэтому смещение УФ-координат спрайта в этом случае сместит использование спрайтом текстуры в неопределенную часть, которая используется в качестве отступа. Кроме того, если спрайт использует изображение, принадлежащее текстуре атласа, УФ-координаты спрайта будут установлены таким образом, чтобы он использовал только ту часть текстуры, которая содержит назначенное ему изображение. Смещение УФ-координат в этом случае сместит использование спрайтом текстуры на другие изображения, которые являются частью текстуры атласа. То же самое можно сказать и о спрайтах, использующих анимацию, содержащуюся в одной текстуре, используя SetSpriteAnimation. Из-за этих возможностей рекомендуется изменять УФ-координаты только на спрайтах, использующих целые изображения (а не текстуры атласа) и имеющих степень 2 размера как по ширине, так и по высоте. С этими ограничениями можно использовать УФ-значения вне 0-1 для успешного зажима или повторения текстуры.

---

<a name="method-setspriteuvborder"></a>

### SetSpriteUVBorder()
```php
SetSpriteUVBorder(int $iSpriteIndex, float $border): void
```
Настраивает УФ-координаты спрайта для создания границы, которая перемещает край спрайта внутрь, подальше от края примененного к нему изображения. Это может быть полезно для субизображений, загруженных из текстуры атласа, где изображения могут быть упакованы очень близко друг к другу. Использование границы гарантирует, что спрайт случайно не возьмет образец из соседнего изображения, вы также можете исправить это, добавив пространство между изображениями в текстуре атласа. По умолчанию спрайт использует границу в 0,5 пикселя, когда его изображение является субизображением, и границу в 0 пикселей, когда оно имеет нормальное изображение. Если вы сами компенсировали это, добавив интервал к изображению атласа, то установка границы на 0 удаляет смещение по умолчанию и создает пиксельное идеальное воспроизведение субизображения. Вы также можете увеличить эту границу, установив границу больше 0,5 пикселя.

---

<a name="method-setspriteuv"></a>

### SetSpriteUV()
```php
SetSpriteUV(int $iSpriteIndex, float $u1, float $v1, float $u2, float $v2, float $u3, float $v3, float $u4, float $v4): void
```
Эта команда переопределяет обычные УФ-вычисления спрайтов и позволяет устанавливать их непосредственно для каждой вершины. Обратите внимание, что анимация с использованием листов спрайта или текстур атласа не будет работать при использовании этой команды, а функции УФ-смещения и масштабирования не будут иметь никакого эффекта. У вас есть полный контроль над УФ-координатами. Чтобы отменить это, используйте ResetSpriteUV для возврата к вычисленным UV-координатам.

---

<a name="method-setspritespeed"></a>

### SetSpriteSpeed()
```php
SetSpriteSpeed(int $iSpriteIndex, float $fFps): void
```
Устанавливает анимацию спрайта на заданную скорость, может использоваться во время работы анимации. Можно установить значение 0, чтобы временно приостановить анимацию.

---

<a name="method-setspritesize"></a>

### SetSpriteSize()
```php
SetSpriteSize(int $iSpriteIndex, float $width, float $height): void
```
Устанавливает спрайту новую ширину и высоту. В системе координат по умолчанию ширина и высота 100 100 будут заполнять весь рисуемый экран (это можно изменить с помощью SetVirtualResolution). Если задано значение width или height, а другое значение равно -1, то значение -1 будет пересчитано для поддержания соотношения сторон изображения, чтобы оно не выглядело растянутым. Если и ширина, и высота равны -1, то спрайт возьмет ширину назначенного изображения и вычислит его высоту, чтобы оно не растягивалось. Эта функция пересчитывает форму столкновения спрайта, что может быть дорогостоящим процессом для круговых и полигональных фигур. Более эффективный способ изменить размер спрайта - масштабировать его с помощью функции SetSpriteScale. Эта функция сбрасывает масштаб спрайта.

---

<a name="method-setspritesnap"></a>

### SetSpriteSnap()
```php
SetSpriteSnap(int $iSpriteIndex, int $snap): void
```
Включает специальный режим рендеринга, который удерживает спрайт только на целых пикселях, чтобы он не рисовал себя через границы пикселей, что может вызвать мерцание при перемещении спрайта по экрану. Как следствие, это может привести к тому, что спрайт будет прыгать с одного пикселя на другой, а не плавно перемещаться по экрану. Если спрайт имеет альфа-смешанные пиксели вдоль своего края, то привязка не требуется и может быть отключена. По умолчанию эта функция отключена.

---

<a name="method-setspritetransparency"></a>

### SetSpriteTransparency()
```php
SetSpriteTransparency(int $iSpriteIndex, int $mode): void
```
Установите прозрачность спрайта на определенную настройку с выбором без прозрачности, альфа-прозрачности и аддитивного смешивания. По умолчанию спрайты создаются с альфа-прозрачностью, но если вам это не нужно, рекомендуется отключить прозрачность для повышения производительности.

---

<a name="method-setspriteshapepolygon"></a>

### SetSpriteShapePolygon()
```php
SetSpriteShapePolygon(int $iSpriteIndex, int $numPoints, int $index, float $x, float $y, int $shapeID): void
```
Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений, тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Полигон определяется набором точек (от 2 до 12) относительно смещения текущего спрайта. Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено от этой точки. Точки определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой фигуры. По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.

---

<a name="method-setspriteshapecircle"></a>

### SetSpriteShapeCircle()
```php
SetSpriteShapeCircle(int $iSpriteIndex, float $x, float $y, float $radius, int $shapeID): void
```
Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений, тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Окружность определяется путем указания ее центральной точки относительно текущего смещения спрайта и радиуса. Например, если круг должен быть центрирован в точке смещения спрайта, он будет указан в позиции 0,0. Любое другое значение будет смещать круг от спрайта. Радиус определяется в координатах x, поскольку мировые координаты не обязательно представляют размер элементов на экране (например, 10 единиц в X могут быть не такими же видимыми размерами, как 10 единиц в Y). По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.

---

<a name="method-setspriteshapechain"></a>

### SetSpriteShapeChain()
```php
SetSpriteShapeChain(int $iSpriteIndex, int $numPoints, int $index, int $loop, float $x, float $y, int $shapeID): void
```
Переопределяет текущую автоматически сгенерированную форму для использования в физике. Обычное тестирование столкновений и попаданий спрайтов не работает с формой цепи, это только для физики. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Цепочка определяется набором точек (не менее 2) относительно смещения текущего спрайта. Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено от этой точки. Цепи являются жесткими и могут быть использованы для создания полых вогнутых полигонов или 2D-ландшафтов. Установите параметр loop равным 1, чтобы соединить два конца цепочки вместе, создав полый многоугольник. Точки определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой фигуры. Использование shapeID 0 удаляет все другие фигуры, назначенные спрайту, и заменяет его этим. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.

---

<a name="method-setspriteshapebox"></a>

### SetSpriteShapeBox()
```php
SetSpriteShapeBox(int $iSpriteIndex, float $x, float $y, float $x2, float $y2, float $angle): void
```
Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений, тестировании ударов и физике. Фигуру можно задать без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Поле определяется путем указания его верхних левых и нижних правых координат в пространстве спрайта относительно смещения спрайта, по умолчанию это центр спрайта. Например, если текущее смещение спрайта равно 0,0, то верхний левый угол коробки будет равен 0,0, но если смещение спрайта равно середине спрайта (по умолчанию), то верхний левый угол будет равен-width/2,-height/2. Вы также можете указать угол смещения коробки относительно текущего поворота спрайта. По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.

---

<a name="method-setspriteshape"></a>

### SetSpriteShape()
```php
SetSpriteShape(int $iSpriteIndex, int $shape): void
```
Задает текущую форму для использования в обнаружении столкновений, тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Если вы выберете no shape (0), то любая существующая фигура будет удалена, а при тестировании хита вместо нее будут использоваться размеры спрайта. Команды, требующие формы, такие как GetspriteCollision, будут генерировать прямоугольную форму для спрайта, если она не существует. Параметр shape позволяет определить, какой тип ограничительной рамки должна использовать система для обнаружения коллизий. Круг создаст идеальный круг, центрированный в точке вращения спрайта и достаточно большой, чтобы охватить видимые пиксели спрайта. Box создаст прямоугольник по краям спрайта, независимо от того, видны пиксели или нет. Полигон создаст плотно прилегающий выпуклый полигон вокруг видимых пикселей спрайта, причем видимый пиксель будет определен как один с альфа-значением больше 128. Эта функция не будет работать с фиктивными спрайтами, так как при вычислении фигуры нет изображения, в этих случаях фигуры должны быть заданы вручную с помощью SetSpriteShapeBox, SetSpriteShapeCircle или SetSpriteShapePolygon. По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.

---

<a name="method-setspriteshader"></a>

### SetSpriteShader()
```php
SetSpriteShader(int $spriteID, int $shaderID): void
```
Устанавливает шейдер, используемый для рисования этого спрайта, загруженный с помощью LoadSpriteShader или LoadShader. По умолчанию спрайтам присваивается внутренний шейдер, который может обрабатывать 1 текстуру и цвет. Если вы используете идентификатор шейдера 0, спрайту присваивается внутренний шейдер.

---

<a name="method-setspritescalebyoffset"></a>

### SetSpriteScaleByOffset()
```php
SetSpriteScaleByOffset(int $iSpriteIndex, float $x, float $y): void
```
Устанавливает масштаб спрайта как абсолютное кратное его исходному размеру. Например, значение масштаба 2 удвоит размер спрайта, в то время как значение 1 вернет его к исходному размеру. Эта функция масштабируется от центра вращения спрайта (его текущей точки смещения), поэтому любое увеличение размера будет держать точку смещения неподвижной, в то время как все четыре стороны расширяются от нее. Для масштабирования из верхнего левого угла используйте SetSpriteScale.

---

<a name="method-setspritescissor"></a>

### SetSpriteScissor()
```php
SetSpriteScissor(int $iSpriteIndex, float $x, float $y, float $x2, float $y2): void
```
При рисовании спрайт привязывается к указанным мировым координатам. Используйте значения 0,0,0,0, чтобы отключить ножницы спрайта

---

<a name="method-setspritescale"></a>

### SetSpriteScale()
```php
SetSpriteScale(int $iSpriteIndex, float $x, float $y): void
```
Устанавливает масштаб спрайта как абсолютное кратное его исходному размеру. Например, значение масштаба 2 удвоит размер спрайта, в то время как значение 1 вернет его к исходному размеру. Эта функция масштабируется из верхнего левого угла, поэтому любое увеличение размера будет держать верхнюю и левую стороны неподвижными, в то время как нижняя и правая стороны движутся. Центр вращения спрайтов (его текущая точка смещения) будет масштабироваться вместе со спрайтом. Для масштабирования от точки смещения используйте SetSpriteScaleByOffset.

---

<a name="method-setspritepositionbyoffset"></a>

### SetSpritePositionByOffset()
```php
SetSpritePositionByOffset(int $iSpriteIndex, float $fX, float $fY): void
```
Сразу же позиционирует указанный спрайт в заданные мировые координаты X,Y. Мировая система координат по умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно изменить с помощью SetVirtualResolution). Эта функция всегда позиционирует спрайт, используя его текущее смещение. Например, если текущее смещение является центром спрайта, эта команда поместит центр спрайта в заданные координаты.

---

<a name="method-setspriteposition"></a>

### SetSpritePosition()
```php
SetSpritePosition(int $iSpriteIndex, float $fX, float $fY): void
```
Сразу же позиционирует указанный спрайт в заданные мировые координаты X,Y. Мировая система координат по умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно изменить с помощью SetVirtualResolution). Эта функция всегда позиционирует спрайт, используя его верхний левый угол, независимо от текущего смещения спрайта. Верхний левый угол, используемый для позиционирования спрайта, не вращается вместе со спрайтом, например, когда спрайт вращается вокруг своего центра, воображаемый верхний левый угол остается фиксированным, и значение положения спрайта не меняется.

---

<a name="method-setspritephysicsvelocity"></a>

### SetSpritePhysicsVelocity()
```php
SetSpritePhysicsVelocity(int $iSpriteIndex, float $vx, float $vy): void
```
Немедленно устанавливает скорость спрайта в заданном направлении. Это резкое изменение, которое может показаться неправильным во время физического моделирования, силы и импульсы являются предпочтительным подходом к влиянию на скорость.

---

<a name="method-setspritephysicstorque"></a>

### SetSpritePhysicsTorque()
```php
SetSpritePhysicsTorque(int $iSpriteIndex, float $torque): void
```
Прикладывает крутящий момент к вращению спрайта, подобно тому, как прикладывает силу к его движению. Если спрайт ограничен окружающими объектами, он не может вращаться, если крутящий момент не достаточно велик, чтобы переместить и эти объекты. Крутящий момент будет длиться только для этого кадра, чтобы продолжать применять этот крутящий момент, вы должны продолжать вызывать эту функцию. Реакция на крутящий момент зависит от размера объекта, большие объекты будут вращаться медленнее, чем маленькие объекты при том же крутящем моменте.

---

<a name="method-setspritephysicsrestitution"></a>

### SetSpritePhysicsRestitution()
```php
SetSpritePhysicsRestitution(int $iSpriteIndex, float $restitution, int $shapeID): void
```
Устанавливает значение реституции (bounciness), которое будет использоваться для этого спрайта во время физических вычислений. Должно быть в диапазоне от 0 до 1. Значения больше 1 приведут к тому, что спрайт наберет энергию от столкновений, которые могут привести к нестабильному результату. По умолчанию это устанавливает все фигуры, назначенные этому спрайту, в одно и то же значение, вместо этого вы можете установить его для каждой фигуры, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает, что они применяются ко всем фигурам.

---

<a name="method-setspritephysicson"></a>

### SetSpritePhysicsOn()
```php
SetSpritePhysicsOn(int $iSpriteIndex, int $mode): void
```
Настраивает спрайт на автоматическое столкновение с помощью встроенной физической системы. После того как вы настроили спрайт на управление физикой, вы должны использовать SetSpritePosition и SetSpriteAngle экономно, так как они будут прерывать физическое движение спрайта. Вы также можете использовать SetSpritePhysicsVelocity и SetSpritePhysicsAngularVelocity для изменения скорости и направления спрайта, но опять же они будут мешать физическому движению спрайта. Если вы хотите повлиять на положение или вращение физического спрайта, вы должны использовать функции силы и крутящего момента (вращательной силы) там, где это возможно, они будут поддерживать плавное физическое движение. Параметр mode позволяет выбрать, как спрайт должен вести себя в физическом мире. Статическое означает, что он никогда не будет двигаться или вращаться, динамическое означает, что он будет реагировать на все столкновения и силы, с которыми он сталкивается, включая гравитацию и столкновения со статическими объектами. Кинематика-это особый случай, который можно рассматривать как движущееся статическое тело, оно не будет реагировать на столкновения или силы и будет продолжать двигаться с заданной скоростью вечно, но динамические элементы будут реагировать на него и эффективно выталкиваться с пути. Используемая физическая форма определяется командой SetSpriteShape, которая должна быть вызвана перед этой командой и дорого изменяется для круговых и полигональных форм, поскольку они восстанавливают форму из пикселей изображения спрайта. После того как вы вызвали эту команду для определения режима спрайта, дальнейшие вызовы будут игнорировать значения режима и она будет только повторно активировать спрайт, который был выключен, так как режим не может быть изменен, пока спрайт находится в физической системе. Если вы хотите изменить режим спрайта, вызовите SetSpritePhysicsDelete, который удалит все его физические настройки, а затем вызовите SetSpritePhysicsOn с новым режимом. Но делать это слишком часто будет замедлять работу системы. Все физические спрайты должны быть мировыми спрайтами (не фиксированными на экране), если только SetViewOffset не установлен на 0,0, и в этом случае это не имеет значения. В противном случае отладочные фигуры не будут выстраиваться в линию, а спрайты из разных пространств просмотра не будут взаимодействовать должным образом.

---

<a name="method-setspritephysicsmass"></a>

### SetSpritePhysicsMass()
```php
SetSpritePhysicsMass(int $iSpriteIndex, float $mass): void
```
Эта команда переопределяет вычисленную массу для этого спрайта и устанавливает ее в выбранное вами значение в килограммах. Установка этого значения слишком низко или слишком высоко может привести к нестабильной симуляции, особенно если очень легкий объект встречается с очень тяжелым. Диапазон значений, который вы должны использовать, зависит от выбранной вами шкалы физики. Внутренне масса по умолчанию для каждого объекта вычисляется на основе его размера. Коробка размером 1 х 1 м будет весить 1 кг, поэтому из-за стандартной шкалы физики 5 коробка размером 5 х 5 в виртуальных единицах весит 1 кг.

---

<a name="method-setspritephysicsoff"></a>

### SetSpritePhysicsOff()
```php
SetSpritePhysicsOff(int $iSpriteIndex): void
```
Временно отключив физику для этого спрайта, он больше не будет двигаться и реагировать на столкновения или силы. Используйте SetSpritePhysicsOn для реактивации спрайта.

---

<a name="method-setspritephysicsisbullet"></a>

### SetSpritePhysicsIsBullet()
```php
SetSpritePhysicsIsBullet(int $iSpriteIndex, int $bullet): void
```
Установите это значение в true, если спрайт, скорее всего, будет двигаться очень быстро, как пуля, так как затем он будет более тщательно проверяться на столкновение с другими динамическими спрайтами, использование которых без необходимости повлияет на производительность. Это называется непрерывным обнаружением столкновений (CCD) и автоматически применяется к проверке столкновений между этим спрайтом и статическими объектами. Эта команда включает CCD для проверки коллизий между этим спрайтом и динамическими объектами. Это не сработает, если global CCD будет отключен с помощью SetPhysicsCCD.

---

<a name="method-setspritephysicsissensor"></a>

### SetSpritePhysicsIsSensor()
```php
SetSpritePhysicsIsSensor(int $iSpriteIndex, int $sensor, int $shapeID): void
```
Установите это значение равным 1, чтобы сделать спрайт сенсорным объектом. Физические датчики обнаруживают столкновения и контакты, но не реагируют на них, они также не влияют ни на что, что попадает в них. Их единственная цель-обнаружение столкновений. Если вы примените это к динамическому телу, оно ни с чем не столкнется и, скорее всего, провалится сквозь пол и будет падать вечно, на него все еще действуют силы. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.

---

<a name="method-setspritephysicsimpulse"></a>

### SetSpritePhysicsImpulse()
```php
SetSpritePhysicsImpulse(int $iSpriteIndex, float $x, float $y, float $vx, float $vy): void
```
Похоже на силу, но применяется только один раз. В то время как силы прилагаются непрерывно в течение долгого времени, постепенно влияя на скорость спрайта, импульс имитирует внезапное попадание спрайта и немедленно изменяет скорость с эквивалентной силой аналогичной силы, приложенной в течение 1 секунды. Импульс состоит из точки в мировых координатах и направления, если точка и направление не совпадают с точкой смещения спрайта, то это приведет к вращению спрайта по мере его перемещения импульсом. Длина вектора импульса определяет его силу. Если спрайт ограничен окружающими объектами, он передаст импульс этим объектам и не сможет двигаться сам. Импульсы придают ускорение объекту относительно его массы, тяжелые объекты будут двигаться меньше, чем легкие объекты с тем же импульсом, приложенным к ним.

---

<a name="method-setspritephysicsfriction"></a>

### SetSpritePhysicsFriction()
```php
SetSpritePhysicsFriction(int $iSpriteIndex, float $friction, int $shapeID): void
```
Устанавливает значение трения, которое будет использоваться для этого спрайта во время физических вычислений. Должно быть в диапазоне от 0 до 1. По умолчанию это устанавливает все фигуры, назначенные этому спрайту, в одно и то же значение, вместо этого вы можете установить его для каждой фигуры, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает, что они применяются ко всем фигурам.

---

<a name="method-setspritephysicsforce"></a>

### SetSpritePhysicsForce()
```php
SetSpritePhysicsForce(int $iSpriteIndex, float $x, float $y, float $vx, float $vy): void
```
Применяет силу к спрайту, которая будет длиться только для этого кадра, чтобы продолжать применять эту силу, вы должны продолжать вызывать эту функцию. Сила состоит из точки в мировых координатах и направления, если точка и направление не совпадают с точкой смещения спрайта, то это приведет к вращению спрайта при его перемещении силой. Длина вектора силы определяет его силу. Если спрайт ограничен окружающими объектами, он не может двигаться, если сила не достаточно велика, чтобы переместить и эти объекты. Силы прилагают ускорение к объекту относительно его массы, тяжелые объекты будут двигаться меньше, чем легкие объекты с той же силой, приложенной к ним.

---

<a name="method-setspritephysicsdelete"></a>

### SetSpritePhysicsDelete()
```php
SetSpritePhysicsDelete(int $iSpriteIndex): void
```
Отключает физику для этого спрайта и удаляет все связанные с ним физические настройки для этого спрайта. Вы можете использовать это для изменения режима или формы спрайта, но регулярное выполнение этого может повлиять на производительность приложения.

---

<a name="method-setspritephysicsdensity"></a>

### SetSpritePhysicsDensity()
```php
SetSpritePhysicsDensity(int $iSpriteIndex, float $density, int $shapeID): void
```
Задает значение плотности, которое будет использоваться для данной формы спрайта во время физических вычислений. Значение по умолчанию равно 1.0. Это влияет на расчет массы для данного размера спрайта. Эта команда пересчитает массу и центр масс для этого спрайта. Используйте shapeID 0, чтобы применить эту плотность ко всем фигурам, или укажите идентификатор фигуры больше 0, чтобы применить ее только к этой фигуре. Идентификаторы фигур начинаются с 1 для первой фигуры.

---

<a name="method-setspritephysicsdamping"></a>

### SetSpritePhysicsDamping()
```php
SetSpritePhysicsDamping(int $iSpriteIndex, float $damp): void
```
Устанавливает некоторое демпфирование линейного движения спрайта, которое может имитировать что-то вроде сопротивления ветру. Значение 0 означает отсутствие демпфирования, значение 0,75 будет уменьшать вектор скорости наполовину каждую секунду при работе со скоростью 60 кадров в секунду. Более высокие значения приведут к более быстрому снижению скорости.

---

<a name="method-setspritephysicscanrotate"></a>

### SetSpritePhysicsCanRotate()
```php
SetSpritePhysicsCanRotate(int $iSpriteIndex, int $rotate): void
```
Задает, разрешено ли физическому моделированию вращать спрайт.

---

<a name="method-setspritephysicscom"></a>

### SetSpritePhysicsCOM()
```php
SetSpritePhysicsCOM(int $iSpriteIndex, float $x, float $y): void
```
Устанавливает центр масс (COM) относительно смещения спрайта. По умолчанию AGK вычисляет наилучшее местоположение для COM на основе размера и расположения всех фигур, прикрепленных к спрайту. Установка его на 0,0 поставит COM на точку смещения спрайта (и центр вращения). Если COM сильно отличается от точки смещения, спрайт может показаться нестабильным, так как он будет вести себя как несбалансированный волчок.

---

<a name="method-setspritephysicsangularimpulse"></a>

### SetSpritePhysicsAngularImpulse()
```php
SetSpritePhysicsAngularImpulse(int $iSpriteIndex, float $impulse): void
```
Аналогично силе крутящего момента, но приложенной только один раз. В то время как силы прилагаются непрерывно в течение долгого времени, постепенно влияя на скорость спрайта, импульс имитирует внезапное попадание спрайта и немедленно изменяет угловую скорость с эквивалентной мощностью аналогичной силы крутящего момента, приложенной в течение 1 секунды. Если спрайт ограничен окружающими объектами, он не может вращаться, если импульс не достаточно велик, чтобы переместить и эти объекты.  Реакция на импульс зависит от размера объекта, большие объекты будут вращаться медленнее, чем маленькие объекты, получившие тот же импульс.

---

<a name="method-setspritephysicsangularvelocity"></a>

### SetSpritePhysicsAngularVelocity()
```php
SetSpritePhysicsAngularVelocity(int $iSpriteIndex, float $va): void
```
Немедленно устанавливает скорость вращения спрайта в заданном направлении. Это резкое изменение, которое может показаться неправильным во время физического моделирования, крутящий момент и угловые импульсы являются предпочтительным подходом к влиянию на угловую скорость.

---

<a name="method-setspritephysicsangulardamping"></a>

### SetSpritePhysicsAngularDamping()
```php
SetSpritePhysicsAngularDamping(int $iSpriteIndex, float $damp): void
```
Устанавливает некоторое демпфирование углового движения спрайта, которое может имитировать что-то вроде сопротивления ветру. Значение 0 означает отсутствие демпфирования, значение 0,75 будет уменьшать вектор угловой скорости наполовину каждую секунду при работе со скоростью 60 кадров в секунду. Более высокие значения уменьшат вращение быстрее.

---

<a name="method-setspriteoffset"></a>

### SetSpriteOffset()
```php
SetSpriteOffset(int $iSpriteIndex, float $x, float $y): void
```
Точка смещения-это точка, вокруг которой будет вращаться спрайт,причем (0,0) - верхний левый угол, а (ширина, высота) - нижний правый угол. Смещение также можно использовать для позиционирования спрайта с помощью SetSpritePositionByOffset, в то время как SetSpritePosition всегда будет позиционировать спрайт с помощью его верхнего левого угла. Если спрайт масштабируется, не забудьте принять во внимание масштаб,спрайт, созданный как 10 на 10 единиц в ширину, масштабированный на 0,5, будет иметь нижний правый угол на уровне 5,5, поэтому расположить смещение в центре означало бы поместить его на 2,5, 2,5, когда спрайт масштабируется обратно, точка смещения будет масштабироваться вместе с ним, чтобы сохранить свое относительное положение. Эта команда вызывает пересчет формы спрайта из-за новой центральной точки, дополнительные формы не пересчитываются, поэтому будут искажены от их первоначального определения. Не рекомендуется вызывать эту команду на спрайте, уже настроенном для физики. Измените смещение перед применением физики или дополнительных фигур.

---

<a name="method-setspriteimage"></a>

### SetSpriteImage()
```php
SetSpriteImage(int $iSpriteIndex, int $iImageIndex): void
```
Измените изображение спрайта на новое загруженное изображение. Если новое изображение имеет другой размер или форму, чем старое, спрайт может выглядеть искаженным в результате, вы можете исправить это, сбросив размеры спрайта с помощью SetSpriteSize. Если спрайт анимирован, вам также может потребоваться снова вызвать SetSpriteAnimation. В случае круговых и полигональных спрайтов вы можете установить, использует ли спрайт это новое изображение для изменения своей формы столкновения. На форму коробки изменения изображения не влияют. Использование этой команды очистит все анимационные кадры, которые вы установили с помощью любой из команд sprite animation.

---

<a name="method-setspritegroup"></a>

### SetSpriteGroup()
```php
SetSpriteGroup(int $iSpriteIndex, int $group): void
```
Назначает этот спрайт группе для фильтрации коллизий (физических или нефизических). В физике спрайты с одним и тем же положительным идентификатором группы всегда будут сталкиваться, в то время как те, которые имеют один и тот же отрицательный идентификатор группы, никогда не будут сталкиваться. Те, у кого идентификатор группы равен нулю (по умолчанию), или отличающиеся идентификаторы групп переходят к проверке фильтра категорий. Если спрайт не настроен на физику, этот тест будет применяться только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.

---

<a name="method-setspriteframe"></a>

### SetSpriteFrame()
```php
SetSpriteFrame(int $iSpriteIndex, int $iFrame): void
```
Устанавливает спрайт на определенный кадр, кадры начинаются с 1 и заканчиваются на GetSpriteFrameCount

---

<a name="method-setspriteflip"></a>

### SetSpriteFlip()
```php
SetSpriteFlip(int $iSpriteIndex, int $horz, int $vert): void
```
Переворачивает спрайт либо по горизонтали, либо по вертикали (или и то, и другое). Это просто изменяет УФ-координаты так, чтобы спрайт выглядел перевернутым, он не регулирует значения положения или угла. Обратите внимание, что переворачивание как в горизонтальном, так и в вертикальном направлениях одновременно дает видимость поворота на 180 градусов.

---

<a name="method-setspritedepth"></a>

### SetSpriteDepth()
```php
SetSpriteDepth(int $iSpriteIndex, int $iDepth): void
```
Устанавливает порядок рисования спрайта между 0-10000, 0 - передняя часть экрана, 10000 - задняя. Все, что выше 10000, приведет к тому, что спрайт будет вырезан из поля зрения. По умолчанию спрайты находятся на глубине 10. Если два спрайта занимают одну и ту же глубину, то порядок их рисования не определен, если только SetSortCreated не используется в значении true, и в этом случае спрайты на одной и той же глубине будут нарисованы в том порядке, в котором они были созданы. Для максимальной производительности рекомендуется, чтобы каждый спрайт имел свое собственное значение глубины, если только порядок их рисования не имеет значения, например, физические спрайты, которые обычно не перекрываются. Обратите внимание, что если вы не используете КАКИЕ-либо 3D-объекты и используете глубину спрайта больше 5000, вы должны использовать SetGlobal3DDepth до 10000 для повышения производительности (по существу, выводя все спрайты на переднюю панель 3D-рендера).

---

<a name="method-setspritecolorblue"></a>

### SetSpriteColorBlue()
```php
SetSpriteColorBlue(int $iSpriteIndex, int $iBlue): void
```
Установите синий компонент спрайта.

---

<a name="method-setspritecolorgreen"></a>

### SetSpriteColorGreen()
```php
SetSpriteColorGreen(int $iSpriteIndex, int $iGreen): void
```
Установите зеленый компонент спрайта.

---

<a name="method-setspritecolorred"></a>

### SetSpriteColorRed()
```php
SetSpriteColorRed(int $iSpriteIndex, int $iRed): void
```
Установите красный компонент спрайта.

---

<a name="method-setspritecoloralpha"></a>

### SetSpriteColorAlpha()
```php
SetSpriteColorAlpha(int $iSpriteIndex, int $iAlpha): void
```
Установите альфа-компонент спрайта.

---

<a name="method-setspritecolor"></a>

### SetSpriteColor()
```php
SetSpriteColor(int $iSpriteIndex, int $iRed, int $iGreen, int $iBlue, int $iAlpha): void
```
Установите цвет спрайта.

---

<a name="method-setspritecollidebits"></a>

### SetSpriteCollideBits()
```php
SetSpriteCollideBits(int $iSpriteIndex, int $mask, int $shapeID): void
```
Использует побитовую маску, чтобы определить, с какими категориями спрайтов этот спрайт может столкнуться. Спрайты назначаются категориям с помощью SetSpriteCategoryBits. Существует 16 категорий, каждая из которых представлена одним битом в параметре "маска", значение 1 для бита означает, что этот спрайт столкнется со спрайтами из этой категории, и 0-что он не столкнется с этой категорией, независимо от того, к какой категории принадлежит сам этот спрайт. По умолчанию все спрайты принадлежат к категории 1 (0x0001 самый правый бит) и сталкиваются со всеми категориями (0xffff). Если спрайт не настроен на физику, этот тест будет применяться только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.

---

<a name="method-setspritecategorybits"></a>

### SetSpriteCategoryBits()
```php
SetSpriteCategoryBits(int $iSpriteIndex, int $categories): void
```
Присваивает спрайту ноль или более категорий для фильтрации столкновений (физические и нефизические). Существует 16 категорий, каждая из которых представлена одним битом в параметре "категории", значение 1 для бита означает, что этот спрайт является частью этой категории, а 0-что он не принадлежит к этой категории. Затем спрайты могут быть настроены на столкновение с определенными категориями с помощью SetSpriteCollideBits независимо от того, к каким категориям они сами принадлежат. По умолчанию все спрайты относятся к категории 1 (0x0001 самый правый бит) и сталкиваются со всеми категориями (0xffff). Если спрайт не настроен на физику, этот тест будет применяться только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.

---

<a name="method-setspritecollidebit"></a>

### SetSpriteCollideBit()
```php
SetSpriteCollideBit(int $iSpriteIndex, int $category, int $flag): void
```
Устанавливает или удаляет категорию, с которой может столкнуться этот спрайт. Спрайтам присваиваются категории с помощью SetSpriteCategoryBit. Существует 16 категорий, значение 1 для этой категории означает, что этот спрайт столкнется со спрайтами из этой категории, а 0-что он не столкнется с этой категорией, независимо от того, к какой категории принадлежит сам этот спрайт. По умолчанию все спрайты относятся к категории 1 и сталкиваются со всеми категориями. Эта команда похожа на SetSpriteCategoryBits, за исключением того, что эта команда устанавливает одну категорию за раз, в то время как эта команда устанавливает их все сразу, используя битовую маску. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.

---

<a name="method-setspritecategorybit"></a>

### SetSpriteCategoryBit()
```php
SetSpriteCategoryBit(int $iSpriteIndex, int $category, int $flag, int $shapeID): void
```
Назначает или удаляет спрайт из определенной категории. Существует 16 категорий, к которым может принадлежать спрайт, и спрайт может принадлежать к любому числу сразу. Эта команда похожа на SetSpriteCategoryBits, за исключением того, что эта команда устанавливает одну категорию за раз, в то время как эта команда устанавливает их все сразу, используя битовую маску. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.

---

<a name="method-setspriteanimation"></a>

### SetSpriteAnimation()
```php
SetSpriteAnimation(int $iSpriteIndex, int $iFrameWidth, int $iFrameHeight, int $iFrameCount): void
```
Инициализирует анимацию спрайта кадрами из назначенного ему изображения на основе ширины и высоты кадра. Спрайт будет использовать ширину и высоту кадра для извлечения изображений этого размера из назначенного ему изображения, начиная с верхнего левого угла и перемещаясь слева направо. Когда он достигнет правой части изображения, он снова начнет двигаться на одну строку вниз, снова двигаясь слева направо, пока не будет достигнуто количество кадров или не закончится место на изображении для поиска кадров. Поддерживается сохранение анимационного изображения на текстуре атласа. Эта функция является предпочтительным методом назначения анимации спрайту, поскольку она позволяет избежать дорогостоящих изменений изображения во время рендеринга. Однако если все ваши анимационные кадры являются отдельными изображениями, вы можете использовать AddSpriteAnimationFrame для добавления кадров из изображений по отдельности. Использование SetSpriteImage очистит все анимационные кадры, которые вы установили здесь.

---

<a name="method-setspriteanglerad"></a>

### SetSpriteAngleRad()
```php
SetSpriteAngleRad(int $iSpriteIndex, float $fAng): void
```
Немедленно поворачивает указанный спрайт на заданный угол в радианах. По умолчанию спрайты вращаются вокруг своего центра, см. SetSpriteOffset, чтобы изменить это.

---

<a name="method-setspriteangle"></a>

### SetSpriteAngle()
```php
SetSpriteAngle(int $iSpriteIndex, float $fAng): void
```
Немедленно поворачивает указанный спрайт на заданный угол в градусах. По умолчанию спрайты вращаются вокруг своего центра, см. SetSpriteOffset, чтобы изменить это.

---

<a name="method-setspriteadditionalimage"></a>

### SetSpriteAdditionalImage()
```php
SetSpriteAdditionalImage(int $iSpriteIndex, int $iImageIndex, int $iStage): void
```
Добавляет в спрайт дополнительные изображения, которые можно использовать с шейдерами. Набор изображений с помощью SetSpriteImage используется в качестве этапа текстуры 0, и эта команда позволит вам установить этапы от 1 до 7. Эти дополнительные изображения не играют никакой роли в анимации или вычислениях формы. Обратите внимание, что спрайт будет иметь одинаковые УФ-координаты для каждой текстуры, поэтому рекомендуется, чтобы изображения имели одинаковые размеры или использовали мощность 2 изображений, чтобы избежать УФ-преобразования на мобильных устройствах, где изображения могут быть масштабированы.

---

<a name="method-setspriteactive"></a>

### SetSpriteActive()
```php
SetSpriteActive(int $iSpriteIndex, int $bActive): void
```
Устанавливает, обновляет ли этот спрайт свою анимацию и физику каждый кадр, спрайт может быть видимым или нет, что контролируется SetSpriteVisible.

---

<a name="method-setspeechrate"></a>

### SetSpeechRate()
```php
SetSpeechRate(float $rate): void
```
Устанавливает скорость речи, где 1.0-нормальная скорость, 2.0-двойная скорость, 0.5-половинная скорость и так далее.  В настоящее время работает только на iOS и Android.

---

<a name="method-setspeechlanguagebyid"></a>

### SetSpeechLanguageByID()
```php
SetSpeechLanguageByID(string $sID): void
```
Задает язык, используемый при произнесении текста по голосовому идентификатору. Идентификатор можно найти с помощью GetSpeechVoiceID и необходим, когда несколько голосов имеют один и тот же язык, но с разными акцентами.

---

<a name="method-setspeechlanguage"></a>

### SetSpeechLanguage()
```php
SetSpeechLanguage(string $lang): void
```
Задает язык, используемый при произнесении текста, например "en_GB" для британского английского, "en_US" для американского английского, "fr_FR" для французского и т. Д. Если языковой движок в данный момент не находится на устройстве, то устройство попытается загрузить его при следующем вызове Speak, что может привести к задержке перед произнесением этого текста. Если загрузка завершится неудачно или подключение к Интернету будет недоступно, то будет использоваться языковой движок по умолчанию для текущего устройства.  В настоящее время работает только на iOS и Android.

---

<a name="method-setsoundsystemvolume"></a>

### SetSoundSystemVolume()
```php
SetSoundSystemVolume(int $iVol): void
```
Устанавливает основную громкость звука для всех звуков. Отдельные объемы звука останутся нетронутыми, но все объемы умножаются на основную громкость звука, позволяя использовать такие функции, как затухание.

---

<a name="method-setsoundinstancevolume"></a>

### SetSoundInstanceVolume()
```php
SetSoundInstanceVolume(int $iID, int $vol): void
```
Устанавливает текущий объем указанного экземпляра в диапазоне от 0 до 100. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.

---

<a name="method-setsoundinstancerate"></a>

### SetSoundInstanceRate()
```php
SetSoundInstanceRate(int $iID, float $rate): void
```
Устанавливает текущую скорость воспроизведения указанного экземпляра, где 1.0-нормальная скорость, 2.0 - двойная скорость и так далее. Не все устройства гарантированно поддерживают изменение скорости воспроизведения. Используйте GetSoundMaxRate и GetSoundMinRate для проверки допустимых диапазонов для текущего устройства, любые значения вне этого диапазона будут зажаты. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.

---

<a name="method-setsoundinstancebalance"></a>

### SetSoundInstanceBalance()
```php
SetSoundInstanceBalance(int $iID, float $balance): void
```
Устанавливает текущий баланс указанного экземпляра, при этом 0 находится по центру, -1.0-все на левом динамике, а 1.0-все на правом динамике, любые значения вне этого диапазона будут зажаты. Это лучше всего работает с моно-звуками, но может быть применено и к стереозвукам. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.

---

<a name="method-setsounddevicemode"></a>

### SetSoundDeviceMode()
```php
SetSoundDeviceMode(int $mode): void
```
Устанавливает, будет ли приложение разрешать фоновую музыку из других приложений продолжать воспроизведение (режим=0) или отключать другие приложения, пока это приложение активно (режим=1). Обратите внимание, что в режиме 0 устройство считает звук вашего приложения несущественным, поэтому будет отключено, если звонок устройства установлен в бесшумное состояние. Это работает только на iOS.

---

<a name="method-setsorttransparentdepth"></a>

### SetSortTransparentDepth()
```php
SetSortTransparentDepth(int $sort): void
```
Задает, должен ли AGK сортировать прозрачные спрайты по глубине при рисовании. Это сначала рисует спрайты в задней части экрана, чтобы достичь правильного результата смешивания, когда прозрачные спрайты перекрываются. Он включен по умолчанию, но если ваши прозрачные спрайты гарантированно не перекрываются, вы можете отключить его, чтобы повысить производительность. Эта команда устарела, сортировка теперь обрабатывается автоматически.

---

<a name="method-setsorttextures"></a>

### SetSortTextures()
```php
SetSortTextures(int $sort): void
```
Задает, должен ли AGK сортировать спрайты по текстуре при рисовании, чтобы ограничить количество изменений текстуры. Это улучшит производительность на устройствах, которые плохо справляются с частыми изменениями состояния, но может снизить производительность, если текстуры на спрайтах часто меняются. По умолчанию он выключен, но если вы не меняете текстуры спрайтов или используете текстуры атласа, рекомендуется включить его. Эта команда устарела, сортировка теперь обрабатывается автоматически.

---

<a name="method-setsortdepth"></a>

### SetSortDepth()
```php
SetSortDepth(int $sort): void
```
Задает, должен ли AGK сортировать непрозрачные спрайты по глубине при рисовании. Это сначала рисует спрайты в передней части экрана, которые заполняют буфер глубины, так что более поздние спрайты позади могут быть пропущены. Это улучшит производительность на устройствах с ограниченной скоростью заполнения, где вы рисуете много перекрывающихся непрозрачных спрайтов. По умолчанию он выключен, но если вы не часто меняете глубину спрайта, рекомендуется включить его. Это не относится к прозрачным спрайтам, которые имеют свои собственные требования к сортировке. Эта команда устарела, сортировка теперь обрабатывается автоматически.

---

<a name="method-setsortcreated"></a>

### SetSortCreated()
```php
SetSortCreated(int $sort): void
```
Если два спрайта занимают одну и ту же глубину, то порядок их рисования не определен, если только эта функция не установлена в 1, и в этом случае спрайты на одной и той же глубине будут нарисованы в том порядке, в котором они были созданы. Для максимальной производительности рекомендуется, чтобы каждый спрайт имел свое собственное значение глубины с этой командой, установленной в 0. Если порядок их рисования не важен, например, физические спрайты, которые обычно не перекрываются, то вы можете использовать спрайты на одной и той же глубине, не устанавливая эту команду в 1.

---

<a name="method-setsleepmode"></a>

### SetSleepMode()
```php
SetSleepMode(int $mode): void
```
Устанавливает, должно ли устройство спать, когда ваше приложение находится в режиме ожидания. По умолчанию он выключен, но если он активирован, то будет использовать настройки устройства, чтобы определить, как долго оно должно простаивать перед сном.

---

<a name="method-setsnapchatstickersettings"></a>

### SetSnapChatStickerSettings()
```php
SetSnapChatStickerSettings(float $x, float $y, int $width, int $height, float $angle): void
```
Задает свойства для любых изображений наклеек, добавляемых в будущие вызовы ShareSnapChatImage. Параметры X и Y должны находиться в диапазоне от 0.0 до 1.0, например, в направлении X 1.0-это крайняя правая часть изображения, а 0.0-крайняя левая часть изображения.

---

<a name="method-setskyboxvisible"></a>

### SetSkyBoxVisible()
```php
SetSkyBoxVisible(int $active): void
```
Устанавливает, виден ли объект sky box или нет. По умолчанию он не виден. Поле неба всегда будет появляться позади всех других 3D-объектов и будет нарисовано в максимальном видимом диапазоне обзора, который задается с помощью SetCameraRange. В поле sky есть дополнительное солнце, которое будет нарисовано в соответствии с текущим направлением света, установленным с помощью SetSunDirection. Однако он не будет использовать направленный световой цвет, поэтому вы можете иметь направленный свет как один цвет, а небо и солнце-как другой цвет.

---

<a name="method-setskyboxsunvisible"></a>

### SetSkyBoxSunVisible()
```php
SetSkyBoxSunVisible(int $visible): void
```
Устанавливает, будет ли небесная коробка рисовать солнце в месте текущего направленного света. Его положение можно установить с помощью SetSunDirection, но он не будет использовать направленный светлый цвет, вы можете установить его отдельно с помощью SetSkyBoxSunColor. Обратите внимание, что установка видимого солнца изменяет расчеты чертежа небесного ящика, делая их более сложными, что может повлиять на производительность.

---

<a name="method-setskyboxsunsize"></a>

### SetSkyBoxSunSize()
```php
SetSkyBoxSunSize(float $sun, float $halo): void
```
Устанавливает размер солнца и его ореола, если он виден. Значения размера не относятся ни к каким мировым единицам измерения и должны находиться в диапазоне от 1,0 до 100,0. Значения по умолчанию-5,0 для солнца и 50,0 для гало.

---

<a name="method-setskyboxsuncolor"></a>

### SetSkyBoxSunColor()
```php
SetSkyBoxSunColor(int $red, int $green, int $blue): void
```
Устанавливает цвет солнца, если он виден. По умолчанию это 255,230,179. Цвета должны находиться в диапазоне от 0 до 255, хотя это не ограничено и значения за пределами этого диапазона будут приниматься, включая отрицательные значения. Обратите внимание, что из-за того, как цвет солнца добавляется к цвету неба, цвета солнца темнее, чем цвет неба, могут привести к неожиданному цвету солнца, когда один или несколько цветовых компонентов полностью отсутствуют. Если это произойдет, то масштабирование цвета солнца, поднимаясь выше 255, если это необходимо, удалит его. Цвет солнца оказывает некоторое влияние на размер солнца в дополнение к SetSkyBoxSunSize, причем более яркие цвета делают его больше.

---

<a name="method-setskyboxskycolor"></a>

### SetSkyBoxSkyColor()
```php
SetSkyBoxSkyColor(int $red, int $green, int $blue): void
```
Задает цвет, который заполнит большую часть неба. По умолчанию это 161 183 209. Цвета должны находиться в диапазоне от 0 до 255, хотя это не ограничено и значения за пределами этого диапазона будут приниматься, включая отрицательные значения.

---

<a name="method-setskyboxhorizonsize"></a>

### SetSkyBoxHorizonSize()
```php
SetSkyBoxHorizonSize(float $size, float $height): void
```
Устанавливает размер и высоту горизонта. По умолчанию размер равен 4.0, а высота-0.0. Это влияет на то, как высоко простирается цвет горизонта, прежде чем стать цветом неба. Значение высоты находится в мировых координатах, и все, что находится на этой высоте или ниже нее, будет иметь цвет горизонта. Выше этой высоты горизонт сливается с цветом неба, пока в какой-то момент не остается только цвет неба. Горизонт всегда будет находиться на заданной высоте в мире, даже если камера движется вверх и вниз. Значение размера не относится ни к каким мировым единицам и должно быть установлено по вашему вкусу, тогда эффективный диапазон составляет от 0,1 до примерно 50,0, но может быть установлен и выше. Если диапазон обзора мал, то значение высоты будет иметь больший эффект, поскольку небесный ящик приближается к камере ближе, чем если бы диапазон обзора был больше. Например, высота горизонта 100 с небольшим диапазоном обзора будет казаться очень высокой, но когда диапазон обзора больше, камера просматривает горизонт с гораздо большего расстояния, поэтому изменение высоты на 100 единиц будет иметь меньший эффект.

---

<a name="method-setskyboxhorizoncolor"></a>

### SetSkyBoxHorizonColor()
```php
SetSkyBoxHorizonColor(int $red, int $green, int $blue): void
```
Задает цвет, который будет отображаться на горизонте. По умолчанию это 255,255,255. Цвета должны находиться в диапазоне от 0 до 255, хотя это не ограничено и значения за пределами этого диапазона будут приниматься, включая отрицательные значения.

---

<a name="method-setskeleton2dvisible"></a>

### SetSkeleton2DVisible()
```php
SetSkeleton2DVisible(int $iSkeleton, int $mode): void
```
Устанавливает, является ли указанный скелет видимым или нет. AGK автоматически скроет скелет, когда он переместится за пределы экрана, чтобы повысить производительность, поэтому вам нужно сделать это только в том случае, если вы хотите скрыть его, пока он находится на экране. Когда скелет спрятан, он все равно оживет.

---

<a name="method-setskeleton2drotation"></a>

### SetSkeleton2DRotation()
```php
SetSkeleton2DRotation(int $iSkeleton, float $r): void
```
Устанавливает угол корня скелета, углы костей будут относительно этого угла.

---

<a name="method-setskeleton2dposition"></a>

### SetSkeleton2DPosition()
```php
SetSkeleton2DPosition(int $iSkeleton, float $x, float $y): void
```
Устанавливает положение корня скелета, положение костей будет относительно этого места. Это может быть использовано для перемещения скелета во время его анимации, чтобы сделать его похожим на ходьбу.

---

<a name="method-setskeleton2dflip"></a>

### SetSkeleton2DFlip()
```php
SetSkeleton2DFlip(int $iSkeleton, int $flipH, int $flipV): void
```
Устанавливает горизонтальный и вертикальный режим переворота скелета, это будет переворачивать все кости и спрайты вдоль горизонтальной или вертикальной оси (или и то, и другое).

---

<a name="method-setskeleton2ddepth"></a>

### SetSkeleton2DDepth()
```php
SetSkeleton2DDepth(int $iSkeleton, int $depth): void
```
Устанавливает глубину этого скелета в диапазоне 0-10000 с 0 - вершиной.

---

<a name="method-setskeleton2dbonescale"></a>

### SetSkeleton2DBoneScale()
```php
SetSkeleton2DBoneScale(int $iSkeleton, int $bone, float $sx, float $sy): void
```
Установите исходную шкалу кости. Анимация переопределит это значение.

---

<a name="method-setskeleton2dboneposition"></a>

### SetSkeleton2DBonePosition()
```php
SetSkeleton2DBonePosition(int $iSkeleton, int $bone, float $x, float $y): void
```
Установка исходного положения кости относительно ее родителя также известна как установочная поза. Вся анимация будет находиться относительно этой позиции, она может быть изменена во время воспроизведения анимации.

---

<a name="method-setskeleton2dbonemode"></a>

### SetSkeleton2DBoneMode()
```php
SetSkeleton2DBoneMode(int $iSkeleton, int $bone, int $mode): void
```
Устанавливает, может ли кость оживать или она остается неподвижной. Вы все еще можете изменить положение кости, угол наклона и масштаб вручную.

---

<a name="method-setskeleton2danimationspeed"></a>

### SetSkeleton2DAnimationSpeed()
```php
SetSkeleton2DAnimationSpeed(int $iSkeleton, float $speed): void
```
Устанавливает скорость анимации (по умолчанию 1.0), отрицательные значения разрешены для реверса анимации.

---

<a name="method-setskeleton2dboneangle"></a>

### SetSkeleton2DBoneAngle()
```php
SetSkeleton2DBoneAngle(int $iSkeleton, int $bone, float $r): void
```
Установите исходный угол кости относительно ее родителя. Вся анимация будет относительно этого угла, он может быть изменен во время воспроизведения анимации.

---

<a name="method-setskeleton2danimationframe"></a>

### SetSkeleton2DAnimationFrame()
```php
SetSkeleton2DAnimationFrame(int $iSkeleton, string $anim, float $time, float $tweentime): void
```
Устанавливает скелет в определенную точку анимации в зависимости от времени, с дополнительным временем твиннинга. Время анимации будет плавно интерполировать скелет из его текущего состояния в выбранный кадр указанной анимации, чтобы не было резкого перехода.

---

<a name="method-setsharedvariableappgroup"></a>

### SetSharedVariableAppGroup()
```php
SetSharedVariableAppGroup(string $group): void
```
Только для iOS. Сообщает AGK, какую группу приложений вы используете для обмена данными между приложениями. Например, group.com.mycompany.mygroup.myvariables создается на портале разработчиков Apple и должен быть добавлен к каждому идентификатору приложения, к которому вы хотите получить доступ к этим переменным. Вам нужно будет заново создать профиль подготовки для каждого приложения после добавления группы приложений к его идентификатору приложения.

---

<a name="method-setshadowmappingmode"></a>

### SetShadowMappingMode()
```php
SetShadowMappingMode(int $mode): void
```
Включает или выключает отображение теней, по умолчанию это выключено. Тени генерируются только глобальным направленным светом, которым можно управлять с помощью команды SetSunDirection. Обратите внимание, что это не гарантировано поддерживается на всех устройствах, вы можете проверить наличие текущего устройства, вызвав GetShadowMappingSupported. В настоящее время существует три режима теней, которые можно использовать, режим 1 использует равномерное отображение теней, которое имеет более низкое, но стабильное качество. Режим 2 использует Light Space Perspective shadow mapping (LiPSM), который в большинстве случаев имеет более высокое качество, но если камера смотрит в том же направлении, что и свет, то это не лучше, чем Равномерное теневое отображение. Перспектива светлого пространства также страдает от мерцания теней при движении камеры, в то время как Равномерность более стабильна. Оба имеют примерно одинаковую производительность. Режим 3 использует каскадное теневое отображение, которое использует несколько теневых карт для поддержания высокого качества вблизи камеры, в то же время позволяя более низкие качественные тени на расстоянии. Этот метод имеет гораздо более низкую производительность, чем предыдущие два метода, но во всех случаях приводит к более качественным теням. Обратите внимание, что при использовании режимов 1 и 2 этап текстуры 7 на всех объектах, получающих тень, зарезервирован для карты теней. При использовании теневого режима 3 (каскадные тени) для теневых карт зарезервированы этапы текстуры 4, 5, 6 и 7.

---

<a name="method-setshadowsmoothing"></a>

### SetShadowSmoothing()
```php
SetShadowSmoothing(int $mode): void
```
Устанавливает режим сглаживания для теневой карты. Режим 0 отключает сглаживание и приводит к самым быстрым теням, но создает жесткие края. Режим 1 немного медленнее, но создает более мягкие тени, многократно пробуя карту теней. Режим 2 использует случайную мультисэмплировку, чтобы избежать полос, создаваемых режимом 1, но еще медленнее.

---

<a name="method-setshadowmapsize"></a>

### SetShadowMapSize()
```php
SetShadowMapSize(int $width, int $height): void
```
Задает разрешение теневой карты в пикселях. Хорошие значения-512x512 или 1024x1024, это не обязательно должна быть степень двух по размеру. Чем выше разрешение, тем лучше качество теней, хотя производительность будет ниже при более высоком разрешении теневых карт.

---

<a name="method-setshadowrange"></a>

### SetShadowRange()
```php
SetShadowRange(float $range): void
```
Устанавливает диапазон от камеры, в котором будут нарисованы тени. В идеале это должно быть установлено на дальний диапазон камеры от SetCameraRange, но рисование теней до самой дальней плоскости может отнять некоторое качество у тех теней, которые находятся ближе к камере. Поэтому установка диапазона теней ниже, чем дальний диапазон камеры, может улучшить качество теней за счет удаленных объектов, не имеющих теней. Фактический диапазон теней будет меньшим значением дальнего диапазона камеры и этого диапазона теней, поэтому вы можете безопасно установить его больше, чем дальний диапазон камеры, без какого-либо влияния на качество. Если позже вы отрегулируете дальний диапазон камеры, то диапазон теней не изменится соответствующим образом, вы должны установить его отдельно. Используйте значение -1, чтобы игнорировать это значение, и всегда используйте дальний диапазон камеры для теней. По умолчанию это значение равно -1.

---

<a name="method-setshadowbias"></a>

### SetShadowBias()
```php
SetShadowBias(float $bias): void
```
Устанавливает смещение для смещения теней так, чтобы поверхности объектов не затеняли сами себя, по умолчанию значение равно 0,001. Это может помочь предотвратить появление теневых артефактов на поверхностях, которые находятся на свету, но также отбрасывают тень позади себя.

---

<a name="method-setshadowlightstepsize"></a>

### SetShadowLightStepSize()
```php
SetShadowLightStepSize(float $step): void
```
Ограничивает угол направленного света шагами заданного размера, а не непрерывным значением. Это может предотвратить мерцание тени, если направленный свет медленно меняет свой угол, например, солнце движется по небу. По умолчанию это значение равно 0, что отключает размер шага и сохраняет угол как непрерывное значение. Значения в диапазоне от 0,1 до 2,0, по-видимому, работают лучше всего. Это применимо только в том случае, если SetShadowMappingMode имеет значение Uniform.

---

<a name="method-setshadowcascadevalues"></a>

### SetShadowCascadeValues()
```php
SetShadowCascadeValues(float $cascade1, float $cascade2, float $cascade3): void
```
При использовании cascade shadow maps (SetShadowMappingMode 3) эта команда устанавливает диапазон, который будет охватывать каждая каскадная карта. Всего существует 4 каскадных теневых карты, четвертая всегда охватывает всю затененную область (cascade4 = 1.0), по умолчанию третий каскад охватывает половину затененной области (cascade3 = 0.5), второй каскад охватывает четверть затененной области (cascade2 = 0.25), а первый каскад охватывает одну восьмую затененной области (cascade1 = 0.125). Поскольку все каскадные теневые карты используют одинаковое разрешение, чем меньше площадь, которую они покрывают, тем больше деталей тени будет в этой области. Каскадные теневые карты упорядочены таким образом, что самая маленькая из них находится ближе всего к камере, а самая большая-дальше всего. Таким образом, тени вблизи камеры должны иметь высокую детализацию, в то время как самые дальние, которые менее заметны, будут иметь более низкую детализацию. Обратите внимание, что, хотя использование меньшей площади для конкретного каскада увеличит качество тени, это уменьшит площадь, которую этот каскад покрывает, поэтому качество тени упадет на следующий уровень раньше, чем расстояние от камеры увеличится.   Каскадные уровни должны находиться в диапазоне от 0.0 до 1.0, и каждый уровень должен быть больше предыдущего уровня, то есть каскад2 должен быть больше каскада1 и так далее. Если эти правила нарушены, то эта команда ничего не сделает.

---

<a name="method-setshaderconstantarraybyname"></a>

### SetShaderConstantArrayByName()
```php
SetShaderConstantArrayByName(int $shaderID, string $szName, int $arrayIndex, float $value1, float $value2, float $value3, float $value4): void
```
Задает индекс массива констант шейдера по имени, константа должна быть помечена как "однородная" в источнике шейдера. Индексы массива начинаются с 0, если индекс массива находится за пределами границ, то он будет проигнорирован и никакие изменения не будут внесены. Это повлияет на все объекты, нарисованные с помощью этого шейдера. Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4 значения и отбрасывает все, которые не используются именованной переменной.

---

<a name="method-setshaderconstantbyname"></a>

### SetShaderConstantByName()
```php
SetShaderConstantByName(int $shaderID, string $szName, float $value1, float $value2, float $value3, float $value4): void
```
Задает константу шейдера по имени, константа должна быть помечена как "однородная" в источнике шейдера. Это повлияет на все объекты, нарисованные с помощью этого шейдера. Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4 значения и отбрасывает все, которые не используются именованной переменной.

---

<a name="method-setscreenresolution"></a>

### SetScreenResolution()
```php
SetScreenResolution(int $width, int $height): void
```
Устанавливает разрешение заднего буфера там, где это возможно. Если выбранное вами разрешение больше, чем может отображать устройство, чем устройство будет использовать свое максимально возможное разрешение, вы можете использовать GetDeviceWidth и GetDeviceHeight, чтобы узнать, что было использовано. На мобильных устройствах использование разрешения экрана с другим соотношением сторон, чем на устройстве, приведет к растяжению. Вы можете проверить соотношение сторон устройства с помощью GetMaxDeviceWidth и GetMaxDeviceHeight. Не рекомендуется разрешать как портретную, так и альбомную ориентацию при использовании этой команды, так как AGK не может предотвратить растяжение без отмены желаемого разрешения экрана, поэтому он этого не сделает. Если вы хотите, чтобы все ориентации были без растяжения, вам нужно будет следить за изменениями GetMaxDeviceWidth и GetMaxDeviceHeight и установить соответствующее разрешение замены с помощью SetScreenResolution, чтобы оно соответствовало новому соотношению сторон. Использование разрешения 0 в любом направлении приведет к сбросу разрешения экрана до максимального разрешения, поддерживаемого на устройстве. Обратите внимание, что в Windows и Mac размер backbuffer изменяется путем изменения размера окна, поэтому он будет перезаписывать любые настройки из SetWindowSize. Это может быть не так в будущем, и AGK может иметь отдельные размеры окон и размеры backbuffer в будущей версии.

---

<a name="method-setscissor"></a>

### SetScissor()
```php
SetScissor(float $x, float $y, float $x2, float $y2): void
```
Эта функция задает область экрана, которая будет отображаться в последующих командах Sync() или Render (). Область определяется двумя точками, представляющими верхний левый и нижний правый углы прямоугольника, который будет новой областью рисования. По умолчанию это значение равно вашему виртуальному разрешению, поэтому все, что находится за пределами этого разрешения, не будет видно. Использование SetScissor(0,0,0,0) - это особый случай, который отключит все отсечения и сделает весь экран пригодным для отображения вещей. Это может быть полезно при создании приложения, которое работает с различными соотношениями сторон. Например, использование виртуального разрешения 1024х768 на устройстве с экраном 1280х800 будет соответствовать области 1024х768 как можно ближе в центре экрана, с черными границами по обе стороны. SetScissor(0,0,0,0) помещает область 1024x768 в одно и то же место, но там нет черных границ, поэтому размещение чего-то в отрицательном положении X все равно будет видно до тех пор, пока экран все еще может поместиться. В то время как размещение чего-то в отрицательном положении на устройстве с экраном 1024x768 (который идеально подходит для вашего виртуального разрешения) приведет к тому, что этот элемент исчезнет с края экрана. Вы можете использовать это с помощью команд GetScreenBoundsLeft, GetScreenBoundsRight, GetScreenBoundsTop и GetScreenBoundsBottom, чтобы найти фактический край экрана в выбранном вами разрешении. Это позволяет размещать элементы по краю экрана на всех устройствах независимо от его соотношения сторон.

---

<a name="method-setresolutionmode"></a>

### SetResolutionMode()
```php
SetResolutionMode(int $mode): void
```
Некоторые платформы имеют экраны с высоким разрешением, такие как iPad, эта функция определяет, как эти платформы отображают свой контент. У вас есть выбор mode=1, который будет использовать буфер кадров полного разрешения, который будет выглядеть лучше, или mode=0, который будет использовать буфер кадров меньшего разрешения (обычно половинного размера), который затем масштабируется по размеру экрана и будет работать быстрее. Это не влияет на устройства с низким разрешением, которые всегда будут использовать буфер кадров с низким разрешением.

---

<a name="method-setrendertoscreen"></a>

### SetRenderToScreen()
```php
SetRenderToScreen(): void
```
Эта команда устанавливает конвейер рендеринга для вывода любых будущих вызовов рисования на экран. Это режим по умолчанию, поэтому вам нужно вызвать его только в том случае, если вы ранее перенаправили рисунок на изображение с помощью SetRenderToImage.

---

<a name="method-setrendertoimage"></a>

### SetRenderToImage()
```php
SetRenderToImage(int $colorImage, int $depthImage): void
```
Перенаправляет все будущие вызовы рисования на изображение, а не на экран. Затем указанное изображение может быть применено к объекту или спрайту. Будьте осторожны, чтобы не применять к объекту или спрайту одновременно с его рисованием, так как это может привести к ошибке. Вы также можете выбрать визуализацию информации о глубине для изображения, которое вы можете использовать позже, или визуализацию без буфера глубины, если ваша сцена в нем не нуждается. Вы также можете использовать идентификатор изображения глубины, равный -1, для рендеринга буфера глубины без захвата его в изображение. Обратите внимание, что некоторые устройства (особенно Android) не поддерживают рендеринг глубины изображения, в этих случаях единственными допустимыми значениями идентификатора глубины являются 0 и -1. Вы можете проверить, поддерживает ли текущее устройство текстуры глубины, используя IsSupportedDepthTexture. Рендеринг изображений может быть любого размера, и не обязательно должен быть в степени 2 по ширине или высоте. Для более подробного объяснения, когда вы визуализируете изображение, оно будет рисовать на изображении именно то, что оно нарисовало бы на экране. Например, если ваше виртуальное разрешение составляет 1024x768 и требует границ, то оно будет рисовать границы на изображении рендеринга. Это означает, что если вы посмотрите на полученное изображение рендеринга в его родной форме, например 1024x1024, оно будет выглядеть так, как будто вы взяли окно 1024х768 и растянули его вертикально в квадрат. В результате, если вы возьмете это квадратное изображение и растянете его обратно в 1024х768, текстурируя спрайт или квадроцикл размером 1024х768, то оно снова будет выглядеть нормально. Это означает, что вы можете визуализировать окно 1024x768 в изображение любого размера, скажем 64x512, и растянуть его до 1024x768, и оно должно выглядеть правильно с точки зрения соотношения сторон, конечно, в нем будут отсутствовать некоторые детали. Затем вы можете получить более продвинутый результат, изменив виртуальное разрешение после установки изображения рендеринга и изменив его обратно при рендеринге на экран, или используя SetCameraAspect для изменения соотношения сторон 3D, если изображение рендеринга будет использоваться для чего-то другого, чем представление экрана 1:1. При рендеринге изображения очень важно, чтобы изображение было очищено с помощью ClearScreen (), прежде чем рисовать на нем новую сцену. Это делается для того, чтобы графический процессор знал, что он может отбросить предыдущее содержимое. Если изображение не очищается и вещи продолжают притягиваться к нему, то производительность некоторых графических процессоров со временем ухудшится.

---

<a name="method-setrawwritepath"></a>

### SetRawWritePath()
```php
SetRawWritePath(string $str): void
```
Задает папку, в которой будут храниться файлы, созданные AGK. Это никак не влияет на iOS, так как она не может писать вне своей папки приложения. Вы можете установить его на любой абсолютный путь на устройстве, однако некоторые места, такие как папка Program Files в Windows, потребуют прав администратора для записи в них. Некоторые места будут защищены операционной системой, SetRawWritePath позволит вам установить путь к этим местам, но любая попытка записи в них потерпит неудачу. Вы можете использовать GetDocumentsPath, чтобы получить системную папку документов для текущего пользователя или папку sdcard на Android, которая гарантированно разрешит доступ на запись. Эта команда теперь устарела. Предпочтительным способом доступа к файлам за пределами обычной папки записи является использование команд OpenRawFolder и путей к файлам "raw:".

---

<a name="method-setrawtouchmovesensitivity"></a>

### SetRawTouchMoveSensitivity()
```php
SetRawTouchMoveSensitivity(int $distance): void
```
Задает расстояние, на которое должно переместиться событие касания, прежде чем оно будет классифицировано как событие перетаскивания. По умолчанию это значение равно 6.

---

<a name="method-setrawmousevisible"></a>

### SetRawMouseVisible()
```php
SetRawMouseVisible(int $visible): void
```
Пытается скрыть или показать любой указатель мыши, используемый на этой платформе. Не гарантируется работа на всех платформах.

---

<a name="method-setrawtouchvalue"></a>

### SetRawTouchValue()
```php
SetRawTouchValue(int $iIndex, int $value): void
```
Позволяет вам установить некоторые пользовательские данные для хранения в этом событии, которые вы можете получить позже. Это может быть значение или указатель.

---

<a name="method-setrawmouseposition"></a>

### SetRawMousePosition()
```php
SetRawMousePosition(float $x, float $y): void
```
Пытается расположить любой указатель мыши, используемый на этой платформе. Не гарантируется работа на всех платформах. Будет работать только тогда, когда окно вашего приложения имеет фокус.

---

<a name="method-setrawjoystickdeadzone"></a>

### SetRawJoystickDeadZone()
```php
SetRawJoystickDeadZone(float $threshold): void
```
Устанавливает мертвую зону для всех реальных джойстиков так, чтобы любое значение X или Y ниже заданного порога возвращало 0. Это значение должно быть между 0 и 1, по умолчанию оно равно 0,15.

---

<a name="method-setrandomseed2"></a>

### SetRandomSeed2()
```php
SetRandomSeed2(int $seed): void
```
Задает начальное значение для генератора случайных чисел. Два приложения AGK, использующие одно и то же начальное значение, будут генерировать одну и ту же последовательность случайных чисел. По умолчанию начальное значение устанавливается на текущее время при запуске, так что каждый запуск приложения будет генерировать другую последовательность чисел.

---

<a name="method-setrandomseed"></a>

### SetRandomSeed()
```php
SetRandomSeed(int $seed): void
```
Задает начальное значение для генератора случайных чисел. Два приложения AGK, использующие одно и то же начальное значение, будут генерировать одну и ту же последовательность случайных чисел. По умолчанию начальное значение устанавливается на текущее время при запуске, так что каждый запуск приложения будет генерировать другую последовательность чисел.

---

<a name="method-setpushnotificationkeys"></a>

### SetPushNotificationKeys()
```php
SetPushNotificationKeys(string $keyName, string $keyValue): void
```
Эта команда используется на Android для установки SenderID, используемого проектом Firebase. В настоящее время keyName должно быть установлено в "SenderID" (с учетом регистра), а KeyValue должно быть установлено в значение SenderID, которое можно найти в настройках проекта Firebase на вкладке Облачные сообщения.

---

<a name="method-setprintspacing"></a>

### SetPrintSpacing()
```php
SetPrintSpacing(float $fSpacing): void
```
Устанавливает интервал между буквами. Значение 0 не создает зазора между ограничивающими буквами, положительное значение увеличивает этот зазор, отрицательное значение перекрывает буквы. Это глобальная команда, которая будет влиять на весь печатный текст при следующем вызове синхронизации. Для управления интервалом на основе каждой строки используйте текстовые команды.

---

<a name="method-setprintsize"></a>

### SetPrintSize()
```php
SetPrintSize(float $fSize): void
```
Задает размер печатного текста, который будет отображаться на экране. Это глобальная команда, которая будет влиять на весь печатный текст при следующем вызове синхронизации. Для управления размером на основе каждой строки используйте текстовые команды.

---

<a name="method-setprintfont"></a>

### SetPrintFont()
```php
SetPrintFont(int $fontID): void
```
Устанавливает шрифт для использования для всего печатного текста, шрифт должен быть предварительно загружен с помощью LoadFont. Используйте идентификатор шрифта 0, чтобы использовать шрифт AGK по умолчанию.

---

<a name="method-setprintcolor"></a>

### SetPrintColor()
```php
SetPrintColor(int $iRed, int $iGreen, int $iBlue, int $iAlpha): void
```
Задает цвет печатного текста. Это глобальная команда, которая будет влиять на весь печатный текст при следующем вызове синхронизации. Для управления цветом на основе каждой строки используйте текстовые команды. Эта версия устанавливает альфа-код на 255, полностью непрозрачный.

---

<a name="method-setpointlightradius"></a>

### SetPointLightRadius()
```php
SetPointLightRadius(int $lightID, float $radius): void
```
Изменяет точечный свет на новый радиус воздействия. Объекты, находящиеся на большем расстоянии от источника света, будут получать от него нулевой свет.

---

<a name="method-setpointlightposition"></a>

### SetPointLightPosition()
```php
SetPointLightPosition(int $lightID, float $x, float $y, float $z): void
```
Помещает точечный свет в новое положение.

---

<a name="method-setpointlightmode"></a>

### SetPointLightMode()
```php
SetPointLightMode(int $lightID, int $mode): void
```
Устанавливает точечный свет в режим вершины или пикселя. Вершинный режим быстрее, но пиксельный режим имеет лучшее качество. По умолчанию огни создаются в режиме вершин. Сетка может быть освещена до 8 вершинными огнями и 4 пиксельными огнями одновременно, если вы добавите больше огней, чем это, то самые близкие огни будут использоваться сеткой.

---

<a name="method-setpointlightcolor"></a>

### SetPointLightColor()
```php
SetPointLightColor(int $lightID, int $red, int $green, int $blue): void
```
Меняет точечный свет на новый цвет. Значения должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать свет.

---

<a name="method-setphysicswalltop"></a>

### SetPhysicsWallTop()
```php
SetPhysicsWallTop(int $mode): void
```
Переключает существование физической стены в верхней части экрана, чтобы физические объекты не покидали экран в этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с ним, они фиксированы к миру, поэтому они будут отключены автоматически.

---

<a name="method-setphysicswallright"></a>

### SetPhysicsWallRight()
```php
SetPhysicsWallRight(int $mode): void
```
Переключает существование физической стены справа от экрана, чтобы физические объекты не покидали экран в этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с ним, они фиксированы к миру, поэтому они будут отключены автоматически.

---

<a name="method-setphysicswallleft"></a>

### SetPhysicsWallLeft()
```php
SetPhysicsWallLeft(int $mode): void
```
Переключает существование физической стены в левой части экрана, чтобы физические объекты не покидали экран в этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с ним, они фиксированы к миру, поэтому они будут отключены автоматически.

---

<a name="method-setphysicsthreading"></a>

### SetPhysicsThreading()
```php
SetPhysicsThreading(int $threads): void
```
Задает количество потоков для использования во время физики. Значение 0 или 1 отключает многопоточность, значение минус 1 выбирает значение, соответствующее количеству процессоров в устройстве для лучшей производительности. Использование значения, превышающего количество процессоров в устройстве, скорее всего, повредит производительности. По умолчанию-минус 1.

---

<a name="method-setphysicswallbottom"></a>

### SetPhysicsWallBottom()
```php
SetPhysicsWallBottom(int $mode): void
```
Переключает существование физической стены в нижней части экрана, чтобы физические объекты не покидали экран в этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с ним, они фиксированы к миру, поэтому они будут отключены автоматически.

---

<a name="method-setphysicsscale"></a>

### SetPhysicsScale()
```php
SetPhysicsScale(float $scale): void
```
Устанавливает шкалу, используемую физической системой, по сравнению с мировыми координатами. По замыслу физическая система настроена на использование 1 единицы измерения, равной 1 метру, что в случае стандартных мировых координат (100 100) означало бы, что экран в физическом моделировании равен 100 на 100 метров. Однако по своей конструкции физическая система предназначена для лучшей работы с динамическими объектами размером от 0,1 метра до 10 метров и со статическими объектами размером до 50 метров, поэтому экран масштабируется при отправке в физическую систему, по умолчанию масштаб равен 0,2, поэтому в физическом мире экран составляет 20 метров на 20 метров. Это делается исключительно для того, чтобы позволить физической системе работать в своем разработанном масштабе, позволяя использовать мировые координаты в качестве параметров, а AGK выполняет все необходимое масштабирование за кулисами. Эта функция позволяет вам изменить масштабный коэффициент, если ваше виртуальное разрешение будет отличаться от 100,100. Эта функция должна вызываться перед любыми другими физическими функциями и не должна вызываться после запуска физической системы.

---

<a name="method-setphysicssleeping"></a>

### SetPhysicsSleeping()
```php
SetPhysicsSleeping(int $mode): void
```
Устанавливает способность динамических тел спать, когда они не двигаются, это значительно улучшает производительность, когда динамические тела расположились в своих конечных положениях. Выключение его полезно только для бенчмаркинга, когда вы хотите, чтобы процессор постоянно обрабатывал все тела. По умолчанию включено.

---

<a name="method-setphysicsmaxpolygonpoints"></a>

### SetPhysicsMaxPolygonPoints()
```php
SetPhysicsMaxPolygonPoints(int $points): void
```
Задает максимальное количество точек, которые будут сгенерированы в будущих полигональных физических фигурах, не влияет на уже сгенерированные фигуры, может вызываться несколько раз. Влияет только на формы, генерируемые AGK через SetSpriteShape. Должно быть от 2 до 12. Значение по умолчанию-8.

---

<a name="method-setphysicsgravity"></a>

### SetPhysicsGravity()
```php
SetPhysicsGravity(float $x, float $y): void
```
Задает вектор гравитации для всех спрайтов с помощью физики. Значения x и y будут масштабироваться в физическом пространстве, поэтому будут представлять только метры в секунду в квадрате, когда масштаб = 1,0, в мировом пространстве значения представляют пиксели в секунду в квадрате. Например, в шкале по умолчанию 0,2 значение SetPhysicsGravity 0,50 будет представлять 10 метров в секунду в квадрате. Гравитация-это постоянное ускорение, приложенное ко всем физическим объектам одинаково, независимо от массы. В то время как сила прилагает ускорение, пропорциональное массе объектов. Чтобы противодействовать гравитации с помощью силы, потребуется учет массы.

---

<a name="method-setphysicsforcerange"></a>

### SetPhysicsForceRange()
```php
SetPhysicsForceRange(int $iForceIndex, float $range): void
```
Изменяет диапазон действия глобальной силы. Спрайты, находящиеся на большем расстоянии от положения силы, не почувствуют ее воздействия. Диапазон меньше нуля равен бесконечному диапазону.

---

<a name="method-setphysicsforceposition"></a>

### SetPhysicsForcePosition()
```php
SetPhysicsForcePosition(int $iForceIndex, float $x, float $y): void
```
Изменяет положение глобальной силы в мировых координатах.

---

<a name="method-setphysicsforcepower"></a>

### SetPhysicsForcePower()
```php
SetPhysicsForcePower(int $iForceIndex, float $power): void
```
Изменяет силу глобальной силы. Для сил, которые исчезают, это будет сила в 1 единице от положения силы. Эта сила выражена в Ньютонах и по своим размерам похожа на гравитацию, за исключением того, что на нее влияет масса объекта. Например, для объекта массой 1 кг и силой 10 ньютонов будет воздействовать на объект так же, как гравитация, установленная на 10 м/с^2. Для массы 2 кг двигаться труднее, поэтому сила в 10 Ньютонов будет вдвое эффективнее при перемещении объекта, чем сила тяжести при 10 м/с^2.

---

<a name="method-setphysicsdebugon"></a>

### SetPhysicsDebugOn()
```php
SetPhysicsDebugOn(): void
```
Позволяет рисовать внутренние физические фигуры на экране. Если вы установили значение viewoffset на что-то отличное от 0,0, убедитесь, что ни один из ваших физических спрайтов не закреплен на экране с помощью FixSpriteToScreen, иначе отладочные фигуры не выстроятся в линию. Отладочные контуры рисуются как мировые спрайты. Отладочный вывод будет рисовать форму каждого набора физических спрайтов с помощью SetSpritePhysicsOn и всех нефизических спрайтов, которым назначена форма для команд столкновения нефизических спрайтов. Фигуры будут нарисованы в следующих цветах: Кремовый=Динамический физический объект, Зеленый=Статический физический объект, Темно-синий=Кинематический физический объект, Светло-Голубой=нефизический объект. Серый=Спящий динамический физический объект. Кроме того, физические объекты будут нарисованы как затененные контуром, нефизические объекты будут только контуром.

---

<a name="method-setphysicsccd"></a>

### SetPhysicsCCD()
```php
SetPhysicsCCD(int $mode): void
```
Включает и выключает непрерывное обнаружение столкновений. Это предотвращает туннелирование быстро движущихся объектов через статические тела. Чтобы предотвратить прохождение быстро движущихся объектов друг через друга, используйте SetSpritePhysicsIsBullet, когда у вас есть большое количество динамических тел, которые могут быть узким местом в физическом движке, особенно когда резьба включена, так как эта часть в настоящее время не имеет резьбы. По умолчанию он выключен.

---

<a name="method-setphysicsdebugoff"></a>

### SetPhysicsDebugOff()
```php
SetPhysicsDebugOff(): void
```
Отключает рисование внутренних физических фигур на экране.

---

<a name="method-setparticlesvisible"></a>

### SetParticlesVisible()
```php
SetParticlesVisible(int $ID, int $visible): void
```
Устанавливает, рисуются ли испускаемые частицы. Установите значение 1, чтобы показать частицы, и 0, чтобы скрыть их. Частицы все равно будут обновляться, пока они скрыты, вы можете остановить обновление частиц с помощью SetParticlesActive

---

<a name="method-setparticlesvelocityrange"></a>

### SetParticlesVelocityRange()
```php
SetParticlesVelocityRange(int $ID, float $v1, float $v2): void
```
Устанавливает минимальный и максимальный множитель, который будет влиять на испускаемые частицы. Это может быть использовано для того, чтобы гарантировать, что при испускании частиц будут наблюдаться некоторые изменения.

---

<a name="method-setparticlestransparency"></a>

### SetParticlesTransparency()
```php
SetParticlesTransparency(int $ID, int $mode): void
```
Установите прозрачность частиц на определенную настройку с выбором без прозрачности, альфа-прозрачности и аддитивного смешивания. По умолчанию частицы создаются с альфа-прозрачностью.

---

<a name="method-setparticlesstartzone"></a>

### SetParticlesStartZone()
```php
SetParticlesStartZone(int $ID, float $x1, float $y1, float $x2, float $y2): void
```
Задает область вокруг излучателя, в которой могут появиться новые частицы. Эти значения относятся к положению эмиттера, например, зона 0,0,0,0 будет означать, что все частицы начинаются в точке положения эмиттера. Зона -10 в x и +10 x, где y равно 0 (-10,0,10,0), создаст линию, центрированную на положении излучателя, вдоль которой будут случайным образом появляться частицы. Зона коробки, где и x, и y имеют ненулевые размеры, означала бы, что частицы могут начинаться в любой точке внутри коробки.

---

<a name="method-setparticlessize"></a>

### SetParticlesSize()
```php
SetParticlesSize(int $ID, float $size): void
```
Задает размер всех частиц в мировых координатах. Установка большого количества частиц на большой размер будет плохо работать на мобильных устройствах с низкой скоростью заполнения (количество пикселей, которые он может нарисовать в секунду).

---

<a name="method-setparticlesrotationrangerad"></a>

### SetParticlesRotationRangeRad()
```php
SetParticlesRotationRangeRad(int $ID, float $angle1, float $angle2): void
```
Задает диапазон вращения в радианах, который частица может иметь в течение своей жизни. Когда частица создается, она начинается под углом 0 и выбирает случайную скорость вращения между углом 1 и углом 2. Затем частица будет вращаться с выбранной скоростью в течение всей своей жизни. Используйте отрицательные значения для вращения против часовой стрелки и положительные для вращения по часовой стрелке.

---

<a name="method-setparticlesrotationrange"></a>

### SetParticlesRotationRange()
```php
SetParticlesRotationRange(int $ID, float $angle1, float $angle2): void
```
Задает диапазон вращения в радианах, который частица может иметь в течение своей жизни. Когда частица создается, она начинается под углом 0 и выбирает случайную скорость вращения между углом 1 и углом 2. Затем частица будет вращаться с выбранной скоростью в течение всей своей жизни. Используйте отрицательные значения для вращения против часовой стрелки и положительные для вращения по часовой стрелке.

---

<a name="method-setparticlesposition"></a>

### SetParticlesPosition()
```php
SetParticlesPosition(int $ID, float $x, float $y): void
```
Устанавливает положение излучателя частиц. Это положение, из которого будут появляться новые частицы, и не влияет на частицы, которые уже видны.

---

<a name="method-setparticlesmax"></a>

### SetParticlesMax()
```php
SetParticlesMax(int $ID, int $max): void
```
Устанавливает максимальное количество частиц, которые будут испускаться. Если это значение равно -1, то число бесконечно. Излучатель будет вести подсчет количества частиц, которые он испускает, и остановится, когда будет достигнут предел. Чтобы проверить, достиг ли излучатель своего предела, используйте GetParticlesMaxReached. Чтобы сбросить счетчик и заставить его снова начать излучать, используйте ResetParticleCount.

---

<a name="method-setparticleslife"></a>

### SetParticlesLife()
```php
SetParticlesLife(int $ID, float $time): void
```
Задает время жизни частиц после их испускания в секундах. После того, как частицы будут живы в течение заданного количества секунд, они исчезнут. Это одно из двух значений, влияющих на количество генерируемых частиц, другое-SetParticlesFrequency. Максимальное количество частиц, которое может быть на экране в любой момент времени, - это freq*life, причем freq-это количество частиц, испускаемых в секунду. Это значение не зависит от частоты кадров.

---

<a name="method-setparticlesimage"></a>

### SetParticlesImage()
```php
SetParticlesImage(int $ID, int $imageID): void
```
Устанавливает изображение, которое будет использоваться для каждой частицы. Начиная с 1083 изображений, которые могут быть загружены из субизображений, содержащихся в текстурах атласа.

---

<a name="method-setparticlesfrequency"></a>

### SetParticlesFrequency()
```php
SetParticlesFrequency(int $ID, float $freq): void
```
Задает частоту генерации новых частиц. Значение freq указывает, сколько частиц должно быть произведено в секунду, это не зависит от частоты кадров. Это одно из двух значений, влияющих на количество генерируемых частиц, другое-SetParticlesLife. Максимальное количество частиц, которое может быть на экране в любой момент времени, - это freq*life, причем жизнь-это количество секунд, в течение которых частица живет, прежде чем исчезнуть. Это значение не зависит от частоты кадров.

---

<a name="method-setparticlesfacedirection"></a>

### SetParticlesFaceDirection()
```php
SetParticlesFaceDirection(int $ID, int $mode): void
```
Позволяет частицам вращаться в том направлении, в котором они движутся. Это переопределяет любое использование SetParticlesRotationRange для изменения скорости вращения частиц. Вместо этого частицы всегда будут вращаться лицом к направлению своего движения.

---

<a name="method-setparticlesdirection"></a>

### SetParticlesDirection()
```php
SetParticlesDirection(int $ID, float $vx, float $vy): void
```
Задает начальное направление новых частиц, когда они выходят из излучателя. Это можно использовать вместе с командой SetParticlesAngle, чтобы установить диапазон изменения от этого начального направления, которое могут выбрать новые частицы. Это также устанавливает начальную скорость частиц, принимая длину вектора за единицы в секунду. Например, если начальное направление vx=10, vy=-15, частицы начнут двигаться вправо со скоростью 10 единиц в секунду и вверх со скоростью 15 единиц в секунду и будут продолжать эту скорость движения в течение всей своей жизни, если на них не будут влиять силы, добавленные с помощью AddParticlesForce.

---

<a name="method-setparticlesdepth"></a>

### SetParticlesDepth()
```php
SetParticlesDepth(int $ID, int $depth): void
```
Задает глубину излучателя частиц. Это касается всех частиц, даже тех, которые уже видны. Все частицы рисуются на той же глубине, что и излучатель, так что AGK может сгруппировать их в один вызов рисования для более быстрого рисования. Глубина должна быть между 0 и 10000, причем 0-это передняя часть экрана.

---

<a name="method-setparticlescolorinterpolation"></a>

### SetParticlesColorInterpolation()
```php
SetParticlesColorInterpolation(int $ID, int $mode): void
```
Устанавливает режим интерполяции для изменения цвета. Цвета могут быть установлены в определенные моменты жизни частицы с помощью AddParticlesColorKeyFrame, и частица либо смешается между этими цветами, либо быстро изменится, когда достигнет следующего изменения цвета.

---

<a name="method-setparticlesanglerad"></a>

### SetParticlesAngleRad()
```php
SetParticlesAngleRad(int $ID, float $angle): void
```
Задает диапазон направления в радианах, который частица может выбрать при первом запуске. Это берет базовое направление, заданное с помощью SetParticlesDirection, и регулирует его на случайную величину от 0 до угла/2 радиана. Например, угол 0 будет означать, что все новые частицы следуют точно в указанном ранее направлении. Угол 2*PI будет означать, что частицы могут появиться, двигаясь в любом направлении, а угол PI/2 будет означать, что частицы будут двигаться наружу в конусе радианов PI/2 от их начального положения с центром конуса в данном направлении.

---

<a name="method-setparticlesangle"></a>

### SetParticlesAngle()
```php
SetParticlesAngle(int $ID, float $angle): void
```
Задает диапазон направления в градусах, который частица может выбрать при первом запуске. Это берет базовое направление, заданное с помощью SetParticlesDirection, и регулирует его на случайную величину между 0 и углом/2 градуса. Например, угол 0 будет означать, что все новые частицы следуют точно в указанном ранее направлении. Угол 360 будет означать, что частицы могут появиться, двигаясь в любом направлении, а угол 90 будет означать, что частицы будут двигаться наружу в конусе 90 градусов от их начального положения с центром конуса в данном направлении.

---

<a name="method-setparticlesactive"></a>

### SetParticlesActive()
```php
SetParticlesActive(int $ID, int $active): void
```
Устанавливает, обновляются ли испускаемые частицы каждый кадр. Установите значение 1, чтобы обновить частицы как обычно, и 0, чтобы приостановить их. Частицы будут продолжать быть видимыми, когда остановятся. Чтобы скрыть частицы, используйте SetParticlesVisible.

---

<a name="method-setorientationallowed"></a>

### SetOrientationAllowed()
```php
SetOrientationAllowed(int $portrait, int $portrait2, int $landscape, int $landscape2): void
```
Устанавливает, в какую ориентацию AGK позволит вращаться приложению. Есть две портретные и две пейзажные ориентации, одна для правильного пути вверх, а другая для перевернутого. На платформах, которые не могут вращаться, таких как Windows или Mac, эта команда не имеет никакого эффекта, и приложение всегда будет нарисовано правильно. Значение 1 для каждой ориентации будет определять, будет ли приложение вращаться, когда устройство удерживается в этой ориентации. Значение 0 сохранит приложение в его последней допустимой ориентации. Обратите внимание, что если устройство в данный момент находится в запрещенной ориентации, то AGK попытается повернуть устройство в разрешенную ориентацию, однако это не гарантируется немедленно. Так, например, если вам нужно, чтобы устройство находилось в ландшафтном режиме, и вы вызываете эту команду с разрешенным только ландшафтным режимом, вам следует дождаться, пока GetDeviceWidth вернет больше, чем GetDeviceHeight, что будет сигнализировать о том, что устройство теперь находится в ландшафтном режиме.

---

<a name="method-setobjectvisible"></a>

### SetObjectVisible()
```php
SetObjectVisible(int $objID, int $mode): void
```
Устанавливает, является ли этот объект видимым или нет. Он по-прежнему будет участвовать в столкновениях и других невизуальных взаимодействиях.

---

<a name="method-setobjectuvscale"></a>

### SetObjectUVScale()
```php
SetObjectUVScale(int $objID, int $textureStage, float $scaleU, float $scaleV): void
```
Изменяет все сетки в объекте для использования указанного УФ-масштаба, см. SetObjectMeshUVScale для получения дополнительной информации.

---

<a name="method-setobjectuvoffset"></a>

### SetObjectUVOffset()
```php
SetObjectUVOffset(int $objID, int $textureStage, float $offsetU, float $offsetV): void
```
Изменяет все сетки в объекте для использования указанного смещения UV, дополнительные сведения см. в разделе SetObjectMeshUVOffset.

---

<a name="method-setobjecttransparency"></a>

### SetObjectTransparency()
```php
SetObjectTransparency(int $objID, int $mode): void
```
Устанавливает режим прозрачности для этого объекта, 0-непрозрачный, 1-альфа-смешанный, 2-аддитивный смешанный, 3-пользовательский смешанный. Использование значения прозрачности больше 0 замедлит рендеринг, он также не записывает прозрачные объекты в Z-буфер, поэтому может вызвать некоторые проблемы с упорядочением глубины. Существует альтернативная форма прозрачности, называемая альфа-маскировкой, которая полезна, если вам нужны только полностью прозрачные или полностью непрозрачные пиксели, но нет смешивания между ними. Более подробную информацию см. в разделе SetObjectAlphaMask. При использовании режима 3 (custom) значения смешивания должны быть заданы с помощью SetObjectBlendModes, иначе объект не будет прозрачным.

---

<a name="method-setobjectshapestaticpolygon"></a>

### SetObjectShapeStaticPolygon()
```php
SetObjectShapeStaticPolygon(int $objID): void
```
Устанавливает форму столкновения объектов в статическую треугольную сетку на основе размера объекта. Объект становится статическим объектом треугольная сетчатая форма не может быть динамической. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.

---

<a name="method-setobjectshapesphere"></a>

### SetObjectShapeSphere()
```php
SetObjectShapeSphere(int $objID, float $diameter): void
```
Задает форму столкновения в виде сферы в зависимости от размера объекта. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.

---

<a name="method-setobjectshapecylinder"></a>

### SetObjectShapeCylinder()
```php
SetObjectShapeCylinder(int $objID, int $axis, float $height, float $diameter): void
```
Задает форму столкновения в виде цилиндра в зависимости от размера объекта. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.

---

<a name="method-setobjectshapeconvexhull"></a>

### SetObjectShapeConvexHull()
```php
SetObjectShapeConvexHull(int $objID): void
```
Устанавливает форму столкновения объектов на выпуклую оболочку в зависимости от размера объекта. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.

---

<a name="method-setobjectshapecone"></a>

### SetObjectShapeCone()
```php
SetObjectShapeCone(int $objID, int $axis): void
```
Устанавливает форму столкновения в виде конуса на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена. Возвращает идентификатор фигуры.

---

<a name="method-setobjectshapecompound"></a>

### SetObjectShapeCompound()
```php
SetObjectShapeCompound(int $objID): void
```
Устанавливает форму столкновения объектов в составную форму, готовую к добавлению новых фигур. Объект должен быть динамическим.

---

<a name="method-setobjectshapecapsule"></a>

### SetObjectShapeCapsule()
```php
SetObjectShapeCapsule(int $objID, int $axis, int $vectorID): void
```
Устанавливает форму столкновения в капсулу на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.

---

<a name="method-setobjectshapebox"></a>

### SetObjectShapeBox()
```php
SetObjectShapeBox(int $objID): void
```
Устанавливает форму столкновения в поле на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.

---

<a name="method-setobjectshaderconstantdefault"></a>

### SetObjectShaderConstantDefault()
```php
SetObjectShaderConstantDefault(int $objID, string $szName): void
```
Останавливает объект, устанавливающий заданное имя константы в его шейдерах, и с этого момента использует значение шейдера по умолчанию.

---

<a name="method-setobjectshaderconstantbyname"></a>

### SetObjectShaderConstantByName()
```php
SetObjectShaderConstantByName(int $objID, string $szName, float $value1, float $value2, float $value3, float $value4): void
```
Задает константу шейдера для объекта по имени, константа должна быть помечена как "однородная" в источнике шейдера. Объект установит указанную константу в это значение для любого шейдера, к которому он будет применен. Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4 значения и отбрасывает все, которые не используются именованной переменной.

---

<a name="method-setobjectshaderconstantarraybyname"></a>

### SetObjectShaderConstantArrayByName()
```php
SetObjectShaderConstantArrayByName(int $objID, string $szName, int $arrayIndex, float $value1, float $value2, float $value3, float $value4): void
```
Задает константу шейдера для объекта по имени, константа должна быть помечена как "однородная" в источнике шейдера. Объект установит указанную константу в это значение для любого шейдера, к которому он будет применен. Индексы массива начинаются с 0, если индекс массива находится за пределами границ, то он будет проигнорирован и никакие изменения не будут внесены. Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4 значения и отбрасывает все, которые не используются именованной переменной.

---

<a name="method-setobjectshader"></a>

### SetObjectShader()
```php
SetObjectShader(int $objID, int $shaderID): void
```
Устанавливает шейдер, используемый для рисования сеток в этом объекте, каждая сетка может иметь свой собственный набор шейдеров с помощью SetObjectMeshShader, эта команда устанавливает все сетки в этом объекте для использования указанного шейдера. Шейдер, должно быть, был загружен LoadShader. Шейдер похож на сценарий, отправленный в графический процессор, чтобы рассказать ему, как объединить полигональные и текстурные данные для отображения их на экране. По умолчанию сеткам присваивается внутренний шейдер, который будет обрабатывать освещение и текстурирование. Если вы используете идентификатор шейдера 0, сеткам присваивается внутренний шейдер.

---

<a name="method-setobjectscreenculling"></a>

### SetObjectScreenCulling()
```php
SetObjectScreenCulling(int $objID, int $mode): void
```
Устанавливает, будет ли объект отбракован при его перемещении за пределы экрана. По умолчанию AGK попытается определить, когда объект переместился за пределы экрана, и объекты, которые больше не находятся на экране, больше не будут отправляться в конвейер рендеринга. Если вершинный шейдер изменяет вершины из их нормальных положений, то это должно быть отключено, так как AGK не может заранее знать, где будет нарисован объект.

---

<a name="method-setobjectscalepermanent"></a>

### SetObjectScalePermanent()
```php
SetObjectScalePermanent(int $objID, float $x, float $y, float $z): void
```
Изменяет размер объекта в направлениях X, Y и Z. Это изменяет вершины объекта, что делает это постоянное изменение более медленным, чем SetObjectScale. Эта команда не считывает и не влияет на значения,заданные с помощью SetObjectScale,поэтому использование SetObjectScale(ID,2, 2, 2), а затем установка постоянного масштаба 3,3,3 все равно нарисует объект в 2 раза больше обычного, что означает в 6 раз больше, чем при запуске. Эта команда не влияет ни на какие дочерние объекты, которые могли быть загружены вместе с ней, ни на какие объекты, прикрепленные к ней с помощью FixObjectToObject. Эта команда будет работать с костяными анимированными объектами до тех пор, пока масштаб однороден, то есть значения шкалы X, Y и Z одинаковы.

---

<a name="method-setobjectscale"></a>

### SetObjectScale()
```php
SetObjectScale(int $objID, float $x, float $y, float $z): void
```
Изменяет размер объекта в направлениях X, Y и Z. Значение масштаба 1,1,1 возвращает объект к его первоначальному размеру, значение масштаба 2 делает объект вдвое больше, 0,5 - вдвое меньше и так далее. Эта команда не складывается, поэтому вызов ее дважды со значением 2 не сделает ее в 4 раза больше, она останется в 2 раза больше. Обратите внимание, что использование различных значений для направлений X, Y и Z, таких как so 1,2,1, называется неоднородной шкалой, в то время как 1.5,1.5,1.5 будет однородной шкалой. Неравномерное масштабирование требует, чтобы любой шейдер, используемый этим объектом, использовал матрицу agk_WorldNormal для любых нормальных преобразований, чтобы выглядеть правильно. Если этот объект был загружен командой LoadObjectWithChildren и имеет дочерние объекты или имеет объекты, прикрепленные к нему с помощью FixObjectToObject, то они также будут масштабироваться на эту величину в дополнение к их собственному масштабированию. Обратите внимание, что это не будет корректно работать с костяными анимированными объектами, вместо этого используйте SetObjectScalePermanent.

---

<a name="method-setobjectrotationquat"></a>

### SetObjectRotationQuat()
```php
SetObjectRotationQuat(int $objID, float $w, float $x, float $y, float $z): void
```
Задает вращение указанного объекта с помощью кватерниона. В качестве альтернативы вы можете использовать SetObjectRotation для использования углов Эйлера. По умолчанию объекты создаются с кватернионом 1,0,0,0 в порядке w,x,y,z. Кватернион-это 4-мерное представление трехмерного вращения со свойством w^2+x^2+y^2+z^2 = 1, которое позволяет легко интерполировать между двумя вращениями путем линейной интерполяции двух кватернионов и их нормализации. Каждое 3D-вращение представлено ровно 2 кватернионами, w,x,y,z и -w,-x,-y,-z, поэтому любая версия может быть возвращена командами GetObjectQuat. Кватернионы и углы Эйлера могут использоваться одновременно. Например, установка вращения кватерниона будет генерировать эквивалентные значения Эйлера, которые могут быть получены с помощью GetObjectAngleX, GetObjectAngleX и GetObjectAngleZ.

---

<a name="method-setobjectrotation"></a>

### SetObjectRotation()
```php
SetObjectRotation(int $objID, float $angx, float $angy, float $angz): void
```
Задает поворот указанного объекта с помощью углов Эйлера в градусах. В качестве альтернативы вы можете использовать SetObjectRotationQuat для использования кватерниона. По умолчанию объекты создаются с углами 0,0,0 в порядке YXZ. Углы Эйлера-это составные углы, где объект начинается с 0,0,0 и затем поворачивается на заданный угол Y, затем на заданный угол X, а затем катится на заданный угол Z. Каждое 3D-вращение может быть представлено 2 комбинациями углов Эйлера, Y,X,Z и Y-180,X-180,Z-180, поэтому любая версия может быть возвращена командами GetObjectAngle. Кватернионы и углы Эйлера могут использоваться одновременно. Например, установка вращения кватерниона будет генерировать эквивалентные значения Эйлера, которые могут быть получены с помощью GetObjectAngleX, GetObjectAngleX и GetObjectAngleZ.

---

<a name="method-setobjectreceiveshadow"></a>

### SetObjectReceiveShadow()
```php
SetObjectReceiveShadow(int $objID, int $mode): void
```
Задает объект для получения теней от других объектов. По умолчанию это значение равно 1. Объект может быть настроен как на отбрасывание, так и на получение теней.

---

<a name="method-setobjectposition"></a>

### SetObjectPosition()
```php
SetObjectPosition(int $objID, float $x, float $y, float $z): void
```
Задает положение указанного объекта. По умолчанию объекты располагаются на уровне 0,0,0

---

<a name="method-setobjectnormalmapscale"></a>

### SetObjectNormalMapScale()
```php
SetObjectNormalMapScale(int $objID, float $scaleU, float $scaleV): void
```
Масштабирует нормальные координаты карты UV на заданную величину. Это не влияет ни на какую другую текстуру, но накладывается поверх УФ-смещения и масштаба объекта. Значение масштаба 1.0 будет использовать немодифицированный UVS, значение масштаба 2.0 удвоит значение UV и так далее.

---

<a name="method-setobjectnormalmap"></a>

### SetObjectNormalMap()
```php
SetObjectNormalMap(int $objID, int $imageID): void
```
Устанавливает все сетки в этом объекте для использования указанного изображения в качестве карты нормалей. Вы можете установить нормальную карту для одной сетки с помощью SetObjectMeshNormalMap. Нормальная карта будет помещена в текстурную стадию 2, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который сочетает ее с любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете свой собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму карту нормалей, так как AGK не будет изменять ваш шейдер таким образом. Нормальная карта будет использовать второй набор УФ-координат, если таковой имеется, в противном случае она будет использовать те же УФ-координаты, что и базовая текстура. Если есть также изображение на стадии текстуры 1 (например, световая карта), то нормальная карта всегда будет использовать базовый UVS.

---

<a name="method-setobjectmeshuvscale"></a>

### SetObjectMeshUVScale()
```php
SetObjectMeshUVScale(int $objID, int $meshIndex, int $textureStage, float $scaleU, float $scaleV): void
```
Изменяет UVS сетки, чтобы масштабировать их на заданную величину. Это может вытолкнуть УФ-координаты за пределы диапазона от 0.0 до 1.0, и в этом случае режим обертывания изображения будет использоваться либо для зажима, либо для повторения текстуры. Используйте SetImageWrapU и SetImageWrapV для установки режима обертывания. Значение масштаба 1 оставит UV-координаты со значениями по умолчанию, в то время как значение масштаба 2.0 удвоит количество раз, когда текстура появляется на сетке (при условии, что режим обертывания установлен на повторение). Обратите внимание, что изображение должно быть размером в 2 степени, чтобы использовать режим повтора.

---

<a name="method-setobjectmeshvisible"></a>

### SetObjectMeshVisible()
```php
SetObjectMeshVisible(int $objID, int $meshIndex, int $mode): void
```
Устанавливает, является ли эта сетка объектов видимой или нет.

---

<a name="method-setobjectmeshuvoffset"></a>

### SetObjectMeshUVOffset()
```php
SetObjectMeshUVOffset(int $objID, int $meshIndex, int $textureStage, float $offsetU, float $offsetV): void
```
Изменяет UVS сетки, чтобы сдвинуть их на заданное смещение. Это может вытолкнуть УФ-координаты за пределы диапазона от 0.0 до 1.0, и в этом случае режим переноса изображения будет использоваться либо для зажима, либо для повторения текстуры. Используйте SetImageWrapU и SetImageWrapV для установки режима обертывания. Обратите внимание, что изображение должно быть размером в 2 степени, чтобы использовать режим повтора.

---

<a name="method-setobjectmeshshader"></a>

### SetObjectMeshShader()
```php
SetObjectMeshShader(int $objID, int $meshIndex, int $shaderID): void
```
Устанавливает шейдер, используемый для рисования этой сетки, шейдер должен быть загружен LoadShader. Шейдер похож на сценарий, отправленный в графический процессор, чтобы рассказать ему, как объединить полигональные и текстурные данные для отображения их на экране. По умолчанию сеткам присваивается внутренний шейдер, который будет обрабатывать освещение и текстурирование. Если вы используете идентификатор шейдера 0, сетке присваивается внутренний шейдер. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes

---

<a name="method-setobjectmeshnormalmapscale"></a>

### SetObjectMeshNormalMapScale()
```php
SetObjectMeshNormalMapScale(int $objID, int $meshIndex, float $scaleU, float $scaleV): void
```
Масштабирует нормальные координаты карты UV на заданную величину. Это не влияет ни на какую другую текстуру, но накладывается поверх УФ-смещения и масштаба объекта. Значение масштаба 1.0 будет использовать немодифицированный UVS, значение масштаба 2.0 удвоит значение UV и так далее.

---

<a name="method-setobjectmeshnormalmap"></a>

### SetObjectMeshNormalMap()
```php
SetObjectMeshNormalMap(int $objID, int $meshIndex, int $imageID): void
```
Устанавливает сетку объекта для использования указанного изображения в качестве карты нормалей. Нормальная карта будет помещена в текстурную стадию 2, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который сочетает ее с любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете свой собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму карту нормалей, так как AGK не будет изменять ваш шейдер таким образом. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes

---

<a name="method-setobjectmeshlightmap"></a>

### SetObjectMeshLightMap()
```php
SetObjectMeshLightMap(int $objID, int $meshIndex, int $imageID): void
```
Устанавливает сетку объекта для использования указанного изображения в качестве световой карты. Световая карта будет помещена в текстурную стадию 1, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который объединит ее с текстурной стадией 0 и любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете свой собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму световую карту, так как AGK не будет изменять ваш шейдер таким образом. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes

---

<a name="method-setobjectmeshimage"></a>

### SetObjectMeshImage()
```php
SetObjectMeshImage(int $objID, int $meshIndex, int $imageID, int $textureStage): void
```
Устанавливает сетку объекта для использования этого изображения при рендеринге. Сетка может иметь до 8 изображений, назначенных ей на этапах текстуры от 0 до 7. Если вы не уверены, какой этап текстуры использовать, поместите изображение в этап 0. Стадии текстуры можно использовать для назначения нескольких изображений сетке, например, вы можете поместить базовую (диффузную) текстуру в стадию 0, нормальную карту в стадию 1 и световую карту в стадию 2. Шейдер, используемый для рисования этого объекта, может затем объединить различные текстуры в пиксельное значение для отображения на экране. Использование значения изображения 0 для определенного этапа текстуры удаляет любое назначенное изображение с этого этапа. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes

---

<a name="method-setobjectmeshfrommemblock"></a>

### SetObjectMeshFromMemblock()
```php
SetObjectMeshFromMemblock(int $objID, int $meshIndex, int $memID): void
```
Изменяет сетку объекта на основе предоставленного memblock. Мемблок не обязательно должен иметь такое же количество атрибутов или вершин, как исходная сетка, но он улучшит производительность, если это произойдет. Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда должен быть кратен 4 по соображениям выравнивания, сама строка может иметь немного меньше символов, но всегда округляется до ближайшего кратного 4 для значения длины строки. например, строка длины 5 должна иметь значение длины строки 8. Обратите внимание, что строка из 4 символов имеет нулевой терминатор на конце, что делает ее длиной 5, поэтому, даже если она уже имеет кратное 4 символам значение длины, она должна использовать значение длины 8 из-за нулевого терминатора. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник. Если вы планируете регулярно вносить изменения в сетку, вы должны сохранить memblock после использования SetObjectMeshFromMemblock вместо того, чтобы регенерировать его из объекта каждый раз, когда вы хотите внести изменения. Затем снова вызовите SetObjectMeshFromMemblock, когда вы хотите перенести свои новые изменения на объект.

---

<a name="method-setobjectmeshcollisionmode"></a>

### SetObjectMeshCollisionMode()
```php
SetObjectMeshCollisionMode(int $objID, int $meshIndex, int $mode): void
```
Включает или выключает обнаружение столкновений для одной сетки в объекте.

---

<a name="method-setobjectlookat"></a>

### SetObjectLookAt()
```php
SetObjectLookAt(int $objID, float $x, float $y, float $z, float $roll): void
```
Вращает объект, чтобы посмотреть на определенную точку в пространстве с дополнительным значением крена. "смотреть" определяется как выравнивание локальной оси Z объекта, чтобы указать его положительную сторону в данной точке. Это может быть достигнуто с помощью только углов Y и X в эйлеровой нотации, поэтому вы можете указать дополнительный угол Z в градусах, чтобы перевернуть объект слева направо, всегда глядя на одно и то же место.

---

<a name="method-setobjectlightmode"></a>

### SetObjectLightMode()
```php
SetObjectLightMode(int $objID, int $mode): void
```
Включает или выключает освещение при рисовании этого объекта.

---

<a name="method-setobjectimage"></a>

### SetObjectImage()
```php
SetObjectImage(int $objID, int $imageID, int $texStage): void
```
Устанавливает все сетки в этом объекте для использования этого изображения при рендеринге. Вы можете установить текстуры отдельно для каждой сетки с помощью SetObjectMeshImage. Каждая сетка может иметь до 8 изображений, назначенных ей на этапах текстуры от 0 до 7. Если вы не уверены, какой этап текстуры использовать, поместите изображение в этап 0. Стадии текстуры можно использовать для назначения нескольких изображений сетке, например, вы можете поместить базовую (диффузную) текстуру в стадию 0, нормальную карту в стадию 1 и световую карту в стадию 2. Шейдер, используемый для рисования этого объекта, может затем объединить различные текстуры в пиксельное значение для отображения на экране. Использование значения изображения 0 для определенного этапа текстуры удаляет любое назначенное изображение с этого этапа.

---

<a name="method-setobjectlightmap"></a>

### SetObjectLightMap()
```php
SetObjectLightMap(int $objID, int $imageID): void
```
Устанавливает все сетки в этом объекте для использования указанного изображения в качестве световой карты. Вы можете установить световую карту для одной сетки с помощью SetObjectMeshLightMap. Световая карта будет помещена в текстурную стадию 1, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который объединит ее с текстурной стадией 0 и любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете свой собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму световую карту, так как AGK не будет изменять ваш шейдер таким образом. Световая карта будет использовать второй набор УФ-координат, если он доступен, в противном случае она будет использовать те же УФ-координаты, что и базовая текстура.

---

<a name="method-setobjectfogmode"></a>

### SetObjectFogMode()
```php
SetObjectFogMode(int $objID, int $mode): void
```
Включает или выключает туман при рисовании этого объекта. По умолчанию все объекты получают туман, когда он включен с помощью SetFogMode

---

<a name="method-setobjectdepthwrite"></a>

### SetObjectDepthWrite()
```php
SetObjectDepthWrite(int $objID, int $mode): void
```
Устанавливает режим записи глубины при рисовании этого объекта на экране. Если он проходит тест глубины, объект записывает свое значение глубины в буфер глубины, чтобы остановить что-либо еще позади от прохождения их тестов глубины. По умолчанию только объекты, которые находятся ближе (меньше) текущего значения глубины, будут перезаписывать текущее содержимое экрана. Вы можете отключить эту запись в буфер глубины для этого объекта, это может быть полезно для прозрачных объектов, которые не должны блокировать рисование позади себя. По умолчанию для всех непрозрачных объектов включена запись глубины, а для всех прозрачных объектов-выключена запись глубины.

---

<a name="method-setobjectdepthreadmode"></a>

### SetObjectDepthReadMode()
```php
SetObjectDepthReadMode(int $objID, int $mode): void
```
Устанавливает режим чтения глубины при рисовании этого объекта на экране. Объект должен пройти тест глубины, чтобы быть видимым. Доступные варианты: 0=никогда не проходите, 1=меньше, 2=равно, 3=меньше или равно, 4=больше, 5=не равно, 6=больше или равно, 7=всегда проходите. По умолчанию все объекты используют режим 1 (меньше), что означает, что они должны быть ближе, чем любые уже нарисованные объекты, чтобы быть видимыми.

---

<a name="method-setobjectdepthbias"></a>

### SetObjectDepthBias()
```php
SetObjectDepthBias(int $objID, float $bias): void
```
Устанавливает смещение глубины при рисовании этого объекта на экране. Если два объекта находятся очень близко друг к другу, один перед другим, они могут вызвать Z-бой, где они, кажется, мерцают между одним объектом и другим, отображаемым друг перед другом. Например, наклейка на поверхность другого объекта. Смещение Z предназначено для предотвращения этого мерцания, заставляя (смещая) один объект всегда находиться впереди или позади другого. Величина смещения должна быть положительной, чтобы приблизить этот объект к камере, и отрицательной, чтобы отодвинуть его назад. На самом деле это не влияет на положение объекта, только на его воспринимаемое положение, когда система рендеринга проверяет, должен ли объект быть нарисован или нет. Если объект проходит этот тест на смещенную глубину, то он рисуется в исходном положении. Значение смещения кратно наименьшему значению буфера z, поэтому рекомендуемым значением является значение смещения 1. Значения меньше этого вряд ли будут иметь какой-либо эффект, значения больше этого можно попробовать, если значение 1 не работает, попробуйте 1.5, 2.0 и т. Д.

---

<a name="method-setobjectdepthrange"></a>

### SetObjectDepthRange()
```php
SetObjectDepthRange(int $objID, float $zNear, float $zFar): void
```
Задает диапазон значений глубины, с которыми сопоставляется этот объект. По умолчанию это от 0 до 1, где 0 - ближняя плоскость, а 1-дальняя. Например, установка диапазона глубины 1,1 приведет к тому, что каждый пиксель в этом объекте будет иметь значение глубины 1 при сравнении и записи в буфер глубины. Значения будут зажаты в диапазоне от 0 до 1, объекты за пределами ближней или дальней плоскостей все равно будут обрезаны. Обратные сопоставления разрешаются установкой near больше, чем far.

---

<a name="method-setobjectcullmode"></a>

### SetObjectCullMode()
```php
SetObjectCullMode(int $objID, int $mode): void
```
Задает, должен ли этот объект рисовать свои задние грани при рендеринге. Используйте режим 0=как передние, так и задние нарисованные, 1=только передние грани, 2=только задние грани. По умолчанию рисуются только лицевые грани (режим 1).

---

<a name="method-setobjectcoloremissive"></a>

### SetObjectColorEmissive()
```php
SetObjectColorEmissive(int $objID, int $red, int $green, int $blue): void
```
Задает эмиссионный цвет, используемый при рисовании этого объекта. Значения должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать объект, а значения меньше 0 будут отнимать свет. Излучающий цвет имитирует свет, генерируемый объектом, поэтому он получит этот цвет, даже если он ничем не освещается. Это не влияет ни на какие окружающие предметы.

---

<a name="method-setobjectcolor"></a>

### SetObjectColor()
```php
SetObjectColor(int $objID, int $red, int $green, int $blue, int $alpha): void
```
Задает диффузный цвет, используемый при рисовании этого объекта. Значения должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать объект, а значения меньше 0 будут отнимать свет.

---

<a name="method-setobjectcollisionmode"></a>

### SetObjectCollisionMode()
```php
SetObjectCollisionMode(int $objID, int $mode): void
```
Включает или выключает обнаружение столкновений для этого объекта.

---

<a name="method-setobjectcastshadow"></a>

### SetObjectCastShadow()
```php
SetObjectCastShadow(int $objID, int $mode): void
```
Задает объект для отбрасывания теней на другие объекты. По умолчанию это значение равно 0. Объект может быть настроен как на отбрасывание, так и на получение теней.

---

<a name="method-setobjectbonerotationquat"></a>

### SetObjectBoneRotationQuat()
```php
SetObjectBoneRotationQuat(int $objID, int $boneIndex, float $w, float $x, float $y, float $z): void
```
Задает вращение указанной кости относительно ее родителя в виде кватерниона.

---

<a name="method-setobjectbonerotation"></a>

### SetObjectBoneRotation()
```php
SetObjectBoneRotation(int $objID, int $boneIndex, float $angx, float $angy, float $angz): void
```
Задает поворот указанной кости с помощью углов Эйлера в градусах. В качестве альтернативы вы можете использовать SetObjectBoneRotationQuat для использования кватерниона.

---

<a name="method-setobjectbonelookat"></a>

### SetObjectBoneLookAt()
```php
SetObjectBoneLookAt(int $objID, int $boneIndex, float $x, float $y, float $z, float $roll): void
```
Вращает кость, чтобы посмотреть на определенную точку в мировом пространстве с дополнительным значением крена. "смотреть" определяется как выравнивание локальной оси Z кости, чтобы указать ее положительную сторону в данной точке. Это может быть достигнуто с помощью только углов Y и X в эйлеровой нотации, поэтому вы можете указать дополнительный угол Z в градусах, чтобы катить кость слева направо, всегда глядя на одно и то же место.

---

<a name="method-setobjectboneposition"></a>

### SetObjectBonePosition()
```php
SetObjectBonePosition(int $objID, int $boneIndex, float $x, float $y, float $z): void
```
Устанавливает положение указанной кости относительно ее родителя.

---

<a name="method-setobjectbonecananimate"></a>

### SetObjectBoneCanAnimate()
```php
SetObjectBoneCanAnimate(int $objID, int $boneIndex, int $animate): void
```
Задает, управляется ли указанная кость анимацией или управляется вручную. При управлении анимацией ни одна из команд SetObjectBonePosition или аналогичных команд не будет иметь никакого эффекта. При ручном управлении кость будет сохранять свое текущее положение, если вы не измените его.

---

<a name="method-setobjectblendmodes"></a>

### SetObjectBlendModes()
```php
SetObjectBlendModes(int $objID, int $src, int $dst): void
```
Если SetObjectTransparency имеет значение 3, то исходные и целевые значения смешивания можно задать вручную с помощью этой команды. Доступны следующие режимы наложения: 0 = 0 1 = 1 2 = Исходный пиксель Альфа 3 = 1 - Исходный Пиксель Альфа 4 = Целевой Пиксель Альфа 5 = 1 - Целевой Пиксель Альфа 6 = Исходный Пиксель Цвет (действителен только для режима назначения) 7 = 1 - Исходный пиксель Цвет (действителен только для режима назначения) 8 = Целевой пиксель Цвет (действителен только для режима источника) 9 = 1 - Целевой пиксель Цвет (действителен только для режима источника) 10 = Альфа Насыщение (действителен только для режима источника) Исходный пиксель будет умножен на исходный режим, а целевой пиксель будет умножен на целевой режим. Затем они будут сложены вместе, чтобы получить окончательный цвет пикселя. Исходный пиксель-это пиксель, принадлежащий рисуемому объекту, в то время как конечный пиксель-это цвет пикселя, уже находящегося на экране, над которым рисуется текущий объект.

---

<a name="method-setobjectanimationspeed"></a>

### SetObjectAnimationSpeed()
```php
SetObjectAnimationSpeed(int $objID, float $speed): void
```
Устанавливает скорость анимации для данного объекта как кратную времени по умолчанию, то есть 1.0 будет использовать время из ключевых кадров анимации, 2.0 будет воспроизводить их в два раза быстрее, 0.5-в два раза медленнее и так далее. Вы также можете использовать отрицательные значения для воспроизведения анимации в обратном порядке или 0 для ее приостановки.

---

<a name="method-setobjectanimationframe"></a>

### SetObjectAnimationFrame()
```php
SetObjectAnimationFrame(int $objID, string $animName, float $time, float $tweentime): void
```
Устанавливает положение костей объекта в соответствии с заданным временем в анимации. Только объекты, загруженные с помощью LoadObjectWithChildren, будут иметь назначенные им анимации. Имена анимаций определяются программой моделирования при создании анимаций вы можете узнать, что это за имена, используя GetObjectAnimationName. Если заданное время попадает между ключевыми кадрами, то позиции костей будут интерполированы между ними. Параметр tweentime можно использовать для интерполяции между текущими позициями костей и заданным временем анимации, чтобы не было резкого скачка в позициях костей. Обратите внимание, что как только эта команда будет вызвана, кости будут управляться анимацией и не могут быть перемещены с помощью SetObjectBonePosition или аналогичных команд. Вы можете восстановить ручное управление отдельными костями, используя SetObjectBoneCanAnimate на нем. Вы можете восстановить контроль над всей костной структурой с помощью ResetObjectAnimation.

---

<a name="method-setobjectalphamask"></a>

### SetObjectAlphaMask()
```php
SetObjectAlphaMask(int $objID, int $mode): void
```
Включает или выключает альфа-маскировку для этого объекта. Это похоже на прозрачность, но производит только полностью прозрачные или полностью непрозрачные пиксели, нет смешанных или полупрозрачных пикселей. Если пиксель имеет альфа - значение меньше 128, он будет проигнорирован, если он больше или равен 128, то он будет нарисован. Это имеет меньше проблем с упорядочением глубины, чем при использовании SetObjectTransparency, но в некоторых случаях может быть немного медленнее. Вы не должны использовать как прозрачность, так и альфа-маскировку на одном и том же объекте одновременно, используйте только одну или другую.

---

<a name="method-setobject3dphysicssleepingthreshold"></a>

### SetObject3DPhysicsSleepingThreshold()
```php
SetObject3DPhysicsSleepingThreshold(int $objID, float $angular, float $linear): void
```
Устанавливает пороги спящего режима 3d-физики для объекта.

---

<a name="method-setobjectalpha"></a>

### SetObjectAlpha()
```php
SetObjectAlpha(int $objID, int $alpha): void
```
Задает значение альфа-сигнала, которое будет использоваться при рисовании этого объекта. Это то же самое альфа-значение, которое можно установить в SetObjectColor. Значения должны находиться в диапазоне 0-255, но не ограничиваться им.

---

<a name="method-setobject3dphysicsmaxlinearvelocity"></a>

### SetObject3DPhysicsMaxLinearVelocity()
```php
SetObject3DPhysicsMaxLinearVelocity(int $objID, float $maxLinearVelocity): void
```
Это установит максимальную линейную скорость для динамического объекта. Это предотвратит движение объектов слишком быстро, чтобы их можно было увидеть на экране.

---

<a name="method-setobject3dphysicsrollingfriction"></a>

### SetObject3DPhysicsRollingFriction()
```php
SetObject3DPhysicsRollingFriction(int $objID, float $friction): void
```
Это установит трение качения для статических и динамических объектов.

---

<a name="method-setobject3dphysicslinearvelocity"></a>

### SetObject3DPhysicsLinearVelocity()
```php
SetObject3DPhysicsLinearVelocity(int $objID, float $dirX, float $dirY, float $dirZ, float $initialSpeed): void
```
Задает вектор линейной скорости объекта. Вектор направления автоматически нормализуется.

---

<a name="method-setobject3dphysicsmass"></a>

### SetObject3DPhysicsMass()
```php
SetObject3DPhysicsMass(int $objID, float $mass): void
```
Задает массу объекта

---

<a name="method-setobject3dphysicsgroupandmask"></a>

### SetObject3DPhysicsGroupAndMask()
```php
SetObject3DPhysicsGroupAndMask(int $objID, int $group, int $mask): void
```
Устанавливает группу столкновений объектов и маску. По умолчанию все физические объекты находятся в одной группе и не маскируются. Если вы используете группы столкновений и маски, вы должны использовать их для всех физических объектов в мире.

---

<a name="method-setobject3dphysicsfriction"></a>

### SetObject3DPhysicsFriction()
```php
SetObject3DPhysicsFriction(int $objID, float $friction): void
```
Это установит трение для динамических и статических объектов

---

<a name="method-setobject3dphysicsdamping"></a>

### SetObject3DPhysicsDamping()
```php
SetObject3DPhysicsDamping(int $objID, float $linearDamp, float $angularDamp): void
```
Устанавливает линейное и угловое демпфирование для объекта

---

<a name="method-setobject3dphysicsanisotropicfriction"></a>

### SetObject3DPhysicsAnisotropicFriction()
```php
SetObject3DPhysicsAnisotropicFriction(int $objID, int $type): void
```
Это позволит установить тип анизотропного трения.

---

<a name="method-setobject3dphysicsrestitution"></a>

### SetObject3DPhysicsRestitution()
```php
SetObject3DPhysicsRestitution(int $objID, float $friction): void
```
Устанавливает реституционное трение для объекта. Вы можете установить Реституцию для динамических и статических объектов.

---

<a name="method-setobject3dphysicsdeactivationtime"></a>

### SetObject3DPhysicsDeactivationTime()
```php
SetObject3DPhysicsDeactivationTime(int $objID, mixed $time): void
```
Устанавливает время деактивации физического объекта. Это количество времени, которое физический объект ждет, когда он придет в состояние покоя, прежде чем он станет деактивированным.

---

<a name="method-setobject3dphysicscansleep"></a>

### SetObject3DPhysicsCanSleep()
```php
SetObject3DPhysicsCanSleep(int $objID, int $canSleep): void
```
Все динамические объекты автоматически переводятся в состояние покоя. Это остановит автоматическое погружение динамического объекта в спящий режим.

---

<a name="method-setnetworklocalinteger"></a>

### SetNetworkLocalInteger()
```php
SetNetworkLocalInteger(int $iNetID, string $name, int $i): void
```
Задает локальную целочисленную переменную для этого клиента по имени. Затем другие клиенты могут прочитать эту переменную, используя то же имя при запросе ее значения. Параметр mode указывает, как должна вести себя эта переменная, со значением 1, означающим, что эта переменная будет сброшена до 0 при чтении. Например, если вы хотите отправить уведомление о щелчке, вы можете установить значение 1, чтобы обозначить щелчок со значением режима 1. Когда каждый клиент читает переменную, каждый увидит значение 1, но если он попытается прочитать ее снова, то получит значение 0. Каждый клиент сбрасывает только свою собственную копию переменной. Значение режима 0 означает, что это нормальная переменная, которая не изменится при чтении. Если переменная с таким именем не существует, она создается. Как только переменная создается в обычном или сброшенном режиме, она не может быть изменена, и параметр mode игнорируется.

---

<a name="method-setobject3dphysicsangularvelocity"></a>

### SetObject3DPhysicsAngularVelocity()
```php
SetObject3DPhysicsAngularVelocity(int $objID, int $vectorID, float $initialSpeed): void
```
Задает угловую скорость объекта. Вектор угла автоматически нормализуется.

---

<a name="method-setnetworklocalfloat"></a>

### SetNetworkLocalFloat()
```php
SetNetworkLocalFloat(int $iNetID, string $name, float $f, int $mode): void
```
Задает локальную переменную float для этого клиента по имени. Затем другие клиенты могут прочитать эту переменную, используя то же имя при запросе ее значения. Переменная с плавающей точкой может не иметь того же имени, что и целочисленная переменная. Если переменная с таким именем не существует, она создается.

---

<a name="method-setnetworknomoreclients"></a>

### SetNetworkNoMoreClients()
```php
SetNetworkNoMoreClients(int $iNetID): void
```
Останавливает больше клиентов от подключения к этой сети, применимо только в том случае, если вы размещаете эту сеть. Также прекращается вещание сети в локальную сеть, поэтому она больше не будет отображаться для тех приложений, которые слушают трансляции.

---

<a name="method-setnetworkclientuserdata"></a>

### SetNetworkClientUserData()
```php
SetNetworkClientUserData(int $iNetID, int $client, int $index, int $value): void
```
Присваивает локальное значение одному из 5 слотов данных в клиенте, которые можно использовать для отслеживания элементов, принадлежащих этому клиенту. Например, если вы создаете спрайт для представления клиента в вашей игре, вы можете назначить идентификатор спрайта одному из этих слотов данных, чтобы при просмотре списка клиентов вы могли определить, какой спрайт вы использовали для каждого клиента. Это также позволяет очистить спрайт, если обнаружится, что клиент отключился. Это значение является полностью локальным и не передается по сети.

---

<a name="method-setnetworklatency"></a>

### SetNetworkLatency()
```php
SetNetworkLatency(int $iNetID, int $latency): void
```
Устанавливает, как часто сеть отправляет обновления и проверяет наличие обновлений переменных от других клиентов в миллисекундах. Чем ниже это значение, тем чаще этот клиент будет отправлять и получать обновления, что означает, что общие переменные с большей вероятностью будут обновляться, но это увеличит сетевой трафик. В случае соединений через Интернет это особенно важно, так как большое количество переменных, которые часто обновляются, означает, что может не хватить пропускной способности. Значение по умолчанию составляет 15 миллисекунд, что переводится примерно в 67 обновлений каждую секунду, чтобы точно соответствовать частоте кадров игры 60 кадров в секунду. Если вы обновляете большое количество переменных через интернет-соединение, рекомендуется увеличить это значение до 50 миллисекунд, что приведет к 20 обновлениям в секунду или более.

---

<a name="method-setmusicsystemvolumeogg"></a>

### SetMusicSystemVolumeOGG()
```php
SetMusicSystemVolumeOGG(int $vol): void
```
Устанавливает основную громкость для всех музыкальных файлов OGG. Это умножается на объем файла, так что если системный том установлен на 100, а объем файла установлен на 0, то файл все равно будет иметь объем 0.

---

<a name="method-setnetworkallowclients"></a>

### SetNetworkAllowClients()
```php
SetNetworkAllowClients(int $iNetID): void
```
Перезапуск прослушивания новых клиентских подключений, применимый только в том случае, если вы размещаете сеть. Также перезапускается вещание сети в локальную сеть, так что она будет отображаться для тех приложений, которые слушают трансляции. Это нужно сделать только в том случае, если вы ранее вызывали SetNetworkNoMoreClients и теперь хотите снова разрешить соединения.

---

<a name="method-setmusicvolumeogg"></a>

### SetMusicVolumeOGG()
```php
SetMusicVolumeOGG(int $musicID, int $vol): void
```
Устанавливает объем для каждого файла. По умолчанию файлы воспроизводятся на томе 100. Уровень громкости должен быть между 0 и 100.

---

<a name="method-setmusicsystemvolume"></a>

### SetMusicSystemVolume()
```php
SetMusicSystemVolume(int $iVol): void
```
Устанавливает основную громкость музыкального проигрывателя в диапазоне от 0 до 100.

---

<a name="method-setmusiclooptimesogg"></a>

### SetMusicLoopTimesOGG()
```php
SetMusicLoopTimesOGG(int $musicID, float $startTime, float $endTime): void
```
Устанавливает время начала и окончания музыкального цикла. Когда PlayMusicOGG используется с параметром loop, он по умолчанию останавливается в конце файла и возвращается к началу файла. Эта команда изменит его на цикл, начинающийся и заканчивающийся в определенное время в музыкальном файле. Использование времени начала -1 приведет к возврату в начало файла, использование и время окончания -1 остановится в конце файла, они соответствуют поведению по умолчанию. Если время начала больше текущего времени воспроизведения, то музыкальный файл будет продолжать воспроизводиться до тех пор, пока не достигнет конечного времени, а затем вернется к выбранному времени начала.

---

<a name="method-setmusicloopcountogg"></a>

### SetMusicLoopCountOGG()
```php
SetMusicLoopCountOGG(int $musicID, int $loop): void
```
Изменяет количество циклов воспроизведения музыкального файла, может быть установлено во время его воспроизведения. Используйте значение 0 для воспроизведения до конца файла или текущего времени окончания цикла, а затем остановитесь. Значение цикла, равное 1, будет циклическим навсегда, значение, большее 1, будет циклическим для этого числа раз. Эта команда сбрасывает команду GetMusicLoopCountOGG и снова начинает отсчет с 0.

---

<a name="method-setmusicfilevolume"></a>

### SetMusicFileVolume()
```php
SetMusicFileVolume(int $ID, int $vol): void
```
Устанавливает громкость на основе каждого файла, этот уровень громкости объединяется с громкостью музыкальной системы для создания окончательной громкости. По умолчанию файлы воспроизводятся на томе 100. Уровень громкости должен быть между 0 и 100.

---

<a name="method-setmeshmemblockvertexuv"></a>

### SetMeshMemblockVertexUV()
```php
SetMeshMemblockVertexUV(int $memID, int $vertexIndex, float $u, float $v): void
```
Обеспечивает быстрый способ изменения УФ-значений вершины внутри мемблока сетки. Он использует атрибутивные данные из начала мемблока для определения смещения вершин и изменения значений UV. Вершины начинаются с индекса 0.

---

<a name="method-setmeshmemblockvertexposition"></a>

### SetMeshMemblockVertexPosition()
```php
SetMeshMemblockVertexPosition(int $memID, int $vertexIndex, float $x, float $y, float $z): void
```
Обеспечивает быстрый способ изменения положения вершины внутри мемблока сетки. Он использует атрибутивные данные из начала мемблока для определения смещения вершины и изменения значений позиции. Вершины начинаются с индекса 0.

---

<a name="method-setmeshmemblockvertexnormal"></a>

### SetMeshMemblockVertexNormal()
```php
SetMeshMemblockVertexNormal(int $memID, int $vertexIndex, float $x, float $y, float $z): void
```
Обеспечивает быстрый способ изменения нормали вершины внутри мемблока сетки. Он использует атрибутивные данные из начала мемблока для определения смещения вершин и изменения нормальных значений. Вершины начинаются с индекса 0.

---

<a name="method-setmemblockstring"></a>

### SetMemblockString()
```php
SetMemblockString(int $memID, int $offset, string $value): void
```
Записывает строку в memblock в виде необработанных байтов. Первый найденный нулевой терминатор завершит строку, и один нулевой терминатор будет записан в данные memblock. Чтобы снова прочитать строку из memblock, вам нужно будет знать ее длину, поэтому рекомендуется также записать значение длины строки перед строковыми данными, чтобы помочь прочитать строку обратно позже. Смещение плюс длина строки, плюс 1 для нулевого терминатора, должно быть меньше размера memblock.

---

<a name="method-setmemblockshort"></a>

### SetMemblockShort()
```php
SetMemblockShort(int $memID, int $offset, int $value): void
```
Записывает короткое (2 байта) значение с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 2, поскольку запись коротких значений, не выровненных по 2-байтовым границам, влечет за собой снижение производительности оборудования. Короткие значения хранятся в формате little endian, поэтому запись короткого числа 23 со смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, а байт со смещением 1 как 0. Данное значение будет усечено до диапазона -32768 и 32767.

---

<a name="method-setmemblockint"></a>

### SetMemblockInt()
```php
SetMemblockInt(int $memID, int $offset, int $value): void
```
Записывает значение int (4 байта) с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку запись целочисленных значений, не выровненных по 4-байтовым границам, влечет за собой снижение производительности оборудования. Значения Int хранятся в формате little endian, поэтому запись int 23 со смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, байт со смещением 1 как 0, байт со смещением 2 как 0 и байт со смещением 3 как 0.

---

<a name="method-setmemblockfloat"></a>

### SetMemblockFloat()
```php
SetMemblockFloat(int $memID, int $offset, float $value): void
```
Запишите значение float (4 байта) с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку запись значений с плавающей запятой, не выровненных по 4-байтовым границам, влечет за собой снижение производительности оборудования. Значения Float хранятся в формате IEEE 754, поэтому запись float и последующее чтение его обратно в байтах вернут различные компоненты формата float.

---

<a name="method-setmeshmemblockvertexcolor"></a>

### SetMeshMemblockVertexColor()
```php
SetMeshMemblockVertexColor(int $memID, int $vertexIndex, int $red, int $green, int $blue, int $alpha): void
```
Обеспечивает быстрый способ изменения значений цвета вершины внутри мемблока сетки. Он использует атрибутивные данные из начала memblock для определения смещения вершин и изменения значений цвета. Вершины начинаются с индекса 0. Значения цвета должны быть в диапазоне от 0 до 255.

---

<a name="method-setmemblockbytesigned"></a>

### SetMemblockByteSigned()
```php
SetMemblockByteSigned(int $memID, int $offset, int $value): void
```
Записывает однобайтовое значение с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Данное значение будет усечено до диапазона -128 и 127.

---

<a name="method-setmemblockbyte"></a>

### SetMemblockByte()
```php
SetMemblockByte(int $memID, int $offset, int $value): void
```
Записывает однобайтовое значение с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Данное значение будет усечено до диапазона 0 и 255.

---

<a name="method-setlocalnotification"></a>

### SetLocalNotification()
```php
SetLocalNotification(int $iID, int $datetime, string $szMessage, string $szDeepLink): void
```
Создает локальное уведомление, которое появится в какой-то момент в будущем. Уведомления ссылаются на идентификатор и могут быть перезаписаны путем создания нового уведомления с тем же идентификатором, что и уведомление, которое вы хотите перезаписать. Если уведомление срабатывает во время работы приложения, то оно не появляется и бесшумно исчезает из списка запланированных уведомлений. Если приложение не открыто, то пользователю будет показано уведомление, и нажатие на него откроет ваше приложение. Если вы установите параметр deeplink, то этот URL-адрес будет отправлен в приложение при нажатии уведомления. URL-адрес можно получить с помощью команды GetURLSchemeText. Параметр datetime должен быть указан в unix time, который измеряется в секундах с 1 января 1970 года, вы можете использовать команду GetUnixTime для возврата текущей даты и времени, а затем изменить ее по мере необходимости. Если дата и время находятся в прошлом, то уведомление будет проигнорировано, оно не будет перезаписывать ни одно существующее уведомление. Идентификатор должен находиться в диапазоне от 1 до 100 включительно.

---

<a name="method-setjoystickscreenposition"></a>

### SetJoystickScreenPosition()
```php
SetJoystickScreenPosition(float $x, float $y, float $size): void
```
Джойстик AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания ввода в стиле джойстика в диапазоне от -1 до 1. Эта команда позиционирует виртуальный джойстик на экране только в том случае, если необходимо эмулировать этот ввод. Например, если имеется реальный джойстик или клавиатура, то эта команда не имеет заметного эффекта. Рекомендуется всегда вызывать эту команду в любом случае, если вы собираетесь использовать GetJoystickX или GetJoystickY, просто если вам нужен виртуальный джойстик. Любой виртуальный джойстик будет центрирован в заданном положении X и Y.

---

<a name="method-setjoystickdeadzone"></a>

### SetJoystickDeadZone()
```php
SetJoystickDeadZone(float $threshold): void
```
Устанавливает мертвую зону для универсальных джойстиков так, чтобы любое значение X или Y ниже заданного порога возвращало 0. Это значение должно быть между 0 и 1, по умолчанию оно равно 0,15.

---

<a name="method-setjointmousetarget"></a>

### SetJointMouseTarget()
```php
SetJointMouseTarget(int $iJointIndex, float $x, float $y): void
```
Задает целевую точку в мировых координатах, к которой мышиный сустав будет пытаться переместить прикрепленное тело. Работает только на мышиных суставах.

---

<a name="method-setjointmousemaxforce"></a>

### SetJointMouseMaxForce()
```php
SetJointMouseMaxForce(int $iJointIndex, float $maxForce): void
```
Устанавливает максимальное усилие, которое может быть использовано суставом мыши для перемещения объекта. По умолчанию это значение равно 0

---

<a name="method-setjointmotoron"></a>

### SetJointMotorOn()
```php
SetJointMotorOn(int $iJointIndex, float $speed, float $maxForce): void
```
Включает двигатель для соединения так, чтобы оно двигалось непрерывно, пока не будет предотвращено столкновение. Работает на линейных/колесных соединениях, призматических соединениях и вращающихся соединениях. Двигатели работают, прикладывая усилие для достижения заданной скорости, и если они встречают сопротивление, то увеличивают усилие до тех пор, пока двигатель не будет двигаться с желаемой скоростью или не будет достигнута максимальная заданная сила, после чего двигатель остановится, продолжая прикладывать максимальную силу. В случае линейных соединений двигатель работает в одном направлении и либо толкает прикрепленные спрайты вместе, либо раздвигает.

---

<a name="method-setjointmotoroff"></a>

### SetJointMotorOff()
```php
SetJointMotorOff(int $iJointIndex): void
```
Выключает двигатель, ранее приложенный к шарниру, который его поддерживает. Работает на линейных соединениях, призматических соединениях и револьверных соединениях.

---

<a name="method-setjointlimitoff"></a>

### SetJointLimitOff()
```php
SetJointLimitOff(int $iJointIndex): void
```
Отключает ограничения для суставов, которые их поддерживают. Работает на призматических и револьверных соединениях.

---

<a name="method-setjointdamping"></a>

### SetJointDamping()
```php
SetJointDamping(int $iJointIndex, float $dampingRatio, float $frequency): void
```
Демпфирование можно использовать, чтобы сделать сустав мягким, как пружина. Частота задается в герцах и обычно должна быть меньше половины частоты шага физики. Например, если fps равен 60, то частота должна быть меньше 30. Коэффициент демпфирования должен быть между 0 и 1, но может быть и больше. Это можно использовать только на дистанционных соединениях, сварных соединениях, соединениях линии/колеса и соединениях мыши. По умолчанию расстояние и сварные соединения имеют коэффициент демпфирования и частоту 0, что делает соединение жестким. По умолчанию суставы мыши имеют частоту 5 и коэффициент демпфирования 0,7. По умолчанию линейные/колесные соединения имеют частоту 2 и коэффициент демпфирования 0,7.

---

<a name="method-setjointlimiton"></a>

### SetJointLimitOn()
```php
SetJointLimitOn(int $iJointIndex, float $lowerLimit, float $upperLimit): void
```
Работает на призматических и револьверных соединениях. Устанавливает предел, которого этот сустав может достичь до остановки, для вращающихся суставов это основано на углах, для других-на длине. По умолчанию сустав не имеет ограничений.

---

<a name="method-setintendeddevicesize"></a>

### SetIntendedDeviceSize()
```php
SetIntendedDeviceSize(int $width, int $height): void
```
Устанавливает размер устройства, для которого вы разработали все свои произведения искусства, это позволяет AGK уменьшить размер изображений, чтобы сэкономить память на устройствах с более низким разрешением. Обратите внимание, что такие команды, как SetSpriteAnimation, которые могут предполагать размеры изображений, должны учитывать уменьшенные изображения. Например, загрузка изображения 512x512 и использование SetSpriteAnimation(spr,128,128,16) должны вместо этого использовать SetSpriteAnimation(spr,GetImageWidth(img)/4,GetImageHeight(img)/4,16) в случае, если изображение больше не имеет размера 512. Эта команда устарела, и вы должны использовать LoadImageResized для настройки размеров изображений в зависимости от разрешения устройства, вы можете проверить разрешение устройства с помощью GetDeviceWidth и GetDeviceHeight.

---

<a name="method-setinneractivedetails"></a>

### SetInneractiveDetails()
```php
SetInneractiveDetails(string $szCode): void
```
Устанавливает данные вашей учетной записи Inneractive для использования CreateAdvert. Не все платформы поддерживают всех поставщиков рекламы, поэтому установка как можно большего количества реквизитов учетной записи позволит AGK выбрать подходящее объявление для этой платформы. В настоящее время Inneractive поддерживается iOS, Android, Windows и Mac.

---

<a name="method-setimmersivemode"></a>

### SetImmersiveMode()
```php
SetImmersiveMode(int $mode): void
```
Удаляет все экранные элементы управления, которые могли быть размещены на экране операционной системой, например кнопки "Домой" и "Назад", позволяя вашему приложению использовать весь экран. Ваше приложение может быть изменено после вызова этой команды, поэтому, если вы использовали GetDeviceWidth или GetDeviceHeight, вам следует подождать несколько кадров, а затем вызвать их снова, чтобы получить новые значения. Значения могут измениться не сразу после вызова этой команды, так как для изменения навигационной панели требуется некоторое время. Иногда ОС отключает иммерсивный режим без предупреждения, например, при нажатии кнопок регулировки громкости. Когда это произойдет, ваше приложение вернется к своему размеру без погружения в режим, чтобы предотвратить скрытие любой части приложения навигационной панелью, что может сделать некоторые части приложения недоступными для сенсорных событий. Вы можете обнаружить это изменение, регулярно проверяя GetDeviceWidth и GetDeviceHeight, и снова использовать SetImmersiveMode, чтобы запросить возврат в режим погружения. В настоящее время это относится только к устройствам Android под управлением версии 4.4 (API 19) или выше. На других платформах эта команда ничего не делает.

---

<a name="method-setimagewrapu"></a>

### SetImageWrapU()
```php
SetImageWrapU(int $iImageIndex, int $mode): void
```
Устанавливает режим УФ-обертывания изображения, когда U-координата выходит за пределы диапазона 0-1. По умолчанию используется режим 0, который фиксирует значение пикселя до последнего допустимого пикселя, режим 1 повторяет текстуру, начиная с противоположной стороны. Чтобы успешно использовать значения UV за пределами 0-1 на всех платформах, рассматриваемое изображение должно иметь степень 2 по ширине и высоте и не быть частью текстуры атласа. Это относится как к зажиму, так и к повторению.

---

<a name="method-setimagewrapv"></a>

### SetImageWrapV()
```php
SetImageWrapV(int $iImageIndex, int $mode): void
```
Устанавливает режим УФ-обертывания изображения, когда координата V выходит за пределы диапазона 0-1. По умолчанию используется режим 0, который фиксирует значение пикселя до последнего допустимого пикселя, режим 1 повторяет текстуру, начиная с противоположной стороны. Чтобы успешно использовать УФ-значения за пределами 0-1 на всех платформах, рассматриваемое изображение должно иметь степень 2 по ширине и высоте и не быть частью текстуры атласа. Это относится как к зажиму, так и к повторению.

---

<a name="method-setimagetransparentcolor"></a>

### SetImageTransparentColor()
```php
SetImageTransparentColor(int $iImage, int $r, int $g, int $b): void
```
Делает определенный цвет полностью прозрачным в выбранном изображении. Это медленная команда, и ее не следует вызывать каждый кадр.

---

<a name="method-setimagesubimages"></a>

### SetImageSubImages()
```php
SetImageSubImages(int $iImageIndex, string $sSubImageFile): void
```
Задает данные подизображения для изображения атласа, которое представляет собой расположение каждого подизображения внутри изображения атласа. Обычно это загружается автоматически из subimages.txt файл при загрузке изображения, но если это невозможно, то эта команда может быть использована для установки этих данных. Файл должен быть действительным subimages.txt файл в том же формате что и указанный в LoadSubImage В отличие от обычной команды load image файл не нуждается в имени subimages.txt, он может иметь любое имя и путь

---

<a name="method-setimageminfilter"></a>

### SetImageMinFilter()
```php
SetImageMinFilter(int $iImageIndex, int $mode): void
```
Устанавливает фильтр для текстур, когда текстура меньше пространства экрана, в котором она отображается. Вы можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть блочным, или 1, чтобы использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно совпадает с пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница, ближайший имеет тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей.

---

<a name="method-setimagemagfilter"></a>

### SetImageMagFilter()
```php
SetImageMagFilter(int $iImageIndex, int $mode): void
```
Устанавливает фильтр для текстур, когда текстура больше, чем пространство экрана, в котором она отображается. Вы можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть блочным, или 1, чтобы использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно совпадает с пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница, ближайший имеет тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей.

---

<a name="method-setimagemask"></a>

### SetImageMask()
```php
SetImageMask(int $iDstImage, int $iSrcImage, int $dst, int $src, int $x, int $y): void
```
Копирует цветовой канал с одного изображения на другое. Вы можете указать исходный и конечный каналы, используя значения 1,2,3,4 для представления красного, зеленого, синего и альфа-каналов соответственно. Это медленная команда, и ее не следует вызывать каждый кадр. Значения смещения x,y позволяют смещать исходное изображение на целевом изображении, поэтому небольшое исходное изображение можно использовать для маскировки любой части большого изображения. Любая часть большого изображения за пределами размера маленького изображения останется неизменной. отрицательные значения смещения поддерживаются для смещения исходного изображения от верхнего левого края целевого изображения. Если вы добавляете несколько прозрачных пикселей к изображению, которое в настоящее время не имеет ни одного, и используете изображение на спрайте, то обязательно используйте SetSpriteTransparency, чтобы сделать спрайт прозрачным.

---

<a name="method-sethttpverifycertificate"></a>

### SetHTTPVerifyCertificate()
```php
SetHTTPVerifyCertificate(int $iHTTP, int $mode): void
```
Устанавливает, должно ли устройство проверять SSL-сертификат при создании защищенного соединения. Если сервер, к которому вы подключаетесь, использует самозаверяющий сертификат, вам нужно будет установить его равным 0, иначе соединение не удастся. Во всех остальных случаях вы должны оставить это значение равным 1, чтобы обеспечить безопасное соединение с сервером. Отключение проверки отключит защиту от атак man in the middle на SSL-соединения.

---

<a name="method-sethttptimeout"></a>

### SetHTTPTimeout()
```php
SetHTTPTimeout(int $iHTTP, int $milliseconds): void
```
Устанавливает время в миллисекундах, в течение которого AGK будет ждать установления соединения, прежде чем отказаться от него.

---

<a name="method-sethttphost"></a>

### SetHTTPHost()
```php
SetHTTPHost(int $iHTTP, string $szHost, int $iSecure, string $szUser, string $szPass): int
```
Задает домен хоста, к которому вы хотите подключиться, например для доступа www.thegamecreators.com/index.php вы бы использовали значение хоста www.thegamecreators.com, не включайте http:, который обычно идет перед ним. Обратите внимание, что попытка использовать определенный порт с www.thegamecreators.com:8080 на некоторых платформах это может быть проигнорировано, и в этих случаях будет использоваться порт 80. При экспорте в HTML5 обратите внимание, что веб-браузеры ограничивают количество серверов, к которым вы можете подключиться. По умолчанию вы ограничены файлами, размещенными на том же сервере, что и ваше приложение. Однако если сервер отправляет заголовок Access-Control-Allow-Origin в своем ответе, который разрешает сервер вашего приложения, то браузер позволит вам подключиться к нему.

---

<a name="method-setglobal3ddepth"></a>

### SetGlobal3DDepth()
```php
SetGlobal3DDepth(int $depth): void
```
Задает положение всех 3D-объектов относительно 2D-объектов. Например, использование глобальной 3D-глубины 100 будет означать, что все спрайты на глубине меньше или равной 100 будут появляться над любыми 3D-объектами, в то время как спрайты на глубине больше 100 будут появляться под любыми 3D-объектами.

---

<a name="method-setgeneratemipmaps"></a>

### SetGenerateMipmaps()
```php
SetGenerateMipmaps(int $generate): void
```
Устанавливает, генерируются ли и используются ли загруженные изображения с mip-картами. Должен быть вызван до того, как будут загружены какие-либо изображения. Может быть изменено до загрузки другого изображения, чтобы некоторые использовали mip-карты, а другие-нет.

---

<a name="method-setfolder"></a>

### SetFolder()
```php
SetFolder(string $str): int
```
При обычном использовании вашему приложению AGK доступны только две папки: папка чтения и папка записи. Папка чтения - это расположение исполняемого файла, включающее папку мультимедиа. Папка записи (которая также имеет разрешение на чтение) находится в безопасном месте платформы и отличается в зависимости от устройства. Например, в Windows по умолчанию используется следующее место записи: C:\Users\username\AppData\AGKApps\appName (По умолчанию это скрытая папка в Windows, и вам, возможно, придется показать скрытые файлы, чтобы увидеть ее). Это ваши корневые папки. Любые файлы, созданные/записанные с помощью OpenToWrite, будут сохранены в папке записи. Для простоты AGK объединяет эти две папки чтения и записи в один набор команд. Это означает, что при попытке открыть или загрузить файл AGK сначала будет искать в папке записи, а затем в папке чтения. При использовании SetFolder его поведение соответствует тому, что вы ожидаете от команды CD в консоли Windows или Linux; Он работает из текущего каталога. Например, если текущая папка чтения C:\games\myApp\ затем SetFolder("images") поместит вас в C:\games\myApp\images. Вызов команды во второй раз с помощью SetFolder("backgrounds") приведет вас в C:\games\myApp\images\backgrounds\. Есть два способа вернуться на базовый путь. Первый-вызвать SetFolder (""), используя пустую строку. Другой способ-предварить свой путь прямой косой чертой, SetFolder("/stuff"). Это также относится и к загрузке ваших файлов с помощью других команд. Предположим, что вы все еще находитесь в папках images\backgrounds и хотите загрузить файл bk.png, расположенный в основании папки read. Вы можете просто сказать LoadImage("/bk.png"), который будет загружаться C:\games\myApp\bk.png. Установка пути к несуществующей папке и использование OpenToWrite создаст эту папку в пути записи. SetFolder не проверяет, существует ли папка, он просто устанавливает внутренний путь, который будет использоваться в следующей команде file. По умолчанию AGK первым делом вызывает SetFolder("media"). Эта команда возвращает 1 при успешном выполнении или 0, если вы используете недопустимый путь, такой как SetFolder("C:\"). Примечание: При настройке путей важно помнить, что всегда следует использовать косую черту вперед, а не обратную. AGK преобразует их в соответствующий файловый разделитель для данной платформы. Если вы хотите получить доступ к файлам вне папок чтения и записи, вы можете использовать обычные файловые команды, такие как OpenToRead с путем к файлу "raw:", см. Эту команду для получения более подробной информации. Для доступа к папкам вне папок чтения и записи можно использовать команды OpenRawFolder.

---

<a name="method-setfogrange"></a>

### SetFogRange()
```php
SetFogRange(float $minDist, float $maxDist): void
```
Устанавливает диапазон действия 3D-тумана. На минимальном расстоянии не будет возникать тумана, после чего туман начнет действовать. Максимальное расстояние не является пределом и является лишь приблизительным руководством для того, как далеко вы хотите видеть в своей сцене. Туман увеличивается экспоненциально, чтобы имитировать реальность, то есть сначала он быстро увеличивается, затем затихает и постепенно достигает полной интенсивности на максимальном расстоянии.

---

<a name="method-setfogsuncolor"></a>

### SetFogSunColor()
```php
SetFogSunColor(int $red, int $green, int $blue): void
```
Устанавливает цвет солнца 3D тумана. Это используется вместо обычного цвета тумана, когда камера обращена к солнцу, как определено командой SetSunDirection. Это может быть использовано для имитации эффектов рассеяния света, чтобы воздух казался туманным. Цвет туманного солнца должен быть близок к цвету солнца для лучшего эффекта, но это не обязательно. Обратите внимание, что вызов этой команды изменяет расчет тумана на более сложную версию, что приведет к снижению производительности на мобильных устройствах. Чтобы вернуться к более быстрому методу расчета тумана, сделайте цвет солнца тумана равным нормальному цвету тумана.

---

<a name="method-setfogcolor"></a>

### SetFogColor()
```php
SetFogColor(int $red, int $green, int $blue): void
```
Устанавливает цвет 3D тумана. Объекты будут постепенно исчезать до этого цвета по мере удаления от камеры. Цветовые значения должны находиться в диапазоне от 0 до 255, но этим они не ограничиваются и система будет принимать значения вне диапазона, в том числе и отрицательные.

---

<a name="method-setfogmode"></a>

### SetFogMode()
```php
SetFogMode(int $mode): void
```
Устанавливает 3D туман включенным или выключенным, это может быть использовано для создания атмосферной дымки или выцветания объектов до цвета фона, чтобы имитировать уменьшенную видимость. Туман будет автоматически применен ко всем 3D-объектам, если они используют шейдер по умолчанию. Если вы применили свой собственный шейдер с помощью SetObjectShader, то объявите функцию mediump vec3 ApplyFog( mediump vec3 color, highp vec3 pointPos ); в пиксельном шейдере, который AGK заполнит для вас во время выполнения. pointPos-это положение пикселя в мировых координатах, которое вам нужно будет передать из вершинного шейдера.

---

<a name="method-setfilepos"></a>

### SetFilePos()
```php
SetFilePos(int $iFileID, int $pos): void
```
Задает текущую позицию чтения в файле

---

<a name="method-setexpansionfileversion"></a>

### SetExpansionFileVersion()
```php
SetExpansionFileVersion(int $version): void
```
Задает номер версии для использования в других командах расширения файла. В настоящее время применимо только к Android. Номер версии файла расширения определяется номером версии APK, который был загружен вместе с ним. Например, APK может быть обновлен до нового номера версии, но файл расширения все равно может быть исходным номером версии.

---

<a name="method-setexpansionfilekey"></a>

### SetExpansionFileKey()
```php
SetExpansionFileKey(string $key): void
```
Задает открытый ключ для использования в других командах расширения файла. В настоящее время применимо только к Android. Открытый ключ можно найти в консоли разработчика Google Play и он отличается для каждого приложения. Нажмите на приложение, а затем нажмите на раздел Служб и API, это длинная строка, которая начинается MIIB.

---

<a name="method-seterrormode"></a>

### SetErrorMode()
```php
SetErrorMode(int $mode): void
```
Устанавливает режим ошибки для команд AGK from ignore, report или stop from AGK, например, идентификатор спрайта не существует в команде, которая принимает идентификатор спрайта. Игнорирование заставит AGK попытаться продолжить, игнорируя всю команду, если это необходимо. Отчет заставит AGK сообщить об ошибке в соответствующую консоль отладки и продолжить работу. Stop заставит AGK сообщить об ошибке, как и раньше, а затем остановится, вызвав исключение, которое должно быть поймано, иначе приложение завершится. В случае уровня 1 исключение перехватывается интерпретатором и при отладке отображается в IDE.

---

<a name="method-seteditboxwrapmode"></a>

### SetEditBoxWrapMode()
```php
SetEditBoxWrapMode(int $index, int $mode): void
```
Если SetEditBoxMultiLine имеет значение 0, эта команда устанавливает, будет ли одна строка текста прокручиваться вправо или переноситься на новую строку, когда она перетекает по ширине поля редактирования. Использование по-прежнему не будет разрешено вводить новые символы строки самостоятельно.

---

<a name="method-seteditboxvisible"></a>

### SetEditBoxVisible()
```php
SetEditBoxVisible(int $index, int $visible): void
```
Переключает видимое состояние этого поля редактирования, когда видимое установлено в 1, поле редактирования можно щелкнуть, получить фокус и изменить, когда установлено в 0, поле редактирования не отображается, не может быть изменено или получить фокус.

---

<a name="method-seteditboxusealternateinput"></a>

### SetEditBoxUseAlternateInput()
```php
SetEditBoxUseAlternateInput(int $index, int $mode): void
```
Задает, будет ли поле редактирования использовать альтернативный метод ввода текста, если поле редактирования будет скрыто виртуальной клавиатурой. Это относится только к мобильным платформам, таким как iOS и Android, и альтернативный метод ввода обычно представляет собой меньшее поле редактирования, расположенное чуть выше клавиатуры. Поле редактирования по-прежнему будет обновляться в режиме реального времени, как если бы оно вводилось непосредственно, но поскольку оно закрыто клавиатурой, пользователь его не увидит. По умолчанию он включен. Если вы хотите, вы можете отключить его и переместить поле редактирования в поле зрения, когда GetEditBoxHasFocus возвращает 1, обязательно переместите его обратно, когда GetEditBoxHasFocus возвращает 0.

---

<a name="method-seteditboxtextsize"></a>

### SetEditBoxTextSize()
```php
SetEditBoxTextSize(int $index, float $size): void
```
Задает высоту в мировых координатах текста в этом поле редактирования. По умолчанию он установлен на высоту поля редактирования минус 2.

---

<a name="method-seteditboxtextcolor"></a>

### SetEditBoxTextColor()
```php
SetEditBoxTextColor(int $index, int $red, int $green, int $blue): void
```
Задает цвет вводимого текста.

---

<a name="method-seteditboxtext"></a>

### SetEditBoxText()
```php
SetEditBoxText(int $index, string $str): void
```
Задает текст, который в данный момент отображается в поле редактирования.

---

<a name="method-seteditboxsize"></a>

### SetEditBoxSize()
```php
SetEditBoxSize(int $index, float $width, float $height): void
```
Задает размер поля редактирования в мировых координатах. При этом устанавливается размер фактического поля ввода текста, его граница будет выходить за пределы этих значений.

---

<a name="method-seteditboxscissor"></a>

### SetEditBoxScissor()
```php
SetEditBoxScissor(int $index, float $x, float $y, float $x2, float $y2): void
```
При рисовании поле редактирования привязывается к указанным мировым координатам.

---

<a name="method-seteditboxposition"></a>

### SetEditBoxPosition()
```php
SetEditBoxPosition(int $index, float $x, float $y): void
```
Устанавливает положение в мировых координатах поля редактирования, используя его верхний левый угол. Это устанавливает положение фактического поля ввода текста, его граница будет расширяться влево и выше этой точки.

---

<a name="method-seteditboxpasswordmode"></a>

### SetEditBoxPasswordMode()
```php
SetEditBoxPasswordMode(int $index, int $mode): void
```
Задает, будут ли в поле редактирования отображаться звезды вместо ввода текста. Использование GetEditBoxText по-прежнему будет возвращать фактические символы, введенные пользователем.

---

<a name="method-seteditboxmultiline"></a>

### SetEditBoxMultiLine()
```php
SetEditBoxMultiLine(int $index, int $multiline): void
```
Задает, будет ли поле редактирования переносить текст в новую строку, когда он достигнет края поля редактирования. По умолчанию многострочный текст равен 0, поэтому текст представляет собой одну непрерывную строку в поле.

---

<a name="method-seteditboxmaxlines"></a>

### SetEditBoxMaxLines()
```php
SetEditBoxMaxLines(int $index, int $max): void
```
Задает максимальное количество строк, которые могут быть введены в это многострочное поле редактирования. Используйте 0 для неограниченного количества.

---

<a name="method-seteditboxmaxchars"></a>

### SetEditBoxMaxChars()
```php
SetEditBoxMaxChars(int $index, int $max): void
```
Задает максимальное количество символов, которое может быть введено в это поле редактирования. Используйте 0 для неограниченного количества.

---

<a name="method-seteditboxinputtype"></a>

### SetEditBoxInputType()
```php
SetEditBoxInputType(int $index, int $inputType): void
```
Задает тип клавиатуры, которая будет отображаться на мобильных устройствах при редактировании этого поля редактирования. Там, где это возможно, будет отображаться клавиатура такого типа, например клавиатура только с цифрами.

---

<a name="method-seteditboxfontimage"></a>

### SetEditBoxFontImage()
```php
SetEditBoxFontImage(int $index, int $image): void
```
Устанавливает изображение шрифта, которое будет использоваться для этого поля редактирования, должно быть ранее загружено с помощью LoadImage(). Используйте 0, чтобы вернуть поле редактирования к шрифту по умолчанию.

---

<a name="method-seteditboxfocus"></a>

### SetEditBoxFocus()
```php
SetEditBoxFocus(int $index, int $focus): void
```
Переключает состояние фокуса этого поля редактирования, когда фокус установлен на 1, курсор начинает мигать, и любое нажатие клавиши добавит текст в поле редактирования. При установке значения 0 курсор исчезает, и текст не добавляется.

---

<a name="method-seteditboxfont"></a>

### SetEditBoxFont()
```php
SetEditBoxFont(int $index, int $fontID): void
```
Устанавливает шрифт, используемый для этого поля редактирования, который должен быть ранее загружен с помощью LoadFont. Используйте 0, чтобы вернуть поле редактирования к шрифту по умолчанию.

---

<a name="method-seteditboxextendedfontimage"></a>

### SetEditBoxExtendedFontImage()
```php
SetEditBoxExtendedFontImage(int $index, int $image): void
```
Устанавливает расширенное изображение шрифта, используемое для этого поля редактирования, должно быть ранее загружено с помощью LoadImage(). Используйте 0, чтобы удалить расширенное изображение шрифта. Если вы не установите это изображение, поле редактирования не будет принимать расширенные символы, такие как £ é á и т. Д.

---

<a name="method-seteditboxdepth"></a>

### SetEditBoxDepth()
```php
SetEditBoxDepth(int $index, int $depth): void
```
Устанавливает глубину поля редактирования таким образом, чтобы оно могло появляться позади или перед другими спрайтами и текстовыми объектами.

---

<a name="method-seteditboxcursorwidth"></a>

### SetEditBoxCursorWidth()
```php
SetEditBoxCursorWidth(int $index, float $width): void
```
Устанавливает ширину в мировых координатах курсора ввода текста, по умолчанию это значение равно 1,5 Обратите внимание, что функции, изменяющие размер текста или размер поля редактирования, могут перезаписать это значение.

---

<a name="method-seteditboxcursorblinktime"></a>

### SetEditBoxCursorBlinkTime()
```php
SetEditBoxCursorBlinkTime(int $index, float $time): void
```
Задает время в секундах между видимым и невидимым курсором в поле ввода текста.

---

<a name="method-seteditboxcursorcolor"></a>

### SetEditBoxCursorColor()
```php
SetEditBoxCursorColor(int $index, int $red, int $green, int $blue): void
```
Задает цвет мигающего курсора в этом поле редактирования.

---

<a name="method-seteditboxcursorposition"></a>

### SetEditBoxCursorPosition()
```php
SetEditBoxCursorPosition(int $index, int $pos): void
```
Устанавливает курсор в заданную позицию в тексте, т. е. позиция 0 находится слева от первого символа, позиция 1-слева от второго символа и т. Д. Если значение позиции находится вне диапазона, оно будет зажато до ближайшего символа. Текущая позиция курсора гарантированно находится в поле зрения пользователя, поэтому ее можно использовать для выравнивания текста влево или вправо, установив курсор в крайнем левом или правом углу текста.

---

<a name="method-seteditboxbordersize"></a>

### SetEditBoxBorderSize()
```php
SetEditBoxBorderSize(int $index, float $size): void
```
Задает размер границы в мировых координатах, которая будет окружать поле ввода текста. Например, значение 2 добавит границу в 2 пикселя вокруг поля ввода.

---

<a name="method-seteditboxborderimage"></a>

### SetEditBoxBorderImage()
```php
SetEditBoxBorderImage(int $index, int $image): void
```
Устанавливает изображение для использования в качестве границы, это может быть использовано вместе с цветом границы. Используйте 0, чтобы удалить изображение границы.

---

<a name="method-seteditboxbordercolor"></a>

### SetEditBoxBorderColor()
```php
SetEditBoxBorderColor(int $index, int $red, int $green, int $blue, int $alpha): void
```
Задает цвет любой присутствующей границы. Вы также можете использовать изображение с помощью SetEditBoxBorderImage().

---

<a name="method-seteditboxbackgroundcolor"></a>

### SetEditBoxBackgroundColor()
```php
SetEditBoxBackgroundColor(int $index, int $red, int $green, int $blue, int $alpha): void
```
Задает цвет основного поля ввода текста.

---

<a name="method-seteditboxbackgroundimage"></a>

### SetEditBoxBackgroundImage()
```php
SetEditBoxBackgroundImage(int $index, int $image): void
```
Устанавливает изображение для использования в качестве фона, это может быть использовано вместе с цветом фона. Используйте 0, чтобы удалить фоновое изображение.

---

<a name="method-setdisplayaspect"></a>

### SetDisplayAspect()
```php
SetDisplayAspect(float $aspect): void
```
Эта команда используется в сочетании с системой позиционирования по умолчанию на основе процентов в AGK. При использовании этого подхода вам нужно будет указать аспект отображения, чтобы AGK знал, как правильно отображать объекты на экране. Если бы ваше произведение изначально было рассчитано на разрешение 1024 x 768, это привело бы к соотношению сторон 4:3, что также равносильно утверждению 1024 / 768 = 1.33, поэтому вы бы вызвали SetDisplayAspect и передали бы значение 1.33 в качестве вашего соотношения сторон. На платформах, где разрешение было другим, AGK позаботится о том, чтобы ваше приложение все еще поддерживало это соотношение сторон и выглядело правильно. Альтернативный подход заключается в вызове SetVirtualResolution для управления системой координат и размещения спрайтов с использованием экранных координат вместо использования процентов, и в этом случае вы не должны вызывать эту команду. Если спрайты уже существуют, когда это называется, они будут искажены. Если заданное соотношение сторон не подходит точно на текущем устройстве, черные границы будут нарисованы вокруг области рендеринга, чтобы центрировать ее на экране. Используйте соотношение сторон 0, чтобы использовать текущую систему координат в качестве соотношения сторон. Используйте соотношение сторон -1 для использования соотношения сторон устройства (заполняет весь экран без черных границ, но вызовет растяжение и будет выглядеть по-разному на каждом устройстве) Альтернативным методом заполнения экрана, который позволяет избежать этой проблемы, является использование SetScissor со значениями 0,0,0,0.

---

<a name="method-setdevicecameratoimage"></a>

### SetDeviceCameraToImage()
```php
SetDeviceCameraToImage(int $cameraID, int $imageID): int
```
Использование идентификатора изображения, большего нуля, приведет к потоковой передаче камеры устройства на выбранное изображение. Изображение в данный момент не должно существовать, оно будет создано этой командой. Используйте ImageID 0, чтобы остановить потоковую передачу, это также приведет к удалению изображения. Параметр cameraID используется, когда устройство имеет несколько камер, например фронтальную и заднюю. Обычно 0 относится к камере, обращенной назад. Используйте GetNumDeviceCameras, чтобы узнать, сколько камер имеет это устройство, и GetDeviceCameraType, чтобы проверить, обращено ли оно спереди или сзади. Этот параметр игнорируется, если ImageID равен 0. У вас может быть активна только одна камера устройства одновременно, поэтому для переключения с задней камеры на фронтальную вы должны сначала вызвать эту команду с ImageID, установленным в 0, чтобы остановить захват, а затем запустить его снова с новым cameraID. Возвращает 1, если она была успешной, 0, если возникла проблема или текущая платформа не поддерживает эту команду. В настоящее время это поддерживается на iOS, Android 4.0.3 и выше, а также Windows.

---

<a name="method-setdefaultwrapv"></a>

### SetDefaultWrapV()
```php
SetDefaultWrapV(int $mode): void
```
Устанавливает текстурное обертывание по умолчанию для изображений, где координаты UV выходят за пределы диапазона от 0 до 1 в направлении V.

---

<a name="method-setdefaultwrapu"></a>

### SetDefaultWrapU()
```php
SetDefaultWrapU(int $mode): void
```
Устанавливает текстурное обертывание по умолчанию для изображений, где координаты UV выходят за пределы диапазона от 0 до 1 в направлении U.

---

<a name="method-seteditboxactive"></a>

### SetEditBoxActive()
```php
SetEditBoxActive(int $index, int $active): void
```
Переключает активное состояние этого поля редактирования, когда активное установлено в 1, поле редактирования можно щелкнуть, получить фокус и изменить, когда установлено в 0, поле редактирования нельзя ни изменить, ни получить фокус.

---

<a name="method-setdefaultminfilter"></a>

### SetDefaultMinFilter()
```php
SetDefaultMinFilter(int $filter): void
```
Устанавливает фильтр минификации по умолчанию для текстур, когда текстура меньше пространства экрана, в котором она отображается. Вы можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть блочным, или 1, чтобы использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно совпадает с пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница, ближайший имеет тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей. Вы можете установить это значение для каждого изображения с помощью SetImageMinFilter.

---

<a name="method-setdefaultmagfilter"></a>

### SetDefaultMagFilter()
```php
SetDefaultMagFilter(int $filter): void
```
Устанавливает фильтр увеличения по умолчанию для текстур, когда текстура больше, чем пространство экрана, в котором она отображается. Вы можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть блочным, или 1, чтобы использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно совпадает с пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница, ближайший имеет тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей. Вы можете установить это значение для каждого изображения с помощью SetImageMagFilter.

---

<a name="method-setcursorblinktime"></a>

### SetCursorBlinkTime()
```php
SetCursorBlinkTime(float $seconds): void
```
Устанавливает время в секундах между появлением и исчезновением курсора в полноэкранном окне редактирования

---

<a name="method-setcurrentdir"></a>

### SetCurrentDir()
```php
SetCurrentDir(string $szPath): int
```
Эта команда устарела и была заменена на SetFolder.

---

<a name="method-setclouddatavariable"></a>

### SetCloudDataVariable()
```php
SetCloudDataVariable(string $varName, string $varValue): void
```
Устанавливает переменную облачных данных в заданное значение. Если несколько устройств записывают значение одновременно, то облачный провайдер выбирает одно из них и отправляет его всем устройствам. Имя переменной должно быть меньше 64 байт, один символ UTF8 может быть несколько байт, но обычно 1 символ равен 1 байту. Рекомендуется, чтобы имена переменных включали имя приложения, например "myapp.myvariablename", поскольку при трансляции ваших приложений все они будут совместно использовать одно хранилище данных в приложении AGK PLayer. Изменяемые данные хранятся локально, поэтому GetCloudDataVariable немедленно вернет новое значение, однако синхронизация с облаком выполняется в фоновом режиме и может занять несколько минут. Если устройство не имеет подключения к Интернету, то данные будут синхронизированы при следующей доступной возможности. В iOS вы ограничены 1024 переменными с общим объемом памяти 1 МБ. На Android любые данные, которые вы храните, засчитываются в лимит хранения Google Диска пользователя, пользователь может очистить данные вашего приложения, чтобы освободить место, но он не может прочитать данные, которые вы храните.  Вы не должны хранить конфиденциальную информацию, такую как пароли, в виде обычного текста с помощью этих команд.

---

<a name="method-setclipboardtext"></a>

### SetClipboardText()
```php
SetClipboardText(string $szText): void
```
Устанавливает буфер обмена устройства на указанный текст, при этом перезаписывается все, что ранее было в буфере обмена устройства. Буфер обмена такой же, как и тот, который используется функцией копирования/вставки устройства.

---

<a name="method-setclearcolor"></a>

### SetClearColor()
```php
SetClearColor(int $red, int $green, int $blue): void
```
Устанавливает четкий цвет, используемый при очистке заднего буфера.

---

<a name="method-setchartboostdetails"></a>

### SetChartboostDetails()
```php
SetChartboostDetails(string $szKey1, string $szKey2): void
```
Устанавливает данные вашей учетной записи Chartboost для использования в интерстициальной (полноэкранной) рекламе и видеорекламе вознаграждений. После вызова этой команды будет предпринята попытка кэшировать интерстициал, чтобы вы могли сразу же отобразить его позже. Вы можете проверить ход выполнения этой задачи с помощью GetFullscreenAdvertLoadedChartboost. Обратите внимание, что эта команда не будет автоматически кэшировать видеорекламу с вознаграждением, вы должны сделать это вручную с помощью CacheRewardAdChartboost. Реклама Chartboost в настоящее время поддерживается Android и iOS.

---

<a name="method-setcamerarotationquat"></a>

### SetCameraRotationQuat()
```php
SetCameraRotationQuat(int $cameraID, float $w, float $x, float $y, float $z): void
```
Устанавливает вращение указанной камеры с помощью кватерниона. В качестве альтернативы вы можете использовать SetCameraRotation для использования углов Эйлера. По умолчанию камеры создаются с кватернионом 1,0,0,0 в порядке w,x,y,z. Кватернион-это 4-мерное представление трехмерного вращения со свойством w^2+x^2+y^2+z^2 = 1, которое позволяет легко интерполировать между двумя вращениями путем линейной интерполяции двух кватернионов и их нормализации. Каждое 3D-вращение представлено ровно 2 кватернионами, w,x,y,z и -w,-x,-y,-z, поэтому любая версия может быть возвращена командами GetCameraQuat. Кватернионы и углы Эйлера могут использоваться одновременно. Например, установка вращения кватерниона создаст представление Эйлера, которое можно получить с помощью GetCameraAngleX и т. Д.

---

<a name="method-setcamerarotation"></a>

### SetCameraRotation()
```php
SetCameraRotation(int $cameraID, float $angx, float $angy, float $angz): void
```
Задает поворот указанной камеры с помощью углов Эйлера в градусах. В качестве альтернативы вы можете использовать SetCameraRotationQuat для использования кватерниона. По умолчанию камеры создаются с углами 0,0,0 в порядке YXZ. Углы Эйлера-это составные углы, где камера начинается с 0,0,0 и затем поворачивается на заданный угол Y, затем на заданный угол X, а затем катится на заданный угол Z. Каждое 3D-вращение может быть представлено 2 комбинациями углов Эйлера, Y,X,Z и Y-180,X-180,Z-180, поэтому любая версия может быть возвращена командами GetCameraAngle. Кватернионы и углы Эйлера могут использоваться одновременно. Например, установка угла поворота Эйлера создаст представление кватерниона, которое можно получить с помощью GetCameraQuatX и т. Д.

---

<a name="method-setcamerarange"></a>

### SetCameraRange()
```php
SetCameraRange(int $cameraID, float $fNear, float $fFar): void
```
Устанавливает ближнюю и дальнюю плоскости камеры. Из-за ограничений рендеринга не все перед камерой может быть рендерено, поэтому они должны быть ограничены видимым диапазоном. Все, что находится за пределами этого диапазона, отсекается системой рендеринга и остается невидимым. Ближняя плоскость-это самое близкое, что объект может быть к камере и все еще визуализироваться, она должна быть больше 0. Обратите внимание, что использование очень малых значений для ближней плоскости повлияет на точность буфера глубины при рендеринге объектов вдали, что может вызвать мерцание на удаленных объектах. Это происходит потому, что буфер глубины не является линейным, вместо этого он смещен в сторону ближней плоскости, и чем ближе к 0 становится ближняя плоскость, тем меньше буфера глубины доступно для дальних объектов. Дальняя плоскость-это максимальное расстояние, на котором объект может находиться от камеры и все еще визуализироваться, его максимальное значение равно бесконечности, но опять же, чем дальше вы пытаетесь визуализировать объект от ближней плоскости, тем менее точной становится буферизация глубины. Если объект пересекает ближнюю или дальнюю плоскость так, что часть его находится с одной стороны, а часть-с другой, то объект будет разрезан плоскостью, и будет видна только часть в пределах диапазона обзора. Диапазон по умолчанию-near=1, far=1000.

---

<a name="method-setcameraposition"></a>

### SetCameraPosition()
```php
SetCameraPosition(int $cameraID, float $x, float $y, float $z): void
```
Устанавливает положение указанной камеры. По умолчанию камеры расположены на уровне 0,0,0, основная камера-ID 1.

---

<a name="method-setcameraoffcenter"></a>

### SetCameraOffCenter()
```php
SetCameraOffCenter(int $cameraID, int $mode): void
```
Устанавливает камеру на использование смещенной от центра проекционной матрицы. Вы должны установить значения матрицы проекции с помощью SetCameraBounds и SetCameraRange.

---

<a name="method-setcameraorthowidth"></a>

### SetCameraOrthoWidth()
```php
SetCameraOrthoWidth(int $cameraID, float $width): void
```
Если FOV камеры установлен в 0, то это будет определять ширину ортогонального вида, значение по умолчанию равно 40. Значение высоты будет вычислено из него на основе соотношения сторон камеры. При использовании ортогональной проекции все остается одного и того же размера независимо от того, насколько близко или далеко оно находится к камере, поэтому при использовании значения ширины по умолчанию куб размером 80 единиц всегда будет заполнять вид камеры, когда камера смотрит на него, так как 40 измеряется от центра экрана до края. Эта команда перезапишет все значения, заданные с помощью SetCameraBounds.

---

<a name="method-setcameralookat"></a>

### SetCameraLookAt()
```php
SetCameraLookAt(int $cameraID, float $x, float $y, float $z, float $roll): void
```
Поворачивает камеру, чтобы посмотреть на определенную точку в пространстве с дополнительным значением крена. "смотреть" определяется как выравнивание локальной оси Z камеры, чтобы указать ее положительную сторону в данной точке. Это может быть достигнуто с помощью только углов Y и X в эйлеровой нотации, поэтому вы можете указать дополнительный угол Z в градусах, чтобы повернуть камеру влево или вправо, всегда глядя на одно и то же место.

---

<a name="method-setcamerafov"></a>

### SetCameraFOV()
```php
SetCameraFOV(int $cameraID, float $fov): void
```
Устанавливает горизонтальное поле зрения камеры (FOV). Это определяет угол между левой и правой сторонами обзора камеры, по умолчанию равный 70, и обеспечивает реалистичную 3D-проекцию. Использование меньших значений будет выглядеть так, как будто камера увеличивает масштаб сцены, фактически не двигаясь. Это иногда используется для драматического эффекта в фильмах, где FOV масштабируется в одну сторону, в то время как камера движется в другую. Использование значения FOV 0-это особый случай, который будет генерировать ортогональную матрицу вместо проекционной матрицы, это заставит все оставаться одного и того же размера независимо от того, насколько близко или далеко оно находится к камере. Ортогональная матрица будет иметь ширину 40 мировых единиц с высотой, определяемой соотношением сторон камеры.

---

<a name="method-setcamerabounds"></a>

### SetCameraBounds()
```php
SetCameraBounds(int $cameraID, float $left, float $right, float $top, float $bottom): void
```
Задает параметры для матрицы проекции вне центра. Ближние и дальние значения задаются отдельно с помощью SetCameraRange. Чтобы использовать матрицу проекции вне центра, вы должны активировать ее с помощью SetCameraOffCenter.

---

<a name="method-setcameraaspect"></a>

### SetCameraAspect()
```php
SetCameraAspect(int $cameraID, float $aspect): void
```
Устанавливает соотношение сторон камеры при рендеринге 3D. По умолчанию используется GetDeviceWidth()/GetDeviceHeight() и обеспечивает реалистичную 3D-проекцию. Если размер backbuffer устройства изменяется, например, если устройство меняет ориентацию, или размер окна изменяется, или вызывается SetScreenResolution, то это значение будет сброшено до значения по умолчанию.

---

<a name="method-setbuttonscreenposition"></a>

### SetButtonScreenPosition()
```php
SetButtonScreenPosition(int $index, float $x, float $y, float $size): void
```
Эта функция позиционирует виртуальную кнопку в заданном положении только в том случае, если это необходимо для данного устройства, например, если присутствует реальный джойстик или клавиатура, то эта команда не будет иметь заметного эффекта. Рекомендуется вызвать эту команду в любом случае, просто на случай, если потребуется виртуальная кнопка. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут использоваться для команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5 соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая появится на экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа гарантированно имеет способ активации кнопок AGK. Если виртуальная кнопка создана,она будет центрирована на заданной позиции X, Y.

---

<a name="method-setbordercolor"></a>

### SetBorderColor()
```php
SetBorderColor(int $red, int $green, int $blue): void
```
Устанавливает цвет или любые границы, используемые, когда дисплей не точно соответствует соотношению сторон. Если этот цвет отличается от цвета clear, то выполняется дополнительная операция clear, которая может повлиять на производительность, если скорость заполнения является проблемой.

---

<a name="method-setantialiasmode"></a>

### SetAntialiasMode()
```php
SetAntialiasMode(int $mode): void
```
Задает, должно ли устройство использовать сглаживание при рендеринге в задний буфер. В настоящее время это относится только к Windows, Mac и Linux, и доступна только 4-кратная множественная выборка. Это не относится ни к каким объектам, нарисованным на изображении с помощью SetRenderToImage, только задний буфер сглажен.

---

<a name="method-setambientcolor"></a>

### SetAmbientColor()
```php
SetAmbientColor(int $red, int $green, int $blue): void
```
Задает новый цвет для глобального окружающего света. Значения должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать свет. Цвет окружающей среды по умолчанию-76,76,76.

---

<a name="method-setamazonadtesting"></a>

### SetAmazonAdTesting()
```php
SetAmazonAdTesting(int $mode): void
```
Определяет, будут ли объявления Amazon тестовыми или платными. Это должно быть вызвано перед SetAmazonAdDetails, чтобы убедиться, что все объявления являются тестовыми. По умолчанию будет показываться платная реклама.

---

<a name="method-setamazonaddetails"></a>

### SetAmazonAdDetails()
```php
SetAmazonAdDetails(string $szKey): void
```
Устанавливает данные учетной записи Amazon Ads для использования в интерстициальной (полноэкранной) рекламе. После вызова этой команды будет предпринята попытка кэшировать интерстициал, чтобы вы могли сразу же отобразить его позже. Вы можете проверить ход этого процесса с помощью GetFullscreenAdvertLoadedAmazon. В настоящее время Amazon ads поддерживается iOS и Android.

---

<a name="method-setadvertvisible"></a>

### SetAdvertVisible()
```php
SetAdvertVisible(int $iVisible): void
```
Установите видимость любого объявления.

---

<a name="method-setadvertposition"></a>

### SetAdvertPosition()
```php
SetAdvertPosition(float $x, float $y, float $width): void
```
Размещает рекламу, созданную с помощью CreateAdvert, где-то на экране и пытается масштабировать ее до определенной ширины. Поскольку реклама будет иметь свое собственное соотношение сторон, высота будет рассчитываться исходя из ширины. Это не гарантирует работу со всеми поставщиками рекламы, в настоящее время только Inneractive может масштабировать и перемещать рекламу в абсолютное положение.

---

<a name="method-setadvertlocation"></a>

### SetAdvertLocation()
```php
SetAdvertLocation(int $horz, int $vert, float $width): void
```
Размещает рекламу, созданную с помощью CreateAdvert, где-то на экране и пытается масштабировать ее до определенной ширины. Поскольку реклама будет иметь свое собственное соотношение сторон, высота будет рассчитываться исходя из ширины. Это обеспечивает грубое позиционирование, позволяя вам выбирать между левым, центрированным или правым выравниванием для горизонтального и вертикального положений. Это не гарантирует работу со всеми поставщиками рекламы, в настоящее время только Inneractive может масштабировать рекламу до определенной ширины.

---

<a name="method-setadmobrewardaddetails"></a>

### SetAdMobRewardAdDetails()
```php
SetAdMobRewardAdDetails(string $szID): void
```
Устанавливает данные вашей учетной записи AdMob для использования в видеообъявлениях с вознаграждением. После вызова этой команды будет предпринята попытка кэшировать видео награды, чтобы вы могли сразу же отобразить его позже. Вы можете проверить ход выполнения этой задачи с помощью GetRewardAdLoadedAdMob. Видео AdMob reward в настоящее время поддерживаются iOS и Android.

---

<a name="method-setadvertlocationex"></a>

### SetAdvertLocationEx()
```php
SetAdvertLocationEx(int $horz, int $vert, float $offsetx, float $offsety, float $width): void
```
Размещает рекламу, созданную с помощью CreateAdvert, где-то на экране и пытается масштабировать ее до определенной ширины. Поскольку реклама будет иметь свое собственное соотношение сторон, высота будет рассчитываться исходя из ширины. Это обеспечивает грубое позиционирование, позволяя вам выбирать между левым, центрированным или правым выравниванием для горизонтального и вертикального положений. Это не гарантирует работу со всеми поставщиками рекламы, в настоящее время только Inneractive может масштабировать рекламу до определенной ширины.

---

<a name="method-setadmobtesting"></a>

### SetAdMobTesting()
```php
SetAdMobTesting(int $mode): void
```
Определяет, будут ли объявления AdMob тестовыми или платными. Это должно быть вызвано перед SetAdMobDetails, чтобы убедиться, что все объявления являются тестовыми. По умолчанию будет показываться платная реклама. Обратите внимание, что если вы показываете платные объявления во время тестирования, вы не должны нажимать на них, иначе ваша учетная запись AdMob может быть приостановлена.

---

<a name="method-setadmobdetails"></a>

### SetAdMobDetails()
```php
SetAdMobDetails(string $szID): void
```
Устанавливает данные учетной записи AdMob для использования в баннерной рекламе и интерстициальной (полноэкранной) рекламе. Обратите внимание, что это поддерживает только одно или другое, вы можете установить либо ИДЕНТИФИКАТОР рекламного блока баннера, либо идентификатор интерстициального рекламного блока, но не оба одновременно. После вызова этой команды будет предпринята попытка кэшировать интерстициал, чтобы вы могли сразу же отобразить его позже. Вы можете проверить ход выполнения этой задачи с помощью GetFullscreenAdvertLoadedAdMob. Реклама AdMob в настоящее время поддерживается iOS и Android.

---

<a name="method-setadmobchildrating"></a>

### SetAdMobChildRating()
```php
SetAdMobChildRating(int $rating): void
```
Устанавливает рейтинг контента для рекламы AdMob, если ваше приложение ориентировано на детей. Это должно быть вызвано перед SetAdMobDetails

---

<a name="method-set3dphysicstwistjointmotorrotationtarget"></a>

### Set3DPhysicsTwistJointMotorRotationTarget()
```php
Set3DPhysicsTwistJointMotorRotationTarget(int $jointID, int $rotationVec3ID): void
```
Установите целевую скорость для твист-соединения. Должен быть вызван в цикле. Сначала включите соединение с Set3DPhysicsTwistJointMotorIsEnabled()

---

<a name="method-set3dphysicsragdollstatic"></a>

### Set3DphysicsRagdollStatic()
```php
Set3DphysicsRagdollStatic(int $objID, int $isStatic): void
```
Устанавливает статику тряпичной куклы, изменяя массу всех костей тряпичной куклы на ноль.

---

<a name="method-set3dphysicstwistjointmotorisenabled"></a>

### Set3DPhysicsTwistJointMotorIsEnabled()
```php
Set3DPhysicsTwistJointMotorIsEnabled(int $jointID, int $isEnabled): void
```
Включает двигатель с твист-соединением.

---

<a name="method-set3dphysicstwistjointmaxmotorimpulse"></a>

### Set3DPhysicsTwistJointMaxMotorImpulse()
```php
Set3DPhysicsTwistJointMaxMotorImpulse(int $jointID, float $maxImpulse): void
```
Устанавливает максимальное значение импульса двигателя для Твист-соединения. Сначала включите соединение с Set3DPhysicsTwistJointMotorIsEnabled()

---

<a name="method-set3dphysicsstaticplanerotation"></a>

### Set3DPhysicsStaticPlaneRotation()
```php
Set3DPhysicsStaticPlaneRotation(int $planeID, float $angX, float $angY, float $angZ): void
```
Задает вращение статической плоскости

---

<a name="method-set3dphysicssliderjointtargetlinearmotorvelocity"></a>

### Set3DPhysicsSliderJointTargetLinearMotorVelocity()
```php
Set3DPhysicsSliderJointTargetLinearMotorVelocity(int $jointID, float $linearMotorVelocity): void
```
Устанавливает целевую линейную скорость двигателя для физического ползункового соединения.

---

<a name="method-set3dphysicssliderjointpoweredlinearmotorisenabled"></a>

### Set3DPhysicsSliderJointPoweredLinearMotorIsEnabled()
```php
Set3DPhysicsSliderJointPoweredLinearMotorIsEnabled(int $jointID, int $isEnabled): void
```
Установите линейный двигатель с приводом от ползунковых соединений в положение включено.

---

<a name="method-set3dphysicssliderjointmaxlinearmotorforce"></a>

### Set3DPhysicsSliderJointMaxLinearMotorForce()
```php
Set3DPhysicsSliderJointMaxLinearMotorForce(int $jointID, float $maxLinearForce): void
```
Устанавливает двигатель шарниров на максимальное линейное усилие.

---

<a name="method-set3dphysicsragdollsleepingthresholds"></a>

### Set3DPhysicsRagdollSleepingThresholds()
```php
Set3DPhysicsRagdollSleepingThresholds(float $linear, float $angular): void
```
Устанавливает пороги сна для создаваемой тряпичной куклы. Значения по умолчанию должны быть хороши для большинства ситуаций. Звоните только в том случае, если вы хотите изменить эти значения. Должен быть вызван до Finalize3DPhysicsRagDoll()

---

<a name="method-set3dphysicsragdolldeactivationtime"></a>

### Set3DPhysicsRagdollDeactivationTime()
```php
Set3DPhysicsRagdollDeactivationTime(float $time): void
```
Устанавливает время деактивации создаваемой тряпичной куклы. Значения по умолчанию должны быть хороши для большинства ситуаций. Звоните только в том случае, если вы хотите изменить эти значения. Должен быть вызван перед Finalize3DPhysicsRagDoll()

---

<a name="method-set3dphysicsstaticplaneposition"></a>

### Set3DPhysicsStaticPlanePosition()
```php
Set3DPhysicsStaticPlanePosition(int $planeID, float $posX, float $posY, float $posZ): void
```
Задает положение статической плоскости

---

<a name="method-set3dphysicsragdolldeactivation"></a>

### Set3DPhysicsRagdollDeactivation()
```php
Set3DPhysicsRagdollDeactivation(int $objID, int $isDisabled): void
```
Поддерживает физическую тряпичную куклу в активном состоянии. Не допускает автоматической деактивации, когда рэгдолл приходит в состояние покоя.

---

<a name="method-set3dphysicsragdolldamping"></a>

### Set3DPhysicsRagdollDamping()
```php
Set3DPhysicsRagdollDamping(float $linear, float $angular): void
```
Устанавливает демпфирование для создаваемой тряпичной куклы. Значения по умолчанию должны быть хороши для большинства ситуаций. Звоните только в том случае, если вы хотите изменить эти значения. Должен быть вызван перед Finalize3DPhysicsRagDoll()

---

<a name="method-set3dphysicsragdollbonesvisible"></a>

### Set3DPhysicsRagdollBonesVisible()
```php
Set3DPhysicsRagdollBonesVisible(int $objID, int $isVisible): void
```
Показывает объекты кости тряпичной куклы и скрывает объект.

---

<a name="method-set3dphysicsjointsliderlinearlimits"></a>

### Set3DPhysicsJointSliderLinearLimits()
```php
Set3DPhysicsJointSliderLinearLimits(int $jointID, float $lowerLimit, float $upperLimit): void
```
Устанавливает линейные пределы для ползункового соединения. Чтобы разблокировать соединение, установите нижний предел больше верхнего.

---

<a name="method-set3dphysicsjointsliderangularlimits"></a>

### Set3DPhysicsJointSliderAngularLimits()
```php
Set3DPhysicsJointSliderAngularLimits(int $jointID, float $lowerLimit, float $upperLimit): void
```
Устанавливает угловые пределы для ползункового соединения. Чтобы разблокировать соединение, установите нижний предел больше верхнего.

---

<a name="method-set3dphysicsjointhingelimits"></a>

### Set3DPhysicsJointHingeLimits()
```php
Set3DPhysicsJointHingeLimits(int $jointID, float $minAng, float $maxAng): void
```
Устанавливает угловые пределы для шарнирного соединения в градусах. Чтобы разблокировать соединение, установите нижний предел больше верхнего.

---

<a name="method-set3dphysicsjointenabled"></a>

### Set3DPhysicsJointEnabled()
```php
Set3DPhysicsJointEnabled(int $jointID, int $isEnabled): void
```
Устанавливает порог разрушения соединения.

---

<a name="method-set3dphysicsjointconetwistlimits"></a>

### Set3DPhysicsJointConeTwistLimits()
```php
Set3DPhysicsJointConeTwistLimits(int $jointID, float $swingSpan1, float $swingSpan2, float $twistSpan): void
```
Устанавливает угловые пределы для соединения закрутки конуса в градусах. Чтобы разблокировать определенное значение установите его на 360

---

<a name="method-set3dphysicshingejointmotorvelocity"></a>

### Set3DPhysicsHingeJointMotorVelocity()
```php
Set3DPhysicsHingeJointMotorVelocity(int $jointID, float $targetVelocity): void
```
Установите целевую скорость для шарнирного соединения. Должен быть вызван в цикле. Сначала включите соединение с Set3DPhysicsHingeJointMotorIsEnabled()

---

<a name="method-set3dphysicshingejointmotorisenabled"></a>

### Set3DPhysicsHingeJointMotorIsEnabled()
```php
Set3DPhysicsHingeJointMotorIsEnabled(int $jointID, int $isEnabled): void
```
Включает мотор шарнирного соединения.

---

<a name="method-set3dphysicsjointbreakingthreshold"></a>

### Set3DPhysicsJointBreakingThreshold()
```php
Set3DPhysicsJointBreakingThreshold(int $jointID, float $breakThreshold): void
```
Устанавливает порог разрушения соединения.

---

<a name="method-set3dphysicshingejointmaxmotorimpulse"></a>

### Set3DPhysicsHingeJointMaxMotorImpulse()
```php
Set3DPhysicsHingeJointMaxMotorImpulse(int $jointID, float $maxImpulse): void
```
Устанавливает максимальное значение импульса двигателя для шарнирного соединения. Сначала включите соединение с Set3DPhysicsHingeJointMotorIsEnabled()

---

<a name="method-set3dphysicscharactercontrollerstepheight"></a>

### Set3DPhysicsCharacterControllerStepHeight()
```php
Set3DPhysicsCharacterControllerStepHeight(int $objID, float $stepHeight): void
```
Устанавливает высоту, на которую контроллер может подниматься и опускаться.

---

<a name="method-set3dphysicsgravity"></a>

### Set3DPhysicsGravity()
```php
Set3DPhysicsGravity(int $vectorID): void
```
Устанавливает гравитацию мира физики, гравитация измеряется в метрах в секунду. По умолчанию гравитация установлена на ( 0.0, -10.0, 0.0 ). Вам нужно только вызвать эту команду, если вам нужно изменить настройки по умолчанию.

---

<a name="method-set3dphysicscharactercontrollerposition"></a>

### Set3DPhysicsCharacterControllerPosition()
```php
Set3DPhysicsCharacterControllerPosition(int $objID, float $posX, float $posY, float $posZ): void
```
Перемещает Контроллер в новые переданные координаты. Не размещайте контроллер внутри другого физического объекта.

---

<a name="method-set3dphysicscharactercontrollermaxslope"></a>

### Set3DPhysicsCharacterControllerMaxSlope()
```php
Set3DPhysicsCharacterControllerMaxSlope(int $objID, float $maxSlopeDegress): void
```
установите максимальный наклон в угловых градусах, на которые может подняться контроллер.

---

<a name="method-set3dphysicscharactercontrollerjumpspeed"></a>

### Set3DPhysicsCharacterControllerJumpSpeed()
```php
Set3DPhysicsCharacterControllerJumpSpeed(int $objID, float $jumpSpeed): void
```
Установите скорость, с которой контроллер перемещается вверх при вызове прыжка.

---

<a name="method-set3dphysicscharactercontrollergravity"></a>

### Set3DPhysicsCharacterControllerGravity()
```php
Set3DPhysicsCharacterControllerGravity(int $objID, float $gravity): void
```
Устанавливает гравитацию для контроллера символов. Эта гравитация не то же самое, что физическая мировая гравитация. и влияет только на индивидуальный характер контроллера.

---

<a name="method-set3dphysicscharactercontrollerfallspeed"></a>

### Set3DPhysicsCharacterControllerFallSpeed()
```php
Set3DPhysicsCharacterControllerFallSpeed(int $objID, float $fallSpeed): void
```
Устанавливает скорость, с которой контроллер будет падать.

---

<a name="method-set3dparticlesvisible"></a>

### Set3DParticlesVisible()
```php
Set3DParticlesVisible(int $ID, int $visible): void
```
Устанавливает, рисуются ли испускаемые частицы. Установите значение 1, чтобы показать частицы, и 0, чтобы скрыть их. Частицы все равно будут обновляться, пока они скрыты, вы можете остановить обновление частиц с помощью Set3DParticlesActive

---

<a name="method-set3dparticlesvelocityrange"></a>

### Set3DParticlesVelocityRange()
```php
Set3DParticlesVelocityRange(int $ID, float $v1, float $v2): void
```
Устанавливает минимальный и максимальный множитель, который будет влиять на испускаемые частицы. Это может быть использовано для обеспечения некоторого изменения скорости при испускании частиц.

---

<a name="method-set3dparticlestransparency"></a>

### Set3DParticlesTransparency()
```php
Set3DParticlesTransparency(int $ID, int $mode): void
```
Установите прозрачность частиц на определенную настройку с выбором без прозрачности, альфа-прозрачности и аддитивного смешивания. По умолчанию частицы создаются с альфа-прозрачностью.

---

<a name="method-set3dparticlesstartzone"></a>

### Set3DParticlesStartZone()
```php
Set3DParticlesStartZone(int $ID, float $x1, float $y1, float $z1, float $x2, float $y2, float $z2): void
```
Задает область вокруг излучателя, в которой могут появиться новые частицы. Эти значения относятся к положению эмиттера, например, зона 0,0,0,0 будет означать, что все частицы начинаются в точке положения эмиттера. Зона -10 в x и +10 x, где y и z равны 0 (-10,0,0,10,0,0), создаст линию, центрированную на положении излучателя, вдоль которой будут случайным образом появляться частицы. Зона коробки, где x, y и z не равны нулю, означала бы, что частицы могут начинаться в любой точке внутри коробки.

---

<a name="method-set3dparticlessize"></a>

### Set3DParticlesSize()
```php
Set3DParticlesSize(int $ID, float $size): void
```
Задает размер всех частиц в мировых координатах. Установка большого количества частиц на большой размер будет плохо работать на мобильных устройствах с низкой скоростью заполнения (количество пикселей, которые он может нарисовать в секунду).

---

<a name="method-set3dparticlesposition"></a>

### Set3DParticlesPosition()
```php
Set3DParticlesPosition(int $ID, float $x, float $y, float $z): void
```
Устанавливает положение 3D-излучателя частиц. Это положение, из которого будут появляться новые частицы, и не влияет на частицы, которые уже видны.

---

<a name="method-set3dparticlesmax"></a>

### Set3DParticlesMax()
```php
Set3DParticlesMax(int $ID, int $max): void
```
Устанавливает максимальное количество частиц, которые будут испускаться. Если это значение равно -1, то число бесконечно. Излучатель будет вести подсчет общего количества частиц, которые он испускает, и остановится, когда будет достигнут предел. Чтобы проверить, достиг ли излучатель своего предела, используйте Get3DParticlesMaxReached. Чтобы сбросить счетчик и заставить его снова начать излучать, используйте Reset3DParticleCount.

---

<a name="method-set3dparticleslife"></a>

### Set3DParticlesLife()
```php
Set3DParticlesLife(int $ID, float $time): void
```
Устанавливает время жизни частиц в секундах после их испускания. После того, как частицы будут живы в течение заданного количества секунд, они исчезнут. Это одно из двух значений, влияющих на количество генерируемых частиц, другое-Set3DParticlesFrequency. Максимальное количество частиц, которое может быть на экране в любой момент времени, - это freq*life, причем freq-это количество частиц, испускаемых в секунду. Это значение не зависит от частоты кадров.

---

<a name="method-set3dparticlesimage"></a>

### Set3DParticlesImage()
```php
Set3DParticlesImage(int $ID, int $imageID): void
```
Устанавливает изображение, которое будет использоваться для каждой частицы.

---

<a name="method-set3dparticlesfrequency"></a>

### Set3DParticlesFrequency()
```php
Set3DParticlesFrequency(int $ID, float $freq): void
```
Задает частоту генерации новых частиц. Значение freq указывает, сколько частиц должно быть произведено в секунду, это не зависит от частоты кадров. Это одно из двух значений, влияющих на количество генерируемых частиц, другое-SetParticlesLife. Максимальное количество частиц, которое может быть на экране в любой момент времени, - это freq*life, причем жизнь-это количество секунд, в течение которых частица живет, прежде чем исчезнуть.

---

<a name="method-set3dparticlesdirectionrange"></a>

### Set3DParticlesDirectionRange()
```php
Set3DParticlesDirectionRange(int $ID, float $angle1, float $angle2): void
```
Задает диапазон направления в градусах, который частица может выбрать при первом запуске. Это берет базовое направление, заданное с помощью Set3DParticlesDirection, и регулирует его на случайную величину между 0 и углом 1/2 градуса в одном направлении и углом 2/2 градуса в перпендикулярном направлении. Например, угол 1, равный 0, и угол 2, равный 0, означают, что все новые частицы следуют точно в указанном ранее направлении. Угол 1, равный 360, и угол 2, равный 0, означали бы, что частицы могут двигаться в любом направлении по плоскому кругу, в то время как угол 1, равный 360, и угол 2, равный 180, означали бы, что частицы будут двигаться в любом направлении по сфере. Углы образуют пирамиду, выровненную с направлением излучателя частиц, указанным ранее. Угол 1 должен быть между 0 и 360, угол 2 должен быть между 0 и 180.

---

<a name="method-set3dparticlesdirection"></a>

### Set3DParticlesDirection()
```php
Set3DParticlesDirection(int $ID, float $vx, float $vy, float $vz, float $roll): void
```
Задает начальное направление новых частиц, когда они выходят из излучателя. Это можно использовать вместе с командой Set3DParticlesDirectionRange, чтобы установить диапазон отклонения от этого начального направления, которое могут выбрать новые частицы. Это также устанавливает начальную скорость частиц, принимая длину вектора за единицы в секунду. Например, если начальное направление vx=10, vy=-15, vz=0, частицы начнут двигаться в направлении X со скоростью 10 единиц в секунду и в направлении Y со скоростью 15 единиц в секунду и будут продолжать эту скорость движения в течение всей своей жизни, если на них не будут влиять силы, добавленные с помощью Add3DParticlesForce.

---

<a name="method-set3dparticlescolorinterpolation"></a>

### Set3DParticlesColorInterpolation()
```php
Set3DParticlesColorInterpolation(int $ID, int $mode): void
```
Устанавливает режим интерполяции для изменения цвета. Цвета могут быть установлены в определенные моменты жизни частицы с помощью Add3DParticlesColorKeyFrame, и частица либо смешается между этими цветами (плавная интерполяция), либо быстро изменится, когда достигнет следующего изменения цвета (без интерполяции).

---

<a name="method-set3dparticlesactive"></a>

### Set3DParticlesActive()
```php
Set3DParticlesActive(int $ID, int $active): void
```
Устанавливает, обновляются ли испускаемые частицы каждый кадр. Установите значение 1, чтобы обновить частицы как обычно, и 0, чтобы приостановить их. Частицы будут продолжать быть видимыми, когда остановятся. Чтобы скрыть частицы, используйте Set3DParticlesVisible.

---

<a name="method-sendsocketstring"></a>

### SendSocketString()
```php
SendSocketString(int $socketID, string $value): int
```
Отправит строку на удаленное соединение. Обратите внимание, что данные отправляются не сразу, для их отправки необходимо вызвать FlushSocket. Если вы отправляете строку в приложение, не являющееся AGK, то строка строится из значения длины 4 байта, за которым следует X байт строковых данных, где X-значение длины. Строка не завершается нулем. Возвращает 1, если строка была успешно записана в буфер, 0, если сокет отключен.

---

<a name="method-sendudpnetworkmessage"></a>

### SendUDPNetworkMessage()
```php
SendUDPNetworkMessage(int $listenerID, int $messageID, string $toIP, int $toPort): void
```
Отправляет сетевое сообщение, созданное с помощью CreateNetworkMessage, на указанный удаленный IP-адрес и порт. Вы должны указать прослушиватель UDP для использования в качестве исходного IP-адреса и порта. Эта функция удалит указанный идентификатор сообщения.

---

<a name="method-sendsocketinteger"></a>

### SendSocketInteger()
```php
SendSocketInteger(int $socketID, int $value): int
```
Отправит 4-байтовое целое число на удаленное соединение. Обратите внимание, что данные отправляются не сразу, для их отправки необходимо вызвать FlushSocket. Возвращает 1, если целое число было успешно записано в буфер, 0, если сокет отключен.

---

<a name="method-sendsocketfloat"></a>

### SendSocketFloat()
```php
SendSocketFloat(int $socketID, float $value): int
```
Отправит 4-байтовый поплавок на удаленное соединение. Обратите внимание, что данные отправляются не сразу, для их отправки необходимо вызвать FlushSocket. Возвращает 1, если float был успешно записан в буфер, 0, если сокет отключен.

---

<a name="method-sendsmartwatchdata"></a>

### SendSmartWatchData()
```php
SendSmartWatchData(string $szJson): void
```
Отправка данных на смарт-часы в фоновом режиме, если приложение watch в данный момент не открыто, сообщение будет поставлено в очередь и получено приложением watch при следующем открытии. Сообщение должно быть в виде строки JSON, например "{"label":"my message"}". Вы также можете использовать тип с функцией .toJSON() для создания строки JSON. Приложение watch получит его как NSDictionary с метками в качестве ключей.  В настоящее время работает только на iOS.

---

<a name="method-sendsocketbyte"></a>

### SendSocketByte()
```php
SendSocketByte(int $socketID, int $value): int
```
Отправит один байт в диапазоне от -128 до 127 на удаленное соединение. Обратите внимание, что данные отправляются не сразу, для их отправки необходимо вызвать FlushSocket. Возвращает 1, если байт был успешно записан в буфер, 0, если сокет отключен.

---

<a name="method-sendnetworkmessage"></a>

### SendNetworkMessage()
```php
SendNetworkMessage(int $iNetID, int $toClient, int $iMsgID): void
```
Отправляет созданное сетевое сообщение данному клиенту в данной сети. Используйте идентификатор клиента 0 для отправки всем подключенным клиентам (кроме отправителя), в противном случае, если идентификатор клиента не существует, будет сгенерирована ошибка. Эта функция удалит указанный идентификатор сообщения.

---

<a name="method-sendhttprequestasync"></a>

### SendHTTPRequestASync()
```php
SendHTTPRequestASync(int $iHTTP, string $szServerFile, string $szPostData): int
```
Отправьте запрос на сервер, указанный в SetHTTPHost, например, если запрашивается http: www.thegamecreators.com/index.php szServerFile должен быть "index.php". Эта команда немедленно возвращается и ждет ответа сервера в фоновом режиме. Вы можете проверить статус ответа с помощью GetHTTPResponseReady и, когда он будет готов, получить ответ с помощью GetHTTPResponse.

---

<a name="method-sendhttprequest"></a>

### SendHTTPRequest()
```php
SendHTTPRequest(int $iHTTP, string $szServerFile, string $szPostData): string
```
Отправьте запрос на сервер, указанный в SetHTTPHost (), например, если запрашивается http: www.thegamecreators.com/index.php szServerFile должен быть "index.php". Эта команда ожидает ответа сервера и возвращает ответ сервера. Если вы используете уровень 2, вы должны удалить этот ответ, когда закончите с ним. Не работает при экспорте в HTML5

---

<a name="method-sendhttpfile"></a>

### SendHTTPFile()
```php
SendHTTPFile(int $iHTTP, string $szServerFile, string $szPostData, string $szLocalFile): int
```
Отправьте файл на сервер, указанный в SetHTTPHost, например, если запрашивается http: www.thegamecreators.com/index.php szServerFile должен быть "index.php". Также позволяет отправлять POST-данные на сервер, которые могут включать переменные или файловые данные, например "myvar=5&var2=test". Эта команда немедленно возвращается и ждет ответа сервера в фоновом режиме. Вы можете проверить статус ответа с помощью GetHTTPResponseReady и, когда он будет готов, получить ответ с помощью GetHTTPResponse. Вы можете проверить ход загрузки с помощью GetHTTPFileProgress. Не работает при экспорте в HTML5

---

<a name="method-seekmusicogg"></a>

### SeekMusicOGG()
```php
SeekMusicOGG(int $musicID, float $seconds, int $mode): void
```
Стремится к заданному значению времени, если файл воспроизводится в данный момент, то он немедленно продолжит воспроизведение оттуда. Если файл в данный момент не воспроизводится, то он вступит в силу после следующего вызова PlayMusicOGG. Параметр mode позволяет выбрать, следует ли искать на основе абсолютного или относительного значения времени. Абсолют будет стремиться к этой позиции в файле, в то время как относительный будет искать относительно текущей позиции.

---

<a name="method-seekmusic"></a>

### SeekMusic()
```php
SeekMusic(float $seconds, int $mode): void
```
Ищет воспроизводимую в данный момент музыку в заданном количестве секунд, либо относительно текущей позиции, либо в абсолютном положении. Например, если музыкальная дорожка имеет длину 60 секунд и в настоящее время находится в положении 10 секунд (она воспроизводила 10 секунд музыки), поиск абсолютного значения 3 секунды вернет ее обратно к 3 секундам после начала музыкальной дорожки. Используя относительное значение 3, вы добавите 3 секунды к текущей позиции, взяв ее до 13.

---

<a name="method-screentoworldy"></a>

### ScreenToWorldY()
```php
ScreenToWorldY(float $y): float
```
Преобразует координату Y экрана в мировую координату Y на основе текущего смещения и масштабирования вида. Когда SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен на 20 пикселей вниз, ввод при 0,0 на экране будет выглядеть 0,20 в мире.

---

<a name="method-screentoworldx"></a>

### ScreenToWorldX()
```php
ScreenToWorldX(float $x): float
```
Преобразует координату X экрана в мировую координату X на основе текущего смещения и масштабирования вида. Когда SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен на 20 пикселей вправо, ввод при 0,0 на экране появится 20,0 в мире.

---

<a name="method-screenfps"></a>

### ScreenFPS()
```php
ScreenFPS(): float
```
Возвращает среднее значение кадров в секунду на основе времени рендеринга последних нескольких кадров. Чтобы получить точное время, затраченное на последний кадр, вы можете вызвать GetFrameTime.

---

<a name="method-savesound"></a>

### SaveSound()
```php
SaveSound(int $iID, string $sFilename): void
```
Сохраняет звуковой файл в папку записи приложения.

---

<a name="method-saveobjectshape"></a>

### SaveObjectShape()
```php
SaveObjectShape(int $objID, string $fileName): int
```
Сохраняет форму столкновения объектов в файл .bcs (Bullet Collision Shape). Возвращает true, если это удалось.

---

<a name="method-savesharedvariable"></a>

### SaveSharedVariable()
```php
SaveSharedVariable(string $varName, string $varValue): void
```
Сохраняет переменную, чтобы к ней можно было получить доступ из других приложений. Это работает только на платформах iOS, Android 10 и ниже, а также HTML5. Приложения могут совместно использовать переменную только в том случае, если они отвечают определенным требованиям, основанным на платформе. В iOS приложения должны быть созданы одной и той же учетной записью разработчика Apple и иметь одну и ту же группу приложений, добавленную к их идентификаторам приложений на портале разработчиков Apple. После этого вам нужно будет заново создать профиль подготовки. В iOS вы должны сообщить AGK, что такое группа приложений, используя SetSharedVariableAppGroup. На Android 10 и ниже приложения должны иметь разрешение WRITE_EXTERNAL_STORAGE и иметь одно и то же имя пакета до последней точки. Например, com.mycompany.mygroup.myapp1 и com.mycompany.mygroup.myapp2 смогут совместно использовать переменные. На Android общие переменные записываются в доступное пользователю место, поэтому имейте в виду, что пользователи могут читать и/или редактировать сохраненные вами переменные. На Android 11 или выше эта команда не будет работать, так как приложения ограничены в записи в общие места. В HTML приложения должны размещаться в одном домене, значения хранятся в виде файлов cookie. Переменные идентифицируются по имени, поэтому использование SaveSharedVariable("username", "Alice") установит переменную с именем "username" в значение "Alice". Затем это может быть прочитано другими приложениями с помощью LoadSharedVariable( "username",""), Если два приложения сохраняют разные значения в одном и том же имени переменной, то значение будет перезаписано и будет доступно только самое последнее значение. Значения переменных будут сохраняться даже в том случае, если приложение будет удалено и повторно установлено. Вы не должны использовать эту команду для хранения любой конфиденциальной информации, такой как пароли, в виде обычного текста. В iOS длина имени переменной плюс длина идентификатора вашего приложения до последней точки (например, com.mycompany.mygroup) должна быть меньше 58.

---

<a name="method-saveobject"></a>

### SaveObject()
```php
SaveObject(int $objID, string $szFilename): void
```
Еще не функционирует.

---

<a name="method-saveimage"></a>

### SaveImage()
```php
SaveImage(int $iImageIndex, string $filename): void
```
Сохраняет изображение с заданным идентификатором в указанное имя файла. Файл будет помещен в папку записи приложения в том месте, которое в данный момент указано SetFolder. Кроме того, вы можете указать путь, начинающийся с прямой косой черты, чтобы выбрать местоположение из корня папки записи, игнорируя любую папку SetFolder. Рекомендуется использовать расширение ".png" в конце имени файла для сохранения в формате PNG. Некоторые платформы могут поддерживать дополнительные расширения, такие как ".jpg", но это не гарантирует работу на всех платформах.

---

<a name="method-round"></a>

### Round()
```php
Round(float $a): int
```
Округляет поплавок до ближайшего целого числа (положительного или отрицательного).

---

<a name="method-rotateobjectlocalz"></a>

### RotateObjectLocalZ()
```php
RotateObjectLocalZ(int $objID, float $amount): void
```
Вращает указанный объект вокруг своей локальной оси Z, то есть если бы объект был самолетом, эта команда заставила бы его сделать бочкообразный крен независимо от того, в каком направлении он был обращен.

---

<a name="method-runapp"></a>

### RunApp()
```php
RunApp(string $szFilename, string $szParameters): int
```
Запускает внешний исполняемый файл, который не зависит от этого приложения. Он вернет идентификатор, который вы можете использовать, чтобы проверить, работает ли приложение по-прежнему или, в крайнем случае, завершить его работу. Если это не удастся, он вернет 0. В настоящее время работает только на Windows, Mac, Linux и Raspberry Pi.

---

<a name="method-rotateobjectlocaly"></a>

### RotateObjectLocalY()
```php
RotateObjectLocalY(int $objID, float $amount): void
```
Вращает указанный объект вокруг его локальной оси Y, то есть если бы объект был самолетом, эта команда заставила бы его поворачиваться влево и вправо независимо от того, в каком направлении он находится.

---

<a name="method-rotateobjectglobalz"></a>

### RotateObjectGlobalZ()
```php
RotateObjectGlobalZ(int $objID, float $amount): void
```
Вращает указанный объект вокруг глобальной оси Z. Представьте себе, что камера смотрит вниз по оси Z на объект со случайным вращением. Эта команда будет вращать объект влево и вправо относительно камеры независимо от того, в какую сторону он обращен.

---

<a name="method-rotateobjectlocalx"></a>

### RotateObjectLocalX()
```php
RotateObjectLocalX(int $objID, float $amount): void
```
Вращает указанный объект вокруг его локальной оси X, то есть, если бы объект был самолетом, эта команда заставила бы его наклоняться вверх и вниз независимо от того, в каком направлении он обращен.

---

<a name="method-rotateobjectglobaly"></a>

### RotateObjectGlobalY()
```php
RotateObjectGlobalY(int $objID, float $amount): void
```
Вращает указанный объект вокруг глобальной оси Y. Представьте себе, что камера смотрит вниз по оси Z на объект со случайным вращением. Эта команда повернет объект влево и вправо относительно камеры независимо от того, в какую сторону он обращен.

---

<a name="method-rotateobjectglobalx"></a>

### RotateObjectGlobalX()
```php
RotateObjectGlobalX(int $objID, float $amount): void
```
Вращает указанный объект вокруг глобальной оси X. Представьте себе, что камера смотрит вниз по оси Z на объект со случайным вращением. Эта команда будет наклонять объект вверх и вниз относительно камеры независимо от того, в какую сторону он обращен.

---

<a name="method-rotateobjectbonelocalz"></a>

### RotateObjectBoneLocalZ()
```php
RotateObjectBoneLocalZ(int $objID, int $boneIndex, float $amount): void
```
Катит указанную кость вокруг своей локальной оси Z, то есть если бы кость была самолетом, эта команда заставила бы ее сделать бочкообразный крен независимо от того, в каком направлении она обращена.

---

<a name="method-rotateobjectbonelocalx"></a>

### RotateObjectBoneLocalX()
```php
RotateObjectBoneLocalX(int $objID, int $boneIndex, float $amount): void
```
Вращает указанную кость вокруг ее локальной оси X, то есть, если бы кость была самолетом, эта команда заставила бы ее наклоняться вверх и вниз независимо от того, в каком направлении она обращена.

---

<a name="method-rotateobjectbonelocaly"></a>

### RotateObjectBoneLocalY()
```php
RotateObjectBoneLocalY(int $objID, int $boneIndex, float $amount): void
```
Вращает указанную кость вокруг ее локальной оси Y, то есть, если бы кость была самолетом, эта команда заставила бы ее поворачиваться влево и вправо независимо от того, в каком направлении она обращена.

---

<a name="method-rotatecameralocalz"></a>

### RotateCameraLocalZ()
```php
RotateCameraLocalZ(int $cameraID, float $amount): void
```
Вращает указанную камеру вокруг своей локальной оси Z, то есть если бы камера была самолетом, эта команда заставила бы ее катиться влево и вправо независимо от того, в каком направлении она была обращена.

---

<a name="method-rotatecameralocaly"></a>

### RotateCameraLocalY()
```php
RotateCameraLocalY(int $cameraID, float $amount): void
```
Вращает указанную камеру вокруг своей локальной оси Y, то есть если бы камера была самолетом, эта команда заставила бы ее поворачиваться влево и вправо независимо от того, в каком направлении она обращена.

---

<a name="method-rotatecameralocalx"></a>

### RotateCameraLocalX()
```php
RotateCameraLocalX(int $cameraID, float $amount): void
```
Вращает указанную камеру вокруг своей локальной оси X, то есть если бы камера была самолетом, эта команда заставила бы ее наклоняться вверх и вниз независимо от того, в каком направлении она обращена.

---

<a name="method-rotatecameraglobalz"></a>

### RotateCameraGlobalZ()
```php
RotateCameraGlobalZ(int $cameraID, float $amount): void
```
Вращает указанную камеру вокруг глобальной оси Z. Представьте себе, что вы смотрите на камеру, как если бы это был объект, расположенный на 0,0,0 и смотрящий в случайном направлении. Эта команда будет вращать его вокруг фиксированной оси Z, которая используется для определения положения всего в мире.

---

<a name="method-rotatecameraglobaly"></a>

### RotateCameraGlobalY()
```php
RotateCameraGlobalY(int $cameraID, float $amount): void
```
Вращает указанную камеру вокруг глобальной оси Y. Представьте себе, что вы смотрите на камеру, как если бы это был объект, расположенный на 0,0,0 и смотрящий в случайном направлении. Эта команда повернет его вокруг неподвижной оси Y, той, которая используется для определения положения всего в мире.

---

<a name="method-rotatecameraglobalx"></a>

### RotateCameraGlobalX()
```php
RotateCameraGlobalX(int $cameraID, float $amount): void
```
Вращает указанную камеру вокруг глобальной оси X. Представьте себе, что вы смотрите на камеру, как если бы это был объект, расположенный на 0,0,0 и смотрящий в случайном направлении. Эта команда будет вращать его вокруг фиксированной оси X, которая используется для определения положения всего в мире.

---

<a name="method-rotate3dphysicscharactercontroller"></a>

### Rotate3DPhysicsCharacterController()
```php
Rotate3DPhysicsCharacterController(int $objID, float $angle): void
```
Вращает контроллер.

---

<a name="method-right"></a>

### Right()
```php
Right(string $strin, int $count): string
```
Обрезает заданную строку, сохраняя наибольшее количество символов справа до заданного значения счетчика.

---

<a name="method-resumetweentext"></a>

### ResumeTweenText()
```php
ResumeTweenText(int $tweenID, int $textID): void
```
Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenText. Если анимация уже возобновлена или не существует, то это ничего не делает.

---

<a name="method-resumetweensprite"></a>

### ResumeTweenSprite()
```php
ResumeTweenSprite(int $tweenID, int $spriteID): void
```
Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenSprite. Если анимация уже возобновлена или не существует, то это ничего не делает.

---

<a name="method-resumetweencustom"></a>

### ResumeTweenCustom()
```php
ResumeTweenCustom(int $tweenID): void
```
Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenCustom. Если анимация уже возобновлена или не существует, то это ничего не делает.

---

<a name="method-resumetweenchar"></a>

### ResumeTweenChar()
```php
ResumeTweenChar(int $tweenID, int $textID, int $charID): void
```
Возобновляет заданный интервал с того момента, когда он был приостановлен с помощью PauseTweenChar. Если анимация уже возобновлена или не существует, то это ничего не делает.

---

<a name="method-resumetweenobject"></a>

### ResumeTweenObject()
```php
ResumeTweenObject(int $tweenID, int $objectID): void
```
Возобновляет заданную анимацию с того момента, когда она была приостановлена с помощью PauseTweenObject. Если анимация уже возобновлена или не существует, то это ничего не делает.

---

<a name="method-resumetweencamera"></a>

### ResumeTweenCamera()
```php
ResumeTweenCamera(int $tweenID, int $cameraID): void
```
Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenCamera. Если анимация уже возобновлена или не существует, то это ничего не делает.

---

<a name="method-resumemusicogg"></a>

### ResumeMusicOGG()
```php
ResumeMusicOGG(int $musicID): void
```
Возобновляет воспроизведение музыкального файла, если он был приостановлен.

---

<a name="method-resumesprite"></a>

### ResumeSprite()
```php
ResumeSprite(int $iSpriteIndex): void
```
Продолжает анимацию спрайта, используя значения, используемые для его настройки. Продолжается с текущего кадра, а не начинается снова с первого кадра.

---

<a name="method-resumemusic"></a>

### ResumeMusic()
```php
ResumeMusic(): void
```
Возобновляет прерванную музыку с того места, где она остановилась.

---

<a name="method-restoreapp"></a>

### RestoreApp()
```php
RestoreApp(): void
```
Восстанавливает приложение из свернутого состояния в нормальное окно.

---

<a name="method-resizeimage"></a>

### ResizeImage()
```php
ResizeImage(int $imageID, int $width, int $height): void
```
Изменяет размер изображения на новую ширину и высоту. Если изображение является изображением атласа, то его subimages.txt значения также будут изменены таким образом, чтобы LoadSubImage все еще работал. Обратите внимание, что если вы ранее использовали LoadSubImage на этом изображении, то изменение его размера приведет к неправильному отображению этих субизображений. Эта команда не будет работать с самими субизображениями.

---

<a name="method-resetspriteuv"></a>

### ResetSpriteUV()
```php
ResetSpriteUV(int $iSpriteIndex): void
```
Эта команда восстанавливает нормальную функциональность UV-координат после вызова SetSpriteUV.

---

<a name="method-resettimer"></a>

### ResetTimer()
```php
ResetTimer(): void
```
Сбрасывает время, возвращенное таймером, на 0. Это позволяет восстановить полную точность после того, как ваше приложение работает в течение некоторого времени. Это также сбрасывает значения, возвращаемые getSeconds и GetMilliseconds, на 0.

---

<a name="method-resetrewardadmob"></a>

### ResetRewardAdMob()
```php
ResetRewardAdMob(): void
```
Устанавливает значение вознаграждения AdMob равным 0. Вы можете использовать это после обнаружения события вознаграждения и действовать так, чтобы не вознаграждать пользователя более одного раза.

---

<a name="method-resetrewardchartboost"></a>

### ResetRewardChartboost()
```php
ResetRewardChartboost(): void
```
Устанавливает значение вознаграждения Chartboost равным 0. Вы можете использовать это после обнаружения события вознаграждения и действовать так, чтобы не вознаграждать пользователя более одного раза.

---

<a name="method-resetparticlecount"></a>

### ResetParticleCount()
```php
ResetParticleCount(int $ID): void
```
Сбрасывает количество испускаемых частиц, когда излучатель был установлен с максимальным количеством частиц с помощью SetParticlesMax. Вы можете проверить, когда излучатель достиг своего максимального количества, используя GetParticlesMaxReached. Если максимум установлен на -1, то эта команда не имеет никакого эффекта.

---

<a name="method-resetobjectanimation"></a>

### ResetObjectAnimation()
```php
ResetObjectAnimation(int $objID): void
```
Останавливает любую воспроизводимую анимацию и сбрасывает кости объекта в их положение привязки.

---

<a name="method-reset3dphysicsworld"></a>

### Reset3DPhysicsWorld()
```php
Reset3DPhysicsWorld(): void
```
Это удаляет физический мир и все формы, твердые тела, суставы, совместные двигатели, тряпичные куклы и контроллеры персонажей. Затем воссоздается пустой физический мир с масштабом и гравитацией по умолчанию. Затем вам нужно будет воссоздать все формы, твердые тела, суставы, совместные двигатели, тряпичные куклы и контроллеры персонажей, которые вам нужны.

---

<a name="method-reset3dparticlecount"></a>

### Reset3DParticleCount()
```php
Reset3DParticleCount(int $ID): void
```
Сбрасывает количество испускаемых частиц, когда излучатель был установлен с максимальным количеством частиц с помощью Set3DParticlesMax. Вы можете проверить, когда излучатель достиг своего максимального количества, используя Get3DParticlesMaxReached. Если максимум установлен на -1, то эта команда не имеет никакого эффекта.

---

<a name="method-requestpermission"></a>

### RequestPermission()
```php
RequestPermission(string $szPermission): void
```
Только для Android все остальные платформы ничего не сделают. Генерирует системный диалог с запросом у пользователя указанного разрешения устройства, используемого определенными командами Android. Разрешения следующие: "writeExternal" - используется командами SaveSharedVariable и любыми путями "raw:", которые обращаются к SD-карте. "Местоположение" - используется командами GPS "Камера" - используется командой SetDeviceCameraToImage и для канала AR - камеры "RecordAudio" - используется командой StartScreenRecording Вы можете проверить результат запроса, вызвав checkPermission. После первого запроса Android предоставит пользователю возможность прекратить отображение диалогового окна запроса. В этом случае эта команда больше не будет генерировать диалоговое окно запроса и вместо этого ничего не будет делать. Пользователю придется зайти в настройки приложения устройства, чтобы отменить это решение. Любое разрешение, не указанное здесь, не требует от вас запроса разрешения пользователя, оно будет автоматически предоставлено при установке, если ваше приложение этого требует. Все разрешения, которые использует ваше приложение, даже те, которые требуют запроса, должны быть указаны в диалоговом окне экспорта APK, установив соответствующие флажки.

---

<a name="method-requestconsentadmob"></a>

### RequestConsentAdMob()
```php
RequestConsentAdMob(): void
```
Отображает всплывающее диалоговое окно с запросом согласия пользователя на показ персонализированной рекламы. Ответ пользователя будет автоматически использован для изменения настроек AdMob таким образом, чтобы реклама отображалась в соответствии с предпочтениями пользователя. Статус согласия также будет сохранен на сервере AdMob, чтобы будущий вызов LoadConsentStatusAdMob мог получить это значение. Вы можете вызвать эту команду в любое время в вашем приложении, чтобы пользователь мог изменить свои предпочтения, пользователь должен иметь возможность сделать это где-то внутри вашего приложения.  Это согласие не распространяется на Chartboost или Amazon, оно запрашивает только согласие на показ персонализированной рекламы от AdMob. Вам понадобится свой собственный метод запроса согласия для Chartboost и Amazon.

---

<a name="method-requestappreview"></a>

### RequestAppReview()
```php
RequestAppReview(): void
```
iOS 10.3 имеет специальную функцию, которая позволит пользователю просматривать ваше приложение изнутри самого приложения, эта команда подскажет iOS начать этот процесс. Обратите внимание, что iOS не гарантирует отображение чего-либо при вызове этой команды, и она не должна вызываться в ответ на нажатие кнопки или другое взаимодействие пользователя. Вы должны вызвать его, когда в приложении наступает затишье, например в конце уровня. Если вы хотите запустить процесс проверки в ответ на действие пользователя, например нажатие кнопки, то вам следует использовать команду OpenBrowser для открытия AppStore.

---

<a name="method-requestadvertrefresh"></a>

### RequestAdvertRefresh()
```php
RequestAdvertRefresh(): void
```
Вызовите эту команду, чтобы запросить новое объявление. Обычно реклама предоставляется автоматически. Вы можете сделать это только при переключении на новые экраны в вашем приложении

---

<a name="method-rendershadowmap"></a>

### RenderShadowMap()
```php
RenderShadowMap(): void
```
Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает Render2DBack, RenderShadowMap, Render3D, Render2DFront, чтобы нарисовать все в мире. Эта команда вычисляет только карту теней.

---

<a name="method-replacestring"></a>

### ReplaceString()
```php
ReplaceString(string $str, string $find, string $replace, int $qty): string
```
Возвращает строку со всеми экземплярами "find", замененными на "replace". Вы можете использовать параметр qty для ограничения количества сделанных замен или использовать -1 для ограничения без ограничений. Исходная строка не изменяется, и возвращается новая строка с заменами в ней. Обратите внимание, что если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-render2dfront"></a>

### Render2DFront()
```php
Render2DFront(): void
```
Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает Render2DBack, ClearDepthBuffer, Render3D, ClearDepthBuffer, Render2DFront, чтобы нарисовать все в мире. Эта команда рисует только 2D-спрайты и текст, которые находятся перед 3D.

---

<a name="method-render3d"></a>

### Render3D()
```php
Render3D(): void
```
Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает Render2DBack, RenderShadowMap, Render3D, Render2DFront, чтобы нарисовать все в мире. Эта команда рисует только 3D-объекты.

---

<a name="method-render2dback"></a>

### Render2DBack()
```php
Render2DBack(): void
```
Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает Render2DBack, ClearDepthBuffer, Render3D, ClearDepthBuffer, Render2DFront, чтобы нарисовать все в мире. Эта команда рисует только 2D-спрайты и текст, которые находятся за 3D.

---

<a name="method-render"></a>

### Render()
```php
Render(): void
```
Рисует все 2D и 3D, созданные с использованием идентификационного номера, в текущий буфер кадров. Он не переключает backbuffer на экран. Он не рисует спрайты или объекты, созданные вами с помощью указателей, вам придется либо рисовать их по отдельности, либо назначать их менеджеру спрайтов для пакетного рисования. В этом случае Рендеринг все равно должен быть вызван, так как он также рисует печатный текст. Вызываемый автоматически Sync, вы можете использовать Sync или Update(), Render(), Swap() для ручной синхронизации. Если вы хотите иметь больше контроля, вы можете разбить это дальше и заменить Рендеринг на Render2DBack, ClearDepthBuffer, Render3D, ClearDepthBuffer, Render2DFront

---

<a name="method-removehttpheader"></a>

### RemoveHTTPHeader()
```php
RemoveHTTPHeader(int $iHTTP, string $headerName): void
```
Удаляет заголовок, который вы ранее добавили, если вы не использовали AddHTTPHeader для добавления заголовка с заданным именем, то эта команда ничего не делает. Если имя заголовка является стандартным заголовком, который обычно включается, то эта команда не удаляет его, а вместо этого использует AddHTTPHeader с пустой строкой, чтобы перезаписать его. Если имя заголовка является стандартным заголовком, который вы перезаписали, то эта команда возвращает его к нормальному значению. Обратите внимание, что эта команда не работает в версии HTML5.

---

<a name="method-recordsound"></a>

### RecordSound()
```php
RecordSound(string $szFilename): void
```
Еще не функционирует.

---

<a name="method-receivesmartwatchdata"></a>

### ReceiveSmartWatchData()
```php
ReceiveSmartWatchData(): string
```
Получает сообщение в очереди из приложения watch. Это будет в виде строки JSON. Если вы вызываете эту команду из уровня 2, вы должны удалить возвращенную строку, когда закончите с ней, вызвав agk::DeleteString.  В настоящее время работает только на iOS.

---

<a name="method-readstring2"></a>

### ReadString2()
```php
ReadString2(int $iFileID): string
```
Считывает строку из данного файла, который должен быть открыт для чтения. Обратите внимание, что это может читать только строки в двоичной форме, такие как те, которые написаны с помощью WriteString2, если вы пытаетесь прочитать строки, разделенные новыми строками, то вместо этого используйте ReadLine. Если вы используете эту команду на уровне 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней. Это использует другой метод от ReadString, который немного быстрее, но эта команда может читать только строки, написанные с помощью WriteString2

---

<a name="method-readstring"></a>

### ReadString()
```php
ReadString(int $iFileID): string
```
Считывает строку с нулевым завершением из данного файла, который должен быть открыт для чтения. Обратите внимание, что это может читать только строки в двоичной форме, такие как те, которые написаны с помощью WriteString, если вы пытаетесь прочитать строки, разделенные новыми строками, то вместо этого используйте ReadLine. Если вы используете эту команду на уровне 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней.

---

<a name="method-readline"></a>

### ReadLine()
```php
ReadLine(int $iFileID): string
```
Считывает новую строку, завершенную строкой из данного файла, который должен быть открыт для чтения. Если вы используете эту команду на уровне 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней.

---

<a name="method-readinteger"></a>

### ReadInteger()
```php
ReadInteger(int $iFileID): int
```
Считывает 4-байтовое целое число из данного файла, который должен быть открыт для чтения.

---

<a name="method-readbyte"></a>

### ReadByte()
```php
ReadByte(int $iFileID): int
```
Считывает 1-байтовое целое число без знака (0-255) из данного файла, который должен быть открыт для чтения.

---

<a name="method-readfloat"></a>

### ReadFloat()
```php
ReadFloat(int $iFileID): float
```
Считывает 4-байтовый поплавок из данного файла, который должен быть открыт для чтения.

---

<a name="method-raycast3dphysicsobject"></a>

### RayCast3DPhysicsObject()
```php
RayCast3DPhysicsObject(int $objID, int $rayID, int $fromVec3ID, int $toVec3ID, int $allOrClosest): int
```
Бросьте луч и проверьте объект.

---

<a name="method-raycast3dphysics"></a>

### RayCast3DPhysics()
```php
RayCast3DPhysics(int $rayID, int $fromVec3ID, int $toVec3ID, int $allOrClosest): void
```
Бросьте луч

---

<a name="method-ray3dphysicsexist"></a>

### Ray3DPhysicsExist()
```php
Ray3DPhysicsExist(int $rayID): int
```
Верните 1, если луч существует. Возвращает 0, если это не так.

---

<a name="method-rateapp"></a>

### RateApp()
```php
RateApp(string $szID): void
```
Отображает диалоговое окно с запросом пользователя оценить приложение в App Store. В настоящее время эта команда поддерживается только на iOS.

---

<a name="method-random2"></a>

### Random2()
```php
Random2(int $from, int $to): int
```
Генерирует случайное число на основе текущего начального значения. Генератор случайных чисел встроен в AGK, поэтому определенное начальное значение будет производить одну и ту же последовательность чисел на каждой платформе. Производит случайное число между -2,147,483,648 и 2,147,483,647. Этот генератор работает медленнее, чем Случайный, но производит более качественную случайность в большем диапазоне значений.

---

<a name="method-randomsign"></a>

### RandomSign()
```php
RandomSign(int $value): int
```
Будет случайным образом отрицать данное значение и возвращать его. Имеет 50-50 шансов на отрицание ценности. Начальное значение может быть отрицательным, и в этом случае оно случайно станет положительным.

---

<a name="method-random"></a>

### Random()
```php
Random(int $from, int $to): int
```
Генерирует случайное число на основе текущего начального значения. Генератор случайных чисел встроен в AGK, поэтому определенное начальное значение будет производить одну и ту же последовательность чисел на каждой платформе. Производит случайное число от 0 до 65535

---

<a name="method-pushnotificationsetup"></a>

### PushNotificationSetup()
```php
PushNotificationSetup(): int
```
Возвращает 1, если настройка прошла успешно, 0, если она не удалась или устройство не поддерживает push-уведомления.

---

<a name="method-printimage"></a>

### PrintImage()
```php
PrintImage(int $image, float $size): void
```
Печать изображения на подключенном принтере. Эта команда не гарантированно работает на всех платформах. Параметр size определяет размер изображения на странице, значение 100 позволяет использовать как можно большую часть страницы, 50-половину этой суммы, 25-четверть и так далее.

---

<a name="method-printc"></a>

### PrintC()
```php
PrintC(float $f): void
```
Выводит заданное значение или строку на экран, но не добавляет новый символ строки в конец. Следующая команда Print или PrintC будет следовать непосредственно из этой.

---

<a name="method-print"></a>

### Print()
```php
Print(string $szString): void
```
Выводит заданное значение или строку на экран и добавляет новый символ строки, чтобы следующая команда печати была на одну строку ниже.

---

<a name="method-pow"></a>

### Pow()
```php
Pow(float $a, float $b): float
```
Возвращает a, возведенное в степень b.

---

<a name="method-playyoutubevideo"></a>

### PlayYoutubeVideo()
```php
PlayYoutubeVideo(string $developerKey, string $videoID, float $startTime): void
```
Воспроизводит указанное видео Youtube в отдельном окне над вашим приложением. Для Android вы должны включить Youtube Data API v3 в Google Cloud Console для вашего приложения и создать для него ключ API в разделе учетные данные. Вы можете создать ключ специально для использования с API Youtube или использовать неограниченный ключ, который может использоваться несколькими API. Видеоид-это строка, которая следует за ?v= часть URL-адреса Youtube, например "eLIgxYHCgWA". Вы также можете указать время начала воспроизведения видео с середины, а не с самого начала. Время указывается в секундах и принимает десятичные значения для представления долей секунды.  В Windows, Mac и Linux эта команда откроет браузер по умолчанию для воспроизведения видео Youtube. Поле ключа разработчика требуется только для Android.

---

<a name="method-playvideotoimage"></a>

### PlayVideoToImage()
```php
PlayVideoToImage(int $imageID): void
```
Воспроизведение видео или возобновление его после паузы. Воспроизведение видео на изображение, а не на экран, изображение не должно уже существовать. Изображение будет удалено при вызове DeleteVideo, вы не должны удалять его вручную. Вы можете использовать либо эту команду, либо playVideo, но не оба. Если вы приостановите видео, вы должны возобновить его с помощью той же команды, что и при запуске, с теми же параметрами. В настоящее время это поддерживается только на iOS 7.0 или выше, Android 4.0.3 или выше и Windows.

---

<a name="method-playvideo"></a>

### PlayVideo()
```php
PlayVideo(): void
```
Воспроизводит видео на экране или возобновляет его после паузы. Вы можете использовать либо эту команду, либо PlayVideoToImage, но не оба. Если вы ставите видео на паузу, вы должны возобновить его с помощью той же команды, что и при запуске.

---

<a name="method-playtweentext"></a>

### PlayTweenText()
```php
PlayTweenText(int $tweenID, int $textID, float $delay): void
```
Применяет данный идентификатор анимации к заданному текстовому идентификатору с необязательной задержкой и начинает его воспроизведение. Анимация может воспроизводиться на нескольких текстовых объектах одновременно, просто вызовите эту команду еще раз с другим текстовым идентификатором. Текст не будет изменен до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на текстовом объекте, текст будет соответствующим образом корректировать свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-playtweensprite"></a>

### PlayTweenSprite()
```php
PlayTweenSprite(int $tweenID, int $spriteID, float $delay): void
```
Применяет заданный идентификатор анимации к заданному идентификатору спрайта с необязательной задержкой и начинает его воспроизведение. Анимация может воспроизводиться на нескольких спрайтах одновременно, просто вызовите эту команду снова с другим идентификатором спрайта. Спрайт не будет изменен до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на спрайте, то спрайт соответствующим образом скорректирует свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-playtweenobject"></a>

### PlayTweenObject()
```php
PlayTweenObject(int $tweenID, int $objectID, float $delay): void
```
Применяет заданный идентификатор анимации к заданному идентификатору объекта с необязательной задержкой и начинает его воспроизведение. Анимация может воспроизводиться на нескольких объектах одновременно, просто вызовите эту команду снова с другим идентификатором объекта. Объект не будет изменен до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на объекте, то объект соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-playtweenchar"></a>

### PlayTweenChar()
```php
PlayTweenChar(int $tweenID, int $textID, int $charID, float $delay): void
```
Применяет заданный идентификатор анимации к заданному символу в текстовом объекте с необязательной задержкой и начинает его воспроизведение. Анимация может воспроизводиться на нескольких символах в нескольких текстовых объектах одновременно, просто вызовите эту команду снова с другим идентификатором текста или символа. Символ не будет изменен до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на символе, то символ соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-playtweencustom"></a>

### PlayTweenCustom()
```php
PlayTweenCustom(int $tweenID, float $delay): void
```
Воспроизводит заданный пользовательский идентификатор анимации с дополнительной задержкой и начинает его воспроизведение. В отличие от других подростков, это не применяется к какому-либо конкретному элементу или объекту и не может иметь несколько копий, работающих одновременно, вам придется создать отдельный пользовательский твин для каждой копии, которую вы хотите запустить одновременно. Значения анимации не будут изменены до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение tween изменяется во время воспроизведения tween, то tween соответствующим образом скорректирует свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-playtweencamera"></a>

### PlayTweenCamera()
```php
PlayTweenCamera(int $tweenID, int $cameraID, float $delay): void
```
Применяет заданный идентификатор анимации к заданному идентификатору камеры с дополнительной задержкой и начинает его воспроизведение. Анимация может воспроизводиться на нескольких камерах одновременно, просто вызовите эту команду еще раз с другим идентификатором камеры. Камера не будет изменена до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на камере, камера соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-playtweenchain"></a>

### PlayTweenChain()
```php
PlayTweenChain(int $chainID): void
```
Начинает воспроизведение данной цепочки с самого начала или возобновляет ее, если она была приостановлена.

---

<a name="method-playsprite"></a>

### PlaySprite()
```php
PlaySprite(int $iSpriteIndex, float $fFps, int $iLoop, int $iFromFrame, int $iToFrame): void
```
Начинается анимация спрайта на основе заданных значений. Скорость анимации основана на кадрах анимации в секунду и не зависит от частоты кадров рисования.

---

<a name="method-playsound"></a>

### PlaySound()
```php
PlaySound(int $iID): int
```
Воспроизведение звука, ранее загруженного в указанный звуковой номер. Эта команда может быть вызвана несколько раз для одного и того же идентификатора звука, и она запустит несколько копий этого звука, воспроизводимых в качестве экземпляров. Команда вернет идентификатор экземпляра, который можно использовать для взаимодействия с этим экземпляром во время его воспроизведения. Когда экземпляр перестает воспроизводиться, он автоматически удаляется и больше не может быть использован. По умолчанию звук не зацикливается.

---

<a name="method-playskeleton2danimation"></a>

### PlaySkeleton2DAnimation()
```php
PlaySkeleton2DAnimation(int $iSkeleton, string $anim, float $starttime, int $loop, float $tweentime): void
```
Воспроизводит данную анимацию по имени, если она существует с необязательным временем начала (По умолчанию 0), необязательным циклом и необязательным временем анимации (по умолчанию 0). Время анимации будет плавно интерполировать скелет из его текущего состояния в первый кадр указанной анимации, прежде чем он начнет анимацию, так что резкого перехода не будет. Значение цикла 1 будет петлять вечно, значение цикла больше 1 будет петлять столько раз, а затем остановится, а значение цикла 0 будет воспроизводить анимацию один раз, а затем остановится

---

<a name="method-playobjectanimation"></a>

### PlayObjectAnimation()
```php
PlayObjectAnimation(int $objID, string $animName, float $starttime, float $endtime, int $loop, float $tweentime): void
```
Воспроизводит заданную анимацию на своем родительском объекте. Только объекты, загруженные с помощью LoadObjectWithChildren, будут иметь назначенные им анимации. Имена анимаций определяются программой моделирования при создании анимаций вы можете узнать, что это за имена, используя GetObjectAnimationName. Анимация может быть запущена и закончена в любой момент анимации с использованием параметров start и end, они задаются в секундах, и если цикл включен, то объект вернется к заданному времени начала в начале каждого цикла. Если вы хотите, чтобы петля была бесшовной, то положение костей в начале и в конце должно быть точно таким же, так как при петле между ними не будет интерполяции. Параметр tweentime можно использовать для интерполяции между текущими позициями костей и временем начала анимации, чтобы не было резкого скачка в позициях костей. Это твининг происходит только один раз, он не происходит каждый цикл и не вносит свой вклад во время анимации. По сути, анимация приостанавливается до тех пор, пока твининг не закончит. Обратите внимание, что как только эта команда будет вызвана, кости будут управляться анимацией и не могут быть перемещены с помощью SetObjectBonePosition или аналогичных команд. Вы можете восстановить ручное управление отдельными костями, используя SetObjectBoneCanAnimate на нем. Вы можете восстановить контроль над всей костной структурой с помощью ResetObjectAnimation.

---

<a name="method-playmusicogg"></a>

### PlayMusicOGG()
```php
PlayMusicOGG(int $musicID): void
```
Воспроизведение музыкального файла. Несколько музыкальных файлов OGG могут воспроизводиться одновременно.

---

<a name="method-playmusic"></a>

### PlayMusic()
```php
PlayMusic(int $iID, int $bLoop, int $iStartID, int $iEndID): void
```
Воспроизводит только данный музыкальный файл и при желании зацикливает его. Это изменение по сравнению с предыдущими версиями, где AGK продолжал бы воспроизводить следующий музыкальный трек после этого. Теперь вы должны использовать дополнительные параметры PlayMusic для воспроизведения треков один за другим. В любой момент времени может воспроизводиться только один музыкальный файл.

---

<a name="method-physicsraycastgroup"></a>

### PhysicsRayCastGroup()
```php
PhysicsRayCastGroup(int $group, float $x, float $y, float $x2, float $y2): int
```
Бросает луч через все физические объекты, включая спрайты, у которых включена физика, и сохраняет ближайший предмет, попавший в цель. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Эта функция фильтрует проверяемые спрайты, поэтому проверяются только спрайты определенной группы, а значение группы 0 означает, что будут проверены все группы. Возвращает 1, если произошло столкновение, и 0, если нет.

---

<a name="method-physicsraycastcategory"></a>

### PhysicsRayCastCategory()
```php
PhysicsRayCastCategory(int $category, float $x, float $y, float $x2, float $y2): int
```
Бросает луч через все физические объекты, включая спрайты, у которых включена физика, и сохраняет ближайший предмет, попавший в цель. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Эта функция фильтрует проверяемые спрайты, поэтому проверяются только спрайты определенных категорий. Параметр category - это побитовое поле, которое использует младшие 16 битов для представления каждой из возможных 16 категорий, используемых при настройке спрайта. Значение по умолчанию all 1s означает, что все категории будут включены, тогда как значение all 0s означает, что никакие категории не будут включены. Вы можете установить отдельные биты, чтобы установить, какие из них должны быть проверены. Возвращает 1, если произошло столкновение, и 0, если нет.

---

<a name="method-physicsraycast"></a>

### PhysicsRayCast()
```php
PhysicsRayCast(float $x, float $y, float $x2, float $y2): int
```
Бросает луч через все физические объекты, включая спрайты, у которых включена физика, и сохраняет ближайший предмет, попавший в цель. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Возвращает 1, если произошло столкновение, и 0, если нет.

---

<a name="method-pausevideo"></a>

### PauseVideo()
```php
PauseVideo(): void
```
Приостанавливает видео и сохраняет его на экране.

---

<a name="method-pausetweentext"></a>

### PauseTweenText()
```php
PauseTweenText(int $tweenID, int $textID): void
```
Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван ResumeTweenText. Если анимация уже остановилась или не существует, то это ничего не делает.

---

<a name="method-pausetweensprite"></a>

### PauseTweenSprite()
```php
PauseTweenSprite(int $tweenID, int $spriteID): void
```
Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван ResumeTweenSprite. Если анимация уже остановилась или не существует, то это ничего не делает.

---

<a name="method-pausetweenobject"></a>

### PauseTweenObject()
```php
PauseTweenObject(int $tweenID, int $objectID): void
```
Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван ResumeTweenObject. Если анимация уже остановилась или не существует, то это ничего не делает.

---

<a name="method-pausetweencustom"></a>

### PauseTweenCustom()
```php
PauseTweenCustom(int $tweenID): void
```
Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван ResumeTweenCustom. Если анимация уже остановилась или не существует, то это ничего не делает.

---

<a name="method-pausetweenchar"></a>

### PauseTweenChar()
```php
PauseTweenChar(int $tweenID, int $textID, int $charID): void
```
Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван ResumeTweenChar. Если твин уже остановился или не существует, то это ничего не делает.

---

<a name="method-pausetweenchain"></a>

### PauseTweenChain()
```php
PauseTweenChain(int $chainID): void
```
Приостанавливает данную цепочку, которая начала играть, она может быть возобновлена с помощью PlayTweenChain

---

<a name="method-pausetweencamera"></a>

### PauseTweenCamera()
```php
PauseTweenCamera(int $tweenID, int $cameraID): void
```
Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызвана ResumeTweenCamera. Если твин уже остановился или не существует, то это ничего не делает.

---

<a name="method-pausemusicogg"></a>

### PauseMusicOGG()
```php
PauseMusicOGG(int $musicID): void
```
Ставит музыкальный файл на паузу. GetMusicPlayingOGG будет продолжать возвращать 1.

---

<a name="method-pausemusic"></a>

### PauseMusic()
```php
PauseMusic(): void
```
Приостанавливает воспроизведение музыки в данный момент, какой бы идентификатор это ни был.

---

<a name="method-overrideconsentchartboost"></a>

### OverrideConsentChartboost()
```php
OverrideConsentChartboost(int $consent): void
```
Заставляет Chartboost использовать данное значение согласия при показе рекламы, по умолчанию AGK показывает неперсонализированные объявления из Chartboost. Эта команда может быть использована, если у вас есть собственный метод получения согласия пользователя на показ персонализированной рекламы. Обратите внимание, что GDPR требует от вас по закону получить согласие пользователей ЕС, прежде чем показывать им персонализированную рекламу.

---

<a name="method-overrideconsentadmob"></a>

### OverrideConsentAdMob()
```php
OverrideConsentAdMob(int $consent): void
```
Если AdMob использует заданное значение согласия при показе рекламы, оно не сохраняется на сервере AdMob и переопределяет обычный процесс получения согласия. Это используется, если у вас есть собственный метод получения согласия пользователя на показ персонализированной рекламы. Обратите внимание, что GDPR требует от вас по закону получить согласие пользователей ЕС, прежде чем показывать им персонализированную рекламу.

---

<a name="method-opentowrite"></a>

### OpenToWrite()
```php
OpenToWrite(int $ID, string $szFile, int $append): void
```
Открывает файл, хранящийся в локальной файловой системе, для записи в указанный идентификатор. Все платформы ограничены одной папкой для записи, поэтому пути к файлам должны быть относительными, а не абсолютными. Эта папка записи не является той же папкой, что и само приложение, поэтому изображения, звуки и само приложение не могут быть перезаписаны. Файлы, записанные в эту папку, можно читать с помощью OpenToRead. Если файл не существует, он будет создан, если файл существует, он будет перезаписан, если append равен 0. или добавлен, если append равен 1. Если каталог указан в имени файла и не существует, он будет создан. Чтобы записать файл вне обычной папки записи, вы можете использовать "raw:", за которым следует абсолютный путь для текущей платформы, например "raw:C:\MyFolder\MyFile.txt" на окнах или "raw:/sdcard/Documents/MyFile.txt-на Андроиде. Если какие-либо папки в выбранном вами пути не существуют, они будут созданы. На Raspberry Pi вы можете использовать эту команду, чтобы открыть pin-код GPIO для записи, используя имя файла "gpio:", за которым следует номер pin-кода GPIO, например OpenToWrite(1, "gpio:4"), это чувствительно к регистру. Затем вы можете использовать writeByte для записи 0 или 1 в pin-код и CloseFile для закрытия pin-кода.

---

<a name="method-opentoread"></a>

### OpenToRead()
```php
OpenToRead(string $szFile): int
```
Открывает файл, хранящийся в локальной файловой системе, для чтения в указанный идентификатор. Все платформы ограничены одной папкой для чтения и записи, поэтому пути к файлам должны быть относительными, а не абсолютными. Эта команда сначала проверит специальную папку записи, а если она не сможет найти файл, то проверит папку мультимедиа, так что вы можете загрузить изображения, звуки и другие связанные медиафайлы с помощью этой команды. Чтобы прочитать файл вне обычных папок чтения или записи, вы можете использовать "raw:", за которым следует абсолютный путь для текущей платформы, например "raw:C:\MyFolder\MyFile.txt" на окнах или "raw:/sdcard/Documents/MyFile.txt-на Андроиде. На Raspberry Pi вы можете использовать эту команду, чтобы открыть pin-код GPIO для чтения, используя имя файла "gpio:", за которым следует номер pin-кода GPIO, например OpenToRead(1, "gpio:4"), это чувствительно к регистру. Затем вы можете использовать ReadByte для чтения из pin-кода и CloseFile для закрытия pin-кода.

---

<a name="method-openrawfolder"></a>

### OpenRawFolder()
```php
OpenRawFolder(string $szPath): int
```
Открывает папку в любом месте файловой системы и считывает список содержащихся в ней файлов и папок. Это делается немедленно, поэтому любые изменения, которые происходят в папке после этой команды, не будут замечены, вам нужно будет вызвать эту команду снова, чтобы получить обновленное содержимое. Путь к файлу должен быть абсолютным для текущего устройства, то есть он должен начинаться с буквы диска и двоеточия в Windows и прямой косой черты на всех других платформах. Путь должен существовать и быть доступен для текущего приложения, иначе эта команда выдаст ошибку. Путь может начинаться с текста "raw:" или нет, принимаются обе формы. Эта команда вернет идентификатор, который вы можете использовать для доступа к найденному списку файлов, он будет оставаться доступным до тех пор, пока вы не закроете его с помощью CloseRawFolder. Несколько папок могут быть открыты одновременно, каждому из них будет присвоен свой идентификатор.

---

<a name="method-openbrowser"></a>

### OpenBrowser()
```php
OpenBrowser(string $url): void
```
Открывает браузер по умолчанию текущей платформы и указывает его на заданную страницу.

---

<a name="method-offsetparticles"></a>

### OffsetParticles()
```php
OffsetParticles(int $ID, float $x, float $y): void
```
Немедленно перемещает все существующие частицы на заданное смещение. Например,смещение x=3, y=5 сдвинет все частицы вправо на 3 единицы и вниз на 5 единиц. Это не влияет на излучатель частиц, но может быть использовано в сочетании с SetParticlesPosition для перемещения как излучателя, так и уже существующих частиц.

---

<a name="method-objectsphereslide"></a>

### ObjectSphereSlide()
```php
ObjectSphereSlide(int $objID, float $oldx, float $oldy, float $oldz, float $newx, float $newy, float $newz, float $radius): int
```
Эта команда делает то же самое, что и ObjectSphereCast, но в течение нескольких итераций, чтобы создать точку скольжения для использования в скользящих столкновениях. Он создает скользящую точку, которая снова проверяется, чтобы убедиться, что эта новая точка не сталкивается ни с какими объектами. Это порождает еще одну точку, которую необходимо проверить и так далее. ObjectSphereSlide использует максимум три итерации для завершения точки, которая будет держать сферу вне всех проверенных объектов. Команда GetObjectRayCastNumHits может быть использована для получения количества итераций, используемых этой командой. Подробная информация о точке столкновения, нормали и точке скольжения для каждой итерации также доступна с использованием индексов столкновения от 1 до 3, т. е. GetObjectRayCastX(1) (2) или (3). Конечная точка столкновения, нормаль и точка скольжения находятся в индексе 0, то есть GetObjectRayCastSlideX(0).

---

<a name="method-offset3dparticles"></a>

### Offset3DParticles()
```php
Offset3DParticles(int $ID, float $x, float $y, float $z): void
```
Немедленно перемещает все существующие частицы на заданное смещение. Например, смещение x=3,y=5,z=0 сдвинет все частицы вправо на 3 единицы и вниз на 5 единиц. Это не влияет на излучатель частиц, но может быть использовано в сочетании с Set3DParticlesPosition для перемещения как излучателя, так и уже существующих частиц.

---

<a name="method-objectraycast"></a>

### ObjectRayCast()
```php
ObjectRayCast(int $objID, float $oldx, float $oldy, float $oldz, float $newx, float $newy, float $newz): int
```
Бросает луч через 1 или все объекты, чтобы проверить пересечение с объектом. Лучи определяются с начальным положением и конечным положением и не сталкиваются с задними поверхностями, вернут номер объекта, попавшего первым, или 0 для отсутствия столкновения. Команды лучевого литья полезны для расчета столкновений пуль с уровнями и объектами или для представления линии визирования противника, чтобы определить, могут ли они видеть игрока.

---

<a name="method-objectspherecast"></a>

### ObjectSphereCast()
```php
ObjectSphereCast(int $objID, float $oldx, float $oldy, float $oldz, float $newx, float $newy, float $newz, float $radius): int
```
Проверит, не сталкивается ли луч, начинающийся в oldx, oldy, oldz и заканчивающийся в newx, newy, newz и радиусом ширины, с указанным объектом (ObjId=0 для всех). Не сталкивается с задними гранями, вернет номер объекта, попавшего первым, или 0 для отсутствия столкновения. Команды Sphere casting добавляют измерение ширины к нормальному лучевому кастингу, которое можно использовать для проверки того, ударил ли игрок что-нибудь во время движения, и для позиционирования их в точке столкновения, чтобы обеспечить "липкое" столкновение, где игрок останавливается, если он что-нибудь ударит. Альтернативой является скользящее столкновение. см. раздел ObjectSphereSlide

---

<a name="method-moveobjectlocalz"></a>

### MoveObjectLocalZ()
```php
MoveObjectLocalZ(int $objID, float $amount): void
```
Перемещает указанный объект вдоль его локальной оси Z, то есть если бы объект был символом, эта команда заставила бы его двигаться вперед независимо от того, в каком направлении он находится.

---

<a name="method-moveobjectlocaly"></a>

### MoveObjectLocalY()
```php
MoveObjectLocalY(int $objID, float $amount): void
```
Перемещает указанный объект вдоль его локальной оси Y, то есть если бы объект был символом, эта команда заставила бы его прыгать независимо от того, в каком направлении он находится.

---

<a name="method-moveobjectlocalx"></a>

### MoveObjectLocalX()
```php
MoveObjectLocalX(int $objID, float $amount): void
```
Перемещает указанный объект вдоль его локальной оси X, то есть, если бы объект был символом, эта команда заставила бы их стреляться независимо от того, в каком направлении они были обращены.

---

<a name="method-movecameralocalz"></a>

### MoveCameraLocalZ()
```php
MoveCameraLocalZ(int $cameraID, float $amount): void
```
Перемещает указанную камеру вдоль ее локальной оси Z, то есть если бы камера была символом, эта команда заставила бы их двигаться вперед независимо от того, в каком направлении они были обращены.

---

<a name="method-movecameralocaly"></a>

### MoveCameraLocalY()
```php
MoveCameraLocalY(int $cameraID, float $amount): void
```
Перемещает указанную камеру вдоль ее локальной оси Y, то есть если бы камера была символом, эта команда заставила бы их прыгать независимо от того, в каком направлении они были обращены.

---

<a name="method-movecameralocalx"></a>

### MoveCameraLocalX()
```php
MoveCameraLocalX(int $cameraID, float $amount): void
```
Перемещает указанную камеру вдоль ее локальной оси X, то есть если бы камера была символом, эта команда заставила бы их стреляться независимо от того, в каком направлении они были обращены.

---

<a name="method-move3dphysicscharactercontroller"></a>

### Move3DPhysicsCharacterController()
```php
Move3DPhysicsCharacterController(int $objID, int $direction, float $velocity): void
```
Перемещает контроллер.

---

<a name="method-mod"></a>

### Mod()
```php
Mod(int $a, int $b): int
```
Возвращает остаток от целочисленного деления a/b.

---

<a name="method-minimizeapp"></a>

### MinimizeApp()
```php
MinimizeApp(): void
```
Отправляет приложение в фоновый режим. На настольных платформах, таких как Windows, приложение будет продолжать работать, когда оно свернуто. На Android приложение будет приостановлено. На iOS он ничего не сделает, так как пользователь должен свернуть приложение, нажав кнопку home. На настольных платформах окно можно восстановить с помощью RestoreApp.

---

<a name="method-mid"></a>

### Mid()
```php
Mid(string $strin, int $position, int $length): string
```
Извлекает подстроку из заданной строки, расположенной в указанной позиции.

---

<a name="method-message"></a>

### Message()
```php
Message(string $msg): void
```
Отображает окно сообщения, содержащее заданный текст. Ваше приложение не гарантированно приостановится во время отображения сообщения.

---

<a name="method-maximizewindow"></a>

### MaximizeWindow()
```php
MaximizeWindow(): void
```
Максимизирует окно таким образом, чтобы оно было максимально возможным размером в текущем видимом пространстве без перехода на полный экран. Ничего не делает на мобильных устройствах.

---

<a name="method-makefolder"></a>

### MakeFolder()
```php
MakeFolder(string $szName): int
```
Создает папку по текущему пути. По умолчанию это определяется командой SetFolder. Вы также можете использовать имя файла, начинающееся с "raw:", чтобы создать папку в любом месте файловой системы, например MakeFolder("raw:C:\Temp\MyFolder")

---

<a name="method-makecolor"></a>

### MakeColor()
```php
MakeColor(int $red, int $green, int $blue): int
```
Создает составное значение цвета из цветовых компонентов, которое затем можно использовать с командами 2D-рисования.

---

<a name="method-lower"></a>

### Lower()
```php
Lower(string $strin): string
```
Преобразует строку в символы нижнего регистра.

---

<a name="method-log"></a>

### Log()
```php
Log(float $a): float
```
Возвращает натуральный логарифм заданного значения.

---

<a name="method-loadsubimage"></a>

### LoadSubImage()
```php
LoadSubImage(int $iImageIndex, int $iParentIndex, string $sImageFilename): void
```
Загружает субизображение из текстуры атласа для использования в качестве автономного изображения в указанный идентификатор изображения. В subimages.txt файл должен начинаться с того же имени, что и файл изображения, например, атласное изображение myImage.png будет иметь файл подизображений с именем "myImage subimages.txt". Файл подизображений содержит ряд строк, каждая из которых описывает изображение, существующее в изображении атласа. Каждая строка должна иметь имя формата:X:Y:Width:Height с разделителем :, используемым между полями. Поле Name - это имя, которое вы хотите использовать для ссылки на субизображение при загрузке, оно должно соответствовать параметру sImageFilename этой команды LoadSubImage. Поля X:Y-это координаты пикселей X и Y, представляющие верхний левый угол подизображения, а поля Width:Height-это размер в пикселях подизображения. Эти значения затем используются для извлечения вашего именованного изображения из атласа и загрузки его в свой собственный идентификатор изображения, который будет использоваться как обычное изображение. Изображение атласа должно оставаться загруженным в течение всего времени использования загруженного субизображения. Обратите внимание, что при загрузке подизображения AGK немного изменит UV-координаты, чтобы изображение не крало пиксели из соседних изображений во время фильтрации, по умолчанию он сдвигает UV внутрь на 0,5 пикселя. Вы можете переопределить это, установив SetSpriteUVBorder равным 0 для спрайтов, где вам нужны идеальные пиксельные результаты, но вам придется следить за тем, чтобы пиксель кровоточил по краям, и, возможно, вам придется дать вашим субизображениям границу в 1 пиксель соответствующего цвета, которую он может безопасно украсть при фильтрации.

---

<a name="method-loadvideo"></a>

### LoadVideo()
```php
LoadVideo(string $szFilename): int
```
Эта команда загружает видеофайл, готовый к воспроизведению. Одновременно может быть загружен только один видеофайл, поэтому загрузка видео удаляет все существующие видеофайлы. На iOS, Android и Mac рекомендуется использовать файлы .mp4 с кодеком H264 (MPEG-4 AVC) для видео. Для аудио он должен быть закодирован в формате MP3 или AAC. В Windows это зависит от установленных кодеков, и хотя в некоторых случаях он будет воспроизводить файлы mp4, рекомендуется использовать wmv в Windows для максимальной поддержки. Возвращает 1 в случае успеха, 0, если произошла ошибка, -1, если эта платформа не поддерживает видео.

---

<a name="method-loadsprite"></a>

### LoadSprite()
```php
LoadSprite(int $iSpriteIndex, string $imagefile): void
```
Создает спрайт в пустом идентификаторе спрайта с явным изображением для использования при рендеринге, возвращает используемый идентификатор спрайта. По умолчанию спрайты создаются с глубиной 10, имеют размер, используя данное изображение в качестве направляющей, и позиционируются на 0,0, используя их верхний левый угол. Если назначенное изображение имеет альфа-пиксели, то спрайт создается с режимом прозрачности 1, в противном случае он использует режим прозрачности 0 (непрозрачный) Эта команда берет имя файла изображения и загружает его специально для этого спрайта, это изображение будет удалено, когда спрайт будет удален. Если много спрайтов собираются использовать одно и то же изображение, вы должны загрузить его отдельно и передать его идентификатор команде CreateSprite для экономии памяти.

---

<a name="method-loadspriteshader"></a>

### LoadSpriteShader()
```php
LoadSpriteShader(int $shaderID, string $szPixelFile): void
```
Загружает шейдер, используемый для изменения спрайтов, поскольку он содержит только пиксельный шейдер, вершинный шейдер автоматически генерируется, чтобы убедиться, что он появляется в нужном месте. Этот тип шейдера должен применяться только к спрайтам, но ничего плохого не произойдет, если вы решите применить его к объектам, он просто даст необычные результаты рендеринга для этого объекта. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера. Возвращает идентификатор, который можно использовать для ссылки на этот шейдер в других командах. Идентификаторы являются общими для всех типов шейдеров, поэтому загрузка спрайтового шейдера в ID 1 не будет работать, если 3D-шейдер существует с ID 1.

---

<a name="method-loadskeleton2dfromspriterfile"></a>

### LoadSkeleton2DFromSpriterFile()
```php
LoadSkeleton2DFromSpriterFile(int $iSkeleton, string $filename, float $scale, int $atlasImage): void
```
Загружает анимацию спрайтера, экспортированную в формате JSON. Пожалуйста, обратитесь к разделу руководства для получения подробной информации о том, что поддерживается. Возвращает идентификатор, используемый для ссылки на этот скелет. Параметр atlas image еще не поддерживается и должен быть равен 0, изображения будут загружаться по путям, указанным в файле Spriter JSON. Вы можете использовать значение масштаба, чтобы изменить размер спрайтов и костей в соответствии с выбранным вами разрешением. Значение 1 не изменит размеров, значение 2 сделает все в два раза больше, значение 0,5 уменьшит размер вдвое, и так далее.

---

<a name="method-loadsound"></a>

### LoadSound()
```php
LoadSound(int $iID, string $sFilename): void
```
Загружает звуковой файл из папки мультимедиа приложения и возвращает номер звука. Пути к файлам должны быть относительными, а не абсолютными, вы не можете загружать звуковые файлы из другого места на диске. Обратите внимание, что сжатые WAV-файлы не поддерживаются. Вы должны использовать несжатые WAV-файлы, чтобы обеспечить совместимость на всех платформах.

---

<a name="method-loadsoundogg"></a>

### LoadSoundOGG()
```php
LoadSoundOGG(string $sFilename): int
```
Загружает звуковой файл из папки мультимедиа приложения. Пути к файлам должны быть относительными, а не абсолютными, вы не можете загружать звуковые файлы из других мест на диске. Эта команда берет сжатый OGG-файл и распаковывает его во время загрузки, позволяя вам сохранить размер файла, но использование памяти будет таким же, как если бы вы использовали WAV-файл. Если вы хотите использовать OGG, а также экономить память, то используйте новые команды LoadMusicOGG.

---

<a name="method-loadskeleton2dfromspinefile"></a>

### LoadSkeleton2DFromSpineFile()
```php
LoadSkeleton2DFromSpineFile(int $iSkeleton, string $filename, float $scale, int $atlasImage, int $loadAnim): void
```
Загружает анимацию позвоночника, экспортированную в формате JSON. Пожалуйста, обратитесь к разделу руководства для получения подробной информации о том, что поддерживается. Возвращает идентификатор, используемый для ссылки на этот скелет. Сначала вы должны загрузить изображение атласа, экспортированное Spine, в изображение AGK с помощью команды normal LoadImage и передать его в эту функцию. Вы также можете загрузить анимацию или просто спрайты и кости и переместить или изменить их вручную. Вы можете использовать значение масштаба, чтобы изменить размер спрайтов и костей в соответствии с выбранным вами разрешением. Значение 1 не изменит размеров, значение 2 сделает все в два раза больше, значение 0,5 уменьшит размер вдвое, и так далее.

---

<a name="method-loadsharedvariable"></a>

### LoadSharedVariable()
```php
LoadSharedVariable(string $varName, string $defaultValue): string
```
Загружает переменную, сохраненную этим приложением или другим приложением. Это работает только на платформах iOS, Android 10 и ниже, а также HTML5. Приложения могут совместно использовать переменную только в том случае, если они отвечают определенным требованиям, основанным на платформе. В iOS приложения должны иметь один и тот же начальный идентификатор пакета (также называемый префиксом идентификатора приложения) и иметь один и тот же явный идентификатор приложения до последней точки. Например, com.mycompany.mygroup.myapp1 и com.mycompany.mygroup.myapp2 смогут совместно использовать переменные. На Android 10 и ниже приложения должны иметь разрешение WRITE_EXTERNAL_STORAGE и иметь одно и то же имя пакета до последней точки. Например, com.mycompany.mygroup.myapp1 и com.mycompany.mygroup.myapp2 смогут совместно использовать переменные. На Android общие переменные записываются в доступное пользователю место, поэтому имейте в виду, что пользователи могут читать и/или редактировать сохраненные вами переменные. На Android 11 или выше эта команда не будет работать, так как приложения ограничены в записи в общие места. В HTML приложения должны размещаться в одном домене, значения хранятся в виде файлов cookie. Переменные идентифицируются по имени, поэтому использование SaveSharedVariable("username", "Alice") установит переменную с именем "username" в значение "Alice". Затем это может быть прочитано другими приложениями с помощью LoadSharedVariable( "username", "" ). Если переменная с заданным именем не существует, то вместо нее возвращается указанное значение по умолчанию

---

<a name="method-loadshaderfromstring"></a>

### LoadShaderFromString()
```php
LoadShaderFromString(string $szVertexSource, string $szPixelSource): int
```
Загружает шейдер, используемый для рисования объектов. Вершинный шейдер преобразует полигоны в экранное пространство, а пиксельный шейдер определяет окончательный цвет каждого пикселя, который покрывает объект. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера.

---

<a name="method-loadshader"></a>

### LoadShader()
```php
LoadShader(string $szVertexFile, string $szPixelFile): int
```
Загружает шейдер, используемый для рисования объектов. Вершинный шейдер преобразует полигоны в экранное пространство, а пиксельный шейдер определяет окончательный цвет каждого пикселя, который покрывает объект. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера.

---

<a name="method-loadobjectwithchildren"></a>

### LoadObjectWithChildren()
```php
LoadObjectWithChildren(int $objID, string $szFilename): void
```
Загружает объект из файла, в настоящее время поддерживаются форматы .X .FBX .dae (collada) .3ds .md3 .smd .md5 .lwo .ac .b3d .dae .3d .lws .ms3d .blend .obj и .ago. Если файл модели содержит иерархию костей или анимационные данные, то они также будут загружены и связаны с объектом. Обратите внимание, что объекты с более чем 50 костями могут не отображаться на некоторых старых устройствах. AGK имеет предел в 200 костей. Если файл модели содержит график сцены, содержащий несколько объектов, то они также будут загружены и сохранены в отдельных объектах, которые могут быть обнаружены с помощью GetObjectNumChildren. Если вы просто хотите загрузить один объект без каких-либо костей, анимации или детей, то вместо этого используйте LoadObject. Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.

---

<a name="method-loadobjectshape"></a>

### LoadObjectShape()
```php
LoadObjectShape(int $objID, string $fileName): int
```
загружает форму столкновения из файла .bcs (Bullet Collision Shape) и устанавливает ее на объект. Возвращает true, если это удалось.

---

<a name="method-loadobject"></a>

### LoadObject()
```php
LoadObject(string $szFilename): int
```
Загружает объект из файла, в настоящее время поддерживаются форматы .X .3ds .md3 .smd .md5 .lwo. ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj и .ago. Эта команда не будет загружать никаких анимационных или костных данных и объединит вершины в один объект с как можно меньшим количеством сеток. Для загрузки анимации и костных данных используйте вместо этого LoadObjectWithChildren.

---

<a name="method-loadmusic"></a>

### LoadMusic()
```php
LoadMusic(string $sFile): int
```
Загружает музыкальный файл из папки мультимедиа приложения в указанный идентификатор. Пути к файлам должны быть относительными, а не абсолютными, вы не можете загружать музыкальные файлы из других мест на диске. Он возвращает идентификатор музыкального файла для последующей ссылки на него. Рекомендуемый формат для кросс-платформенной совместимости-MP3. Обратите внимание, что платформа Meego в настоящее время не поддерживает MP3, вместо этого она попытается загрузить файл OGG Vorbis. Например, если вы попытаетесь загрузить "music.mp3", на Meego это будет интерпретировано как "music.ogg". Идентификатор должен находиться в диапазоне от 1 до 50.

---

<a name="method-loadmusicogg"></a>

### LoadMusicOGG()
```php
LoadMusicOGG(string $sFile): int
```
Загружает музыкальный файл, сжатый с помощью OGG Vorbis. Это поддерживается на всех платформах, как и новый предпочтительный способ воспроизведения музыки, заменяющий команду LoadMusic. Одновременно можно воспроизводить несколько музыкальных файлов OGG. Идентификаторы музыкальных файлов OGG отделены от обычных идентификаторов музыкальных файлов и не ограничены определенным диапазоном чисел.

---

<a name="method-loadimageresized"></a>

### LoadImageResized()
```php
LoadImageResized(int $iImageID, string $szFilename, float $scaleX, float $scaleY, int $cache): void
```
Загружает изображение, изменяя его размер в процессе. Это позволяет вам иметь одно высококачественное изображение, а затем изменять его размер в зависимости от разрешения устройства во время выполнения, вместо того чтобы иметь несколько уровней качества. Уменьшение размера изображения предпочтительнее увеличения размера изображения, так как увеличение размера изображения не улучшает качество, но оба варианта поддерживаются. Значение 1.0 не изменяет размер изображения, значение меньше 1 сделает изображение меньше, значение больше 1 сделает изображение больше. Значения масштабирования должны быть больше 0, но могут быть любой дробью, то есть допустима шкала 0,6742. Масштаб 0,5 уменьшит размер изображения вдвое, 2,0-вдвое, и так далее. Изображение может быть изменено по-разному в направлениях X и Y, хотя это приведет к растяжению. Если вы загружаете текстуру атласа с помощью этой команды, то subimages.txt файл также будет иметь свои значения, измененные таким образом, чтобы LoadSubImage по-прежнему работал правильно. Параметр кэша больше не используется, так как масштабирование изображения теперь выполняется графическим процессором, поэтому почти не влияет на производительность

---

<a name="method-loadimage"></a>

### LoadImage()
```php
LoadImage(int $ID, string $sImageFilename): void
```
Загружает изображение из файла в указанный идентификатор изображения, также может быть использован для загрузки текстуры атласа, которая будет использоваться субизображениями. При загрузке текстуры атласа a subimages.txt файл должен существовать с подробным описанием всех содержащихся в нем изображений. Ширина и высота изображения должны быть от 1 до 2048 пикселей, некоторые устройства могут поддерживать большие размеры, но это не гарантируется. Изображения не должны быть размером в 2 степени (2,4,8,16,32 и т. Д.). Если у вас есть много небольших изображений, вы можете объединить их в текстуру атласа, чтобы повысить производительность.

---

<a name="method-loadfont"></a>

### LoadFont()
```php
LoadFont(string $szFontFile): int
```
Загружает файл шрифта в AGK, как правило, в формате TrueType, но все, что поддерживается FreeType, должно работать. Параметр szFontFile может быть либо файлом шрифта, расположенным в вашей папке мультимедиа, либо именем системного шрифта, эта команда сначала проверит вашу папку мультимедиа, прежде чем проверять наличие системных шрифтов. Если вы загружаете системный шрифт, то расширение файла является необязательным, например "Arial.ttf" и "Arial" будут загружать системный шрифт "Arial", если он существует. При загрузке системного шрифта имя файла не должно иметь никаких путей к папкам в имени файла, то есть никаких прямых или обратных косых черт. Чтобы повысить производительность, вы должны загрузить шрифт только один раз. Например, если вы хотите использовать шрифт "Arial" в нескольких местах, то вам следует загрузить его в идентификатор, а затем использовать этот идентификатор для всех целей, а не загружать несколько копий файла шрифта Arial в отдельные идентификаторы.

---

<a name="method-loadconsentstatusadmob"></a>

### LoadConsentStatusAdMob()
```php
LoadConsentStatusAdMob(string $szPubID, string $privacyPolicy): void
```
Загружает текущий статус согласия пользователя с сервера AdMob, это необходимо сделать перед вызовом RequestConsentAdMob. Вы должны дождаться, пока GetConsentStatusAdMob вернет неотрицательное значение, прежде чем использовать другие команды согласия AdMob.

---

<a name="method-loadfullscreenshader"></a>

### LoadFullScreenShader()
```php
LoadFullScreenShader(int $shaderID, string $szPixelFile): void
```
Загружает шейдер, используемый для изменения целей рендеринга, поскольку он содержит только пиксельный шейдер, вершинный шейдер автоматически генерируется, чтобы убедиться, что он применим к полному экрану. Этот тип шейдера должен применяться только к объектам, созданным с помощью CreateObjectQuad, но ничего плохого не произойдет, если вы решите применить его к другим объектам, он просто даст необычные результаты рендеринга для этого объекта. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера. Возвращает идентификатор, который можно использовать для ссылки на этот шейдер в других командах. Идентификаторы являются общими для всех типов шейдеров, поэтому загрузка полноэкранного шейдера в ID 1 не будет работать, если существует обычный шейдер с ID 1.

---

<a name="method-len"></a>

### Len()
```php
Len(string $strin): int
```
Возвращает количество символов в данной строке. Обратите внимание, что для строк, закодированных в UTF-8, это может быть не равно количеству байтов в строке, так как каждый символ может использовать до 4 байт. Для определения длины в байтах используйте команду ByteLen.

---

<a name="method-left"></a>

### Left()
```php
Left(string $strin, int $count): string
```
Обрезает заданную строку, сохраняя наибольшее количество символов слева до заданного значения счетчика.

---

<a name="method-kicknetworkclient"></a>

### KickNetworkClient()
```php
KickNetworkClient(int $iNetID, int $client): void
```
Пинает клиента из сети. Это происходит не сразу, и клиент может оставаться в течение нескольких кадров, прежде чем его окончательно пнут. Клиент отключится обычным способом, вы должны проверить GetNetworkClientDisconnected, чтобы обнаружить, когда клиент был выгнан, а затем вызвать DeleteNetworkClient, чтобы окончательно избавиться от него.

---

<a name="method-joinpaths"></a>

### JoinPaths()
```php
JoinPaths(string $szPath, string $szPath2): string
```
Соединяет два пути вместе и упрощает их, например, соединение пути с ../ удалит последнюю папку из пути. При необходимости между ними будет добавлена прямая косая черта, если первый путь заканчивается прямой косой чертой, а второй путь начинается с прямой косой черты, то один из них будет удален, чтобы сделать правильный путь. Любые обратные косые черты будут преобразованы в прямые косые черты. Первый путь может быть относительным или абсолютным, второй путь должен быть относительным. Это не будет проверено.

---

<a name="method-jump3dphysicscharactercontroller"></a>

### Jump3DPhysicsCharacterController()
```php
Jump3DPhysicsCharacterController(int $objID): void
```
Перемещает контроллер вверх на высоту прыжка.

---

<a name="method-joinnetwork"></a>

### JoinNetwork()
```php
JoinNetwork(string $szNetworkName, string $szMyName): int
```
Присоединяется к сети AGK, размещенной другим приложением. Сеть определяется по имени или по IP-адресу и номеру порта. Для именованных сетей приложение будет искать любые сети AGK, транслируемые с этим именем, и подключаться к ним, если они будут найдены. В качестве альтернативы, используя IP-адрес и номер порта, вы попытаетесь установить прямое соединение с хостом. В случае подключения к Интернету IP-адрес и порт-это единственный способ подключения, так как широковещательные передачи не покидают локальную сеть. IP-адреса могут быть IPv4 или IPv6 в зависимости от того, какие IP-адреса использует хост (он может иметь один или несколько из них). Вы можете обнаружить все сети, доступные для подключения, настроив прослушиватель широковещательных передач и прослушивая их самостоятельно, а затем отобразить список обнаруженных сетей пользователю, чтобы он мог решить, к какой из них подключиться. Эта функция не подключается сразу, она возвращает идентификатор сети и продолжает пытаться подключиться в фоновом режиме. Вы можете определить, когда установлено соединение, проверив, что GetNetworkNumClients больше 1, что указывает на то, что по крайней мере локальный клиент и серверный клиент были обнаружены. Если IsNetworkActive возвращает 0 в любой момент, то соединение с сервером не удалось и сеть должна быть закрыта, вы можете попытаться восстановить соединение, открыв новую сеть. После подключения приложение становится клиентом сети вместе с хостом и любыми другими клиентами, которые подключились к нему. Все клиенты обрабатываются одинаково и имеют список локальных переменных, которые они могут читать и записывать, все клиенты также могут читать любые переменные на других клиентах только для чтения. Вы должны идентифицировать своего клиента с именем клиента, которое будет видно другим клиентам, имя клиента не обязательно должно быть уникальным. Возвращает идентификатор сети, используемый при взаимодействии с этой сетью. Не работает при экспорте в HTML5

---

<a name="method-issupporteddepthtexture"></a>

### IsSupportedDepthTexture()
```php
IsSupportedDepthTexture(): int
```
Эта команда возвращает 1, если текущее устройство поддерживает использование изображений глубины с помощью SetRenderToImage. Если это возвращает 0, то единственными допустимыми идентификаторами изображения глубины для SetRenderToImage являются 0 для отсутствия глубины или -1 для нормального буфера глубины.

---

<a name="method-isspeaking"></a>

### IsSpeaking()
```php
IsSpeaking(): int
```
Возвращает 1, если Speak был вызван, а текст еще не закончен. Если несколько элементов текста были поставлены в очередь, то эта команда будет продолжать возвращать 1 до тех пор, пока все они не будут произнесены или не будет вызван StopSpeaking.  В настоящее время работает только на iOS и Android.

---

<a name="method-isscreenrecording"></a>

### IsScreenRecording()
```php
IsScreenRecording(): int
```
Возвращает 1, если запись экрана в данный момент активна, и 0, если она остановилась. На Android он мог остановиться, потому что приложение было отправлено в фоновый режим или было активировано другое действие, например покупка в приложении.

---

<a name="method-issoundrecording"></a>

### IsSoundRecording()
```php
IsSoundRecording(): int
```
Еще не функционирует.

---

<a name="method-isnetworkactive"></a>

### IsNetworkActive()
```php
IsNetworkActive(int $iNetID): int
```
Проверяет, что сеть активна, в случае присоединения к сети это вернет 0, если соединение не удалось или по какой-то причине соединение с сервером разорвалось. Для хостера эта функция вернет 0, если ему не удалось прослушать указанный порт для клиентов, в противном случае она навсегда вернет 1, так как не перестанет управлять никакими подключенными клиентами, даже если все отключатся.

---

<a name="method-ischoosingimage"></a>

### IsChoosingImage()
```php
IsChoosingImage(): int
```
Возвращает 1, если AGK в данный момент отображает экран выбора изображения и ждет, пока пользователь выберет изображение. Когда это возвращает 0, пользователь либо отменил, либо выбрал изображение, проверьте GetChosenImage, чтобы увидеть, каков был результат.

---

<a name="method-iscapturingimage"></a>

### IsCapturingImage()
```php
IsCapturingImage(): int
```
Эта функция устарела, вместо нее используйте SetDeviceCameraToImage. Возвращает 1, если AGK в данный момент отображает ленту камеры и ждет, когда пользователь захватит изображение. Когда это возвращает 0, пользователь либо отменил, либо захватил изображение, проверьте GetCapturedImage, чтобы увидеть, каков был результат.

---

<a name="method-isabsolutepath"></a>

### IsAbsolutePath()
```php
IsAbsolutePath(string $szPath): int
```
Возвращает 1, если данный путь является абсолютным, 0, если он относителен. Это зависит от платформы, поэтому путь, начинающийся с "C:/", считается абсолютным в Windows, но не в Linux, в то время как путь, начинающийся с прямой косой черты, считается абсолютным в Linux, но не в Windows. Путь может начинаться с префикса "raw:" или нет, принимаются оба варианта.

---

<a name="method-is3dphysicsragdollstatic"></a>

### Is3dPhysicsRagdollStatic()
```php
Is3dPhysicsRagdollStatic(int $objID): int
```
Возвращает 1, если Тряпичная кукла статична.

---

<a name="method-instanceobject"></a>

### InstanceObject()
```php
InstanceObject(int $newobjID, int $objID): void
```
Копирует объект в новый идентификатор, новый объект делится данными вершин с исходным объектом. Исходный объект должен существовать для того, чтобы экземпляр объекта рисовался правильно. Создание экземпляра объекта, который уже является экземпляром, ничего не даст. Создание экземпляра объекта, а затем удаление оригинала, вероятно, приведет к сбою. Установка шейдера на объект экземпляра разрешена до тех пор, пока атрибуты вершин, используемые шейдером, точно совпадают по имени и порядку с теми, которые используются на шейдере исходного объекта. Поддерживается установка различных изображений на экземпляре и исходном объекте.

---

<a name="method-inapppurchasesetup"></a>

### InAppPurchaseSetup()
```php
InAppPurchaseSetup(): void
```
После установки названия покупки в приложении и добавления идентификаторов продуктов вызовите InAppPurchaseSetup, чтобы завершить процесс. После этого момента вы можете попытаться приобрести разблокируемый контент. В настоящее время эта команда поддерживается только на iOS и Android.

---

<a name="method-inapppurchasesetkeys"></a>

### InAppPurchaseSetKeys()
```php
InAppPurchaseSetKeys(string $szData1, string $szData2): void
```
Устанавливает все необходимые внутренние данные при настройке IAP для этой платформы. В настоящее время это относится только к Google Play и Ouya, где вам нужно предоставить свой открытый ключ в base64. Это должно быть вызвано перед InAppPurchaseSetup. Чтобы найти открытый ключ для приложений Google Play, откройте сведения о приложении в консоли Google PlayDeveloper и нажмите кнопку Службы и API. Открытый ключ будет находиться в поле под названием "Ваш лицензионный ключ для этого приложения".

---

<a name="method-inapppurchasesettitle"></a>

### InAppPurchaseSetTitle()
```php
InAppPurchaseSetTitle(string $szTitle): void
```
Задает имя приложения таким образом, чтобы оно отображалось в любых диалоговых окнах, отображаемых при использовании команд покупки в приложении. В настоящее время эта команда поддерживается только на iOS и Android.

---

<a name="method-inapppurchaserestore"></a>

### InAppPurchaseRestore()
```php
InAppPurchaseRestore(): void
```
Восстанавливает все управляемые покупки, сделанные на этой платформе. Например, если пользователь приобрел товар, а затем переустановил приложение, то приложение вернет 0 для GetInAppPurchaseAvailable, если оно не было приобретено снова. Несмотря на то, что это не будет взимать плату с пользователя снова за управляемые товары, Apple требует, чтобы у вас была кнопка, вызывающая эту функцию, вместо того чтобы заставлять пользователя снова проходить процесс покупки. После вызова этой команды вы можете вызвать GetInAppPurchaseAvailable. В настоящее время эта команда поддерживается только на iOS. Эта команда не нужна на Android и Amazon, так как она автоматически восстанавливается в InAppPurchaseSetup

---

<a name="method-inapppurchaseaddproductid"></a>

### InAppPurchaseAddProductID()
```php
InAppPurchaseAddProductID(string $szID, int $type): void
```
Используйте эту команду для добавления любых идентификаторов продуктов в список, например com.yourcompany.yourproduct.iap. Первый идентификатор продукта, который вы добавляете, становится 0, второй-1 и т. Д. Вы также должны указать тип этого продукта: расходуемый (1) или непотребляемый(0). Расходные материалы-это как монеты, которые можно покупать снова и снова, они называются неуправляемыми предметами в Google Play. Непотребляемые продукты-это одноразовые покупки, такие как разблокировка полной версии приложения, они называются управляемыми элементами Google Play. В настоящее время эта команда поддерживается только на iOS, Google Play и Amazon. Это должно быть вызвано до InAppPurchaseSetup, после чего никакие другие продукты не могут быть добавлены.

---

<a name="method-inapppurchaseactivate"></a>

### InAppPurchaseActivate()
```php
InAppPurchaseActivate(int $iID): void
```
Вызовите это, когда вы хотите начать процесс активации / разблокировки дополнительного контента. В настоящее время эта команда поддерживается только на iOS и Android.

---

<a name="method-hostnetwork"></a>

### HostNetwork()
```php
HostNetwork(string $szNetworkName, string $szMyName, int $port): int
```
Создает сеть AGK с этим приложением в качестве контроллера, это приложение добавляется в качестве первого клиента в сеть. Сети AGK идентифицируются по имени и автоматически транслируются всем, кто слушает в локальной сети, а это означает, что другие приложения AGK в локальной сети могут принимать все широковещательные сети, отображать их имена своим пользователям и позволять им выбирать одну из них для присоединения. Приложения AGK вне локальной сети нуждаются в IP-адресе и порту хостера, чтобы присоединиться к сети, этот порт будет нуждаться в переадресации на хост через любой промежуточный брандмауэр. Значение порта должно быть между 1025 и 65535 и завершится ошибкой, если другое приложение уже прослушивает этот порт. Вы также должны указать имя клиента, которое будет использоваться для идентификации вашего клиента, все имена клиентов должны быть уникальными. Это имя будет видно всем остальным клиентам. Клиенты будут добавлены в сеть автоматически и могут быть подсчитаны с помощью GetNetworkNumClients. Вы можете вызвать IsNetworkActive сразу после этой команды, чтобы проверить, что сеть была успешно настроена, после установки сеть не станет неактивной для хостера. После подключения приложение становится клиентом сети, и все другие клиенты, подключающиеся к нему, присоединяются к сети. Все клиенты обрабатываются одинаково и имеют список локальных переменных, которые они могут читать и записывать, все клиенты также могут читать любые переменные на других клиентах только для чтения. Некоторые порты используются AGK для внутренней сети и не должны использоваться вашим приложением. Порты 5689-5692 используются для управления приложениями, транслируемыми из IDE. Порты 45631 и 45632 используются для именованных сетевых соединений. В сетях IPv4 сетевая трансляция идет на все устройства в локальной подсети, в сетях IPv6 трансляция идет на адрес AGK multicast "FF02::41:474B". Если устройство имеет как IPv4, так и IPv6 IP-адреса, то хост-сеть будет принимать соединения как из сетей IPv4, так и из сетей IPv6. Если вы укажете 0 для порта, то он отключит IPv4-соединения, если вы установите portv6 в 0, то он отключит IPv6-соединения. По крайней мере один должен быть больше 0, иначе будет сгенерирована ошибка. Если вы вообще не укажете portv6, то он будет установлен в 0. Должно быть безопасно использовать один и тот же порт как для IPv4, так и для IPv6, но это не было широко протестировано. Возвращает идентификатор, который можно использовать для взаимодействия с этой сетью. Не работает при экспорте в HTML5

---

<a name="method-hextobase64"></a>

### HexToBase64()
```php
HexToBase64(string $input): string
```
Преобразует шестнадцатеричную строку в строку Base64. Шестнадцатеричная строка-это строка, содержащая только символы 0-9 и A-F. Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-httpencode"></a>

### HTTPEncode()
```php
HTTPEncode(string $str): string
```
Кодирует строку таким образом, чтобы она могла быть отправлена на сервер по протоколу HTTP без вмешательства в HTTP-запрос. Например, если вы хотите отправить переменную POST, содержащую символы & или=, они будут выглядеть как дополнительные переменные внутри строки, которую вы хотите отправить. Использование HTTPEncode в этой строке превратит эти символы в ПОСТ-безопасные значения, которые затем автоматически преобразуются обратно в исходные символы, как только они достигнут чего-то вроде PHP-скрипта. При этом используется стандартная кодировка URL-адреса для не буквенно-цифровых символов, оставляя только буквенно-цифровые символы.

---

<a name="method-hex"></a>

### Hex()
```php
Hex(int $i): string
```
Преобразует целочисленное значение в строку, содержащую его шестнадцатеричное представление. Например, Hex(31) вернет строку, содержащую "1F". Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-httpdecode"></a>

### HTTPDecode()
```php
HTTPDecode(string $str): string
```
Декодирует строку, закодированную URL-адресом. Он может декодировать все буквенно-цифровые символы и большинство не буквенно-цифровых символов.

---

<a name="method-getzipextractprogress"></a>

### GetZipExtractProgress()
```php
GetZipExtractProgress(): float
```
Возвращает значение от 0 до 100 для представления хода извлечения zip-файла, запущенного с помощью ExtractZipASync.

---

<a name="method-getyearfromunix"></a>

### GetYearFromUnix()
```php
GetYearFromUnix(int $unixtime): int
```
Возвращает год заданного значения времени unix. Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным. Если не использовать 64 - битные значения, то значение времени unix ограничено периодом с 1901 по 2038 год.

---

<a name="method-getzipextractcomplete"></a>

### GetZipExtractComplete()
```php
GetZipExtractComplete(): int
```
Возвращает 0, если выполняется извлечение zip-файла, начатое с помощью ExtractZipASync, или 1, если оно завершено. Он не дает указания на то, была ли добыча успешной, только на то, что она закончилась.

---

<a name="method-getwritepath"></a>

### GetWritePath()
```php
GetWritePath(): string
```
Возвращает каталог, в который будут записаны новые файлы на текущей платформе, на которой работает приложение.

---

<a name="method-getworldyfromsprite"></a>

### GetWorldYFromSprite()
```php
GetWorldYFromSprite(int $iSpriteIndex, float $x, float $y): float
```
Преобразует точку на спрайте в мировые координаты. Например,если спрайт 10x10 был повернут на 45 градусов вокруг своей центральной точки (в точке 5x5), то, чтобы найти положение в мире верхнего левого угла спрайта, вы бы вызвали эту команду со значениями -5, -5, так как значения относятся к центральной точке спрайта (определяемой SetSpriteOffset). Команда не ограничена размером спрайта, поэтому в приведенном выше примере допустимы значения 20 или -15.

---

<a name="method-getworldxfromsprite"></a>

### GetWorldXFromSprite()
```php
GetWorldXFromSprite(int $iSpriteIndex, float $x, float $y): float
```
Преобразует точку на спрайте в мировые координаты. Например,если спрайт 10x10 был повернут на 45 градусов вокруг своей центральной точки (в точке 5x5), то, чтобы найти положение в мире верхнего левого угла спрайта, вы бы вызвали эту команду со значениями -5, -5, так как значения относятся к центральной точке спрайта (определяемой SetSpriteOffset). Команда не ограничена размером спрайта, поэтому в приведенном выше примере допустимы значения 20 или -15.

---

<a name="method-getwindowsdrive"></a>

### GetWindowsDrive()
```php
GetWindowsDrive(int $index): string
```
Возвращает букву диска указанного диска, от 0 до CountWindowsDrives минус один. Значения вне этого диапазона будут возвращать пустую строку. Возвращаемая строка будет включать букву диска и двоеточие, больше ничего. Это относится только к Windows, другие платформы вернут пустую строку. Если вы вызываете эту команду из уровня 2, то вы должны удалить возвращенную строку с помощью agk::DeleteString (), когда закончите с ней.

---

<a name="method-getwindowheight"></a>

### GetWindowHeight()
```php
GetWindowHeight(): int
```
Возвращает высоту окна текущего устройства. Это значение может отличаться от GetDeviceHeight, если размер окна не соответствует размеру пикселя backbuffer, который используется для рисования окна. Например, на Mac с дисплеем Retina размер окна будет равен половине размера пикселя.

---

<a name="method-getwindowwidth"></a>

### GetWindowWidth()
```php
GetWindowWidth(): int
```
Возвращает ширину окна текущего устройства. Это значение может отличаться от GetDeviceWidth, если размер окна не соответствует размеру пикселя backbuffer, который используется для рисования окна. Например, на Mac с дисплеем Retina размер окна будет равен половине размера пикселя.

---

<a name="method-getvirtualwidth"></a>

### GetVirtualWidth()
```php
GetVirtualWidth(): int
```
Возвращает координату для крайней правой части экрана. В системе координат, основанной на процентах по умолчанию, это 100. Если вы настроили виртуальное разрешение с помощью SetVirtualResolution, то будет возвращена указанная здесь ширина.

---

<a name="method-getvirtualjoystickx"></a>

### GetVirtualJoystickX()
```php
GetVirtualJoystickX(int $index): float
```
Возвращает значение X виртуального джойстика по заданному индексу. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. Когда пользователь не взаимодействует с виртуальным джойстиком, он возвращает 0.

---

<a name="method-getvirtualjoysticky"></a>

### GetVirtualJoystickY()
```php
GetVirtualJoystickY(int $index): float
```
Возвращает значение Y виртуального джойстика по заданному индексу. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. Когда пользователь не взаимодействует с виртуальным джойстиком, он возвращает 0.

---

<a name="method-getvirtualjoystickexists"></a>

### GetVirtualJoystickExists()
```php
GetVirtualJoystickExists(int $index): int
```
Возвращает 1, если виртуальный джойстик существует по заданному индексу. Должно быть в диапазоне от 1 до 4.

---

<a name="method-getvirtualheight"></a>

### GetVirtualHeight()
```php
GetVirtualHeight(): int
```
Возвращает координату для нижней части экрана. В системе координат, основанной на процентах по умолчанию, это 100. Если вы настроили виртуальное разрешение с помощью SetVirtualResolution, то будет возвращена указанная здесь высота.

---

<a name="method-getvirtualbuttonstate"></a>

### GetVirtualButtonState()
```php
GetVirtualButtonState(int $index): int
```
Возвращает 1, если виртуальная кнопка в данный момент находится внизу, и 0, если она поднята. Используйте GetVirtualButtonPressed или GetVirtualButtonReleased, чтобы проверить, нажата или отпущена ли кнопка.

---

<a name="method-getvirtualbuttonpressed"></a>

### GetVirtualButtonPressed()
```php
GetVirtualButtonPressed(int $index): int
```
Возвращает 1 если виртуальная кнопка была нажата в этом кадре, то после первоначального нажатия эта функция вернется к 0. Используйте GetVirtualButtonState, чтобы проверить, находится ли виртуальная кнопка вверх или вниз.

---

<a name="method-getvirtualbuttonreleased"></a>

### GetVirtualButtonReleased()
```php
GetVirtualButtonReleased(int $index): int
```
Возвращает 1 если виртуальная кнопка была выпущена в этом кадре, то после первоначального выпуска эта функция вернется к 0. Используйте GetVirtualButtonState, чтобы проверить, находится ли виртуальная кнопка вверх или вниз.

---

<a name="method-getvirtualbuttonexists"></a>

### GetVirtualButtonExists()
```php
GetVirtualButtonExists(int $index): int
```
Возвращает 1, если виртуальная кнопка существует в данном индексе. 0 в противном случае.

---

<a name="method-getviewzoom"></a>

### GetViewZoom()
```php
GetViewZoom(): float
```
Возвращает текущий уровень масштабирования прокрутки, установленный с помощью SetViewZoom.

---

<a name="method-getviewoffsety"></a>

### GetViewOffsetY()
```php
GetViewOffsetY(): float
```
Возвращает текущее смещение вида в направлении Y, заданное с помощью SetViewOffset.

---

<a name="method-getviewoffsetx"></a>

### GetViewOffsetX()
```php
GetViewOffsetX(): float
```
Возвращает текущее смещение вида в направлении X, заданное с помощью SetViewOffset.

---

<a name="method-getvideowidth"></a>

### GetVideoWidth()
```php
GetVideoWidth(): float
```
Возвращает ширину в пикселях текущего загруженного видео, если это возвращает 0, то вызовите его в цикле с помощью функции Sync (), чтобы дождаться завершения загрузки метаданных видео. Если он возвращает меньше 0, то эта платформа не поддерживает эту команду или произошла ошибка. пример: width = GetVideoWidth() if ( width = 0 ) repeat Sync() width = GetVideoWidth() until width != 0 endif

---

<a name="method-getvideoplaying"></a>

### GetVideoPlaying()
```php
GetVideoPlaying(): int
```
Возвращает 1, если видео воспроизводится в данный момент, 0, если оно закончено или остановлено с помощью stopVideo() или PauseVideo().

---

<a name="method-getvideoposition"></a>

### GetVideoPosition()
```php
GetVideoPosition(): float
```
Возвращает количество секунд, сыгранных до сих пор.

---

<a name="method-getvideoheight"></a>

### GetVideoHeight()
```php
GetVideoHeight(): float
```
Возвращает высоту в пикселях текущего загруженного видео, если это возвращает 0, то вызовите его в цикле с помощью функции Sync (), чтобы дождаться завершения загрузки метаданных видео. Если он возвращает меньше 0, то эта платформа не поддерживает эту команду или произошла ошибка. пример: height = GetVideoHeight() if ( height = 0 ) repeat Sync() height = GetVideoHeight() until height != 0 endif

---

<a name="method-getvideoduration"></a>

### GetVideoDuration()
```php
GetVideoDuration(): float
```
Возвращает количество секунд, в течение которых видео длится от начала до конца. Если это возвращает 0, то вызовите его в цикле с помощью функции Sync (), чтобы дождаться завершения загрузки метаданных видео. Если он возвращает меньше 0, то эта платформа не поддерживает эту команду или произошла ошибка. пример: duration = GetVideoDuration() if ( duration = 0 ) repeat Sync() duration = GetVideoDuration() until duration != 0 endif

---

<a name="method-getverticesprocessed"></a>

### GetVerticesProcessed()
```php
GetVerticesProcessed(): int
```
Возвращает количество вершин, обработанных последним кадром графического процессора.

---

<a name="method-getvector3z"></a>

### GetVector3Z()
```php
GetVector3Z(int $vectorID): float
```
Получает z из вектора.

---

<a name="method-getvector3y"></a>

### GetVector3Y()
```php
GetVector3Y(int $vectorID): float
```
Получает y из вектора.

---

<a name="method-getvector3x"></a>

### GetVector3X()
```php
GetVector3X(int $vectorID): float
```
Получает x из вектора.

---

<a name="method-getvector3multiply"></a>

### GetVector3Multiply()
```php
GetVector3Multiply(int $resultVec, float $multiplier): void
```
Умножает компоненты данного вектора на данный множитель

---

<a name="method-getvector3length"></a>

### GetVector3Length()
```php
GetVector3Length(int $vectorID): float
```
Возвращает длину вектора

---

<a name="method-getvector3distance"></a>

### GetVector3Distance()
```php
GetVector3Distance(int $vectorU, int $vectorV): float
```
Возвращает расстояние между 2 векторами.

---

<a name="method-getvector3cross"></a>

### GetVector3Cross()
```php
GetVector3Cross(int $resultVec, int $vectorU, int $vectorV): void
```
Заполняет результирующий вектор перекрестным произведением 2 переданных векторов.

---

<a name="method-getvector3dot"></a>

### GetVector3Dot()
```php
GetVector3Dot(int $vectorU, int $vectorV): float
```
Возвращает точечное произведение 2 векторов

---

<a name="method-getvector3add"></a>

### GetVector3Add()
```php
GetVector3Add(int $resultVec, int $addVec): void
```
Заполняет вектор resultVec суммой вектора resultVec и вектора addVec.

---

<a name="method-getupdatetime"></a>

### GetUpdateTime()
```php
GetUpdateTime(): float
```
Возвращает количество секунд и долей секунд, потраченных на обновление всего в мире, кроме физики. Это включает в себя анимацию спрайтов, эмуляцию ввода и обработку звуков.

---

<a name="method-getunixtime"></a>

### GetUnixTime()
```php
GetUnixTime(): int
```
Возвращает текущую дату и время в формате unix time, которое измеряется в секундах с 1 января 1970 года. Он может быть отрицательным для дат до 1970 года.

---

<a name="method-getunixfromdate"></a>

### GetUnixFromDate()
```php
GetUnixFromDate(int $year, int $month, int $days, int $hours, int $minutes, int $seconds): int
```
Преобразует заданную дату и время в свой эквивалент времени unix, unix time-это количество секунд с 1 января 1970 года. Если не использовать 64 - битные значения, то значение времени unix ограничено периодом с 1901 по 2038 год.

---

<a name="method-getunassignedimages"></a>

### GetUnassignedImages()
```php
GetUnassignedImages(): int
```
Возвращает количество изображений, загруженных в данный момент в приложение, но не назначенных спрайту или текстовому объекту. Это полезно для отладки, чтобы проверить, что вы удалили все неиспользуемые изображения при переключении из меню на уровень или с одного уровня на другой.

---

<a name="method-getunassignedimagefilename"></a>

### GetUnassignedImageFileName()
```php
GetUnassignedImageFileName(int $index): string
```
Возвращает имя файла указанного неназначенного изображения.

---

<a name="method-geturlschemetext"></a>

### GetURLSchemeText()
```php
GetURLSchemeText(): string
```
На Android и iOS это возвращает полный URL-адрес, который был использован для открытия этого приложения, если использовалась схема URL-адресов. Например, если вы установили схему URL-адресов "myapp" для этого приложения и пользователь нажимает на ссылку типа "myapp: sometext", то ОС откроет ваше приложение, а GetURLSchemeText будет возвращать "myapp: sometext" до тех пор, пока приложение не будет открыто в следующий раз. Если URL - адрес не был использован для открытия приложения или платформа не поддерживает схемы URL-адресов, то будет возвращена пустая строка. При выборе схемы URL-адресов вы должны убедиться, что она уникальна для вашего приложения, так как iOS не позволит двум приложениям иметь одну и ту же схему.

---

<a name="method-getudpnetworkmessage"></a>

### GetUDPNetworkMessage()
```php
GetUDPNetworkMessage(int $listenerID): int
```
Проверяет прослушиватель UDP на наличие любых широковещательных передач. Возвращает 0, если ничего не было получено. Возвращает идентификатор сообщения если что-то было получено, вы можете получить доступ к содержимому этого сообщения с помощью команд сетевого сообщения. Сообщение должно быть удалено, когда вы закончите чтение.

---

<a name="method-gettweentextplaying"></a>

### GetTweenTextPlaying()
```php
GetTweenTextPlaying(int $tweenID, int $textID): int
```
Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном текстовом объекте, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.

---

<a name="method-gettweentextexists"></a>

### GetTweenTextExists()
```php
GetTweenTextExists(int $tweenID): int
```
Возвращает 1, если существует анимация с заданным идентификатором и это текстовая анимация, в противном случае 0.

---

<a name="method-gettweenspriteplaying"></a>

### GetTweenSpritePlaying()
```php
GetTweenSpritePlaying(int $tweenID, int $spriteID): int
```
Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном спрайте, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.

---

<a name="method-gettweenspriteexists"></a>

### GetTweenSpriteExists()
```php
GetTweenSpriteExists(int $tweenID): int
```
Возвращает 1, если существует анимация с заданным идентификатором и это спрайт-анимация, в противном случае 0.

---

<a name="method-gettweenobjectplaying"></a>

### GetTweenObjectPlaying()
```php
GetTweenObjectPlaying(int $tweenID, int $objectID): int
```
Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном объекте, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.

---

<a name="method-gettweenexists"></a>

### GetTweenExists()
```php
GetTweenExists(int $tweenID): int
```
Возвращает 1, если анимация любого типа существует в данном идентификаторе, и 0 в противном случае.

---

<a name="method-gettweencustominteger4"></a>

### GetTweenCustomInteger4()
```php
GetTweenCustomInteger4(int $tweenID): int
```
Возвращает текущее значение четвертого целого числа пользовательского твина.

---

<a name="method-gettweencustomplaying"></a>

### GetTweenCustomPlaying()
```php
GetTweenCustomPlaying(int $tweenID): int
```
Возвращает 1, если данный пользовательский идентификатор анимации воспроизводится в данный момент, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.

---

<a name="method-gettweencustominteger3"></a>

### GetTweenCustomInteger3()
```php
GetTweenCustomInteger3(int $tweenID): int
```
Возвращает текущее значение третьего целого числа пользовательского твина.

---

<a name="method-gettweencustominteger2"></a>

### GetTweenCustomInteger2()
```php
GetTweenCustomInteger2(int $tweenID): int
```
Возвращает текущее значение второго целого числа пользовательского твина.

---

<a name="method-gettweencustominteger1"></a>

### GetTweenCustomInteger1()
```php
GetTweenCustomInteger1(int $tweenID): int
```
Возвращает текущее значение первого целого числа пользовательского твина.

---

<a name="method-gettweencustomfloat4"></a>

### GetTweenCustomFloat4()
```php
GetTweenCustomFloat4(int $tweenID): float
```
Возвращает текущее значение четвертого поплавка пользовательской анимации.

---

<a name="method-gettweencustomfloat3"></a>

### GetTweenCustomFloat3()
```php
GetTweenCustomFloat3(int $tweenID): float
```
Возвращает текущее значение третьего поплавка пользовательской анимации.

---

<a name="method-gettweencustomfloat2"></a>

### GetTweenCustomFloat2()
```php
GetTweenCustomFloat2(int $tweenID): float
```
Возвращает текущее значение второго поплавка пользовательской анимации.

---

<a name="method-gettweencharplaying"></a>

### GetTweenCharPlaying()
```php
GetTweenCharPlaying(int $tweenID, int $textID, int $charID): int
```
Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном символе и текстовом объекте, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.

---

<a name="method-gettweencustomexists"></a>

### GetTweenCustomExists()
```php
GetTweenCustomExists(int $tweenID): int
```
Возвращает 1, если существует анимация с заданным идентификатором и это пользовательская анимация, в противном случае 0.

---

<a name="method-gettweencustomfloat1"></a>

### GetTweenCustomFloat1()
```php
GetTweenCustomFloat1(int $tweenID): float
```
Возвращает текущее значение первого поплавка пользовательской анимации.

---

<a name="method-gettweenchainplaying"></a>

### GetTweenChainPlaying()
```php
GetTweenChainPlaying(int $chainID): int
```
Возвращает 1, если цепочка в данный момент работает со своим списком подростков. Если последняя анимация закончилась или цепочка еще не запущена, она вернет 0.

---

<a name="method-gettweenobjectexists"></a>

### GetTweenObjectExists()
```php
GetTweenObjectExists(int $tweenID): int
```
Возвращает 1, если анимация существует в данном идентификаторе и это объект tween, в противном случае 0.

---

<a name="method-gettweenchainendtime"></a>

### GetTweenChainEndTime()
```php
GetTweenChainEndTime(int $chainID): float
```
Возвращает общую длину цепочки твинов в секундах.

---

<a name="method-gettweencameraplaying"></a>

### GetTweenCameraPlaying()
```php
GetTweenCameraPlaying(int $tweenID, int $cameraID): int
```
Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данной камере, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.

---

<a name="method-gettweencameraexists"></a>

### GetTweenCameraExists()
```php
GetTweenCameraExists(int $tweenID): int
```
Возвращает 1, если анимация существует по заданному идентификатору и это анимация камеры, в противном случае 0.

---

<a name="method-gettextx"></a>

### GetTextX()
```php
GetTextX(int $iTextIndex): float
```
Возвращает текущее положение X текстового объекта в мировых координатах, текст позиционируется с помощью его верхнего левого угла.

---

<a name="method-gettexty"></a>

### GetTextY()
```php
GetTextY(int $iTextIndex): float
```
Возвращает текущее положение Y текстового объекта в мировых координатах, текст позиционируется с помощью его верхнего левого угла.

---

<a name="method-gettextvisible"></a>

### GetTextVisible()
```php
GetTextVisible(int $iTextIndex): int
```
Возвращает 0, если текущий текст был установлен как невидимый с помощью SetTextVisible, 1, если он установлен как видимый (по умолчанию). Это не проверяет, находится ли текст в данный момент в видимом видовом окне.

---

<a name="method-gettexttotalwidth"></a>

### GetTextTotalWidth()
```php
GetTextTotalWidth(int $iTextIndex): float
```
Возвращает текущую ширину текстового объекта в мировых единицах измерения. Если текстовый объект отображает текст в нескольких строках, он возвращает ширину самой длинной строки. Это не учитывает индивидуальные смещения символов, если вы использовали SetTextCharX или что-то подобное для перемещения символа. Возвращаемое значение-это ширина, используемая положением рисунка текстовых символов по умолчанию.

---

<a name="method-gettexttospeechready"></a>

### GetTextToSpeechReady()
```php
GetTextToSpeechReady(): int
```
Возвращает 1, когда механизм преобразования текста в речь готов начать преобразование текста в речь. Вызов других команд преобразования текста в речь, когда он не готов, будет проигнорирован.  В настоящее время работает только на iOS и Android.

---

<a name="method-gettexttotalheight"></a>

### GetTextTotalHeight()
```php
GetTextTotalHeight(int $iTextIndex): float
```
Возвращает текущую высоту текстового объекта в мировых единицах измерения. Это не учитывает индивидуальные смещения символов, если вы использовали SetTextCharY или что-то подобное для перемещения символа. Возвращаемое значение-это высота, используемая для расположения текстовых символов на чертеже по умолчанию. Обратите внимание, что если строка текста пуста, то это значение вернет 0.

---

<a name="method-gettextstring"></a>

### GetTextString()
```php
GetTextString(int $iTextIndex): string
```
Возвращает текущую строку, отображаемую текстовым объектом. В tier 2 возвращаемая строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-gettextsize"></a>

### GetTextSize()
```php
GetTextSize(int $iTextIndex): float
```
Возвращает текущий размер текстового объекта, заданного с помощью setTextSize.

---

<a name="method-gettextspacing"></a>

### GetTextSpacing()
```php
GetTextSpacing(int $iTextIndex): float
```
Возвращает текущий интервал текстового объекта, заданного с помощью SetTextSpacing.

---

<a name="method-gettweencharexists"></a>

### GetTweenCharExists()
```php
GetTweenCharExists(int $tweenID): int
```
Возвращает 1, если существует анимация с заданным идентификатором и она является char tween, в противном случае 0.

---

<a name="method-gettextlinespacing"></a>

### GetTextLineSpacing()
```php
GetTextLineSpacing(int $iTextIndex): float
```
Возвращает текущий межстрочный интервал текстового объекта, заданного с помощью SetTextLineSpacing.

---

<a name="method-gettextlength"></a>

### GetTextLength()
```php
GetTextLength(int $iTextIndex): int
```
Возвращает текущую длину строки, отображаемой текстовым объектом.

---

<a name="method-gettextinputcompleted"></a>

### GetTextInputCompleted()
```php
GetTextInputCompleted(): int
```
Возвращает 1 для кадра, который пользователь завершил ввод текста (успешно или нет). После завершения эта команда вернется к 0. На этом этапе вы можете проверить, отменил ли пользователь ввод, используя GetTextInputCancelled.

---

<a name="method-gettextinputcancelled"></a>

### GetTextInputCancelled()
```php
GetTextInputCancelled(): int
```
Возвращает 1, если пользователь отменил ввод текста, и 0, если нет. Это значение команды не определяется до тех пор, пока GetTextInputCompleted не вернет 1.

---

<a name="method-gettextinputstate"></a>

### GetTextInputState()
```php
GetTextInputState(): int
```
Возвращает 0, если пользователь в данный момент вводит текст, и 1, если нет.

---

<a name="method-gettextinput"></a>

### GetTextInput()
```php
GetTextInput(): string
```
Возвращает строку, введенную пользователем. Он будет содержать символы, закодированные с помощью UTF-8, некоторые устройства также могут разрешать возврат символов новой строки. Это значение команды не определяется до тех пор, пока GetTextInputCompleted не вернет 1.

---

<a name="method-gettexthittest"></a>

### GetTextHitTest()
```php
GetTextHitTest(int $iTextIndex, float $x, float $y): int
```
Возвращает 1, если заданная точка в мировых координатах находится внутри ограничивающего прямоугольника текста. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY. Это не учитывает отдельные позиции символов, например, если вы расположили символ с помощью SetTextCharX или аналогичного. Проверяется только ограничивающая рамка, созданная путем рисования символов в их позициях по умолчанию.

---

<a name="method-gettextcolorred"></a>

### GetTextColorRed()
```php
GetTextColorRed(int $iTextIndex): int
```
Получите красную составляющую цвета текста. Значение будет находиться в диапазоне 0-255.

---

<a name="method-gettextexists"></a>

### GetTextExists()
```php
GetTextExists(int $iTextIndex): int
```
Возвращает 1, если текст существует, и 0, если его нет.

---

<a name="method-gettextcolorgreen"></a>

### GetTextColorGreen()
```php
GetTextColorGreen(int $iTextIndex): int
```
Получите зеленую составляющую цвета текста. Значение будет находиться в диапазоне 0-255.

---

<a name="method-gettextdepth"></a>

### GetTextDepth()
```php
GetTextDepth(int $iTextIndex): int
```
Возвращает текущую глубину текстового объекта, где 0-передняя часть экрана, а 10000 - задняя.

---

<a name="method-gettextcolorblue"></a>

### GetTextColorBlue()
```php
GetTextColorBlue(int $iTextIndex): int
```
Получите синий компонент цвета текста. Значение будет находиться в диапазоне 0-255.

---

<a name="method-gettextcoloralpha"></a>

### GetTextColorAlpha()
```php
GetTextColorAlpha(int $iTextIndex): int
```
Получите альфа-компонент цвета текста. Значение будет находиться в диапазоне 0-255.

---

<a name="method-gettextcharcolorred"></a>

### GetTextCharColorRed()
```php
GetTextCharColorRed(int $iTextIndex, int $iCharIndex): int
```
Возвращает красный компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.

---

<a name="method-gettextchary"></a>

### GetTextCharY()
```php
GetTextCharY(int $iTextIndex, int $iCharIndex): float
```
Возвращает текущую позицию Y указанного символа относительно текстового объекта.

---

<a name="method-gettextcharx"></a>

### GetTextCharX()
```php
GetTextCharX(int $iTextIndex, int $iCharIndex): float
```
Возвращает текущую позицию X указанного символа относительно текстового объекта.

---

<a name="method-gettextcharcolorgreen"></a>

### GetTextCharColorGreen()
```php
GetTextCharColorGreen(int $iTextIndex, int $iCharIndex): int
```
Возвращает зеленый компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.

---

<a name="method-gettextcharcolorblue"></a>

### GetTextCharColorBlue()
```php
GetTextCharColorBlue(int $iTextIndex, int $iCharIndex): int
```
Возвращает синий компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.

---

<a name="method-gettextcharanglerad"></a>

### GetTextCharAngleRad()
```php
GetTextCharAngleRad(int $iTextIndex, int $iCharIndex): float
```
Возвращает текущий угол в радианах указанного символа.

---

<a name="method-gettextcharcoloralpha"></a>

### GetTextCharColorAlpha()
```php
GetTextCharColorAlpha(int $iTextIndex, int $iCharIndex): int
```
Возвращает альфа-компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.

---

<a name="method-gettextalignment"></a>

### GetTextAlignment()
```php
GetTextAlignment(int $iTextIndex): int
```
Возвращает текущее выравнивание набора текстовых объектов с помощью SetTextAlignment.

---

<a name="method-getsystemfontexists"></a>

### GetSystemFontExists()
```php
GetSystemFontExists(string $szFontFile): int
```
Возвращает 1, если система содержит шрифт с заданным именем, и 0 в противном случае. Если возвращается 1, то передача того же имени файла в LoadFont будет успешной. В iOS это всегда будет возвращать 0, так как системные файлы шрифтов недоступны, однако AGK поставляется со встроенным шрифтом, который вы можете использовать, используя идентификатор шрифта 0 с текстовыми объектами.

---

<a name="method-getsupportedshadervaryings"></a>

### GetSupportedShaderVaryings()
```php
GetSupportedShaderVaryings(): int
```
Возвращает количество изменяющихся значений, которые могут быть использованы в шейдерах на текущем устройстве. Вариации-это переменные, которые передают данные между вершинным и пиксельным шейдерами. Это значение гарантированно будет не менее 32, но большинство устройств поддерживают больше. Один vec4 varying содержит 4 различных значения, поэтому 32 значения varyings означают, что вы можете иметь максимум 8 вариаций vec4. Обратите внимание, что переменная vec3 может занимать 4 пространства значений, если она не может быть упакована с какой-либо другой переменной. Вариации будут автоматически упакованы вместе, если они могут заполнить vec4 без разделения, например, vec3 и поплавок могут быть упакованы вместе, как и два вариации vec2. Однако две вариации vec3 не могут быть упакованы вместе без разделения, поэтому каждая из них будет использовать до 4 значений, а дополнительное пространство будет потрачено впустую.

---

<a name="method-getstringtoken2"></a>

### GetStringToken2()
```php
GetStringToken2(string $str, string $delimiter, int $token): string
```
Возвращает определенный токен из строки, разделенной заданным разделителем, например строка, содержащая "first:second:third", имеет три токена, разделенных ":". Аналогично GetStringToken, за исключением того, что эта команда принимает только один символ в качестве разделителя и распознает пустые поля. Например, "first:second::fourth" имеет четыре токена, а третий-пустую строку. В tier 2 возвращаемая строка должна быть удалена, когда вы закончите с ней. Вы можете использовать CountStringTokens2 для подсчета количества токенов в строке.

---

<a name="method-getstringtoken"></a>

### GetStringToken()
```php
GetStringToken(string $str, string $delimiters, int $token): string
```
Возвращает определенный токен из строки, разделенной заданными разделителями, например строка, содержащая "first:second:third", имеет три токена, разделенных ":" и "first:second;third", имеет три токена, разделенных разделителями ":;". Вы можете иметь несколько разделителей между каждым токеном, например "first:;second:third" является допустимым и имеет три токена. В tier 2 возвращаемая строка должна быть удалена, когда вы закончите с ней. Вы можете использовать CountStringTokens для подсчета количества токенов в строке. Эта команда полезна для разделения слов в предложении, которое может быть разделено как пробелом, так и пунктуацией.

---

<a name="method-getstoragetotal"></a>

### GetStorageTotal()
```php
GetStorageTotal(string $path): int
```
Возвращает общее количество МБ хранения данных по указанному пути, использованных и неиспользуемых. Например, использование пути, указывающего на местоположение на SD-карте на Android, вернет размер sd-карты, в то время как использование пути, указывающего на папку записи AGK, вернет количество МБ во внутреннем хранилище. В некоторых случаях это может быть одно и то же. Эта команда возвращает значение -1, если размер хранилища не может быть определен. В настоящее время реализовано только на iOS и Android, другие платформы вернут -1.

---

<a name="method-getstorageremaining"></a>

### GetStorageRemaining()
```php
GetStorageRemaining(string $path): int
```
Возвращает количество МБ, доступных приложению для хранения данных по указанному пути. Например, использование пути, указывающего на местоположение на SD-карте Android, вернет, сколько МБ может быть сохранено там, в то время как использование пути, указывающего на папку записи AGK, вернет количество МБ, которое приложение может хранить в своем внутреннем хранилище. В некоторых случаях это может быть одно и то же. Эта команда возвращает -1, если доступное пространство не может быть определено. В настоящее время реализовано только на iOS и Android, другие платформы вернут -1.

---

<a name="method-getspriteyfrompixel"></a>

### GetSpriteYFromPixel()
```php
GetSpriteYFromPixel(int $iSpriteIndex, int $y): float
```
Преобразует точку пикселя на изображении спрайта в точку на поверхности спрайта, которая представляет, где находится этот пиксель. Например, если изображение размером 200x100 пикселей было назначено спрайту размером 10x10, то вызов этой команды со значением пикселя 50 (центр изображения) вернет 5 (центр спрайта). Для этого спрайту должно быть назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером изображения или спрайта, поэтому в приведенном выше примере допустимо значение пикселя 300 или -10.

---

<a name="method-getspriteybyoffset"></a>

### GetSpriteYByOffset()
```php
GetSpriteYByOffset(int $iSpriteIndex): float
```
Возвращает текущую координату Y текущей точки смещения спрайта в мире.

---

<a name="method-getspritey"></a>

### GetSpriteY()
```php
GetSpriteY(int $iSpriteIndex): float
```
Возвращает текущую координату Y верхнего левого угла спрайта в виде значения с плавающей запятой.

---

<a name="method-gettextcharangle"></a>

### GetTextCharAngle()
```php
GetTextCharAngle(int $iTextIndex, int $iCharIndex): float
```
Возвращает текущий угол в градусах указанного символа.

---

<a name="method-getspritexfromworld"></a>

### GetSpriteXFromWorld()
```php
GetSpriteXFromWorld(int $iSpriteIndex, float $x, float $y): float
```
Преобразует точку в мировых координатах в точку на спрайте. Это противоположно GetWorldXFromSprite и будет возвращать значения относительно центральной точки спрайта, определенной с помощью SetSpriteOffset. По умолчанию это центр спрайта. Команда не ограничена размером спрайта, она может возвращать значения, превышающие границы спрайта.

---

<a name="method-getspritexfrompixel"></a>

### GetSpriteXFromPixel()
```php
GetSpriteXFromPixel(int $iSpriteIndex, int $x): float
```
Преобразует точку пикселя на изображении спрайта в точку на поверхности спрайта, которая представляет, где находится этот пиксель. Например, если изображение размером 200x100 пикселей было назначено спрайту размером 10x10, то вызов этой команды со значением пикселя 100 (центр изображения) вернет 5 (центр спрайта). Для этого спрайту должно быть назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером изображения или спрайта, поэтому в приведенном выше примере допустимо значение пикселя 300 или -10.

---

<a name="method-getspritexbyoffset"></a>

### GetSpriteXByOffset()
```php
GetSpriteXByOffset(int $iSpriteIndex): float
```
Возвращает текущую координату X текущей точки смещения спрайта в мире.

---

<a name="method-getspritex"></a>

### GetSpriteX()
```php
GetSpriteX(int $iSpriteIndex): float
```
Возвращает текущую координату X верхнего левого угла спрайта в виде значения с плавающей запятой.

---

<a name="method-getspritevisible"></a>

### GetSpriteVisible()
```php
GetSpriteVisible(int $iSpriteIndex): int
```
Возвращает 0, если спрайт был установлен как невидимый с помощью SetSpriteVisible, в противном случае возвращает 1.

---

<a name="method-getspritetransparency"></a>

### GetSpriteTransparency()
```php
GetSpriteTransparency(int $iSpriteIndex): int
```
Возвращает текущий режим прозрачности спрайта, 0=отсутствие прозрачности, 1=прозрачность альфа-канала, 2=аддитивное смешивание.

---

<a name="method-getspriteyfromworld"></a>

### GetSpriteYFromWorld()
```php
GetSpriteYFromWorld(int $iSpriteIndex, float $x, float $y): float
```
Преобразует точку в мировых координатах в точку на спрайте. Это противоположно GetWorldYFromSprite и будет возвращать значения относительно центральной точки спрайта, определенной с помощью SetSpriteOffset. По умолчанию это центр спрайта. Команда не ограничена размером спрайта, она может возвращать значения, превышающие границы спрайта.

---

<a name="method-getspriteshapevertexy"></a>

### GetSpriteShapeVertexY()
```php
GetSpriteShapeVertexY(int $iSpriteIndex, int $shapeID, int $vertex): float
```
Возвращает значение Y данной вершины в заданной форме. Это относится только к полигональным и цепным формам. Идентификаторы фигур начинаются с 1 для первой фигуры вплоть до значения, возвращаемого GetSpriteNumShapes. Идентификаторы вершин начинаются с 1 для первой вершины вплоть до значения, возвращаемого GetSpriteShapeNumVertices

---

<a name="method-getspritewidth"></a>

### GetSpriteWidth()
```php
GetSpriteWidth(int $iSpriteIndex): float
```
Возвращает текущую ширину спрайта в виде значения с плавающей запятой.

---

<a name="method-getspriteshapevertexx"></a>

### GetSpriteShapeVertexX()
```php
GetSpriteShapeVertexX(int $iSpriteIndex, int $shapeID, int $vertex): float
```
Возвращает значение X данной вершины в заданной форме. Это относится только к полигональным и цепным формам. Идентификаторы фигур начинаются с 1 для первой фигуры вплоть до значения, возвращаемого GetSpriteNumShapes. Идентификаторы вершин начинаются с 1 для первой вершины вплоть до значения, возвращаемого GetSpriteShapeNumVertices

---

<a name="method-getspriteshapenumvertices"></a>

### GetSpriteShapeNumVertices()
```php
GetSpriteShapeNumVertices(int $iSpriteIndex, int $shapeID): int
```
Возвращает количество вершин в заданной форме. Это относится только к полигональным и цепным формам. Идентификаторы фигур начинаются с 1 для первой фигуры вплоть до значения, возвращаемого GetSpriteNumShapes.

---

<a name="method-getspritescaley"></a>

### GetSpriteScaleY()
```php
GetSpriteScaleY(int $iSpriteIndex): float
```
Возвращает текущее масштабирование спрайта в направлении Y как задано с помощью SetSpriteScale или SetSpriteScaleByOffset

---

<a name="method-getspritescalex"></a>

### GetSpriteScaleX()
```php
GetSpriteScaleX(int $iSpriteIndex): float
```
Возвращает текущее масштабирование спрайта в направлении X как задано с помощью SetSpriteScale или SetSpriteScaleByOffset

---

<a name="method-getspriteplaying"></a>

### GetSpritePlaying()
```php
GetSpritePlaying(int $iSpriteIndex): int
```
Возвращает 1, если спрайт в данный момент воспроизводит анимацию, и 0, если нет.

---

<a name="method-getspritepixelfromx"></a>

### GetSpritePixelFromX()
```php
GetSpritePixelFromX(int $iSpriteIndex, float $x): int
```
Преобразует точку на изображении спрайта в пиксель на изображении спрайта, который находится под этой точкой. Например, если изображение размером 200x100 пикселей было назначено спрайту размером 10x10, то вызов этой команды со значением пикселя 5 (центр спрайта) вернет 100 (центр изображения). Для этого спрайту должно быть назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером изображения или спрайта, поэтому в приведенном выше примере значение пикселя 20 или -1 будет допустимым.

---

<a name="method-getspritepixelfromy"></a>

### GetSpritePixelFromY()
```php
GetSpritePixelFromY(int $iSpriteIndex, float $y): int
```
Преобразует точку на изображении спрайта в пиксель на изображении спрайта, который находится под этой точкой. Например, если изображение размером 200x100 пикселей было назначено спрайту размером 10x10, то вызов этой команды со значением пикселя 5 (центр спрайта) вернет 50 (центр изображения). Для этого спрайту должно быть назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером изображения или спрайта, поэтому в приведенном выше примере допустимо значение пикселя 20 или -1.

---

<a name="method-getspritephysicsvelocityy"></a>

### GetSpritePhysicsVelocityY()
```php
GetSpritePhysicsVelocityY(int $iSpriteIndex): float
```
Возвращает линейную скорость спрайта в направлении Y. Это количество единиц в секунду, которое спрайт в данный момент перемещает в выбранном вами разрешении.

---

<a name="method-getspritephysicsmass"></a>

### GetSpritePhysicsMass()
```php
GetSpritePhysicsMass(int $iSpriteIndex): float
```
Возвращает массу спрайта в килограммах, используемых в данный момент. Он либо генерировался автоматически при создании формы, либо добавлялся, либо устанавливался вручную.

---

<a name="method-getspritephysicscomx"></a>

### GetSpritePhysicsCOMX()
```php
GetSpritePhysicsCOMX(int $iSpriteIndex): float
```
Возвращает значение X текущего Центра масс для физического тела данного спрайта. Все фигуры, добавленные в данный момент к этому спрайту, вносят свой вклад в это значение. Если вы установили центр масс вручную, то он вернет это значение. Для работы команды необходимо включить физику, иначе она вернет 0.

---

<a name="method-getspritephysicsangularvelocity"></a>

### GetSpritePhysicsAngularVelocity()
```php
GetSpritePhysicsAngularVelocity(int $iSpriteIndex): float
```
Возвращает угловую скорость спрайта в радианах в секунду. Это скорость, с которой в данный момент вращается спрайт.

---

<a name="method-getspriteoffsety"></a>

### GetSpriteOffsetY()
```php
GetSpriteOffsetY(int $iSpriteIndex): float
```
Возвращает компонент Y текущей точки смещения спрайта.

---

<a name="method-getspriteoffsetx"></a>

### GetSpriteOffsetX()
```php
GetSpriteOffsetX(int $iSpriteIndex): float
```
Возвращает компонент X текущей точки смещения спрайта.

---

<a name="method-getspritenumshapes"></a>

### GetSpriteNumShapes()
```php
GetSpriteNumShapes(int $iSpriteIndex): int
```
Возвращает текущее количество фигур, назначенных этому спрайту. Идентификаторы фигур действительны от 1 до значения, возвращаемого этой командой, включая его.

---

<a name="method-getspriteinscreen"></a>

### GetSpriteInScreen()
```php
GetSpriteInScreen(int $iSpriteIndex): int
```
Возвращает 1, если спрайт в данный момент находится в видимой области экрана, и 0, если он находится за пределами видимой области. Обратите внимание, что если спрайт находится очень близко к краю, где может быть трудно определить, находятся ли все пиксели в спрайте за пределами видимой области, то эта команда вернет 1 и предположит, что он виден. Другими словами, если эта команда возвращает 0, то спрайт определенно находится вне экрана, если она возвращает 1, то спрайт, скорее всего, находится на экране, но на самом деле может быть вне экрана и очень близко к краю.

---

<a name="method-getspriteincircle"></a>

### GetSpriteInCircle()
```php
GetSpriteInCircle(int $iSprite, float $x1, float $y1, float $radius): int
```
Возвращает 1, если форма столкновения спрайта касается заданного круга в мировых координатах, и 0, если нет. Если спрайт не имеет формы, ему присваивается собственная прямоугольная форма, которая останется после этой команды. Эта команда учитывает поворот и масштаб спрайта при проверке пересечения. Обратите внимание, что из-за изменений соотношения сторон эта команда ведет себя не так, как ожидалось при использовании процентной системы координат. Вместо этого он будет проверять эллипс с правильным радиусом в направлении X, но большим радиусом в направлении Y.

---

<a name="method-getspritephysicsvelocityx"></a>

### GetSpritePhysicsVelocityX()
```php
GetSpritePhysicsVelocityX(int $iSpriteIndex): float
```
Возвращает линейную скорость спрайта в направлении X. Это количество единиц в секунду, которое спрайт в данный момент перемещает в выбранном вами разрешении.

---

<a name="method-getspriteinbox"></a>

### GetSpriteInBox()
```php
GetSpriteInBox(int $iSprite, float $x1, float $y1, float $x2, float $y2): int
```
Возвращает 1, если форма столкновения спрайта касается заданного поля в мировых координатах, и 0, если нет. Если спрайт не имеет формы, ему присваивается собственная прямоугольная форма, которая останется после этой команды. Эта команда учитывает поворот и масштаб спрайта при проверке пересечения.

---

<a name="method-getspriteimageid"></a>

### GetSpriteImageID()
```php
GetSpriteImageID(int $iSpriteIndex): int
```
Возвращает идентификатор изображения, назначенного в данный момент спрайту. Это работает только в том случае, если изображение было загружено с идентификатором (или присвоено ему AGK).

---

<a name="method-getspritephysicscomy"></a>

### GetSpritePhysicsCOMY()
```php
GetSpritePhysicsCOMY(int $iSpriteIndex): float
```
Возвращает значение Y текущего Центра масс для физического тела данного спрайта. Все фигуры, добавленные в данный момент к этому спрайту, вносят свой вклад в это значение. Если вы установили центр масс вручную, то он вернет это значение. Для работы команды необходимо включить физику, иначе она вернет 0.

---

<a name="method-getspritehittest"></a>

### GetSpriteHitTest()
```php
GetSpriteHitTest(int $iSpriteIndex, float $x, float $y): int
```
Возвращает 1,если точка x, y в мировых координатах лежит внутри спрайта, 0, если нет. Учитывает вращение и масштабные значения спрайта. Использует форму, назначенную ему из SetSpriteShape, если форма не задана, она использует ширину и высоту спрайта в качестве формы коробки. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY.

---

<a name="method-getspritehitgroup"></a>

### GetSpriteHitGroup()
```php
GetSpriteHitGroup(int $group, float $x, float $y): int
```
Возвращает идентификатор первого спрайта,найденного под точкой x, y в мировых координатах, 0, если нет. Спрайты упорядочены по глубине, поэтому спрайт, появляющийся над другим в порядке розыгрыша, будет возвращен вместо спрайта позади него. Фильтрует результаты только для тех спрайтов, которые находятся в указанной группе. По умолчанию спрайты создаются в группе 0, вы можете изменить это с помощью SetSpriteGroup. Учитывается вращение и масштаб значений спрайта. Он не учитывает прозрачность спрайта, только его форму столкновения. Использует форму, назначенную ему из SetSpriteShape, если форма не задана, то она использует ширину и высоту спрайта в качестве формы коробки. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY.

---

<a name="method-getspritehitcategory"></a>

### GetSpriteHitCategory()
```php
GetSpriteHitCategory(int $categories, float $x, float $y): int
```
Возвращает идентификатор первого спрайта,найденного под точкой x, y в мировых координатах, 0, если нет. Спрайты упорядочены по глубине, поэтому спрайт, появляющийся над другим в порядке розыгрыша, будет возвращен вместо спрайта позади него. Эта функция фильтрует результаты, поэтому проверяются только спрайты определенных категорий. Параметр category - это побитовое поле, которое использует младшие 16 битов для представления каждой из возможных 16 категорий, используемых при настройке спрайта. Значение по умолчанию all 1s означает, что все категории будут включены, тогда как значение all 0s означает, что никакие категории не будут включены. Вы можете установить отдельные биты, чтобы установить, какие из них должны быть проверены. Вы можете установить, к каким категориям относится спрайт, с помощью SetSpriteCategoryBits. Учитывает вращение и масштабные значения спрайта. Он не учитывает прозрачность спрайта, только его форму столкновения. Использует форму, назначенную ему из SetSpriteShape, если форма не задана, она использует ширину и высоту спрайта в качестве формы коробки. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY.

---

<a name="method-getspritehit"></a>

### GetSpriteHit()
```php
GetSpriteHit(float $x, float $y): int
```
Возвращает идентификатор первого спрайта,найденного под точкой x, y в мировых координатах, 0, если нет. Спрайты упорядочены по глубине, поэтому спрайт, появляющийся над другим в порядке розыгрыша, будет возвращен вместо спрайта позади него. Учитывает вращение и масштабные значения спрайта. Он не учитывает прозрачность спрайта, только его форму столкновения. Использует форму, назначенную ему из SetSpriteShape, если форма не задана, она использует ширину и высоту спрайта в качестве формы коробки. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY.

---

<a name="method-getspriteheight"></a>

### GetSpriteHeight()
```php
GetSpriteHeight(int $iSpriteIndex): float
```
Возвращает текущую высоту спрайта в виде значения с плавающей запятой.

---

<a name="method-getspritegroup"></a>

### GetSpriteGroup()
```php
GetSpriteGroup(int $iSpriteIndex): int
```
Возвращает значение набора групп с помощью SetSpriteGroup. Если вы не установили группу, то это будет 0.

---

<a name="method-getspriteframecount"></a>

### GetSpriteFrameCount()
```php
GetSpriteFrameCount(int $iSpriteIndex): int
```
Возвращает общее количество кадров, которые спрайту удалось получить из своего изображения. Может быть меньше, чем количество кадров, запрошенных во время настройки.

---

<a name="method-getspritenextcontact"></a>

### GetSpriteNextContact()
```php
GetSpriteNextContact(): int
```
Циклически просматривает список контактов только для данного спрайта. Возвращает 1 если контакт существует, вы можете получить другой спрайт, вовлеченный в этот контакт, используя GetSpriteContactSpriteID2, вы можете перейти к следующему контакту, снова вызвав эту команду, она вернет 0, когда больше контактов не будет. Работает только на спрайтах, настроенных для физики.

---

<a name="method-getspriteflippedv"></a>

### GetSpriteFlippedV()
```php
GetSpriteFlippedV(int $iSpriteIndex): int
```
Возвращает 1, если спрайт был перевернут вертикально с помощью SetSpriteFlip, в противном случае возвращает 0.

---

<a name="method-getspriteflippedh"></a>

### GetSpriteFlippedH()
```php
GetSpriteFlippedH(int $iSpriteIndex): int
```
Возвращает 1, если спрайт был перевернут горизонтально с помощью SetSpriteFlip, в противном случае возвращает 0.

---

<a name="method-getspritefirstcontact"></a>

### GetSpriteFirstContact()
```php
GetSpriteFirstContact(int $iSprite1): int
```
Циклически просматривает список контактов только для данного спрайта. Возвращает 1 если контакт существует, вы можете получить другой спрайт, вовлеченный в этот контакт, используя GetSpriteContactSpriteID2, вы можете перейти к следующему контакту с GetSpriteNextContact. Работает только на спрайтах, настроенных для физики. Возвращает 0, если контактов нет.

---

<a name="method-getspritedistancepoint2y"></a>

### GetSpriteDistancePoint2Y()
```php
GetSpriteDistancePoint2Y(): float
```
Возвращает координату Y ближайшей точки на sprite 2 к sprite 1 из последнего вызова GetSpriteDistance в мировых координатах.

---

<a name="method-getspriteexists"></a>

### GetSpriteExists()
```php
GetSpriteExists(int $iSpriteIndex): int
```
Возвращает 1, если спрайт существует, и 0, если нет.

---

<a name="method-getspritedistancepoint2x"></a>

### GetSpriteDistancePoint2X()
```php
GetSpriteDistancePoint2X(): float
```
Возвращает координату X ближайшей точки на sprite 2 к sprite 1 из последнего вызова GetSpriteDistance в мировых координатах.

---

<a name="method-getspritedistancepoint1x"></a>

### GetSpriteDistancePoint1X()
```php
GetSpriteDistancePoint1X(): float
```
Возвращает координату X ближайшей точки на спрайте 1 к спрайту 2 от последнего вызова GetSpriteDistance в мировых координатах.

---

<a name="method-getspritedistancepoint1y"></a>

### GetSpriteDistancePoint1Y()
```php
GetSpriteDistancePoint1Y(): float
```
Возвращает координату Y ближайшей точки на спрайте 1 к спрайту 2 от последнего вызова GetSpriteDistance в мировых координатах.

---

<a name="method-getspritedepth"></a>

### GetSpriteDepth()
```php
GetSpriteDepth(int $iSpriteIndex): int
```
Возвращает текущую глубину спрайта в диапазоне 0-10000, где 0-передняя часть экрана, а 10000-задняя.

---

<a name="method-getspritecurrentframe"></a>

### GetSpriteCurrentFrame()
```php
GetSpriteCurrentFrame(int $iSpriteIndex): int
```
Возвращает текущий идентификатор кадра спрайта.

---

<a name="method-getspritecontactworldy"></a>

### GetSpriteContactWorldY()
```php
GetSpriteContactWorldY(): float
```
Возвращает координату Y точки контакта в мировых координатах.

---

<a name="method-getspritecontactworldx"></a>

### GetSpriteContactWorldX()
```php
GetSpriteContactWorldX(): float
```
Возвращает координату X точки контакта в мировых координатах.

---

<a name="method-getspritecontactspriteid2"></a>

### GetSpriteContactSpriteID2()
```php
GetSpriteContactSpriteID2(): int
```
Возвращает идентификатор другого спрайта, участвующего в этом контакте.

---

<a name="method-getspritecolorred"></a>

### GetSpriteColorRed()
```php
GetSpriteColorRed(int $iSpriteIndex): int
```
Возвращает текущий красный компонент спрайта в диапазоне 0-255.

---

<a name="method-getspritecolorblue"></a>

### GetSpriteColorBlue()
```php
GetSpriteColorBlue(int $iSpriteIndex): int
```
Возвращает текущий синий компонент спрайта в диапазоне 0-255.

---

<a name="method-getspritecolorgreen"></a>

### GetSpriteColorGreen()
```php
GetSpriteColorGreen(int $iSpriteIndex): int
```
Возвращает текущий зеленый компонент спрайта в диапазоне 0-255.

---

<a name="method-getspritecoloralpha"></a>

### GetSpriteColorAlpha()
```php
GetSpriteColorAlpha(int $iSpriteIndex): int
```
Возвращает текущее альфа-значение спрайта в диапазоне 0-255.

---

<a name="method-getspritecollision"></a>

### GetSpriteCollision()
```php
GetSpriteCollision(int $iSprite1, int $iSprite2): int
```
Проверяет два спрайта на столкновение, если они перекрываются, то возвращает 1. В противном случае возвращает 0. Никакая другая информация не может быть возвращена об этом типе столкновения. Эта команда предназначена в первую очередь для спрайтов, которые не используют физику. Хотя он может быть использован на физических спрайтах, физическая система уже вычислит перекрытие всех физических спрайтов в течение последнего кадра и сохранит результаты в списке контактов. Эта функция фактически выполняет вычисления, необходимые для определения того, перекрываются ли спрайты. Эта функция не ограничена настройками группы или категории. Эта функция работает только с базовой формой спрайта. Любые дополнительные фигуры, добавленные к физическим спрайтам, не будут использоваться в этой функции, вместо этого используйте GetPhysicsCollision. Кроме того, цепные формы всегда не будут возвращать никаких столкновений с помощью этой команды, цепные формы используются только в физических расчетах. Если вы не назначили форму ни одному из спрайтов с помощью SetSpriteShape, они будут использовать форму коробки по умолчанию, основанную на ширине и высоте спрайта.

---

<a name="method-getspriteanglerad"></a>

### GetSpriteAngleRad()
```php
GetSpriteAngleRad(int $iSpriteIndex): float
```
Возвращает текущий угол спрайта в радианах, 0 радианов-это направление x=0 y=-1 и движение по часовой стрелке.

---

<a name="method-getspriteangle"></a>

### GetSpriteAngle()
```php
GetSpriteAngle(int $iSpriteIndex): float
```
Возвращает текущий угол спрайта в градусах, 0 градусов-это направление x=0 y=-1 и движение по часовой стрелке.

---

<a name="method-getspriteactive"></a>

### GetSpriteActive()
```php
GetSpriteActive(int $iSpriteIndex): int
```
Возвращает 0, если спрайт был установлен как неактивный с помощью SetSpriteActive, в противном случае возвращает 1.

---

<a name="method-getspeechvoicename"></a>

### GetSpeechVoiceName()
```php
GetSpeechVoiceName(int $index): string
```
Возвращает имя заданного голоса. На iOS это имя читается человеком, но не дает никаких подробностей о акценте или языке этого голоса. На Android имя дает информацию о языке и акценте, но не так легко читается.  В настоящее время работает только на iOS и Android.

---

<a name="method-getspritedistance"></a>

### GetSpriteDistance()
```php
GetSpriteDistance(int $iSprite1, int $iSprite2): float
```
Вычисляет минимальное расстояние, разделяющее два спрайта. Если спрайты перекрываются, это будет меньше 0. В противном случае это будет расстояние между ближайшими точками на каждом спрайте, эти точки можно найти с помощью GetSpriteDistancePoint1X и т. Д. Этот расчет занимает больше времени, чем просто проверка перекрытия спрайтов, если вам не нужно расстояние, разделяющее спрайты, используйте GetSpriteCollision. Эта функция не ограничена настройками группы или категории. Если вы не назначили форму ни одному из спрайтов с помощью SetSpriteShape, они будут использовать форму коробки по умолчанию, основанную на ширине и высоте спрайта.

---

<a name="method-getspeechvoiceid"></a>

### GetSpeechVoiceID()
```php
GetSpeechVoiceID(int $index): string
```
Возвращает идентификатор данного голоса. Идентификатор можно использовать с SetSpeechLanguageByID для выбора конкретного голоса.

---

<a name="method-getspeechnumvoices"></a>

### GetSpeechNumVoices()
```php
GetSpeechNumVoices(): int
```
Возвращает количество голосов, которые можно выбрать с помощью команды SetSpeechLanguage. Вы можете использовать команды GetSpeechVoiceName и GetSpeechVoiceLanguage, чтобы получить подробную информацию о различных голосах.  В настоящее время работает только на iOS и Android.

---

<a name="method-getspeechvoicelanguage"></a>

### GetSpeechVoiceLanguage()
```php
GetSpeechVoiceLanguage(int $index): string
```
Возвращает языковую строку данного голоса. Это можно использовать непосредственно с командой SetSpeechLanguage, чтобы использовать этот голос для любой будущей речи.  В настоящее время работает только на iOS и Android.

---

<a name="method-getsoundsplaying"></a>

### GetSoundsPlaying()
```php
GetSoundsPlaying(int $iID): int
```
Возвращает количество экземпляров этого звукового идентификатора, которые в данный момент воспроизводятся или зацикливаются. Это точно так же, как GetSoundInstances.

---

<a name="method-getsoundminrate"></a>

### GetSoundMinRate()
```php
GetSoundMinRate(): float
```
Получает минимальную скорость и какие звуковые файлы могут быть воспроизведены на этом устройстве. Скорость 1,0 - это нормальная скорость, скорость 2,0-это двойная скорость, 0,5-половина скорости и так далее. Если вы попытаетесь изменить скорость воспроизведения звука за пределами этих значений, она будет привязана к этим значениям. Если и min, и max возвращают 1.0, то изменение скорости воспроизведения звука на этом устройстве не поддерживается.

---

<a name="method-getsoundmaxrate"></a>

### GetSoundMaxRate()
```php
GetSoundMaxRate(): float
```
Получает максимальную скорость и какие звуковые файлы могут быть воспроизведены на этом устройстве. Скорость 1,0 - это нормальная скорость, скорость 2,0-это двойная скорость, 0,5-половина скорости и так далее. Если вы попытаетесь изменить скорость воспроизведения звука за пределами этих значений, она будет привязана к этим значениям. Если и min, и max возвращают 1.0, то изменение скорости воспроизведения звука на этом устройстве не поддерживается.

---

<a name="method-getsoundinstances"></a>

### GetSoundInstances()
```php
GetSoundInstances(int $iID): int
```
Возвращает количество экземпляров этого звукового идентификатора, которые в данный момент воспроизводятся или зацикливаются. Это точно так же, как GetSoundsPlaying.

---

<a name="method-getsoundinstancerate"></a>

### GetSoundInstanceRate()
```php
GetSoundInstanceRate(int $iID): float
```
Возвращает текущую скорость воспроизведения указанного экземпляра, где 1.0-нормальная скорость, 2.0 - двойная скорость и т. Д. Не все устройства гарантированно поддерживают изменение скорости воспроизведения.

---

<a name="method-getsoundinstancevolume"></a>

### GetSoundInstanceVolume()
```php
GetSoundInstanceVolume(int $iID): int
```
Возвращает текущий объем указанного экземпляра в диапазоне от 0 до 100.

---

<a name="method-getsoundinstanceplaying"></a>

### GetSoundInstancePlaying()
```php
GetSoundInstancePlaying(int $iID): int
```
Возвращает 1, если данный экземпляр все еще воспроизводится или зацикливается, и 0, если он остановился. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука. Как только эта команда вернет 0, экземпляр будет удален и на него больше нельзя будет ссылаться, любая попытка изменить его будет проигнорирована. Вам нужно будет создать новый экземпляр, снова используя PlaySound.

---

<a name="method-getsoundinstanceloopcount"></a>

### GetSoundInstanceLoopCount()
```php
GetSoundInstanceLoopCount(int $iID): int
```
Если звук воспроизводился с включенным циклированием, эта команда возвращает количество завершенных до сих пор циклов. Если экземпляр использует фиксированное количество циклов, то он никогда на самом деле не достигнет этого значения количества циклов, так как будет немедленно удален по достижении конца своего последнего цикла. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.

---

<a name="method-getsocketstring"></a>

### GetSocketString()
```php
GetSocketString(int $socketID): string
```
Будет считывать строку из соединения сокета и возвращать ее. Если вы отправляете строку из источника, отличного от AGK, то строка должна начинаться со значения длины 4 байта, за которым следует X байт строковых данных, где X-значение длины. Строка не должна заканчиваться null. Если существует менее 4 байт данных, ожидающих чтения, то эта команда немедленно вернется и вернет пустую строку. Вы можете проверить, сколько данных нужно прочитать, используя GetSocketBytesAvailable. Если есть 4 или более байтов, ожидающих чтения, то эта команда будет ждать, пока вся строка не будет получена, прежде чем вернуться.

---

<a name="method-getsocketremoteip"></a>

### GetSocketRemoteIP()
```php
GetSocketRemoteIP(int $socketID): string
```
Возвращает IP-адрес компьютера или устройства на другом конце соединения. Это может быть адрес IPv4 или IPv6.

---

<a name="method-getsoundexists"></a>

### GetSoundExists()
```php
GetSoundExists(int $iID): int
```
Возвращает значение 1, если указанный звуковой номер существует, в противном случае возвращается 0.

---

<a name="method-getsocketlistenerconnection"></a>

### GetSocketListenerConnection()
```php
GetSocketListenerConnection(int $listenerID): int
```
Возвращает идентификатор сокета, подключенного к вашему устройству. Прослушиватель будет принимать соединения в фоновом режиме и добавлять их в очередь, эта команда удаляет один из сокетов из очереди и передает вам управление им. Если вы не хотите принимать соединение, вы должны удалить его с помощью DeleteSocket. Вы должны вызвать GetSocketListenerConnection в цикле до тех пор, пока он не вернет 0, чтобы убедиться, что вы справились со всеми подключенными сокетами. Вы можете узнать IP-адрес устройства, которое подключилось к вам, вызвав GetSocketRemoteIP на возвращенном сокете.

---

<a name="method-getsocketfloat"></a>

### GetSocketFloat()
```php
GetSocketFloat(int $socketID): float
```
Будет считывать 4-байтовый поплавок из соединения сокета и возвращать его. Если существует менее 4 байт данных, ожидающих чтения, то эта команда немедленно вернется и вернет 0. Вы можете проверить, сколько данных нужно прочитать, используя GetSocketBytesAvailable.

---

<a name="method-getsocketconnected"></a>

### GetSocketConnected()
```php
GetSocketConnected(int $socketID): int
```
Возвращает 1, если указанный сокет подключен, и 0, если он все еще находится в процессе подключения. Если сокет будет отключен или не сможет подключиться, то это вернет -1.

---

<a name="method-getsocketexists"></a>

### GetSocketExists()
```php
GetSocketExists(int $socketID): int
```
Возвращает 1, если указанный сокет существует, и 0 в противном случае.

---

<a name="method-getsocketbytesavailable"></a>

### GetSocketBytesAvailable()
```php
GetSocketBytesAvailable(int $socketID): int
```
Возвращает количество байтов, доступных для чтения. Если это возвращает 0, то команды чтения, такие как GetSocketInteger, не будут возвращать никаких данных.

---

<a name="method-getskeleton2dy"></a>

### GetSkeleton2DY()
```php
GetSkeleton2DY(int $iSkeleton): float
```
Получает Y-положение корня скелета, не изменяется во время анимации.

---

<a name="method-getskeleton2dx"></a>

### GetSkeleton2DX()
```php
GetSkeleton2DX(int $iSkeleton): float
```
Получает положение X корня скелета, не изменяется во время анимации.

---

<a name="method-getskeleton2distweening"></a>

### GetSkeleton2DIsTweening()
```php
GetSkeleton2DIsTweening(int $iSkeleton): int
```
возвращает 1, если скелет переходит в анимационный кадр.

---

<a name="method-getskeleton2disanimating"></a>

### GetSkeleton2DIsAnimating()
```php
GetSkeleton2DIsAnimating(int $iSkeleton): int
```
возвращает 1, если скелет анимируется или переходит в первый кадр воспроизводимой анимации

---

<a name="method-getsocketinteger"></a>

### GetSocketInteger()
```php
GetSocketInteger(int $socketID): int
```
Будет считывать 4-байтовое целое число из соединения сокета и возвращать его. Если существует менее 4 байт данных, ожидающих чтения, то эта команда немедленно вернется и вернет 0. Вы можете проверить, сколько данных нужно прочитать, используя GetSocketBytesAvailable.

---

<a name="method-getskeleton2dexists"></a>

### GetSkeleton2DExists()
```php
GetSkeleton2DExists(int $iSkeleton): int
```
Возвращает 1, если скелет существует с указанным идентификатором, в противном случае 0.

---

<a name="method-getskeleton2ddepth"></a>

### GetSkeleton2DDepth()
```php
GetSkeleton2DDepth(int $iSkeleton): int
```
Получает текущую глубину скелета. Это находится в диапазоне 0-10000. 0 находится сверху, 10000 - сзади

---

<a name="method-getskeleton2dcurrenttime"></a>

### GetSkeleton2DCurrentTime()
```php
GetSkeleton2DCurrentTime(int $iSkeleton): float
```
Получить текущее время текущей воспроизводимой анимации в секундах

---

<a name="method-getsocketbyte"></a>

### GetSocketByte()
```php
GetSocketByte(int $socketID): int
```
Будет считывать один байт из сокета соединения и возвращать его. Если нет данных, ожидающих чтения, то эта команда немедленно вернется и вернет 0. Вы можете проверить, сколько данных нужно прочитать, используя GetSocketBytesAvailable.

---

<a name="method-getskeleton2dboney"></a>

### GetSkeleton2DBoneY()
```php
GetSkeleton2DBoneY(int $iSkeleton, int $bone): float
```
Возвращает исходное положение Y указанной кости, также известное как установочная поза. Это значение не изменится, пока кость анимируется, вместо этого анимация строится поверх установочной позы, чтобы создать положение кости, видимое на экране. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.

---

<a name="method-getsmartwatchstate"></a>

### GetSmartWatchState()
```php
GetSmartWatchState(): int
```
Возвращает текущее состояние подключения смарт-часов: 0=начальное состояние, ActivateSmartWatch не вызывался. 1=подключение, через мгновение перейдет в более детальное состояние. 2=соединение успешно, вы можете отправлять и получать данные. -1=команды watch не поддерживаются на этом устройстве. -2=соединение не удалось или часы не найдены. -3=часы найдены, но в данный момент они не сопряжены с устройством, -4=часы найдены, но наше приложение для часов в данный момент не установлено.  В настоящее время работает только на iOS.

---

<a name="method-getskeleton2dbonex"></a>

### GetSkeleton2DBoneX()
```php
GetSkeleton2DBoneX(int $iSkeleton, int $bone): float
```
Возвращает исходное положение X указанной кости, также известное как установочная поза. Это значение не изменится, пока кость анимируется, вместо этого анимация строится поверх установочной позы, чтобы создать положение кости, видимое на экране. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.

---

<a name="method-getskeleton2dboneparent"></a>

### GetSkeleton2DBoneParent()
```php
GetSkeleton2DBoneParent(int $iSkeleton, int $bone): int
```
Возвращает идентификатор родителя указанной кости. Если кость не существует или у нее нет родителя, она вернет -1. Индексы начинаются с 0.

---

<a name="method-getskeleton2dbonecurry"></a>

### GetSkeleton2DBoneCurrY()
```php
GetSkeleton2DBoneCurrY(int $iSkeleton, int $bone): float
```
Возвращает текущее положение Y указанной кости в ее текущем анимированном положении. Это значение будет меняться во время анимации кости. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.

---

<a name="method-getskeleton2dbonecurrangle"></a>

### GetSkeleton2DBoneCurrAngle()
```php
GetSkeleton2DBoneCurrAngle(int $iSkeleton, int $bone): float
```
Возвращает текущий угол указанной кости в ее текущем анимированном положении. Это значение будет меняться во время анимации кости. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.

---

<a name="method-getskeleton2dbone"></a>

### GetSkeleton2DBone()
```php
GetSkeleton2DBone(int $iSkeleton, string $name): int
```
Возвращает идентификатор указанной кости для этого скелета. Если кости с заданным именем не существует, она вернет -1. Индекс 0-это допустимая кость.

---

<a name="method-getskeleton2danimationtime"></a>

### GetSkeleton2DAnimationTime()
```php
GetSkeleton2DAnimationTime(int $iSkeleton, string $anim): float
```
получить общее время именованной анимации

---

<a name="method-getskeleton2dangle"></a>

### GetSkeleton2DAngle()
```php
GetSkeleton2DAngle(int $iSkeleton): float
```
Получает угол наклона корня скелета, не меняется во время анимации.

---

<a name="method-getshadowpolygonsdrawn"></a>

### GetShadowPolygonsDrawn()
```php
GetShadowPolygonsDrawn(): int
```
Возвращает количество полигонов, нарисованных последним кадром графического процессора при построении теневых карт.

---

<a name="method-getshadowmappingsupported"></a>

### GetShadowMappingSupported()
```php
GetShadowMappingSupported(): int
```
Возвращает 1, если теневое отображение поддерживается на этом устройстве, и 0 в противном случае.

---

<a name="method-getshadowmappingmode"></a>

### GetShadowMappingMode()
```php
GetShadowMappingMode(): int
```
Возвращает текущий режим отображения теней, который был установлен с помощью SetShadowMappingMode

---

<a name="method-getshaderexists"></a>

### GetShaderExists()
```php
GetShaderExists(int $shaderID): int
```
Возвращает 1, если шейдер в данный момент загружен с заданным идентификатором, в противном случае он возвращает 0.

---

<a name="method-getsecondsfromunix"></a>

### GetSecondsFromUnix()
```php
GetSecondsFromUnix(int $unixtime): int
```
Возвращает секунды заданного значения времени unix (от 0 до 59). Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным.

---

<a name="method-getseconds"></a>

### GetSeconds()
```php
GetSeconds(): int
```
Получите количество целых секунд с момента запуска приложения. С точностью до 1 секунды.  Вызов этой команды внутренне вызовет системный вызов, чтобы получить количество прошедшего времени, поэтому он может меняться каждый раз, когда вы его вызываете.

---

<a name="method-getskeleton2dbonecurrx"></a>

### GetSkeleton2DBoneCurrX()
```php
GetSkeleton2DBoneCurrX(int $iSkeleton, int $bone): float
```
Возвращает текущее положение X указанной кости в ее текущем анимированном положении. Это значение будет меняться во время анимации кости. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.

---

<a name="method-getskeleton2dboneangle"></a>

### GetSkeleton2DBoneAngle()
```php
GetSkeleton2DBoneAngle(int $iSkeleton, int $bone): float
```
Возвращает исходный угол указанной кости, также известный как установочная поза. Это значение не изменится, пока кость анимируется, вместо этого анимация строится поверх установочной позы, чтобы создать вращение кости, видимое на экране. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.

---

<a name="method-getscreenyfrom3d"></a>

### GetScreenYFrom3D()
```php
GetScreenYFrom3D(float $x, float $y, float $z): float
```
Преобразует 3D-точку в экранные координаты.

---

<a name="method-getscreenboundstop"></a>

### GetScreenBoundsTop()
```php
GetScreenBoundsTop(): float
```
Возвращает верхний край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть черные границы в верхней и нижней части дисплея, то это значение будет отрицательным. Это означает, что 0-это конец видимой области и начало черной границы, а верхняя граница - это конец черной границы и край экрана. Если сверху нет черной границы, то верхняя граница всегда будет равна 0.

---

<a name="method-getscreenxfrom3d"></a>

### GetScreenXFrom3D()
```php
GetScreenXFrom3D(float $x, float $y, float $z): float
```
Преобразует 3D-точку в экранные координаты.

---

<a name="method-getscreenboundsright"></a>

### GetScreenBoundsRight()
```php
GetScreenBoundsRight(): float
```
Возвращает правый край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть черные границы слева и справа от дисплея, то это значение будет больше, чем GetVirtualWidth. Это означает, что виртуальная ширина-это конец видимой области и начало черной границы, а правая граница - это конец черной границы и край экрана. Если справа нет черной границы, то правая граница всегда будет равна GetVirtualWidth.

---

<a name="method-getscreenboundsleft"></a>

### GetScreenBoundsLeft()
```php
GetScreenBoundsLeft(): float
```
Возвращает левый край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть черные границы слева и справа от дисплея, то это значение будет отрицательным. Это означает, что 0-это конец видимой области и начало черной границы, а левая граница - это конец черной границы и край экрана. Если слева нет черной границы, то левая граница всегда будет равна 0.

---

<a name="method-getscreenboundsbottom"></a>

### GetScreenBoundsBottom()
```php
GetScreenBoundsBottom(): float
```
Возвращает нижний край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть черные границы в верхней и нижней части дисплея, то это значение будет больше, чем GetVirtualHeight. Это означает, что виртуальная высота является концом видимой области и началом черной границы, а нижняя граница-концом черной границы и краем экрана. Если внизу нет черной границы, то нижняя граница всегда будет равна GetVirtualHeight.

---

<a name="method-getrewardadvalueadmob"></a>

### GetRewardAdValueAdMob()
```php
GetRewardAdValueAdMob(): int
```
Возвращает значение загруженного в данный момент объявления о вознаграждении, это вернет 0, если значение вознаграждения неизвестно. Если в данный момент не загружено ни одно объявление о вознаграждении, то это значение не определено, оно может быть равно 0 или это может быть значение предыдущего объявления. Вы должны спросить пользователя, хочет ли он просмотреть объявление о вознаграждении, прежде чем показывать его, а также вознаграждение, которое он получит за это. Вы можете использовать эту функцию значения для определения подходящего вознаграждения. Это значение останется неизменным при вызове ResetRewardAdMob

---

<a name="method-getrotationvectorsensorexists"></a>

### GetRotationVectorSensorExists()
```php
GetRotationVectorSensorExists(): int
```
Возвращает 1, если текущее устройство имеет датчик вектора вращения, который в настоящее время поддерживается AGK, и 0, если нет.

---

<a name="method-getrewardadrewardedchartboost"></a>

### GetRewardAdRewardedChartboost()
```php
GetRewardAdRewardedChartboost(): int
```
Возвращает 1, если ранее показанное объявление о вознаграждении привело к вознаграждению, которое должно быть дано пользователю, например, некоторые внутриигровые монеты. При вызове ShowRewardAdAdMob это значение устанавливается равным 0 и устанавливается равным 1 только в том случае, если пользователь завершил бонусное видео, в противном случае оно останется равным 0. После того как вы дали пользователю вознаграждение, вы можете установить его обратно в 0 с помощью ResetRewardAdMob.

---

<a name="method-getrewardadloadedchartboost"></a>

### GetRewardAdLoadedChartboost()
```php
GetRewardAdLoadedChartboost(): int
```
Возвращает 1, если есть предварительно загруженное и готовое к показу объявление Chartboost reward, в противном случае 0. Если это так, вы можете отобразить его с помощью ShowRewardAdChartboost. Объявления предварительно загружаются после вызова CacheRewardAdChartboost и после того, как каждое объявление о вознаграждении отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают 0, вы можете попробовать снова позвонить в CacheRewardAdChartboost, чтобы перезапустить процесс загрузки и посмотреть, стали ли доступны новые объявления.

---

<a name="method-getrewardadloadedadmob"></a>

### GetRewardAdLoadedAdMob()
```php
GetRewardAdLoadedAdMob(): int
```
Возвращает 1, если объявление AdMob reward предварительно загружено и готово к показу, в противном случае 0. Если это так, вы можете отобразить его с помощью ShowRewardAdAdMob. Объявления предварительно загружаются, как только вы устанавливаете свои данные о вознаграждении AdMob, и после того, как каждое объявление о вознаграждении отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают 0, то вы можете попробовать вызвать ShowRewardAdAdMob в любом случае, он ничего не покажет, так как ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны какие-либо новые объявления.

---

<a name="method-getresumed"></a>

### GetResumed()
```php
GetResumed(): int
```
Возвращает 1, если ваше приложение было передано в фоновый режим и только что было повторно активировано. Когда это произойдет, вы должны активировать экран паузы. На мобильных платформах приложения не будут работать, пока они находятся в фоновом режиме, так что первый шанс, что ваше приложение получит это уведомление, - это когда оно вернется из фонового режима и продолжит работу. Поскольку пользователь, возможно, еще не готов продолжить воспроизведение, вы должны проверить это значение и показать экран паузы до тех пор, пока он не будет готов.

---

<a name="method-getreadpath"></a>

### GetReadPath()
```php
GetReadPath(): string
```
Возвращает каталог, содержащий исполняемый файл приложения на текущей платформе, на которой оно запущено. Обратите внимание, что на Android этот путь недоступен при обычном использовании и вернет пустую строку.

---

<a name="method-getraycastx"></a>

### GetRayCastX()
```php
GetRayCastX(): float
```
Возвращает координату X точки пересечения последней проверки приведения луча. Результат - в мировых координатах.

---

<a name="method-getraycastnormaly"></a>

### GetRayCastNormalY()
```php
GetRayCastNormalY(): float
```
Возвращает компонент Y нормали самой последней проверки приведения луча. Это не будет единичный вектор, так как он был преобразован в мировые координаты.

---

<a name="method-getraycastnormalx"></a>

### GetRayCastNormalX()
```php
GetRayCastNormalX(): float
```
Возвращает X-компоненту нормали самой последней проверки приведения луча. Это не будет единичный вектор, так как он был преобразован в мировые координаты.

---

<a name="method-getrewardadrewardedadmob"></a>

### GetRewardAdRewardedAdMob()
```php
GetRewardAdRewardedAdMob(): int
```
Возвращает 1, если ранее показанное объявление о вознаграждении привело к вознаграждению, которое должно быть дано пользователю, например, некоторые внутриигровые монеты. При вызове ShowRewardAdAdMob это значение устанавливается равным 0 и устанавливается равным 1 только в том случае, если пользователь завершил бонусное видео, в противном случае оно останется равным 0. После того как вы дали пользователю вознаграждение, вы можете установить его обратно в 0 с помощью ResetRewardAdMob.

---

<a name="method-getrenderername"></a>

### GetRendererName()
```php
GetRendererName(): string
```
Возвращает имя текущего средства визуализации, например "OpenGL" или "OpenGLES"

---

<a name="method-getrawtouchvalue"></a>

### GetRawTouchValue()
```php
GetRawTouchValue(int $iIndex): int
```
Извлекает значение, ранее сохраненное в этом событии с помощью SetRawTouchValue.

---

<a name="method-getraycastfraction"></a>

### GetRayCastFraction()
```php
GetRayCastFraction(): float
```
Возвращает долю луча, пройденного до достижения столкновения. 0 означает начало луча, а 1.0-его конец.

---

<a name="method-getraycasty"></a>

### GetRayCastY()
```php
GetRayCastY(): float
```
Возвращает координату Y точки пересечения последней проверки приведения луча. Результат - в мировых координатах.

---

<a name="method-getrawtouchtype"></a>

### GetRawTouchType()
```php
GetRawTouchType(int $iIndex): int
```
Возвращает тип данного события касания. Все, в чем вы можете быть уверены при неизвестных событиях, - это то, что палец в данный момент находится на экране и находится там менее 1 секунды. Через 1 секунду он автоматически становится событием удержания. Если пользователь поднимает палец с экрана до этого, то это становится коротким событием, а если он перемещает палец дальше, чем расстояние, указанное SetRawTouchMoveSensitivity, то это становится событием перетаскивания. Если текущее событие неизвестно, то оно возвращает 0. События могут измениться с событий удержания на события перетаскивания, но короткие события и события перетаскивания не изменяют тип. Неизвестные события гарантированно изменят тип, как только появится дополнительная информация. Возможные возвращаемые значения-0 для обозначения неизвестного, 1 для короткого касания, 2 для удержания и 3 для перетаскивания.

---

<a name="method-getrawtouchstarty"></a>

### GetRawTouchStartY()
```php
GetRawTouchStartY(int $iIndex): float
```
Возвращает положение Y в координатах экрана, в котором началось событие касания. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldY.

---

<a name="method-getrawtouchtime"></a>

### GetRawTouchTime()
```php
GetRawTouchTime(int $iIndex): float
```
Возвращает общее время, которое заняло это событие, от нажатия до выпуска в секундах.

---

<a name="method-getraycastspriteid"></a>

### GetRayCastSpriteID()
```php
GetRayCastSpriteID(): int
```
Возвращает идентификатор спрайта, попавшего в самую последнюю проверку ray cast. Если луч попал в не спрайтовую фигуру, то будет возвращено 0.

---

<a name="method-getrawtouchstartx"></a>

### GetRawTouchStartX()
```php
GetRawTouchStartX(int $iIndex): float
```
Возвращает позицию X в координатах экрана, где началось событие касания. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldX.

---

<a name="method-getrawtouchlasty"></a>

### GetRawTouchLastY()
```php
GetRawTouchLastY(int $iIndex): float
```
Возвращает позицию Y в координатах экрана, где событие касания было записано в последний раз до его текущего местоположения. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldY.

---

<a name="method-getrawtouchlastx"></a>

### GetRawTouchLastX()
```php
GetRawTouchLastX(int $iIndex): float
```
Возвращает позицию X в координатах экрана, где событие касания было записано в последний раз до его текущего местоположения. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldX.

---

<a name="method-getrawtouchcurrentx"></a>

### GetRawTouchCurrentX()
```php
GetRawTouchCurrentX(int $iIndex): float
```
Возвращает позицию X в координатах экрана, где в данный момент находится событие касания. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldX.

---

<a name="method-getrawtouchcurrenty"></a>

### GetRawTouchCurrentY()
```php
GetRawTouchCurrentY(int $iIndex): float
```
Возвращает положение Y в координатах экрана, где в данный момент находится событие касания. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldY.

---

<a name="method-getrawtouchcount"></a>

### GetRawTouchCount()
```php
GetRawTouchCount(int $bIncludeUnknown): int
```
Возвращает количество событий касания, происходящих в данный момент. По умолчанию AGK не считает событие до тех пор, пока не узнает, какой это тип события, например короткое, длинное, перетаскивание и т. Д. Чтобы также подсчитать неизвестные события, установите значение bIncludeUnknown равным 1. Используйте 0, чтобы игнорировать неизвестные события.

---

<a name="method-getrawrotationvectorz2"></a>

### GetRawRotationVectorZ2()
```php
GetRawRotationVectorZ2(): float
```
Возвращает Z-компонент текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите сориентировать объект, используйте GetRawRotationVectorZ

---

<a name="method-getrawrotationvectory2"></a>

### GetRawRotationVectorY2()
```php
GetRawRotationVectorY2(): float
```
Возвращает компонент Y текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите сориентировать объект, используйте GetRawRotationVectorY

---

<a name="method-getrawrotationvectorz"></a>

### GetRawRotationVectorZ()
```php
GetRawRotationVectorZ(): float
```
Возвращает Z-компонент текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorZ2

---

<a name="method-getrawrotationvectory"></a>

### GetRawRotationVectorY()
```php
GetRawRotationVectorY(): float
```
Возвращает компонент Y текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorY2

---

<a name="method-getrawrotationvectorx2"></a>

### GetRawRotationVectorX2()
```php
GetRawRotationVectorX2(): float
```
Возвращает компонент X текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите сориентировать объект, используйте GetRawRotationVectorX

---

<a name="method-getrawrotationvectorx"></a>

### GetRawRotationVectorX()
```php
GetRawRotationVectorX(): float
```
Возвращает компонент X текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorX2

---

<a name="method-getrawrotationvectorw2"></a>

### GetRawRotationVectorW2()
```php
GetRawRotationVectorW2(): float
```
Возвращает W-компонент текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите сориентировать объект, используйте GetRawRotationVectorW

---

<a name="method-getrawrotationvectorw"></a>

### GetRawRotationVectorW()
```php
GetRawRotationVectorW(): float
```
Возвращает W-компонент текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorW2

---

<a name="method-getrawproximitydistance"></a>

### GetRawProximityDistance()
```php
GetRawProximityDistance(): float
```
Если датчик приближения существует, возвращает расстояние устройства от любого объекта, находящегося в данный момент перед ним, непроверенное, поскольку ни одно устройство не поддерживало его во время тестирования.

---

<a name="method-getrawtouchreleased"></a>

### GetRawTouchReleased()
```php
GetRawTouchReleased(int $iIndex): int
```
Возвращает 1 если прикосновение было отпущено, это всегда будет 1 для коротких событий, события удержания и перетаскивания будут продолжать сообщать 0 до тех пор, пока они не будут отпущены, и в этот момент вы, возможно, захотите предпринять какие-то действия. Каждое событие будет сообщаться только как 1 раз, прежде чем быть удаленным из списка событий. Если событие касания игнорируется (не запрашивается) в течение одного кадра после его освобождения, оно будет удалено из списка событий.

---

<a name="method-getrawnexttouchevent"></a>

### GetRawNextTouchEvent()
```php
GetRawNextTouchEvent(): int
```
Возвращает индекс к следующему событию касания, доступному для чтения, если больше нет доступных событий, он возвращает 0.

---

<a name="method-getrawmousey"></a>

### GetRawMouseY()
```php
GetRawMouseY(): float
```
Возвращает компонент Y текущего положения мыши в координатах экрана. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousex"></a>

### GetRawMouseX()
```php
GetRawMouseX(): float
```
Возвращает компонент X текущего положения мыши в координатах экрана. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousewheeldelta"></a>

### GetRawMouseWheelDelta()
```php
GetRawMouseWheelDelta(): float
```
Возвращает разницу между текущим положением колесика мыши и предыдущим положением колесика мыши, может быть положительной или отрицательной, обновляется один раз в кадр. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousewheel"></a>

### GetRawMouseWheel()
```php
GetRawMouseWheel(): float
```
Возвращает текущее положение колесика мыши, может быть положительным или отрицательным, начинается с 0. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmouserightstate"></a>

### GetRawMouseRightState()
```php
GetRawMouseRightState(): int
```
Возвращает 1, если правая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmouserightreleased"></a>

### GetRawMouseRightReleased()
```php
GetRawMouseRightReleased(): int
```
Возвращает 1, если правая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmouserightpressed"></a>

### GetRawMouseRightPressed()
```php
GetRawMouseRightPressed(): int
```
Возвращает 1, если была нажата правая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousemiddlestate"></a>

### GetRawMouseMiddleState()
```php
GetRawMouseMiddleState(): int
```
Возвращает 1, если средняя кнопка мыши в данный момент опущена, и 0, если нет. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousemiddlereleased"></a>

### GetRawMouseMiddleReleased()
```php
GetRawMouseMiddleReleased(): int
```
Возвращает 1, если средняя кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousemiddlepressed"></a>

### GetRawMouseMiddlePressed()
```php
GetRawMouseMiddlePressed(): int
```
Возвращает 1, если была нажата средняя кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmouseleftstate"></a>

### GetRawMouseLeftState()
```php
GetRawMouseLeftState(): int
```
Возвращает 1, если левая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousefourthreleased"></a>

### GetRawMouseFourthReleased()
```php
GetRawMouseFourthReleased(): int
```
Возвращает 1, если четвертая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousefourthpressed"></a>

### GetRawMouseFourthPressed()
```php
GetRawMouseFourthPressed(): int
```
Возвращает 1, если была нажата четвертая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousefifthstate"></a>

### GetRawMouseFifthState()
```php
GetRawMouseFifthState(): int
```
Возвращает 1, если пятая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousefifthreleased"></a>

### GetRawMouseFifthReleased()
```php
GetRawMouseFifthReleased(): int
```
Возвращает 1, если пятая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousefifthpressed"></a>

### GetRawMouseFifthPressed()
```php
GetRawMouseFifthPressed(): int
```
Возвращает 1, если была нажата пятая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmagneticz"></a>

### GetRawMagneticZ()
```php
GetRawMagneticZ(): float
```
Если магнитный датчик существует, возвращает Z-компоненту любого окружающего магнитного поля. На iOS может потребоваться несколько секунд, чтобы начать отображать данные, отличные от 0, во время этого процесса устройство использует данные движения для калибровки магнитного датчика

---

<a name="method-getrawmouseleftreleased"></a>

### GetRawMouseLeftReleased()
```php
GetRawMouseLeftReleased(): int
```
Возвращает 1, если левая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmousefourthstate"></a>

### GetRawMouseFourthState()
```php
GetRawMouseFourthState(): int
```
Возвращает 1, если четвертая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmagneticy"></a>

### GetRawMagneticY()
```php
GetRawMagneticY(): float
```
Если магнитный датчик существует, возвращает Y-компоненту любого окружающего магнитного поля. На iOS может потребоваться несколько секунд, чтобы начать отображать данные, отличные от 0, во время этого процесса устройство использует данные движения для калибровки магнитного датчика

---

<a name="method-getrawmouseleftpressed"></a>

### GetRawMouseLeftPressed()
```php
GetRawMouseLeftPressed(): int
```
Возвращает 1, если была нажата левая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если мыши не существует, она всегда будет возвращать 0.

---

<a name="method-getrawmagneticx"></a>

### GetRawMagneticX()
```php
GetRawMagneticX(): float
```
Если магнитный датчик существует, возвращает X-компоненту любого окружающего магнитного поля. На iOS может потребоваться несколько секунд, чтобы начать отображать данные, отличные от 0, во время этого процесса устройство использует данные движения для калибровки магнитного датчика

---

<a name="method-getrawlightlevel"></a>

### GetRawLightLevel()
```php
GetRawLightLevel(): float
```
Если датчик окружающего света существует, получите измерение окружающего света в люмел в виде поплавка.

---

<a name="method-getrawlastkey"></a>

### GetRawLastKey()
```php
GetRawLastKey(): int
```
Возвращает код последней нажатой клавиши. Это относится только к платформам с полноразмерной клавиатурой, таким как ПК, Mac и Linux. Вы можете проверить, существует ли клавиатура, используя GetKeyboardExists. Эта функция продолжает возвращать последнюю нажатую клавишу даже после того, как она была отпущена. Проверьте страницу коды сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому коду ключа

---

<a name="method-getrawkeystate"></a>

### GetRawKeyState()
```php
GetRawKeyState(int $key): int
```
Возвращает 1, если данный код ключа в данный момент не работает. 0, если он поднят. Это относится только к платформам с полноразмерной клавиатурой, таким как ПК и Mac, в противном случае все клавиши вернут 0. Вы можете проверить, существует ли клавиатура, проверив, что GetKeyboardExists возвращает 1. Коды клавиш находятся в диапазоне от 0 до 255, все, что выходит за пределы диапазона, возвращает 0. Проверьте страницу коды сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому коду ключа

---

<a name="method-getrawkeyreleased"></a>

### GetRawKeyReleased()
```php
GetRawKeyReleased(int $key): int
```
Возвращает 1, если данный код ключа был выпущен в этом кадре, а затем возвращает 0, пока ключ находится вверх. Это относится только к платформам с полноразмерной клавиатурой, таким как ПК и Mac, в противном случае все клавиши вернут 0. Вы можете проверить, существует ли клавиатура, проверив, что GetKeyboardExists возвращает 1. Коды клавиш находятся в диапазоне от 0 до 255, все, что выходит за пределы диапазона, возвращает 0. Проверьте страницу коды сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому коду ключа

---

<a name="method-getrawkeypressed"></a>

### GetRawKeyPressed()
```php
GetRawKeyPressed(int $key): int
```
Возвращает 1, если данный код клавиши был нажат в этом кадре, а затем возвращает 0, пока клавиша удерживается нажатой. Это относится только к платформам с полноразмерной клавиатурой, таким как ПК и Mac, в противном случае все клавиши вернут 0. Вы можете проверить, существует ли клавиатура, проверив, что GetKeyboardExists возвращает 1. Коды клавиш находятся в диапазоне от 0 до 255, все, что выходит за пределы диапазона, возвращает 0. Проверьте страницу коды сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому коду ключа

---

<a name="method-getrawjoystickz"></a>

### GetRawJoystickZ()
```php
GetRawJoystickZ(int $index): float
```
Возвращает текущее значение Z (если применимо) для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0.

---

<a name="method-getrawjoystickslider"></a>

### GetRawJoystickSlider()
```php
GetRawJoystickSlider(int $index, int $slider): int
```
Возвращает текущее значение ползунка джойстика, которое может варьироваться в зависимости от типа джойстика. В настоящее время индекс ползунка должен быть либо 0, либо 1. Ползунки обычно используются для дополнительных осей.

---

<a name="method-getrawjoysticky"></a>

### GetRawJoystickY()
```php
GetRawJoystickY(int $index): float
```
Возвращает текущее значение Y для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0.

---

<a name="method-getrawjoystickx"></a>

### GetRawJoystickX()
```php
GetRawJoystickX(int $index): float
```
Возвращает текущее значение X для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0.

---

<a name="method-getrawjoystickrz"></a>

### GetRawJoystickRZ()
```php
GetRawJoystickRZ(int $index): float
```
Возвращает текущее вращательное значение Z (если применимо) для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. На самом деле некоторые джойстики используют это значение для второго аналогового джойстика.

---

<a name="method-getrawjoystickname"></a>

### GetRawJoystickName()
```php
GetRawJoystickName(int $index): string
```
Возвращает имя джойстика, обнаруженное операционной системой, в настоящее время работает только на Windows и Linux. В Tier 2 строка кодируется в UTF-8 и должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.

---

<a name="method-getrawjoystickrx"></a>

### GetRawJoystickRX()
```php
GetRawJoystickRX(int $index): float
```
Возвращает текущее вращательное значение X (если применимо) для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. На самом деле некоторые джойстики используют это значение для второго аналогового джойстика.

---

<a name="method-getrawjoystickpov"></a>

### GetRawJoystickPOV()
```php
GetRawJoystickPOV(int $index, int $pov): int
```
Возвращает текущее значение POV джойстика, это может варьироваться в зависимости от типа джойстика. В настоящее время индекс POV должен быть либо 0, 1, 2, либо 3

---

<a name="method-getrawjoystickexists"></a>

### GetRawJoystickExists()
```php
GetRawJoystickExists(int $index): int
```
Возвращает 1, если джойстик существует в данном индексе. Физические джойстики обнаруживаются при запуске и постепенно помещаются в идентификаторы 1-8. Вы должны вызвать CompleteRawJoystickDetection в какой-то момент перед этой командой, чтобы убедиться, что все присутствующие джойстики были обнаружены. После первоначального процесса обнаружения подключение дополнительных джойстиков не будет обнаружено (за исключением Android, который обнаружит новые джойстики). Отсоединение джойстика не приведет к удалению его индекса, и эта команда все равно вернет 1. Вы можете использовать GetRawJoystickConnected для обнаружения отсоединения ранее обнаруженного джойстика. Если отсоединенный джойстик будет снова подключен, AGK попытается снова подключиться к нему. Альтернативная версия этой команды существует GetJoystickExists, и в этом случае она вернет 1, если есть какие-либо необработанные джойстики.

---

<a name="method-getrawjoystickconnected"></a>

### GetRawJoystickConnected()
```php
GetRawJoystickConnected(int $index): int
```
Возвращает 1, если указанный джойстик подключен, и 0, если нет. Это относится только к джойстикам, которые были подключены при запуске приложения, подключение нового джойстика после запуска приложения не будет обнаружено. Используйте GetRawJoystickExists, чтобы узнать, какие джойстики были обнаружены при запуске. Эта команда в настоящее время не работает на Mac.

---

<a name="method-getrawjoystickbuttonstate"></a>

### GetRawJoystickButtonState()
```php
GetRawJoystickButtonState(int $index, int $button): int
```
Возвращает 1, если данная кнопка в данный момент опущена, в противном случае возвращает 0. Чтобы обнаружить экземпляр, в котором кнопка нажата или отпущена, используйте GetRawJoystickButtonPressed или GetRawJoystickButtonReleased. AGK поддерживает до 64 кнопок джойстика в диапазоне 1-64.

---

<a name="method-getrawjoystickbuttonreleased"></a>

### GetRawJoystickButtonReleased()
```php
GetRawJoystickButtonReleased(int $index, int $button): int
```
Возвращает 1, если данная кнопка была отпущена в этом кадре, в противном случае возвращает 0. Как только кнопка была отпущена, эта функция возвращается к 0, чтобы проверить состояние кнопки, используйте GetRawJoystickButtonState. AGK поддерживает до 64 кнопок джойстика в диапазоне 1-64.

---

<a name="method-getrawgyrovelocityz"></a>

### GetRawGyroVelocityZ()
```php
GetRawGyroVelocityZ(): float
```
Если гироскоп существует, возвращает Z-составляющую текущей скорости вращения устройства. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании гироскопа.

---

<a name="method-getrawgyrovelocityy"></a>

### GetRawGyroVelocityY()
```php
GetRawGyroVelocityY(): float
```
Если гироскоп существует, возвращает Y-компоненту текущей скорости вращения устройства. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании гироскопа.

---

<a name="method-getrawgyrovelocityx"></a>

### GetRawGyroVelocityX()
```php
GetRawGyroVelocityX(): float
```
Если гироскоп существует, возвращает X-компоненту текущей скорости вращения устройства. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании гироскопа.

---

<a name="method-getrawjoystickry"></a>

### GetRawJoystickRY()
```php
GetRawJoystickRY(int $index): float
```
Возвращает текущее вращательное значение Y (если применимо) для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. На самом деле некоторые джойстики используют это значение для второго аналогового джойстика.

---

<a name="method-getrawgpslongitude"></a>

### GetRawGPSLongitude()
```php
GetRawGPSLongitude(): float
```
Возвращает самую последнюю доступную долготу.

---

<a name="method-getrawgpsaltitude"></a>

### GetRawGPSAltitude()
```php
GetRawGPSAltitude(): float
```
Возвращает самую актуальную высоту, доступную в метрах над уровнем моря.

---

<a name="method-getrawfoldernumfiles"></a>

### GetRawFolderNumFiles()
```php
GetRawFolderNumFiles(int $ID): int
```
Возвращает количество файлов, найденных при вызове OpenRawFolder.

---

<a name="method-getrawfoldernumfolders"></a>

### GetRawFolderNumFolders()
```php
GetRawFolderNumFolders(int $ID): int
```
Возвращает количество папок, найденных при вызове OpenRawFolder.

---

<a name="method-getrawfolderfoldername"></a>

### GetRawFolderFolderName()
```php
GetRawFolderFolderName(int $ID, int $index): string
```
Возвращая конкретное имя папки из списка файлов, индекс должен быть в диапазоне от 0 до GetRawFolderNumFolders минус один.

---

<a name="method-getrawfolderfilename"></a>

### GetRawFolderFileName()
```php
GetRawFolderFileName(int $ID, int $index): string
```
Возвращая конкретное имя файла из списка файлов, индекс должен быть в диапазоне от 0 до GetRawFolderNumFiles минус один.

---

<a name="method-getrawjoystickbuttonpressed"></a>

### GetRawJoystickButtonPressed()
```php
GetRawJoystickButtonPressed(int $index, int $button): int
```
Возвращает 1, если данная кнопка была нажата в этом кадре, в противном случае возвращает 0. После нажатия кнопки эта функция возвращается к 0, чтобы проверить состояние кнопки, используйте GetRawJoystickButtonState. AGK поддерживает до 64 кнопок джойстика в диапазоне 1-64.

---

<a name="method-getrawfirsttouchevent"></a>

### GetRawFirstTouchEvent()
```php
GetRawFirstTouchEvent(int $bIncludeUnknown): int
```
Возвращает индекс к первому событию касания, доступному для чтения. По умолчанию AGK не считает событие до тех пор, пока не узнает, какой это тип события, например короткое, длинное, перетаскивание и т. Д. Для получения неизвестных событий также установите значение bIncludeUnknown равным 1. Используйте 0, чтобы игнорировать неизвестные события. Все, в чем вы можете быть уверены при неизвестных событиях, - это то, что палец в данный момент находится на экране и находится там менее 1 секунды. Через 1 секунду он автоматически становится событием удержания. Если пользователь поднимает палец с экрана, это становится коротким событием, а если он двигает пальцем, это становится событием перетаскивания. Если никакие события не доступны, он возвращает 0.

---

<a name="method-getrawaccelz"></a>

### GetRawAccelZ()
```php
GetRawAccelZ(): float
```
Если акселерометр существует, возвращает текущее значение акселерометра для направления Z в диапазоне от -1 до 1. Положительное значение Z означает, что экран направлен вверх. Если акселерометр не существует, то он всегда будет возвращать 0, так как нет эмулируемой команды для направления Z. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана акселерометром. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании акселерометра.

---

<a name="method-getrawaccelx"></a>

### GetRawAccelX()
```php
GetRawAccelX(): float
```
Если акселерометр существует, возвращает текущее значение акселерометра для направления X в диапазоне от -1 до 1. Это соответствует экранной системе координат положительного существа справа. Если акселерометра не существует, то он всегда будет возвращать 0. Вы можете использовать команду GetDirectionX для эмуляции ввода направления. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана акселерометром. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании акселерометра.

---

<a name="method-getrawaccely"></a>

### GetRawAccelY()
```php
GetRawAccelY(): float
```
Если акселерометр существует, возвращает текущее значение акселерометра для направления Y в диапазоне от -1 до 1. Это соответствует экранной системе координат положительного бытия вниз. Если акселерометра не существует, то он всегда будет возвращать 0. Вы можете использовать команду GetDirectionY для эмуляции ввода направления. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана акселерометром. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании акселерометра.

---

<a name="method-getpushnotificationtoken"></a>

### GetPushNotificationToken()
```php
GetPushNotificationToken(): string
```
Возвращает маркер push-уведомления для этого устройства, он должен быть отправлен на ваш сервер, который отправляет уведомления, чтобы он мог отправлять уведомления на это устройство. Если PushNotificationSetup вернул 1, то вы должны продолжать вызывать эту команду до тех пор, пока она не вернет непустую строку. Если PushNotificationSetup вернул 0, то эта команда всегда будет возвращать пустую строку.  Пожалуйста, обратитесь к руководству по Push-уведомлениям Android для получения более подробной информации о том, как использовать токен устройства для отправки Push-уведомлений на это устройство.

---

<a name="method-getproximitysensorexists"></a>

### GetProximitySensorExists()
```php
GetProximitySensorExists(): int
```
Возвращает 1, если текущее устройство имеет датчик приближения, который в настоящее время поддерживается AGK, и 0, если нет.

---

<a name="method-getrawgpslatitude"></a>

### GetRawGPSLatitude()
```php
GetRawGPSLatitude(): float
```
Возвращает самую последнюю доступную широту.

---

<a name="method-getpolygonsdrawn"></a>

### GetPolygonsDrawn()
```php
GetPolygonsDrawn(): int
```
Возвращает количество полигонов, нарисованных последним кадром графического процессора.

---

<a name="method-getpointerx"></a>

### GetPointerX()
```php
GetPointerX(): float
```
Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана. Если устройство имеет мышь, то это возвращает текущее положение X мыши. В противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет положение X самого последнего события касания. Если никаких событий не происходит, то это последняя позиция X, записанная сенсорным событием. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldX.

---

<a name="method-getpointerstate"></a>

### GetPointerState()
```php
GetPointerState(): int
```
Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана. Если на устройстве есть мышь, то это вернет 1, если левая кнопка мыши в данный момент нажата, и 0, если нет. В противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет 1, если в данный момент нажимается одно или несколько сенсорных событий. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными.  Существует три команды для получения состояния нажатия указателя: GetPointerPressed возвращает 1 в момент нажатия указателя, а затем возвращает 0, GetPointerReleased возвращает 1 в момент отпускания указателя, а затем возвращает 0, GetPointerState возвращает 1 все время нахождения указателя в нажатом состоянии.

---

<a name="method-getpointlightexists"></a>

### GetPointLightExists()
```php
GetPointLightExists(int $lightID): int
```
возвращает 1, если указанный точечный свет существует, и 0 в противном случае.

---

<a name="method-getpointerreleased"></a>

### GetPointerReleased()
```php
GetPointerReleased(): int
```
Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана. Если на устройстве есть мышь, то это вернет 1, если левая кнопка мыши отпущена, и 0, если нет. В противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет 1, если будет выпущено одно или несколько сенсорных событий. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными. Существует три команды для получения состояния нажатия указателя: GetPointerPressed возвращает 1 в момент нажатия указателя, а затем возвращает 0, GetPointerReleased возвращает 1 в момент отпускания указателя, а затем возвращает 0, GetPointerState возвращает 1 все время нахождения указателя в нажатом состоянии.

---

<a name="method-getpixelsdrawn"></a>

### GetPixelsDrawn()
```php
GetPixelsDrawn(): int
```
Возвращает оценку количества пикселей, которые были нарисованы на экране в последнем кадре. Как правило, чем ниже это значение, тем лучше производительность. Количество нарисованных пикселей может быть больше, чем количество пикселей на экране, так как перекрывающиеся спрайты могут рисовать один и тот же пиксель дважды.

---

<a name="method-getphysicsislandcount"></a>

### GetPhysicsIslandCount()
```php
GetPhysicsIslandCount(): int
```
Возвращает количество островов, обработанных решателем на последнем шаге

---

<a name="method-getphysicstime"></a>

### GetPhysicsTime()
```php
GetPhysicsTime(): float
```
Возвращает количество секунд и долей секунд, затраченных на обновление физического моделирования.

---

<a name="method-getphysicssolvetime"></a>

### GetPhysicsSolveTime()
```php
GetPhysicsSolveTime(): float
```
Возвращает количество миллисекунд, затраченных в решателе

---

<a name="method-getphysicscollisionx"></a>

### GetPhysicsCollisionX()
```php
GetPhysicsCollisionX(): float
```
Возвращает координату X точки столкновения от последнего вызова GetPhysicsCollision относительно смещения первого спрайта.

---

<a name="method-getphysicscollisiony"></a>

### GetPhysicsCollisionY()
```php
GetPhysicsCollisionY(): float
```
Возвращает координату Y точки столкновения от последнего вызова GetPhysicsCollision относительно смещения первого спрайта.

---

<a name="method-getphysicscollisionworldy"></a>

### GetPhysicsCollisionWorldY()
```php
GetPhysicsCollisionWorldY(): float
```
Возвращает координату Y точки столкновения из последнего вызова GetPhysicsCollision в мировых координатах.

---

<a name="method-getpointery"></a>

### GetPointerY()
```php
GetPointerY(): float
```
Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана. Если устройство имеет мышь, то это возвращает текущее положение мыши Y. В противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет положение Y самого последнего события касания. Если никаких событий не происходит, то это последняя позиция Y, записанная сенсорным событием. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldY.

---

<a name="method-getphysicscollision"></a>

### GetPhysicsCollision()
```php
GetPhysicsCollision(int $iSprite1, int $iSprite2): int
```
Возвращает 1, если два физических спрайта перекрываются, в противном случае он возвращает 0. Эта функция не делает никаких вычислений, она просто просматривает результаты последнего физического шага, чтобы определить, перекрываются ли спрайты в данный момент. Если эта функция возвращает true, вы можете получить точку столкновения с помощью GetPhysicsCollisionX и GetPhysicsCollisionY, если существует более одной точки столкновения, неизвестно, какая точка будет возвращена. Вы можете проверить список контактов спрайта, чтобы получить полный список контактных точек. На эту функцию влияют настройки групп и категорий.

---

<a name="method-getphysicscollisionworldx"></a>

### GetPhysicsCollisionWorldX()
```php
GetPhysicsCollisionWorldX(): float
```
Возвращает координату X точки столкновения из последнего вызова GetPhysicsCollision в мировых координатах.

---

<a name="method-getpointerpressed"></a>

### GetPointerPressed()
```php
GetPointerPressed(): int
```
Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана. Если устройство имеет мышь, то это вернет 1, если левая кнопка мыши нажата, 0, если нет. В противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет 1, если существует одно или несколько событий касания. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными.  Существует три команды для получения состояния нажатия указателя: GetPointerPressed возвращает 1 в момент нажатия указателя, а затем возвращает 0, GetPointerReleased возвращает 1 в момент отпускания указателя, а затем возвращает 0, GetPointerState возвращает 1 все время нахождения указателя в нажатом состоянии.

---

<a name="method-getparticlesy"></a>

### GetParticlesY()
```php
GetParticlesY(int $ID): float
```
Возвращает текущее положение Y излучателя, это точка, из которой будут появляться новые частицы. Невозможно получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.

---

<a name="method-getparticlesx"></a>

### GetParticlesX()
```php
GetParticlesX(int $ID): float
```
Возвращает текущее положение X излучателя, это точка, из которой будут появляться новые частицы. Невозможно получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.

---

<a name="method-getparticlesvisible"></a>

### GetParticlesVisible()
```php
GetParticlesVisible(int $ID): int
```
Возвращает 0, если данные частицы были установлены как невидимые с помощью SetParticlesVisible, или 1, если они в данный момент установлены как видимые (по умолчанию). Это не проверяет, находятся ли частицы в видимом окне просмотра.

---

<a name="method-getparticlessize"></a>

### GetParticlesSize()
```php
GetParticlesSize(int $ID): float
```
Возвращает текущий размер всех частиц в мировых координатах. Подробнее об установке размера частиц см. в разделе SetParticlesSize.

---

<a name="method-getparticlesmaxreached"></a>

### GetParticlesMaxReached()
```php
GetParticlesMaxReached(int $ID): int
```
Возвращает 1, если излучатель испустил количество частиц, указанное в SetParticlesMax, и все испущенные частицы с тех пор умерли, в противном случае возвращает 0. Если максимальное значение равно -1, то оно всегда будет возвращать 0. Чтобы сбросить счетчик и заставить излучатель снова начать излучать, используйте ResetParticleCount.

---

<a name="method-getparticleslife"></a>

### GetParticlesLife()
```php
GetParticlesLife(int $ID): float
```
Возвращает текущую жизнь частиц в секундах. Невозможно получить текущую жизнь отдельных частиц. Это значение не зависит от частоты кадров.

---

<a name="method-getparticlesfrequency"></a>

### GetParticlesFrequency()
```php
GetParticlesFrequency(int $ID): float
```
Возвращает текущую частоту генерации частиц в частицах в секунду. Это значение не зависит от частоты кадров.

---

<a name="method-getparticlesexists"></a>

### GetParticlesExists()
```php
GetParticlesExists(int $ID): int
```
Возвращает 1, если излучатель частиц существует с заданным идентификатором, и 0, если нет.

---

<a name="method-getparticlesdirectiony"></a>

### GetParticlesDirectionY()
```php
GetParticlesDirectionY(int $ID): float
```
Возвращает y-компоненту направления излучателя, которое является базовым направлением движения частиц при их создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения SetParticlesAngle.

---

<a name="method-getparticlesdirectionx"></a>

### GetParticlesDirectionX()
```php
GetParticlesDirectionX(int $ID): float
```
Возвращает X-компоненту направления излучателя, которое является базовым направлением движения частиц при их создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения GetParticlesAngle.

---

<a name="method-getparticlesdepth"></a>

### GetParticlesDepth()
```php
GetParticlesDepth(int $ID): int
```
Возвращает текущую глубину, на которой будут нарисованы все частицы. Это значение находится в диапазоне от 0 до 10000, причем 0 находится в передней части экрана.

---

<a name="method-getparticlesanglerad"></a>

### GetParticlesAngleRad()
```php
GetParticlesAngleRad(int $ID): float
```
Возвращает текущий угол излучателя в радианах. Это значение представляет собой величину отклонения частицы от направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 2*PI означает, что частица может двигаться в любом направлении при испускании.

---

<a name="method-getpaused"></a>

### GetPaused()
```php
GetPaused(): int
```
Возвращает 1, если ваше настольное приложение теряет фокус. Вы можете активировать экран паузы, когда это произойдет, или позволить приложению продолжать работать в обычном режиме. Это относится только к настольным платформам, на мобильных платформах вы должны использовать GetResumed вместо этого.

---

<a name="method-getparticlesangle"></a>

### GetParticlesAngle()
```php
GetParticlesAngle(int $ID): float
```
Возвращает текущий угол излучателя в градусах. Это значение представляет собой величину отклонения частицы от направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 360 означает, что частица может двигаться в любом направлении при испускании.

---

<a name="method-getparticlesactive"></a>

### GetParticlesActive()
```php
GetParticlesActive(int $ID): int
```
Возвращает 0, если данные частицы были приостановлены с помощью SetParticlesActive, или 1, если они в данный момент обновляются как обычно (по умолчанию).

---

<a name="method-getparticledrawnquadcount"></a>

### GetParticleDrawnQuadCount()
```php
GetParticleDrawnQuadCount(): int
```
Возвращает количество отдельных частиц, которые были нарисованы в последнем кадре с помощью метода quad. Чем выше это число, тем больше работы выполняет двигатель, обрабатывая частицы.

---

<a name="method-getparticledrawnpointcount"></a>

### GetParticleDrawnPointCount()
```php
GetParticleDrawnPointCount(): int
```
Начиная с версии 108 эта команда всегда будет возвращать 0, так как все частицы рисуются квадратиками. Вместо этого используйте GetParticleDrawnQuadCount.

---

<a name="method-getorientation"></a>

### GetOrientation()
```php
GetOrientation(): int
```
Возвращает текущую ориентацию устройства. Возвращаемые значения: 1 = портретный режим, 2 = портретный режим - поворот на 180 градусов, 3 = ландшафтный режим - 90 градусов против часовой стрелки, 4 = ландшафтный режим - 90 градусов по часовой стрелке

---

<a name="method-getobjects3dphysicscontactpositionvector"></a>

### GetObjects3DPhysicsContactPositionVector()
```php
GetObjects3DPhysicsContactPositionVector(int $objA, int $objB, int $outPosVec3): int
```
Заполняет outPosVec3 контактным положением. Возвращает false, если нет контакта. Сначала создайте вектор с помощью CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен результатами.

---

<a name="method-getobjectz"></a>

### GetObjectZ()
```php
GetObjectZ(int $objID): float
```
Возвращает текущее Z-положение объекта.

---

<a name="method-getobjectx"></a>

### GetObjectX()
```php
GetObjectX(int $objID): float
```
Возвращает текущее положение X объекта.

---

<a name="method-getobjectworldz"></a>

### GetObjectWorldZ()
```php
GetObjectWorldZ(int $objID): float
```
Возвращает текущее Z-положение объекта в мировых координатах. Это учитывает родительские позиции в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое положение объекта.

---

<a name="method-getobjectworldy"></a>

### GetObjectWorldY()
```php
GetObjectWorldY(int $objID): float
```
Возвращает текущее положение объекта Y в мировых координатах. Это учитывает родительские позиции в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое положение объекта.

---

<a name="method-getobjectworldquatz"></a>

### GetObjectWorldQuatZ()
```php
GetObjectWorldQuatZ(int $objID): float
```
Возвращает Z-компоненту текущего вращения объекта, преобразованную в кватернион в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.

---

<a name="method-getobjectworldquaty"></a>

### GetObjectWorldQuatY()
```php
GetObjectWorldQuatY(int $objID): float
```
Возвращает Y-компоненту текущего вращения объекта, преобразованную в кватернион в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.

---

<a name="method-getobjectworldx"></a>

### GetObjectWorldX()
```php
GetObjectWorldX(int $objID): float
```
Возвращает текущее положение X объекта в мировых координатах. Это учитывает родительские позиции в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое положение объекта.

---

<a name="method-getobjectworldquatx"></a>

### GetObjectWorldQuatX()
```php
GetObjectWorldQuatX(int $objID): float
```
Возвращает X-компоненту текущего вращения объекта, преобразованную в кватернион в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.

---

<a name="method-getobjectworldquatw"></a>

### GetObjectWorldQuatW()
```php
GetObjectWorldQuatW(int $objID): float
```
Возвращает W-компонент текущего вращения объекта, преобразованный в кватернион в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.

---

<a name="method-getobjectworldanglez"></a>

### GetObjectWorldAngleZ()
```php
GetObjectWorldAngleZ(int $objID): float
```
Возвращает Z-компоненту текущего вращения объекта, преобразованную в углы Эйлера в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.

---

<a name="method-getobjectworldangley"></a>

### GetObjectWorldAngleY()
```php
GetObjectWorldAngleY(int $objID): float
```
Возвращает Y-компоненту текущего вращения объекта, преобразованную в углы Эйлера в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.

---

<a name="method-getobjectworldanglex"></a>

### GetObjectWorldAngleX()
```php
GetObjectWorldAngleX(int $objID): float
```
Возвращает X-компоненту текущего вращения объекта, преобразованную в углы Эйлера в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.

---

<a name="method-getobjecty"></a>

### GetObjectY()
```php
GetObjectY(int $objID): float
```
Возвращает текущее положение объекта Y.

---

<a name="method-getobjecttransparency"></a>

### GetObjectTransparency()
```php
GetObjectTransparency(int $objID): int
```
Возвращает текущий режим прозрачности для этого объекта

---

<a name="method-getobjecttexturename"></a>

### GetObjectTextureName()
```php
GetObjectTextureName(int $objID, int $textureIndex): string
```
Возвращает имя текстуры, определенное в файле модели, из которого она была загружена, но текстурам не гарантируется наличие имен. Имена текстур находятся в диапазоне от 1 до GetObjectNumTextures включительно. Если вы вызываете эту команду из уровня 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней.

---

<a name="method-getobjectsizeminz"></a>

### GetObjectSizeMinZ()
```php
GetObjectSizeMinZ(int $objID): float
```
Возвращает минимальный экстент объекта в направлении Z, это может быть объединено с GetObjectSizeMaxZ для определения размера объекта в направлении Z. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2 единицы в направлении Z. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной сетки, используйте GetObjectMeshSizeMinZ.

---

<a name="method-getobjectsizeminy"></a>

### GetObjectSizeMinY()
```php
GetObjectSizeMinY(int $objID): float
```
Возвращает минимальный экстент объекта в направлении X, это может быть объединено с GetObjectSizeMaxY для определения размера объекта в направлении Y. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2 единицы в направлении Y. Эта команда берет границы всех сеток, составляющих этот объект, для проверки границ одной сетки используйте GetObjectMeshSizeMinY.

---

<a name="method-getobjectsizeminx"></a>

### GetObjectSizeMinX()
```php
GetObjectSizeMinX(int $objID): float
```
Возвращает минимальный экстент объекта в направлении X, это может быть объединено с GetObjectSizeMaxX для определения размера объекта в направлении X. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2 единицы в направлении X. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной сетки, используйте GetObjectMeshSizeMinX.

---

<a name="method-getobjectsizemaxz"></a>

### GetObjectSizeMaxZ()
```php
GetObjectSizeMaxZ(int $objID): float
```
Возвращает максимальный экстент объекта в направлении Z, это может быть объединено с GetObjectSizeMinZ для определения размера объекта в направлении Z. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, то есть его размер составляет 2 единицы в направлении Z. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной сетки, используйте GetObjectMeshSizeMaxZ.

---

<a name="method-getobjectsizemaxy"></a>

### GetObjectSizeMaxY()
```php
GetObjectSizeMaxY(int $objID): float
```
Возвращает максимальный экстент объекта в направлении X, это можно объединить с GetObjectSizeMinY для определения размера объекта в направлении Y. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2 единицы в направлении Y. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной сетки, используйте GetObjectMeshSizeMaxY.

---

<a name="method-getobjectsizemaxx"></a>

### GetObjectSizeMaxX()
```php
GetObjectSizeMaxX(int $objID): float
```
Возвращает максимальный экстент объекта в направлении X, это может быть объединено с GetObjectSizeMinX для определения размера объекта в направлении X. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, то есть его размер составляет 2 единицы в направлении X. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной сетки, используйте GetObjectMeshSizeMaxX.

---

<a name="method-getobjectreceiveshadowmode"></a>

### GetObjectReceiveShadowMode()
```php
GetObjectReceiveShadowMode(int $objID): int
```
Возвращает 1, если объект в данный момент настроен на получение теней, и 0 в противном случае.

---

<a name="method-getobjectraycastz"></a>

### GetObjectRayCastZ()
```php
GetObjectRayCastZ(int $index): float
```
Возвращает Z-компоненту точки столкновения для заданного индекса столкновения в последней проверке столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.

---

<a name="method-getobjectvisible"></a>

### GetObjectVisible()
```php
GetObjectVisible(int $objID): int
```
Возвращает текущий режим видимости для этого объекта

---

<a name="method-getobjectraycasty"></a>

### GetObjectRayCastY()
```php
GetObjectRayCastY(int $index): float
```
Возвращает компонент Y точки столкновения для заданного индекса столкновения в последней проверке столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.

---

<a name="method-getobjectraycastx"></a>

### GetObjectRayCastX()
```php
GetObjectRayCastX(int $index): float
```
Возвращает компонент X точки столкновения для заданного индекса столкновения в последней проверке столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.

---

<a name="method-getobjectraycastslidez"></a>

### GetObjectRayCastSlideZ()
```php
GetObjectRayCastSlideZ(int $index): float
```
Возвращает Z-компоненту конечной точки покоя для скользящих столкновений. Это допустимо только для индекса 0 и после вызова ObjectSphereSlide. Поместите объект здесь, чтобы он выглядел так, как будто он скользил после столкновения.

---

<a name="method-getobjectraycastslidey"></a>

### GetObjectRayCastSlideY()
```php
GetObjectRayCastSlideY(int $index): float
```
Возвращает компонент Y конечной точки покоя для скользящих столкновений. Это допустимо только для индекса 0 и после вызова ObjectSphereSlide. Поместите объект здесь, чтобы он выглядел так, как будто он скользил после столкновения.

---

<a name="method-getobjectraycastnormalz"></a>

### GetObjectRayCastNormalZ()
```php
GetObjectRayCastNormalZ(int $index): float
```
Возвращает Z-компонент нормальной коллизии при последней проверке коллизии. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.

---

<a name="method-getobjectraycastslidex"></a>

### GetObjectRayCastSlideX()
```php
GetObjectRayCastSlideX(int $index): float
```
Возвращает компонент X конечной точки покоя для скользящих столкновений. Это допустимо только для индекса 0 и после вызова ObjectSphereSlide. Поместите объект здесь, чтобы он выглядел так, как будто он скользил после столкновения.

---

<a name="method-getobjectraycastnormaly"></a>

### GetObjectRayCastNormalY()
```php
GetObjectRayCastNormalY(int $index): float
```
Возвращает компонент Y нормальной коллизии при последней проверке коллизии. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.

---

<a name="method-getobjectraycasthitid"></a>

### GetObjectRayCastHitID()
```php
GetObjectRayCastHitID(int $index): int
```
Возвращает попадание идентификатора объекта для данного индекса коллизии при последней проверке коллизии. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.

---

<a name="method-getobjectraycastdistance"></a>

### GetObjectRayCastDistance()
```php
GetObjectRayCastDistance(int $index): float
```
Возвращает расстояние между начальной точкой луча и точкой столкновения.

---

<a name="method-getobjectraycastbouncez"></a>

### GetObjectRayCastBounceZ()
```php
GetObjectRayCastBounceZ(int $index): float
```
Возвращает Z-компоненту вектора отскока для последней проверки столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits. Расположите объект здесь так, чтобы он выглядел так, как будто отскочил после столкновения.

---

<a name="method-getobjectraycastbouncey"></a>

### GetObjectRayCastBounceY()
```php
GetObjectRayCastBounceY(int $index): float
```
Возвращает компонент Y вектора отскока для последней проверки столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits. Расположите объект здесь так, чтобы он выглядел так, как будто отскочил после столкновения.

---

<a name="method-getobjectraycastbouncex"></a>

### GetObjectRayCastBounceX()
```php
GetObjectRayCastBounceX(int $index): float
```
Возвращает X-компоненту вектора отскока для последней проверки столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits. Расположите объект здесь так, чтобы он выглядел так, как будто отскочил после столкновения.

---

<a name="method-getobjectquatz"></a>

### GetObjectQuatZ()
```php
GetObjectQuatZ(int $objID): float
```
Возвращает Z-компонент текущего вращения объекта, преобразованный в кватернион.

---

<a name="method-getobjectquaty"></a>

### GetObjectQuatY()
```php
GetObjectQuatY(int $objID): float
```
Возвращает компонент Y текущего вращения объекта, преобразованный в кватернион.

---

<a name="method-getobjectquatw"></a>

### GetObjectQuatW()
```php
GetObjectQuatW(int $objID): float
```
Возвращает W-компонент текущего вращения объекта, преобразованный в кватернион.

---

<a name="method-getobjectraycastnumhits"></a>

### GetObjectRayCastNumHits()
```php
GetObjectRayCastNumHits(): int
```
Возвращает количество коллизий, произошедших при последней проверке коллизий. В случае ObjectRayCast и ObjectSphereCast это будет 0 или 1. Для ObjectSphereSlide это может быть где-то между 0 и 4.

---

<a name="method-getobjectraycastnormalx"></a>

### GetObjectRayCastNormalX()
```php
GetObjectRayCastNormalX(int $index): float
```
Возвращает компонент X нормальной коллизии при последней проверке коллизии. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.

---

<a name="method-getobjectnumtextures"></a>

### GetObjectNumTextures()
```php
GetObjectNumTextures(int $objID): int
```
Возвращает количество ссылок на текстуру, найденных при загрузке объекта. Объект может иметь несколько ссылок на текстуру. Эта информация будет доступна только в том случае, если файл модели имеет настройку материала с ссылкой на диффузную текстуру.

---

<a name="method-getobjectnummeshes"></a>

### GetObjectNumMeshes()
```php
GetObjectNumMeshes(int $objID): int
```
Возвращает количество сеток, принадлежащих этому объекту. Объект может иметь несколько сеток, обычно это происходит в случае мультиматериальных объектов, где объект разделен на несколько сеток, каждая из которых использует другую текстуру. Обратите внимание, что экземпляры объектов могут не иметь никаких сеток.

---

<a name="method-getobjectnumbones"></a>

### GetObjectNumBones()
```php
GetObjectNumBones(int $objID): int
```
Получает количество костей, которые были загружены в результате загрузки этого объекта. Это происходит только в том случае, если объект был загружен с помощью LoadObjectWithChildren. Если объект имеет анимацию конечностей, как в DarkBasic Classic, то кости представляют иерархию конечностей, и каждая конечность загружается как дочерний объект, прикрепленный к кости. Если объект имеет взвешенную вершинную анимацию, то кости представляют скелет, а кожа загружается как единая сетка, хранящаяся в корневом объекте. Эти две формы анимации могут быть объединены, так что взвешенная вершинная костная структура может иметь объекты, прикрепленные к ее костям одновременно с деформацией кожной сетки.

---

<a name="method-getobjectname"></a>

### GetObjectName()
```php
GetObjectName(int $objID): string
```
Возвращает имя объекта, определенное в файле модели. Это полезно при использовании LoadObjectWithChildren для идентификации дочерних объектов, к которым можно получить доступ с помощью GetObjectChildID.  Если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.

---

<a name="method-getobjectquatx"></a>

### GetObjectQuatX()
```php
GetObjectQuatX(int $objID): float
```
Возвращает компонент X текущего вращения объекта, преобразованный в кватернион.

---

<a name="method-getobjectmeshsizeminy"></a>

### GetObjectMeshSizeMinY()
```php
GetObjectMeshSizeMinY(int $objID, int $meshIndex): float
```
Возвращает минимальную протяженность сетки в направлении Y, это может быть объединено с GetObjectMeshSizeMaxY для определения размера сетки в направлении Y. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении Y.

---

<a name="method-getobjectnumchildren"></a>

### GetObjectNumChildren()
```php
GetObjectNumChildren(int $objID): int
```
Возвращает количество дочерних объектов, которые были загружены в результате загрузки этого объекта. Например, объект анимированного персонажа из кости может иметь модель пистолета, прикрепленную к кости, представляющей его руку, эта модель пистолета будет загружена как отдельный объект и получит свой собственный идентификатор, которым вы можете манипулировать отдельно от основного объекта. Вы даже можете отсоединить пистолет от руки с помощью FixObjectToBone(ID,0), чтобы сделать его нормальным объектом, который не будет двигаться при движении персонажа. Однако он всегда будет оставаться в этом списке дочерних объектов для справки и будет удален, если DeleteObjectWithChildren вызывается для объекта character. Для тех из вас, кто знаком с DarkBasic, объекты, содержащие конечности в DarkBasic, будут загружены как дочерние объекты в AGK. Однако в дочерних объектах нет иерархии, у них не было бы собственных детей. Вместо этого в корневом объекте создается костная структура, представляющая иерархию конечностей, а дочерние объекты присоединяются к соответствующим костям.

---

<a name="method-getobjectnumanimations"></a>

### GetObjectNumAnimations()
```php
GetObjectNumAnimations(int $objID): int
```
Возвращает количество анимаций, назначенных объекту в данный момент. Только объекты, загруженные с помощью LoadObjectWithChildren, получают назначенные им анимации.

---

<a name="method-getobjectmeshsizeminx"></a>

### GetObjectMeshSizeMinX()
```php
GetObjectMeshSizeMinX(int $objID, int $meshIndex): float
```
Возвращает минимальный экстент сетки в направлении X, это можно объединить с GetObjectMeshSizeMaxX для определения размера сетки в направлении X. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении X.

---

<a name="method-getobjectmeshsizemaxz"></a>

### GetObjectMeshSizeMaxZ()
```php
GetObjectMeshSizeMaxZ(int $objID, int $meshIndex): float
```
Возвращает максимальную протяженность сетки в направлении Z, это может быть объединено с GetObjectMeshSizeMinZ для определения размера сетки в направлении Z. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении Z.

---

<a name="method-getobjectmeshsizemaxy"></a>

### GetObjectMeshSizeMaxY()
```php
GetObjectMeshSizeMaxY(int $objID, int $meshIndex): float
```
Возвращает максимальную протяженность сетки в направлении Y, это может быть объединено с GetObjectMeshSizeMinY для определения размера сетки в направлении Y. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении Y.

---

<a name="method-getobjectmeshsizemaxx"></a>

### GetObjectMeshSizeMaxX()
```php
GetObjectMeshSizeMaxX(int $objID, int $meshIndex): float
```
Возвращает максимальный экстент сетки в направлении X, это может быть объединено с GetObjectMeshSizeMinX для определения размера сетки в направлении X. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении X.

---

<a name="method-getobjectmeshvssource"></a>

### GetObjectMeshVSSource()
```php
GetObjectMeshVSSource(int $objID, int $meshIndex): string
```
Возвращает исходный код вершинного шейдера, используемого в данный момент на этом объекте. Если вы не назначили шейдер для этой сетки, то он генерируется автоматически, и вы можете использовать эту команду, чтобы получить его исходный код, если хотите внести в него коррективы. Затем вы можете загрузить этот модифицированный источник шейдера с помощью LoadShader и назначить его SetObjectMeshShader. Обратите внимание, что изменение количества текстур или использование SetObjectLightMode обычно генерирует новый шейдер для обработки изменений, однако если вы использовали SetObjectMeshShader, то AGK больше не будет изменять ваш шейдер, предполагая, что вы сами учли эти изменения. Обратите внимание, что шейдеры, использующие освещение, будут иметь функции GetVSLighting() и GetPSLighting (), которые будут заполняться AGK во время выполнения в зависимости от того, сколько огней находится рядом с сеткой. Удаление этих функций из источника шейдера приведет к удалению всего освещения из сетки. Если вы вызываете эту команду из уровня 2, вы должны удалить строку, когда закончите с ней.

---

<a name="method-getobjectmeshsizeminz"></a>

### GetObjectMeshSizeMinZ()
```php
GetObjectMeshSizeMinZ(int $objID, int $meshIndex): float
```
Возвращает минимальный экстент сетки в направлении Z, это может быть объединено с GetObjectMeshSizeMaxZ для определения размера сетки в направлении Z. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении Z.

---

<a name="method-getobjectmeshpssource"></a>

### GetObjectMeshPSSource()
```php
GetObjectMeshPSSource(int $objID, int $meshIndex): string
```
Возвращает исходный код пиксельного шейдера, используемого в данный момент на этом объекте. Если вы не назначили шейдер для этой сетки, то он генерируется автоматически, и вы можете использовать эту команду, чтобы получить его исходный код, если хотите внести в него коррективы. Затем вы можете загрузить этот модифицированный источник шейдера с помощью LoadShader и назначить его SetObjectMeshShader. Обратите внимание, что изменение количества текстур или использование SetObjectLightMode обычно генерирует новый шейдер для обработки изменений, однако если вы использовали SetObjectMeshShader, то AGK больше не будет изменять ваш шейдер, предполагая, что вы сами учли эти изменения. Обратите внимание, что шейдеры, использующие освещение, будут иметь функции GetVSLighting() и GetPSLighting (), которые будут заполняться AGK во время выполнения в зависимости от того, сколько огней находится рядом с сеткой. Удаление этих функций из источника шейдера приведет к удалению всего освещения из сетки. Если вы вызываете эту команду из уровня 2, вы должны удалить строку, когда закончите с ней.

---

<a name="method-getobjectmeshname"></a>

### GetObjectMeshName()
```php
GetObjectMeshName(int $objID, int $meshIndex): string
```
Получает имя сетки, как определено в файле модели, из которого она была загружена, но сетки не гарантированно имеют имена. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes включительно. Если вы вызываете эту команду из уровня 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней.

---

<a name="method-getobjectistweening"></a>

### GetObjectIsTweening()
```php
GetObjectIsTweening(int $objID): int
```
Возвращает 1, если объект в данный момент находится в кадре анимации, или в начале, или в готовящейся к воспроизведению анимации. Это происходит только сразу после PlayObjectAnimation или SetObjectAnimationFrame, если вы указали время анимации больше 0. Это не происходит в любое другое время во время анимации.

---

<a name="method-getobjectisanimating"></a>

### GetObjectIsAnimating()
```php
GetObjectIsAnimating(int $objID): int
```
Возвращает 1 если объект в данный момент воспроизводит анимацию, это включает твин до начала анимации, но не твин до одного кадра. По сути, он возвращает 1, если объект должен воспроизводить анимацию. Если анимация настроена на цикл заданное количество раз или воспроизводится только один раз, то эта команда вернет 0, когда анимация будет закончена.

---

<a name="method-getobjectheightmapheight"></a>

### GetObjectHeightMapHeight()
```php
GetObjectHeightMapHeight(int $objID, float $x, float $z): float
```
Если объект был создан с помощью CreateObjectFromHeightMap, то эта команда может быть использована для быстрого получения высоты объекта в определенном мировом положении. Это объясняет положение объекта и поворот Y, чтобы обеспечить высоту независимо от того, где находится объект. Если объект повернут под углом X или Z, то это приведет к неправильным значениям. Вы должны указать координаты X и Z в мировых единицах измерения, если точка лежит вне объекта, то будет возвращено 0.

---

<a name="method-getobjectinscreen"></a>

### GetObjectInScreen()
```php
GetObjectInScreen(int $objID): int
```
Возвращает 1, если AGK считает, что объект в данный момент находится на экране, и 0, если нет. Это оценка, и если вы сомневаетесь, предположим, что объект находится на экране. Таким образом, если эта команда возвращает 0, то объект определенно находится вне экрана, если она возвращает 1, то объект может быть или не быть на экране.

---

<a name="method-getobjectexists"></a>

### GetObjectExists()
```php
GetObjectExists(int $objID): int
```
Возвращает 1, если объект существует с заданным идентификатором, и 0 в противном случае.

---

<a name="method-getobjectdepthwrite"></a>

### GetObjectDepthWrite()
```php
GetObjectDepthWrite(int $objID): int
```
Возвращает текущий режим записи глубины для этого объекта

---

<a name="method-getobjectdepthreadmode"></a>

### GetObjectDepthReadMode()
```php
GetObjectDepthReadMode(int $objID): int
```
Возвращает текущий режим чтения глубины для этого объекта

---

<a name="method-getobjectcolorred"></a>

### GetObjectColorRed()
```php
GetObjectColorRed(int $objID): int
```
Возвращает текущее красное значение цвета этого объекта, заданное параметром SetObjectColor.

---

<a name="method-getobjectcolorgreen"></a>

### GetObjectColorGreen()
```php
GetObjectColorGreen(int $objID): int
```
Возвращает текущее зеленое значение цвета этого объекта, заданное параметром SetObjectColor.

---

<a name="method-getobjectcolorblue"></a>

### GetObjectColorBlue()
```php
GetObjectColorBlue(int $objID): int
```
Возвращает текущее синее значение цвета этого объекта, заданное параметром SetObjectColor.

---

<a name="method-getobjectchildid"></a>

### GetObjectChildID()
```php
GetObjectChildID(int $objID, int $childIndex): int
```
Возвращает идентификатор объекта для указанного дочернего объекта, который был загружен в результате этого объекта. Чтобы найти количество дочерних объектов, используйте GetObjectNumChildren. childIndex находится в диапазоне от 1 до количества детей включительно. Для тех из вас, кто знаком с DarkBasic, объекты, содержащие конечности в DarkBasic, будут загружены как дочерние объекты в AGK. Однако в дочерних объектах нет иерархии, у них не было бы собственных детей. Вместо этого в корневом объекте создается костная структура, представляющая иерархию конечностей, а дочерние объекты присоединяются к соответствующим костям.

---

<a name="method-getobjectcastshadowmode"></a>

### GetObjectCastShadowMode()
```php
GetObjectCastShadowMode(int $objID): int
```
Возвращает 1, если объект в данный момент настроен на отбрасывание теней, и 0 в противном случае.

---

<a name="method-getobjectbonez"></a>

### GetObjectBoneZ()
```php
GetObjectBoneZ(int $objID, int $boneIndex): float
```
Возвращает текущее Z - положение кости.

---

<a name="method-getobjectboney"></a>

### GetObjectBoneY()
```php
GetObjectBoneY(int $objID, int $boneIndex): float
```
Возвращает текущее положение кости по оси Y.

---

<a name="method-getobjectbonex"></a>

### GetObjectBoneX()
```php
GetObjectBoneX(int $objID, int $boneIndex): float
```
Возвращает текущее положение X кости.

---

<a name="method-getobjectboneworldz"></a>

### GetObjectBoneWorldZ()
```php
GetObjectBoneWorldZ(int $objID, int $boneIndex): float
```
Возвращает текущее Z - положение кости в мировых координатах.

---

<a name="method-getobjectdepthbias"></a>

### GetObjectDepthBias()
```php
GetObjectDepthBias(int $objID): float
```
Возвращает текущее смещение глубины для этого объекта

---

<a name="method-getobjectboneworldy"></a>

### GetObjectBoneWorldY()
```php
GetObjectBoneWorldY(int $objID, int $boneIndex): float
```
Возвращает текущее положение кости по оси Y в мировых координатах.

---

<a name="method-getobjectcullmode"></a>

### GetObjectCullMode()
```php
GetObjectCullMode(int $objID): int
```
Возвращает текущий режим отбраковки для этого объекта

---

<a name="method-getobjectboneworldquatz"></a>

### GetObjectBoneWorldQuatZ()
```php
GetObjectBoneWorldQuatZ(int $objID, int $boneIndex): float
```
Возвращает Z-компонент текущего вращения кости, преобразованный в кватернион.

---

<a name="method-getobjectboneworldquaty"></a>

### GetObjectBoneWorldQuatY()
```php
GetObjectBoneWorldQuatY(int $objID, int $boneIndex): float
```
Возвращает Y-компонент текущего вращения кости, преобразованный в кватернион.

---

<a name="method-getobjectboneworldquatx"></a>

### GetObjectBoneWorldQuatX()
```php
GetObjectBoneWorldQuatX(int $objID, int $boneIndex): float
```
Возвращает X-компонент текущего вращения кости, преобразованный в кватернион.

---

<a name="method-getobjectboneworldquatw"></a>

### GetObjectBoneWorldQuatW()
```php
GetObjectBoneWorldQuatW(int $objID, int $boneIndex): float
```
Возвращает W-компонент текущего вращения кости, преобразованный в кватернион.

---

<a name="method-getobjectboneworldanglez"></a>

### GetObjectBoneWorldAngleZ()
```php
GetObjectBoneWorldAngleZ(int $objID, int $boneIndex): float
```
Возвращает Z-компоненту текущего вращения кости, преобразованную в углы Эйлера.

---

<a name="method-getobjectboneworldangley"></a>

### GetObjectBoneWorldAngleY()
```php
GetObjectBoneWorldAngleY(int $objID, int $boneIndex): float
```
Возвращает Y-компоненту текущего вращения кости, преобразованную в углы Эйлера.

---

<a name="method-getobjectboneworldanglex"></a>

### GetObjectBoneWorldAngleX()
```php
GetObjectBoneWorldAngleX(int $objID, int $boneIndex): float
```
Возвращает X-компоненту текущего вращения кости в мировых координатах, преобразованную в углы Эйлера.

---

<a name="method-getobjectbonequatz"></a>

### GetObjectBoneQuatZ()
```php
GetObjectBoneQuatZ(int $objID, int $boneIndex): float
```
Возвращает Z-компонент текущего вращения кости, преобразованный в кватернион.

---

<a name="method-getobjectbonequaty"></a>

### GetObjectBoneQuatY()
```php
GetObjectBoneQuatY(int $objID, int $boneIndex): float
```
Возвращает Y-компонент текущего вращения кости, преобразованный в кватернион.

---

<a name="method-getobjectbonequatx"></a>

### GetObjectBoneQuatX()
```php
GetObjectBoneQuatX(int $objID, int $boneIndex): float
```
Возвращает X-компонент текущего вращения кости, преобразованный в кватернион.

---

<a name="method-getobjectbonequatw"></a>

### GetObjectBoneQuatW()
```php
GetObjectBoneQuatW(int $objID, int $boneIndex): float
```
Возвращает W-компонент текущего вращения кости, преобразованный в кватернион.

---

<a name="method-getobjectboneworldx"></a>

### GetObjectBoneWorldX()
```php
GetObjectBoneWorldX(int $objID, int $boneIndex): float
```
Возвращает текущее положение кости X в мировых координатах.

---

<a name="method-getobjectbonebyname"></a>

### GetObjectBoneByName()
```php
GetObjectBoneByName(int $objID, string $name): int
```
Получает индекс кости по ее имени. Имена загружаются из файла модели при использовании LoadObjectWithChildren, в противном случае кости не загружаются. Индексы будут находиться в диапазоне от 1 до num bones или 0, если они не найдены.

---

<a name="method-getobjectboneanglez"></a>

### GetObjectBoneAngleZ()
```php
GetObjectBoneAngleZ(int $objID, int $boneIndex): float
```
Возвращает Z-компоненту текущего вращения кости, преобразованную в углы Эйлера.

---

<a name="method-getobjectboneangley"></a>

### GetObjectBoneAngleY()
```php
GetObjectBoneAngleY(int $objID, int $boneIndex): float
```
Возвращает Y-компоненту текущего вращения кости, преобразованную в углы Эйлера.

---

<a name="method-getobjectanimationtime"></a>

### GetObjectAnimationTime()
```php
GetObjectAnimationTime(int $objID): float
```
Возвращает текущее время воспроизводимой анимации, или если анимация остановилась, то возвращается последнее время, использованное для интерполяции.

---

<a name="method-getobjectboneanglex"></a>

### GetObjectBoneAngleX()
```php
GetObjectBoneAngleX(int $objID, int $boneIndex): float
```
Возвращает X-компоненту текущего вращения кости, преобразованную в углы Эйлера.

---

<a name="method-getobjectanimationname"></a>

### GetObjectAnimationName()
```php
GetObjectAnimationName(int $objID, int $index): string
```
Возвращает имя указанной анимации для данного объекта. Вы можете найти количество анимаций для этого объекта с помощью GetObjectNumAnimations. Индекс должен находиться в диапазоне от 1 до numAnimations включительно.

---

<a name="method-getobjectanimationduration"></a>

### GetObjectAnimationDuration()
```php
GetObjectAnimationDuration(int $objID, string $animName): float
```
Возвращает длительность указанной анимации в секундах.

---

<a name="method-getobjectanglez"></a>

### GetObjectAngleZ()
```php
GetObjectAngleZ(int $objID): float
```
Возвращает Z-компоненту текущего вращения объекта, преобразованную в углы Эйлера.

---

<a name="method-getobjectangley"></a>

### GetObjectAngleY()
```php
GetObjectAngleY(int $objID): float
```
Возвращает Y-компоненту текущего вращения объекта, преобразованную в углы Эйлера.

---

<a name="method-getobjectanglex"></a>

### GetObjectAngleX()
```php
GetObjectAngleX(int $objID): float
```
Возвращает X-компоненту текущего вращения объекта, преобразованную в углы Эйлера.

---

<a name="method-getobjectalpha"></a>

### GetObjectAlpha()
```php
GetObjectAlpha(int $objID): int
```
Возвращает текущее альфа-значение цвета этого объекта, заданное SetObjectColor или SetObjectAlpha.

---

<a name="method-getobjectbonename"></a>

### GetObjectBoneName()
```php
GetObjectBoneName(int $objID, int $boneIndex): string
```
Возвращает имя кости. Если эта команда вызывается с уровня 2, то вы должны удалить возвращенную строку, когда закончите с ней.

---

<a name="method-getobject3dphysicsrollingfriction"></a>

### GetObject3DPhysicsRollingFriction()
```php
GetObject3DPhysicsRollingFriction(int $objID): float
```
Возвращает трение качения для физического объекта.

---

<a name="method-getobject3dphysicsrestitution"></a>

### GetObject3DPhysicsRestitution()
```php
GetObject3DPhysicsRestitution(int $objID): float
```
Возвращает текущее значение реституции для физического объекта.

---

<a name="method-getobject3dphysicsnextcontact"></a>

### GetObject3DPhysicsNextContact()
```php
GetObject3DPhysicsNextContact(): int
```
Возвращает true, если есть еще один контакт для отчета.

---

<a name="method-getobject3dphysicsmaxlinearvelocity"></a>

### GetObject3DPhysicsMaxLinearVelocity()
```php
GetObject3DPhysicsMaxLinearVelocity(int $objID): float
```
Возвращает максимальную линейную скорость для физического объекта.

---

<a name="method-getobject3dphysicsmass"></a>

### GetObject3DPhysicsMass()
```php
GetObject3DPhysicsMass(int $objID): float
```
Возвращает массу объектов

---

<a name="method-getobject3dphysicsmask"></a>

### GetObject3DPhysicsMask()
```php
GetObject3DPhysicsMask(int $objID): int
```
Возвращает маску столкновения объектов. По умолчанию все физические объекты находятся в одной группе и не маскируются. Если вы используете группы столкновений и маски, вы должны использовать их для всех физических объектов.

---

<a name="method-getobject3dphysicslinearvelocityz"></a>

### GetObject3DPhysicsLinearVelocityZ()
```php
GetObject3DPhysicsLinearVelocityZ(int $objID): float
```
Возвращает X-компоненту вектора линейной скорости.

---

<a name="method-getobject3dphysicslinearvelocityy"></a>

### GetObject3DPhysicsLinearVelocityY()
```php
GetObject3DPhysicsLinearVelocityY(int $objID): float
```
Возвращает X-компоненту вектора линейной скорости.

---

<a name="method-getobject3dphysicslinearvelocityx"></a>

### GetObject3DPhysicsLinearVelocityX()
```php
GetObject3DPhysicsLinearVelocityX(int $objID): float
```
Возвращает X-компоненту вектора линейной скорости.

---

<a name="method-getobject3dphysicslinearsleepingthreshold"></a>

### GetObject3DPhysicsLinearSleepingThreshold()
```php
GetObject3DPhysicsLinearSleepingThreshold(int $objID): float
```
Возвращает линейный порог сна для физического объекта.

---

<a name="method-getobject3dphysicsgroup"></a>

### GetObject3DPhysicsGroup()
```php
GetObject3DPhysicsGroup(int $objID): int
```
Возвращает группу столкновений объектов. По умолчанию все физические объекты находятся в одной группе и не маскируются. Если вы используете группы столкновений и маски, вы должны использовать их для всех физических объектов.

---

<a name="method-getobject3dphysicslineardamp"></a>

### GetObject3DPhysicsLinearDamp()
```php
GetObject3DPhysicsLinearDamp(int $objID): float
```
Возвращает значение линейного демпфирования

---

<a name="method-getobject3dphysicsfriction"></a>

### GetObject3DPhysicsFriction()
```php
GetObject3DPhysicsFriction(int $objID): float
```
Возвращает трение для физического объекта.

---

<a name="method-getobject3dphysicsfirstcontact"></a>

### GetObject3DPhysicsFirstContact()
```php
GetObject3DPhysicsFirstContact(int $objID): int
```
Возвращает true, если объект имел контакт на физическом шаге.

---

<a name="method-getobject3dphysicscontacty"></a>

### GetObject3DPhysicsContactY()
```php
GetObject3DPhysicsContactY(): float
```
Возвращает положение контакта Y

---

<a name="method-getobject3dphysicscontactx"></a>

### GetObject3DPhysicsContactX()
```php
GetObject3DPhysicsContactX(): float
```
Возвращает X положение контакта

---

<a name="method-getobject3dphysicscontactvector"></a>

### GetObject3DPhysicsContactVector()
```php
GetObject3DPhysicsContactVector(int $outPosVec3): int
```
Возвращает true, если есть контактный вектор, и заполняет вектор outPosVec3. Сначала создайте вектор с помощью CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен результатами.

---

<a name="method-getobject3dphysicscontactobjectb"></a>

### GetObject3DPhysicsContactObjectB()
```php
GetObject3DPhysicsContactObjectB(): int
```
Возвращает идентификатор объекта второго объекта в контакте.

---

<a name="method-getobject3dphysicsangularvelocityz"></a>

### GetObject3DPhysicsAngularVelocityZ()
```php
GetObject3DPhysicsAngularVelocityZ(int $objID): float
```
Верните Z-компоненту вектора угловой скорости.

---

<a name="method-getobject3dphysicsangularvelocityy"></a>

### GetObject3DPhysicsAngularVelocityY()
```php
GetObject3DPhysicsAngularVelocityY(int $objID): float
```
Верните Y-компоненту вектора угловой скорости.

---

<a name="method-getobject3dphysicsangularvelocityx"></a>

### GetObject3DPhysicsAngularVelocityX()
```php
GetObject3DPhysicsAngularVelocityX(int $objID): float
```
Верните X-компоненту вектора угловой скорости.

---

<a name="method-getobject3dphysicsangularsleepingthreshold"></a>

### GetObject3DPhysicsAngularSleepingThreshold()
```php
GetObject3DPhysicsAngularSleepingThreshold(int $objID): float
```
Возвращает порог углового сна для физического объекта.

---

<a name="method-getobject3dphysicsangulardamp"></a>

### GetObject3DPhysicsAngularDamp()
```php
GetObject3DPhysicsAngularDamp(int $objID): float
```
Возвращает значение углового демпфирования

---

<a name="method-getnumprocessors"></a>

### GetNumProcessors()
```php
GetNumProcessors(): int
```
Возвращает количество ядер логического процессора на устройстве

---

<a name="method-getnumdevicecameras"></a>

### GetNumDeviceCameras()
```php
GetNumDeviceCameras(): int
```
Возвращает количество камер, доступных для SetDeviceCameraToImage. В настоящее время работает только на Android, iOS и Windows

---

<a name="method-getnextfolder"></a>

### GetNextFolder()
```php
GetNextFolder(): string
```
Возвращает имя следующей папки, найденной в текущей папке, которая задается с помощью SetFolder. GetFirstFolder должен быть вызван первым, чтобы это сработало, любой вызов SetFolder или OpenToWrite потребует повторного запуска с GetFirstFolder. Возвращает пустую строку, если в текущей папке больше нет папок. Не включает в себя . или ..

---

<a name="method-getnextfile"></a>

### GetNextFile()
```php
GetNextFile(): string
```
Возвращает имя следующего файла, найденного в текущей папке, который задается с помощью SetFolder. GetFirstFile должен быть вызван первым, чтобы это сработало, любой вызов SetFolder или OpenToWrite потребует повторного запуска с GetFirstFile. Возвращает пустую строку, если в текущей папке больше нет файлов.

---

<a name="method-getobject3dphysicscontactz"></a>

### GetObject3DPhysicsContactZ()
```php
GetObject3DPhysicsContactZ(): float
```
Возвращает Z положение контакта

---

<a name="method-getnextcontact"></a>

### GetNextContact()
```php
GetNextContact(): int
```
Возвращает 1 если контакт существует, вы можете получить спрайты, вовлеченные в этот контакт, используя GetContactSpriteID1 и GetContactSpriteID2, вы можете перейти к следующему контакту, снова вызвав эту команду, когда контактов больше не будет, она вернет 0.

---

<a name="method-getnetworkserverip"></a>

### GetNetworkServerIP()
```php
GetNetworkServerIP(int $iNetID): string
```
Возвращает IP-адрес, используемый сервером. Эта команда работает только на клиентах, так как сервер может получить свой собственный IP-адрес с помощью GetDeviceIP и GetDeviceIPv6.

---

<a name="method-getnetworkserverid"></a>

### GetNetworkServerID()
```php
GetNetworkServerID(int $iNetID): int
```
Возвращает идентификатор клиента клиента хоста. Это полезно, если вы используете сервер для обработки переменных настройки игры, таких как размер доски, длина игры и т. Д., поскольку только хост - клиент должен иметь копию этих переменных.

---

<a name="method-getnetworknumclients"></a>

### GetNetworkNumClients()
```php
GetNetworkNumClients(int $iNetID): int
```
Возвращает количество клиентов, подключенных к указанной сети. Хост считается клиентом, как и локальный клиент. Это означает, что в подключенной сети должно быть не менее 2 клиентов. Хост, ожидающий клиентов, возвращает 1, если он находится сам по себе. Клиент, пытающийся подключиться, возвращает 0 до тех пор, пока он не подключится и хост не примет клиента, предоставив ему уникальный идентификатор, затем он должен вернуть 2.

---

<a name="method-getnetworknextclient"></a>

### GetNetworkNextClient()
```php
GetNetworkNextClient(int $iNetID): int
```
Возвращает идентификатор клиента следующего клиента в списке клиентов. Используйте эту функцию, чтобы продолжить просмотр списка клиентов, запущенных с помощью GetNetworkFirstClient. Очень важно, чтобы эта команда вызывалась до тех пор, пока она не вернет 0, так как фоновый сетевой код не может продолжаться до тех пор, пока он не узнает, что вы закончили работу со списком клиентов. Локальный клиент также будет возвращен в какой-то момент, который можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkMyClientID. Хост-клиент также будет возвращен в какой-то момент, который можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkServerID.

---

<a name="method-getnetworkmyclientid"></a>

### GetNetworkMyClientID()
```php
GetNetworkMyClientID(int $iNetID): int
```
Каждому клиенту при подключении хост присваивает уникальный идентификатор. Эта функция возвращает идентификатор, который вам был назначен. Хост также присваивает себе идентификатор, который можно найти с помощью GetNetworkServerID.

---

<a name="method-getnetworkmessagestring"></a>

### GetNetworkMessageString()
```php
GetNetworkMessageString(int $iMsgID): string
```
Получает одну строку из сообщения и перемещает указатель сообщения на следующий элемент сообщения. Сообщения должны создаваться и считываться в соответствии с известными форматами, например string, int, string, поскольку у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное целое число для указания идентификатора типа сообщения, который можно использовать для идентификации формата сообщения.

---

<a name="method-getnetworkmessageinteger"></a>

### GetNetworkMessageInteger()
```php
GetNetworkMessageInteger(int $iMsgID): int
```
Получает одно целое число из сообщения и перемещает указатель сообщения к следующему элементу сообщения. Сообщения должны создаваться и считываться в соответствии с известными форматами, например string, int, string, поскольку у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное целое число для указания идентификатора типа сообщения, который можно использовать для идентификации формата сообщения.

---

<a name="method-getnetworkmessagefromip"></a>

### GetNetworkMessageFromIP()
```php
GetNetworkMessageFromIP(int $iMsgID): string
```
Возвращает IP-адрес, отправивший это сообщение. Только применительно к сообщениям, полученным от UDP и широковещательных прослушивателей, сетевые сообщения будут возвращать пустую строку для этой функции. Он также вернет пустую строку для сообщений, созданных с помощью CreateNetworkMessage. Это может быть адрес IPv4 или IPv6.

---

<a name="method-getnetworkmessagefromclient"></a>

### GetNetworkMessageFromClient()
```php
GetNetworkMessageFromClient(int $iMsgID): int
```
Возвращает идентификатор клиента, отправившего это сообщение. Применимо только к сообщениям, полученным из сетей, широковещательный прослушиватель и UDP-сообщения вернут 0 для этой функции. Он также вернет 0 для сообщений, созданных с помощью CreateNetworkMessage.

---

<a name="method-getnetworkmessagebyte"></a>

### GetNetworkMessageByte()
```php
GetNetworkMessageByte(int $iMsgID): int
```
Получает один байт без знака из сообщения и перемещает указатель сообщения на следующий элемент сообщения. Сообщения должны создаваться и считываться в соответствии с известными форматами, например string, int, string, поскольку у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное целое число для указания идентификатора типа сообщения, который можно использовать для идентификации формата сообщения.

---

<a name="method-getnetworkmessage"></a>

### GetNetworkMessage()
```php
GetNetworkMessage(int $iNetID): int
```
Проверьте сеть на наличие любых сообщений, отправленных этому клиенту. Если ничего не найдено, он возвращает 0. Если сообщение найдено, оно возвращает идентификатор сообщения, который вы можете использовать для его чтения. Вы должны удалить сообщение с помощью DeleteNetworkMessage, когда закончите его читать. Вы должны продолжать вызывать GetNetworkMessage до тех пор, пока он не вернет 0, чтобы убедиться, что вы получили все сообщения. Вы можете использовать команды чтения сообщений, чтобы узнать, какой идентификатор клиента отправил сообщение.

---

<a name="method-getnetworkexists"></a>

### GetNetworkExists()
```php
GetNetworkExists(int $iNetID): int
```
Возвращает 1, если сеть существует с заданным идентификатором, в противном случае она возвращает 0.

---

<a name="method-getnetworkfirstclient"></a>

### GetNetworkFirstClient()
```php
GetNetworkFirstClient(int $iNetID): int
```
Возвращает идентификатор клиента первого клиента в списке клиентов. Используйте эту функцию, чтобы начать просмотр списка клиентов и продолжить работу с GetNetworkNextClient до тех пор, пока он не вернет 0. Очень важно, чтобы после вызова этой команды GetNetworkNextClient вызывался до тех пор, пока не вернет 0, так как фоновый сетевой код не может продолжать работу до тех пор, пока не будет известно, что вы закончили работу со списком клиентов. Локальный клиент также будет возвращен в какой-то момент, который можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkMyClientID. Хост-клиент также будет возвращен в какой-то момент, который можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkServerID.

---

<a name="method-getnetworkclientuserdata"></a>

### GetNetworkClientUserData()
```php
GetNetworkClientUserData(int $iNetID, int $client, int $index): int
```
Считывает один из локальных слотов данных, назначенных клиентскому набору, с помощью SetNetworkClientUserData.

---

<a name="method-getnetworkclientping"></a>

### GetNetworkClientPing()
```php
GetNetworkClientPing(int $iNetID, int $client): float
```
Возвращает пинг между данным клиентом и хостом. Чтобы получить общее время передачи данных от одного клиента к другому, вы должны сложить два времени пинга для обоих клиентов вместе, поскольку все данные проходят через хост. Если вы используете идентификатор клиента хоста, он вернет 0, так как хост не имеет пинга для себя. Возвращаемое значение выражается в секундах как значение с плавающей запятой.

---

<a name="method-getnetworkmessagefromport"></a>

### GetNetworkMessageFromPort()
```php
GetNetworkMessageFromPort(int $iMsgID): int
```
Возвращает исходный порт, который был использован этим сообщением. Только применительно к сообщениям, полученным от UDP и широковещательных прослушивателей, сетевые сообщения вернут 0 для этой функции. Он также вернет 0 для сообщений, созданных с помощью CreateNetworkMessage. Это будет в диапазоне от 0 до 65535.

---

<a name="method-getnetworkclientip"></a>

### GetNetworkClientIP()
```php
GetNetworkClientIP(int $iNetID, int $client): string
```
Возвращает IP-адрес, используемый указанным клиентом. Эта команда работает только на сервере, так как клиенты не подключаются непосредственно друг к другу

---

<a name="method-getnetworkmessagefloat"></a>

### GetNetworkMessageFloat()
```php
GetNetworkMessageFloat(int $iMsgID): float
```
Получает один поплавок из сообщения и перемещает указатель сообщения к следующему элементу сообщения. Сообщения должны создаваться и считываться в соответствии с известными форматами, например string, int, string, поскольку у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное целое число для указания идентификатора типа сообщения, который можно использовать для идентификации формата сообщения.

---

<a name="method-getnetworkclientfloat"></a>

### GetNetworkClientFloat()
```php
GetNetworkClientFloat(int $iNetID, int $client, string $name): float
```
Получает копию переменной float удаленного клиента по имени. Также может быть использован для собственных переменных клиента, если ClientID равен GetNetworkMyClientID. Если переменная была установлена как переменная сброса, она вернется к 0 после чтения, это не повлияет на способность других клиентов считывать исходное значение. Каждый из них сбросит свою собственную копию. Если указанный клиент не установил переменную с заданным именем, то возвращается значение 0.

---

<a name="method-getnetworkclientdisconnected"></a>

### GetNetworkClientDisconnected()
```php
GetNetworkClientDisconnected(int $iNetID, int $client): int
```
Проверяет, отключился ли указанный клиент. Отключенные клиенты не удаляются автоматически из списка клиентов, что позволяет вам правильно обрабатывать их очистку. Как только вы справитесь с этим клиентом, вы должны удалить его из списка клиентов, вызвав DeleteNetworkClient. Клиент может сохраняться в течение некоторого времени, пока фоновый сетевой код не начнет фактически удалять его, поэтому будьте готовы к тому, что этот клиент будет болтаться вокруг в течение нескольких кадров, объявляя, что он отключен, и убедитесь, что вы очистите его только один раз. Вы можете обнаружить это, установив одно из значений SetNetworkClientUserData, чтобы уведомить себя о том, что оно было обработано.

---

<a name="method-getnfcexists"></a>

### GetNFCExists()
```php
GetNFCExists(): int
```
Возвращает 1, если текущее устройство имеет встроенное устройство NFC, в противном случае возвращается 0. Эта команда еще не функционирует.

---

<a name="method-getmusicpositionogg"></a>

### GetMusicPositionOGG()
```php
GetMusicPositionOGG(int $musicID): float
```
Возвращает текущую позицию в музыкальном файле, между 0 для начала файла и GetMusicDurationOGG для конца файла.

---

<a name="method-getmusicposition"></a>

### GetMusicPosition()
```php
GetMusicPosition(): float
```
Возвращает количество секунд воспроизведения текущего музыкального файла. Если в данный момент музыка не воспроизводится, эта команда вернет 0.

---

<a name="method-getnetworkclientname"></a>

### GetNetworkClientName()
```php
GetNetworkClientName(int $iNetID, int $client): string
```
Возвращает имя, которое клиент использовал для идентификации себя при подключении к хосту.

---

<a name="method-getmusicplayingogg"></a>

### GetMusicPlayingOGG()
```php
GetMusicPlayingOGG(int $musicID): int
```
Возвращает 1, если музыкальный файл воспроизводится в данный момент, и 0 в противном случае. Это будет продолжать возвращать 1, пока файл находится на паузе.

---

<a name="method-getmusicplaying"></a>

### GetMusicPlaying()
```php
GetMusicPlaying(): int
```
Возвращает идентификатор воспроизводимого в данный момент музыкального файла. Если музыка не воспроизводится, она возвращает 0.

---

<a name="method-getnetworkclientinteger"></a>

### GetNetworkClientInteger()
```php
GetNetworkClientInteger(int $iNetID, int $client, string $name): int
```
Получает копию целочисленной переменной удаленного клиента по имени. Также может быть использован для собственных переменных клиента, если ClientID равен GetNetworkMyClientID. Если переменная была установлена как переменная сброса, она вернется к 0 после чтения, это не повлияет на способность других клиентов считывать исходное значение. Каждый из них сбросит свою собственную копию. Если указанный клиент не установил переменную с заданным именем, то возвращается значение 0.

---

<a name="method-getmusicloopcountogg"></a>

### GetMusicLoopCountOGG()
```php
GetMusicLoopCountOGG(int $musicID): int
```
Возвращает количество раз, когда этот музыкальный файл был зациклен.

---

<a name="method-getmusicexists"></a>

### GetMusicExists()
```php
GetMusicExists(int $iID): int
```
Возвращает 1, если музыкальный файл существует с текущим идентификатором, и 0, если нет.

---

<a name="method-getmusicexistsogg"></a>

### GetMusicExistsOGG()
```php
GetMusicExistsOGG(int $musicID): int
```
Возвращает 1, если музыкальный файл существует с указанным идентификатором, и 0 в противном случае.

---

<a name="method-getmusicdurationogg"></a>

### GetMusicDurationOGG()
```php
GetMusicDurationOGG(int $musicID): float
```
Возвращает длительность музыкального файла в секундах в виде значения с плавающей запятой

---

<a name="method-getmultitouchexists"></a>

### GetMultiTouchExists()
```php
GetMultiTouchExists(): int
```
Возвращает 1, если текущее устройство поддерживает мультитач, и 0, если нет.

---

<a name="method-getmouseexists"></a>

### GetMouseExists()
```php
GetMouseExists(): int
```
Возвращает 1, если на текущем устройстве есть мышь, и 0, если нет.

---

<a name="method-getmonthfromunix"></a>

### GetMonthFromUnix()
```php
GetMonthFromUnix(int $unixtime): int
```
Возвращает месяц заданного значения времени unix (от 1 до 12). Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным.

---

<a name="method-getminutesfromunix"></a>

### GetMinutesFromUnix()
```php
GetMinutesFromUnix(int $unixtime): int
```
Возвращает минуты заданного значения времени unix (от 0 до 59). Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным.

---

<a name="method-getmeshmemblockvertexz"></a>

### GetMeshMemblockVertexZ()
```php
GetMeshMemblockVertexZ(int $memID, int $vertexIndex): float
```
Обеспечивает быстрый способ получить Z-позицию указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершины и расположения значений позиции.

---

<a name="method-getmeshmemblockvertexy"></a>

### GetMeshMemblockVertexY()
```php
GetMeshMemblockVertexY(int $memID, int $vertexIndex): float
```
Обеспечивает быстрый способ получения Y-позиции указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершины и расположения значений позиции.

---

<a name="method-getmeshmemblockvertexx"></a>

### GetMeshMemblockVertexX()
```php
GetMeshMemblockVertexX(int $memID, int $vertexIndex): float
```
Обеспечивает быстрый способ получения X-позиции указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершины и расположения значений позиции.

---

<a name="method-getmeshmemblockvertexv"></a>

### GetMeshMemblockVertexV()
```php
GetMeshMemblockVertexV(int $memID, int $vertexIndex): float
```
Обеспечивает быстрый способ получения значения V указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений UV.

---

<a name="method-getmeshmemblockvertexu"></a>

### GetMeshMemblockVertexU()
```php
GetMeshMemblockVertexU(int $memID, int $vertexIndex): float
```
Обеспечивает быстрый способ получения значения U указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений UV.

---

<a name="method-getmeshmemblockvertexred"></a>

### GetMeshMemblockVertexRed()
```php
GetMeshMemblockVertexRed(int $memID, int $vertexIndex): int
```
Предоставляет быстрый способ получить красное значение указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений цвета.

---

<a name="method-getmusicduration"></a>

### GetMusicDuration()
```php
GetMusicDuration(int $iID): float
```
Возвращает количество секунд, которое потребуется для воспроизведения данного музыкального файла от начала до конца. Для работы этой команды не должно быть никаких звуков, или данный идентификатор должен быть дорожкой, воспроизводимой в данный момент. Например, если вы попытаетесь получить продолжительность ID 2 и ID 1 в данный момент воспроизводится, то это не удастся, но если ID 2 в данный момент воспроизводится, то это будет успешно. Для файлов с переменной скоростью передачи битов эта команда вернет аппроксимацию.

---

<a name="method-getmeshmemblockvertexnormalz"></a>

### GetMeshMemblockVertexNormalZ()
```php
GetMeshMemblockVertexNormalZ(int $memID, int $vertexIndex): float
```
Обеспечивает быстрый способ получить Z-компоненту нормали указанной вершины из memblock. Он использует атрибутивные данные из начала мемблока для определения смещения вершин и расположения нормальных значений.

---

<a name="method-getmeshmemblockvertexnormaly"></a>

### GetMeshMemblockVertexNormalY()
```php
GetMeshMemblockVertexNormalY(int $memID, int $vertexIndex): float
```
Обеспечивает быстрый способ получения Y-компонента нормали указанной вершины из memblock. Он использует атрибутивные данные из начала мемблока для определения смещения вершин и расположения нормальных значений.

---

<a name="method-getmeshmemblockvertexnormalx"></a>

### GetMeshMemblockVertexNormalX()
```php
GetMeshMemblockVertexNormalX(int $memID, int $vertexIndex): float
```
Обеспечивает быстрый способ получения X-компонента нормали указанной вершины из memblock. Он использует атрибутивные данные из начала мемблока для определения смещения вершин и расположения нормальных значений.

---

<a name="method-getmeshmemblockvertexgreen"></a>

### GetMeshMemblockVertexGreen()
```php
GetMeshMemblockVertexGreen(int $memID, int $vertexIndex): int
```
Предоставляет быстрый способ получить зеленое значение указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений цвета.

---

<a name="method-getmeshmemblockvertexalpha"></a>

### GetMeshMemblockVertexAlpha()
```php
GetMeshMemblockVertexAlpha(int $memID, int $vertexIndex): int
```
Обеспечивает быстрый способ получения альфа - значения указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений цвета.

---

<a name="method-getmilliseconds"></a>

### GetMilliseconds()
```php
GetMilliseconds(): int
```
Получите количество миллисекунд с момента запуска приложения. Вызов этой команды внутренне вызовет системный вызов, чтобы получить количество прошедшего времени, поэтому он может меняться каждый раз, когда вы его вызываете.

---

<a name="method-getmeshmemblockvertexblue"></a>

### GetMeshMemblockVertexBlue()
```php
GetMeshMemblockVertexBlue(int $memID, int $vertexIndex): int
```
Обеспечивает быстрый способ получения синего значения указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений цвета.

---

<a name="method-getmemblocksize"></a>

### GetMemblockSize()
```php
GetMemblockSize(int $memID): int
```
Возвращает размер данного memblock в байтах.

---

<a name="method-getmemblockshort"></a>

### GetMemblockShort()
```php
GetMemblockShort(int $memID, int $offset): int
```
Возвращает короткое (2 байта) значение при заданном смещении. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 2, поскольку чтение коротких значений, не выровненных по 2-байтовым границам, влечет за собой снижение производительности оборудования. Короткие значения хранятся в формате little endian, поэтому запись короткого числа 23 со смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, а байт со смещением 1 как 0. Возвращаемое значение будет коротким со знаком между -32768 и 32767.

---

<a name="method-getmemblocksha1"></a>

### GetMemblockSHA1()
```php
GetMemblockSHA1(int $memID): string
```
Хэширует memblock с помощью SHA1 и возвращает полученный хэш

---

<a name="method-getmemblockint"></a>

### GetMemblockInt()
```php
GetMemblockInt(int $memID, int $offset): int
```
Возвращает значение int (4 байта) при заданном смещении. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку чтение целочисленных значений, не выровненных по 4-байтовым границам, влечет за собой снижение производительности оборудования. Значения Int хранятся в формате little endian, поэтому запись int 23 со смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, байт со смещением 1 как 0, байт со смещением 2 как 0 и байт со смещением 3 как 0. Возвращаемое значение будет целым числом со знаком от -2,147,483,648 до 2,147,483,647.

---

<a name="method-getmemblockexists"></a>

### GetMemblockExists()
```php
GetMemblockExists(int $memID): int
```
Возвращает 1, если существует memblock с заданным идентификатором, и 0, если нет.

---

<a name="method-getmemblockbytesigned"></a>

### GetMemblockByteSigned()
```php
GetMemblockByteSigned(int $memID, int $offset): int
```
Возвращает значение байта с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Возвращаемое значение будет байтом со знаком от -128 до 127.

---

<a name="method-getmemblockbyte"></a>

### GetMemblockByte()
```php
GetMemblockByte(int $memID, int $offset): int
```
Возвращает значение байта с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Возвращаемое значение будет байтом без знака между 0 и 255.

---

<a name="method-getmemblockstring"></a>

### GetMemblockString()
```php
GetMemblockString(int $memID, int $offset, int $length): string
```
Возвращает заданное количество байтов с заданным смещением и интерпретирует их как строку. Смещение плюс длина должны быть меньше размера memblock. Первое значение имеет смещение 0. Строка будет завершаться null, даже если в memblock не будет найден нулевой терминатор. Если нулевой терминатор возникает до достижения длины, то все байты все равно будут считаны, но только символы до первого нулевого терминатора будут доступны в AGK. Если вы используете уровень 2, вы должны удалить указатель, возвращаемый этой функцией.

---

<a name="method-getmaxdeviceheight"></a>

### GetMaxDeviceHeight()
```php
GetMaxDeviceHeight(): int
```
Получает максимальную высоту, которую может иметь окно вашего приложения. Для платформ, поддерживающих оконный режим, таких как Windows и Mac, ваше приложение может достичь такого размера только в полноэкранном режиме, поскольку оконный режим имеет границу вокруг вашего приложения. Для приложений HTML5 это вернет размер текущего HTML-документа и не гарантирует работу, если приложение HTML5 работает в полноэкранном режиме. Лучшим названием для этой команды было бы GetMaxWindowHeight, но теперь она высечена в камне.

---

<a name="method-getmanagedspritesortedcount"></a>

### GetManagedSpriteSortedCount()
```php
GetManagedSpriteSortedCount(): int
```
Возвращает количество спрайтов, которые внутренний менеджер спрайтов должен был отсортировать по их правильным позициям с момента последнего кадра. Спрайты нужно использовать только в том случае, если они меняют глубину или текстуру во время текущего кадра.

---

<a name="method-getmemblocksha256"></a>

### GetMemblockSHA256()
```php
GetMemblockSHA256(int $memID): string
```
Хэширует memblock с помощью SHA256 и возвращает полученный хэш

---

<a name="method-getmanagedspritedrawncount"></a>

### GetManagedSpriteDrawnCount()
```php
GetManagedSpriteDrawnCount(): int
```
Возвращает количество спрайтов, которые фактически были отправлены для рендеринга в последний кадр графического процессора, и чем больше их будет нарисовано, тем медленнее будет работать приложение.

---

<a name="method-getmanagedspritecount"></a>

### GetManagedSpriteCount()
```php
GetManagedSpriteCount(): int
```
Возвращает количество спрайтов, управляемых внутренним менеджером спрайтов. Он отвечает за обновление анимации спрайтов и вычисление того, какие спрайты видны и должны быть отправлены для рисования. Он также сортирует спрайты, когда это необходимо для правильного рисования прозрачности.  До тех пор, пока не будет отправлено слишком много спрайтов для рисования, менеджер спрайтов должен быть в состоянии обрабатывать несколько сотен спрайтов.

---

<a name="method-getmemblockfloat"></a>

### GetMemblockFloat()
```php
GetMemblockFloat(int $memID, int $offset): float
```
Возвращает значение float (4 байта) при заданном смещении. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку чтение значений float, не выровненных по 4-байтовым границам, влечет за собой снижение производительности оборудования. Значения Float хранятся в формате IEEE 754, поэтому запись float и последующее чтение его обратно в байтах вернут различные компоненты формата float.

---

<a name="method-getmanagedspritedrawcalls"></a>

### GetManagedSpriteDrawCalls()
```php
GetManagedSpriteDrawCalls(): int
```
Возвращает количество вызовов OpenGL draw, используемых для рисования всех управляемых спрайтов. Как правило, чем меньше это число, тем лучше производительность. AGK пытается паковать спрайты в как можно меньшее количество вызовов рисования, он делает это, ища спрайты с одинаковой текстурой и рисуя их одновременно.

---

<a name="method-getmagneticsensorexists"></a>

### GetMagneticSensorExists()
```php
GetMagneticSensorExists(): int
```
Возвращает 1, если текущее устройство имеет датчик магнетизма, который в настоящее время поддерживается AGK, и 0, если нет.

---

<a name="method-getlocalnotificationtime"></a>

### GetLocalNotificationTime()
```php
GetLocalNotificationTime(int $iID): int
```
Возвращает дату и время отображения указанного уведомления. Возвращаемое время будет в формате unix timestamp, который измеряется количеством секунд с 1 января 1970 года. Если по указанному идентификатору уведомления не существует, то возвращается 0

---

<a name="method-getlocalnotificationmessage"></a>

### GetLocalNotificationMessage()
```php
GetLocalNotificationMessage(int $iID): string
```
Возвращает сообщение, которое будет отображаться указанное уведомление. Если по указанному идентификатору уведомления не существует, то будет возвращена пустая строка

---

<a name="method-getlocalnotificationexists"></a>

### GetLocalNotificationExists()
```php
GetLocalNotificationExists(int $iID): int
```
Возвращает 1, если уведомление с этим идентификатором ожидает отображения, в противном случае 0. Уведомления обновляются каждые 5 секунд, так что это может продолжать возвращать 1 вскоре после того, как уведомление сработало.

---

<a name="method-getmaxdevicewidth"></a>

### GetMaxDeviceWidth()
```php
GetMaxDeviceWidth(): int
```
Получает максимальную ширину окна вашего приложения. Для платформ, поддерживающих оконный режим, таких как Windows и Mac, ваше приложение может достичь такого размера только в полноэкранном режиме, поскольку оконный режим имеет границу вокруг вашего приложения. Для приложений HTML5 это вернет размер текущего HTML-документа и не гарантирует работу, если приложение HTML5 работает в полноэкранном режиме. Лучшим названием для этой команды было бы GetMaxWindowWidth, но теперь она высечена в камне.

---

<a name="method-getloadedimages"></a>

### GetLoadedImages()
```php
GetLoadedImages(): int
```
Возвращает количество изображений, загруженных в данный момент в приложение.

---

<a name="method-getleapyear"></a>

### GetLeapYear()
```php
GetLeapYear(int $year): int
```
Возвращает 1, если данный год является високосным, в противном случае 0.

---

<a name="method-getlastchar"></a>

### GetLastChar()
```php
GetLastChar(): int
```
Возвращает значение unicode последнего ввода символа

---

<a name="method-getkeyboardexists"></a>

### GetKeyboardExists()
```php
GetKeyboardExists(): int
```
Возвращает 1, если текущее устройство имеет полноразмерную клавиатуру, 2, если устройство имеет виртуальную клавиатуру или клавиатуру мобильного телефона, и 0, если клавиатура вообще отсутствует.

---

<a name="method-getjoysticky"></a>

### GetJoystickY()
```php
GetJoystickY(): float
```
Джойстик AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания ввода в стиле джойстика в диапазоне от -1 до 1. Если к системе подключен физический джойстик, то он будет использоваться,в противном случае,если будет найдена полноразмерная клавиатура,клавиши W, A, S, D будут использоваться в качестве четырех направлений для джойстика. Если ни того, ни другого не существует, то на экране будет создан виртуальный джойстик, которым можно управлять либо с помощью сенсорного экрана, либо с помощью мыши. Используемый виртуальный джойстик будет иметь индекс 1, если он уже существует, его значения будут введены в эту эмулируемую команду джойстика. Вы можете расположить этот виртуальный джойстик в выбранном вами положении на экране с помощью SetJoystickScreenPosition. Каждая платформа гарантированно имеет метод генерации значения AGK - Y.

---

<a name="method-getjoystickx"></a>

### GetJoystickX()
```php
GetJoystickX(): float
```
Джойстик AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания ввода в стиле джойстика в диапазоне от -1 до 1. Если к системе подключен физический джойстик, то он будет использоваться,в противном случае,если будет найдена полноразмерная клавиатура,клавиши W, A, S, D будут использоваться в качестве четырех направлений для джойстика. Если ни того, ни другого не существует, то на экране будет создан виртуальный джойстик, которым можно управлять либо с помощью сенсорного экрана, либо с помощью мыши. Используемый виртуальный джойстик будет иметь индекс 1, если он уже существует, его значения будут введены в эту эмулируемую команду джойстика. Вы можете расположить этот виртуальный джойстик в выбранном вами положении на экране с помощью SetJoystickScreenPosition. Каждая платформа гарантированно имеет метод генерации значения AGK джойстика X.

---

<a name="method-getjointreactiontorque"></a>

### GetJointReactionTorque()
```php
GetJointReactionTorque(int $iJointIndex): float
```
Возвращает величину крутящего момента, приложенного к соединению на последнем временном шаге. Вы можете использовать это для обнаружения больших сил и удаления соединения, чтобы имитировать разрыв. Крутящий момент применяется к соединениям, которые вращаются, таким как вращающиеся соединения.

---

<a name="method-getjointreactionforcey"></a>

### GetJointReactionForceY()
```php
GetJointReactionForceY(int $iJointIndex): float
```
Возвращает величину силы, приложенной к соединению в направлении Y на последнем временном шаге. Вы можете использовать это для обнаружения больших сил и удаления соединения, чтобы имитировать разрыв.

---

<a name="method-getlightsensorexists"></a>

### GetLightSensorExists()
```php
GetLightSensorExists(): int
```
Возвращает 1, если текущее устройство имеет датчик окружающего света, который в настоящее время поддерживается AGK, и 0, если нет.

---

<a name="method-getjointreactionforcex"></a>

### GetJointReactionForceX()
```php
GetJointReactionForceX(int $iJointIndex): float
```
Возвращает величину силы, приложенной к соединению в направлении X на последнем временном шаге. Вы можете использовать это для обнаружения больших сил и удаления соединения, чтобы имитировать разрыв.

---

<a name="method-getlasterror"></a>

### GetLastError()
```php
GetLastError(): string
```
Возвращает строку, описывающую последнюю возникшую ошибку. Эта функция будет продолжать возвращать ту же строку до тех пор, пока не возникнет другая ошибка. Это не включает в себя предупреждения.

---

<a name="method-getjointexists"></a>

### GetJointExists()
```php
GetJointExists(int $iJointIndex): int
```
Возвращает 1, если указанное соединение все еще существует, и 0 в противном случае. Стыки могут быть удалены системой.

---

<a name="method-getinapppurchasestate"></a>

### GetInAppPurchaseState()
```php
GetInAppPurchaseState(): int
```
Возвращает текущее состояние попытки активации содержимого. Значение 0 указывает на то, что процесс продолжается, в то время как 1 подтверждает, что процесс завершен. В настоящее время эта команда поддерживается только на iOS и Android.

---

<a name="method-getinternetstate"></a>

### GetInternetState()
```php
GetInternetState(): int
```
Возвращает 1, если устройство подключено к Интернету, и 0, если нет.

---

<a name="method-getinapppurchasesignature"></a>

### GetInAppPurchaseSignature()
```php
GetInAppPurchaseSignature(int $iID): string
```
Возвращает подпись для последней покупки данного товара, это можно проверить по вашему открытому ключу, чтобы подтвердить, что покупка была действительной. Рекомендуется передать эту подпись серверу для выполнения проверки, чтобы ее нельзя было обойти.

---

<a name="method-getjoystickexists"></a>

### GetJoystickExists()
```php
GetJoystickExists(): int
```
Возвращает 1, если текущее устройство имеет по крайней мере один физический джойстик, доступный в качестве метода ввода. 0, если у него нет физических джойстиков джойстика. Если вы обнаружите, что платформа не имеет физических джойстиков, вы можете создать виртуальные джойстики, которые появляются на экране для использования сенсорными экранами или мышами с помощью AddVirtualJoystick. GetJoystickExists не учитывает виртуальные джойстики в своей проверке. На некоторых платформах обнаружение джойстика выполняется в фоновом потоке, который может не завершиться в течение некоторого времени после запуска вашего приложения, чтобы дождаться завершения потока, используйте CompleteRawJoystickDetection, чтобы убедиться, что все подключенные джойстики были найдены.

---

<a name="method-getinapppurchaselocalprice"></a>

### GetInAppPurchaseLocalPrice()
```php
GetInAppPurchaseLocalPrice(int $iID): string
```
Возвращает текущую цену указанного в приложении продукта покупки в местной валюте, это будет строка с включенным символом валюты, где это возможно. После вызова InAppPurchaseSetup может потребоваться несколько секунд, чтобы эти данные стали доступными, поэтому, если вы получите пустую строку, повторите попытку позже. При вызове этого метода из уровня 2 вы должны удалить возвращаемую строку, когда закончите с ней.

---

<a name="method-getinapppurchasedescription"></a>

### GetInAppPurchaseDescription()
```php
GetInAppPurchaseDescription(int $iID): string
```
Возвращает описание для указанного продукта, как определено текущим магазином платформы. После вызова InAppPurchaseSetup может потребоваться несколько секунд, чтобы эти данные стали доступными, поэтому, если вы получите пустую строку, повторите попытку позже. При вызове этого метода из уровня 2 вы должны удалить возвращаемую строку, когда закончите с ней.

---

<a name="method-getinapppurchaseavailable"></a>

### GetInAppPurchaseAvailable()
```php
GetInAppPurchaseAvailable(int $iID): int
```
Возвращает 1, если дополнительный контент был приобретен и поэтому доступен. Возвращает 0, если содержимое недоступно. В настоящее время эта команда поддерживается только на iOS и Android.

---

<a name="method-getimagewidth"></a>

### GetImageWidth()
```php
GetImageWidth(int $iImageIndex): float
```
Возвращает ширину изображения в пикселях. Даже если эта команда возвращает float, значение гарантированно будет целым числом.

---

<a name="method-getimagememoryusage"></a>

### GetImageMemoryUsage()
```php
GetImageMemoryUsage(): float
```
Возвращает объем памяти в мегабайтах, используемый в данный момент всеми загруженными изображениями (включая изображения, используемые шрифтами). Это может помочь отследить проблемы с памятью GPU, которые могут привести к сбою, если она закончится. Каждое загруженное изображение будет помещено в память графического процессора, даже если вы его не используете, поэтому загрузка слишком большого количества больших изображений может израсходовать всю память.

---

<a name="method-getimageexists"></a>

### GetImageExists()
```php
GetImageExists(int $iImageIndex): int
```
Возвращает 1, если изображение существует, и 0, если нет.

---

<a name="method-gethoursfromunix"></a>

### GetHoursFromUnix()
```php
GetHoursFromUnix(int $unixtime): int
```
Возвращает часы заданного значения времени unix (от 0 до 23). Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным.

---

<a name="method-gethttpstatuscode"></a>

### GetHTTPStatusCode()
```php
GetHTTPStatusCode(int $iHTTP): int
```
Возвращает код состояния, который был возвращен с сервера в ответе. Вы должны дождаться, пока GetHTTPResponseReady вернет ненулевое значение, прежде чем проверять эту команду, иначе она вернет 0. Обычно код состояния равен 200, когда запрос был успешным

---

<a name="method-getimagesizefromfile"></a>

### GetImageSizeFromFile()
```php
GetImageSizeFromFile(string $filename): int
```
Открывает файл изображения для извлечения значений ширины и высоты, а затем немедленно закрывает файл. Это намного быстрее, чем загрузка всего изображения. Это может быть полезно при использовании LoadImageResized, чтобы знать, насколько масштабировать изображение перед его загрузкой. И ширина, и высота будут возвращены в одном целочисленном значении, верхние 16 бит будут шириной, а нижние 16 бит-высотой. Вы можете извлечь эти значения в Tier 1, выполнив width = result >> 16 height = result && 0xFFFF

---

<a name="method-getimagefilename"></a>

### GetImageFilename()
```php
GetImageFilename(int $imageID): string
```
Возвращает имя файла, используемого для загрузки этого образа. В tier 2 возвращаемая строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-getimageheight"></a>

### GetImageHeight()
```php
GetImageHeight(int $iImageIndex): float
```
Возвращает высоту изображения в пикселях. Даже если эта команда возвращает float, значение гарантированно будет целым числом.

---

<a name="method-gethttpresponseready"></a>

### GetHTTPResponseReady()
```php
GetHTTPResponseReady(int $iHTTP): int
```
Возвращает 1, если запрос, ранее отправленный с помощью SendHTTPRequestASync, завершен. Вы можете получить ответ с помощью GetHTTPResponse. Возвращает 0, если запрос все еще выполняется, или -1, если запрос не удался.

---

<a name="method-gethttpfilecomplete"></a>

### GetHTTPFileComplete()
```php
GetHTTPFileComplete(int $iHTTP): int
```
Возвращает 1, если загрузка файла, ранее начатая с помощью GetHTTPFile, завершена, в противном случае-0. Даже если это возвращает 1, чтобы сказать, что загрузка завершена, возможно, она не удалась, проверьте GetHTTPResponseReady на наличие отрицательных значений, прежде чем предполагать, что загрузка прошла успешно.

---

<a name="method-getimage"></a>

### GetImage()
```php
GetImage(float $x, float $y, float $width, float $height): int
```
Захватывает часть backbuffer и создает из нее новое изображение. Значения положения и размера должны быть указаны в координатах экрана. Возвращает идентификатор нового изображения, он должен быть удален, когда вы закончите с ним. Чтобы эффективно использовать эту команду, вы должны знать, как AGK обращается к заднему буферу. При вызове синхронизации AGK обновляет позиции всех объектов с помощью Update, затем рисует их все в задний буфер с помощью Render, не очищая его, а затем выводит задний буфер на экран с помощью Swap. Затем он очищает задний буфер и возвращается к вашему коду, так что если бы вы вызвали getImage сразу после синхронизации, то получили бы пустое изображение, заполненное текущим чистым цветом. Поэтому, если вы хотите захватить изображение текущей сцены полностью нарисованной, вы должны вызвать Render, а затем getImage, а затем ClearScreen, чтобы очистить задний буфер, чтобы синхронизация не перерисовывала все по полностью нарисованному буферу глубины. Если вы уже используете Update, Render и Swap вместо Sync, то вызовите getImage между Render и Swap. Это также позволяет вам делать такие вещи, как рисовать линии в заднем буфере, получать изображение результата и затем очищать его, чтобы он не влиял на то, что отображается на экране. Вызов getImage-это медленная команда, и не рекомендуется вызывать ее каждый кадр. Обратите внимание, что изображение, полученное этой командой, не гарантированно будет иметь ту же ширину и высоту, что и заданные этой командой, это происходит потому, что изображение создается из части экрана, которая имеет разный размер на разных устройствах. Например, при виртуальном разрешении 480х360 вы получите изображение во весь экран, вызвав эту команду с шириной 480 и высотой 360, но на iPod это даст изображение 480х360 пикселей, в то время как на iPad оно будет около 1024х768 пикселей. Это не должно влиять на то, как вы используете изображение, поскольку применение его к спрайту и установка размера спрайта на тот же 480x360 заставит спрайт заполнить экран в обоих случаях. Это просто означает, что на iPad у вас есть более качественное изображение для игры. Это также относится к командам рисования линий: рисование линии от 0,0 до 100,100, а затем получение изображения от 0,0 до 100,100 приведет к получению изображения диагональной линии на всех устройствах, но устройства с высоким разрешением экрана будут производить изображение более высокого качества, содержащее больше пикселей. Используйте GetImageWidth и GetImageHeight, если вам нужно знать фактический размер изображения, полученного в пикселях.

---

<a name="method-gethttpfileprogress"></a>

### GetHTTPFileProgress()
```php
GetHTTPFileProgress(int $iHTTP): float
```
Возвращает ход загрузки файла в виде плавающего значения от 0 до 100. Это не следует полагаться на то, чтобы работать, когда загрузка закончена, и на некоторых платформах может не дать точного представления о ходе загрузки. Используйте GetHTTPFileComplete или GetHTTPResponseReady, чтобы определить, завершена ли загрузка.

---

<a name="method-gethttpfile"></a>

### GetHTTPFile()
```php
GetHTTPFile(int $iHTTP, string $szServerFile, string $szLocalFile): int
```
Загружает HTTP - файл с сервера, указанного в SetHTTPHost, и сохраняет его в указанном месте. Также позволяет отправлять POST-данные на сервер, которые могут включать переменные или файловые данные, например "myvar=5&var2=test". Эта команда немедленно возвращается и продолжает загрузку файла в фоновом режиме. Вы можете проверить ход загрузки с помощью GetHTTPFileProgress и GetHTTPFileComplete. Затем файл будет находиться в указанном вами месте, готовый к использованию с AGK.

---

<a name="method-getgyrosensorexists"></a>

### GetGyroSensorExists()
```php
GetGyroSensorExists(): int
```
Возвращает 1, если текущее устройство имеет гироскоп, который в настоящее время поддерживается AGK, и 0, если нет.

---

<a name="method-getgamecenterplayerid"></a>

### GetGameCenterPlayerID()
```php
GetGameCenterPlayerID(): string
```
Возвращает уникальный идентификатор игрока, вошедшего в систему в данный момент. Если никто не вошел в систему или платформа не поддерживает команды GameCenter, то это вернет пустую строку. Если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.

---

<a name="method-getgamecenterplayerdisplayname"></a>

### GetGameCenterPlayerDisplayName()
```php
GetGameCenterPlayerDisplayName(): string
```
Возвращает отображаемое имя для текущего вошедшего в систему игрока. Если никто не вошел в систему или платформа не поддерживает команды GameCenter, то это вернет пустую строку. Если вы вызываете эту команду из уровня 2, то возвращенная строка должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.

---

<a name="method-getgamecenterloggedin"></a>

### GetGameCenterLoggedIn()
```php
GetGameCenterLoggedIn(): int
```
Вернет 1, если пользователь вошел в Game Center или Google Play Games, и 0, если нет. Процесс входа в систему асинхронен, поэтому после вызова GameCenterLogin может потребоваться несколько секунд, чтобы эта команда вернула 1. Если пользователь не может войти в систему или GameCenter недоступен, то это вернет -1.

---

<a name="method-getgamecenterexists"></a>

### GetGameCenterExists()
```php
GetGameCenterExists(): int
```
Возвращает 1, если текущая платформа поддерживает Game Center или Google Play Games.

---

<a name="method-getgpssensorexists"></a>

### GetGPSSensorExists()
```php
GetGPSSensorExists(): int
```
Возвращает 1, если текущее устройство имеет GPS-приемник, который в настоящее время поддерживается AGK, и 0, если нет.

---

<a name="method-getfullscreenadvertloadedchartboost"></a>

### GetFullscreenAdvertLoadedChartboost()
```php
GetFullscreenAdvertLoadedChartboost(): int
```
Возвращает 1, если есть предварительно загруженное и готовое к показу интерстициальное объявление Chartboost, в противном случае 0. Если это так, вы можете отобразить его с помощью ShowFullscreenAdvertChartboost. Реклама предварительно загружается, как только вы устанавливаете свои данные Chartboost, и после того, как каждая полноэкранная реклама отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают 0, то вы можете попробовать вызвать ShowFullscreenAdvertChartboost в любом случае, он ничего не покажет, так как ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны какие-либо новые объявления.

---

<a name="method-getfullscreenadvertloadedamazon"></a>

### GetFullscreenAdvertLoadedAmazon()
```php
GetFullscreenAdvertLoadedAmazon(): int
```
Возвращает 1, если есть предварительно загруженная и готовая к показу реклама Amazon interstitial, в противном случае 0. Если это так, вы можете отобразить его с помощью ShowFullscreenAdvertAmazon. Реклама предварительно загружается, как только вы устанавливаете свои данные Amazon, и после того, как каждая полноэкранная реклама отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают 0, то вы можете попробовать вызвать ShowFullscreenAdvertAmazon в любом случае, он ничего не покажет, так как ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны какие-либо новые объявления.

---

<a name="method-getfullscreenadvertloadedadmob"></a>

### GetFullscreenAdvertLoadedAdMob()
```php
GetFullscreenAdvertLoadedAdMob(): int
```
Возвращает 1, если есть предварительно загруженное и готовое к показу интерстициальное объявление AdMob, в противном случае 0. Если это так, вы можете отобразить его с помощью ShowFullscreenAdvertAdMob. Объявления предварительно загружаются, как только вы устанавливаете свои данные AdMob, и после того, как каждая полноэкранная реклама отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают 0, то вы можете попробовать вызвать ShowFullscreenAdvertAdMob в любом случае, он ничего не покажет, так как ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны какие-либо новые объявления.

---

<a name="method-getframetime"></a>

### GetFrameTime()
```php
GetFrameTime(): float
```
Получите время в секундах, потраченное на обработку и рендеринг последнего кадра. Обновляется только при вызове Sync или Swap. Это ограничение ограничено максимальным значением 0,2 секунды, чтобы предотвратить интерполяцию внутреннего кода на основе таймера с большими временными промежутками. Чтобы найти истинное время кадра, вы можете использовать команду Timer ().

---

<a name="method-gethttpresponse"></a>

### GetHTTPResponse()
```php
GetHTTPResponse(int $iHTTP): string
```
Возвращает ответ с сервера на предыдущий отправленный запрос SendHTTPRequestASync. Вы должны дождаться, пока GetHTTPResponseReady вернет 1, прежде чем вызывать эту команду. В tier 2 вы должны удалить возвращаемую строку с помощью agk::DeleteString, когда закончите ее использовать. Уровень 2 имеет дополнительную команду GetHTTPResponseReadyC, которая возвращает const char, который не нуждается в удалении.

---

<a name="method-getfoldercount"></a>

### GetFolderCount()
```php
GetFolderCount(): int
```
Возвращает количество папок в текущей папке. Не включает в себя . или ..

---

<a name="method-getfolder"></a>

### GetFolder()
```php
GetFolder(): string
```
Возвращает текущую папку, ранее заданную с помощью SetFolder. Возвращаемый путь всегда будет иметь косую черту в качестве конечного символа, за исключением случаев, когда в корневой папке будет возвращена пустая строка.

---

<a name="method-getfirstfolder"></a>

### GetFirstFolder()
```php
GetFirstFolder(int $mode): string
```
Возвращает имя первой папки, найденной в текущей папке, которая задается с помощью SetFolder. Вы можете вызвать GetNextFolder, чтобы продолжить вниз по списку папок в текущей папке. Возвращает пустую строку, если в текущей папке нет папок. Не включает в себя . или .. Обратите внимание, что на Android существует известное ограничение, что любые папки в папке "активы" не могут быть найдены с помощью этой команды. Вы можете обойти эту проблему, используя MakeFolder для создания той же структуры папок в папке write, которую AGK затем может использовать для поиска файлов в папке assets с помощью GetFirstFile. По умолчанию эта команда объединит списки папок из папок чтения и записи в один список (mode=2), который можно изменить на только возвращаемые папки в папке чтения (mode=0) или только возвращаемые папки из папки записи (mode=1)

---

<a name="method-getfogmode"></a>

### GetFogMode()
```php
GetFogMode(): int
```
Возвращает 1, если 3D fog в данный момент включен, в противном случае он возвращает 0.

---

<a name="method-getfirstfile"></a>

### GetFirstFile()
```php
GetFirstFile(): string
```
Возвращает имя первого файла, найденного в текущей папке, который задается с помощью SetFolder. Вы можете вызвать GetNextFile, чтобы продолжить вниз по списку файлов в текущей папке. Возвращает пустую строку, если в текущей папке нет файлов. По умолчанию эта команда объединит списки файлов из папок чтения и записи в один список (mode=2) это может быть изменено на возврат только файлов из папки чтения (mode=0) или только файлов из папки записи (mode=1) Обратите внимание, что папка чтения не существует при использовании широковещательной передачи или отладки для запуска приложения, так как файлы копируются в папку записи проигрывателя AGK для этих режимов запуска. С другой стороны, папка записи начинается как пустая при запуске приложения непосредственно из IDE или при запуске конечного исполняемого файла приложения в папке проекта.

---

<a name="method-getfilepos"></a>

### GetFilePos()
```php
GetFilePos(int $iFileID): int
```
Возвращает текущую позицию чтения в файле

---

<a name="method-getfilesize"></a>

### GetFileSize()
```php
GetFileSize(int $iFileID): int
```
Возвращает размер открытого файла в байтах.

---

<a name="method-getfileexists"></a>

### GetFileExists()
```php
GetFileExists(string $szFile): int
```
Возвращает 1, если данный файл находится либо в каталоге ресурсов, либо в каталоге записи, назначенном приложению.

---

<a name="method-getfilecount"></a>

### GetFileCount()
```php
GetFileCount(): int
```
Возвращает количество файлов в текущей папке.

---

<a name="method-getfacebookdownloadstate"></a>

### GetFacebookDownloadState()
```php
GetFacebookDownloadState(): int
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-getfontexists"></a>

### GetFontExists()
```php
GetFontExists(int $iFontID): int
```
Возвращает 1, если шрифт был успешно загружен с заданным идентификатором.

---

<a name="method-getfacebookdownloadfile"></a>

### GetFacebookDownloadFile()
```php
GetFacebookDownloadFile(): string
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-getexpansionfilestate"></a>

### GetExpansionFileState()
```php
GetExpansionFileState(): int
```
Возвращает состояние любого файла расширения, используемого этой платформой, в настоящее время применимого только к Android. Возвращает -1, если во время загрузки произошла ошибка, 0, если файл расширения не используется на этой платформе, 1, если он должен существовать, но не существует (в этом случае вы вызываете функцию DownloadExpansionFile ()), 2, если он в данный момент загружается, и 3, если все завершено и файл существует.

---

<a name="method-getexpansionfileprogress"></a>

### GetExpansionFileProgress()
```php
GetExpansionFileProgress(): float
```
Проверяет ход загрузки, начатой с помощью DownloadExpansionFile, возвращает плавающее значение от 0 до 100 Используйте GetExpansionFileState, чтобы проверить, завершена ли загрузка.

---

<a name="method-getfirstcontact"></a>

### GetFirstContact()
```php
GetFirstContact(): int
```
Циклически просматривает список всех контактов, обнаруженных на последнем шаге физики. Возвращает 1 если контакт существует, вы можете получить спрайты, участвующие в этом контакте, используя GetContactSpriteID1 и GetContactSpriteID2, вы можете перейти к следующему контакту с помощью GetNextContact. Возвращает 0, если контактов нет.

---

<a name="method-geteditboxy"></a>

### GetEditBoxY()
```php
GetEditBoxY(int $index): float
```
Возвращает текущую позицию Y поля редактирования. Это верхний левый угол фактического поля ввода текста, любая граница будет простираться выше этой точки.

---

<a name="method-geterroroccurred"></a>

### GetErrorOccurred()
```php
GetErrorOccurred(): int
```
Возвращает 1, если с момента последнего вызова этой команды произошла ошибка. 0, если нет. Это не включает в себя предупреждения.

---

<a name="method-getexpansionfileerror"></a>

### GetExpansionFileError()
```php
GetExpansionFileError(): int
```
Возвращает код ошибки самой последней ошибки, возникшей при загрузке файла расширения. Возможные ошибки включают в себя: 15 = Нелицензированный 16 = Неудачная выборка URL-адреса 17 = Полная SD-карта 18 = Отменена 19 = Неизвестная ошибка

---

<a name="method-getfacebookloggedin"></a>

### GetFacebookLoggedIn()
```php
GetFacebookLoggedIn(): int
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-geteditboxvisible"></a>

### GetEditBoxVisible()
```php
GetEditBoxVisible(int $index): int
```
Возвращает 1, если поле редактирования видно и может быть нажато, 0, если поле редактирования невидимо и не может быть изменено.

---

<a name="method-geteditboxwidth"></a>

### GetEditBoxWidth()
```php
GetEditBoxWidth(int $index): float
```
Возвращает текущую ширину поля редактирования. Это ширина фактического поля ввода текста, любая граница будет выходить за пределы этого значения.

---

<a name="method-geteditboxtext"></a>

### GetEditBoxText()
```php
GetEditBoxText(int $index): string
```
Возвращает текст, отображаемый в данный момент в поле редактирования.

---

<a name="method-geteditboxlines"></a>

### GetEditBoxLines()
```php
GetEditBoxLines(int $index): int
```
Возвращает количество строк текста, введенных пользователем в поле редактирования.

---

<a name="method-geteditboxheight"></a>

### GetEditBoxHeight()
```php
GetEditBoxHeight(int $index): float
```
Возвращает текущую высоту поля редактирования. Это высота фактического поля ввода текста, любая граница будет выходить за пределы этого значения.

---

<a name="method-geteditboxhasfocus"></a>

### GetEditBoxHasFocus()
```php
GetEditBoxHasFocus(int $index): int
```
Возвращает 1, если поле редактирования было нажато и принимает входные данные.

---

<a name="method-geteditboxdepth"></a>

### GetEditBoxDepth()
```php
GetEditBoxDepth(int $index): int
```
Возвращает текущую глубину поля редактирования, где 0 - передняя часть экрана, а 10000-задняя.

---

<a name="method-geteditboxcursorposition"></a>

### GetEditBoxCursorPosition()
```php
GetEditBoxCursorPosition(int $index): int
```
Возвращает курсор в заданную позицию в тексте, то есть позиция 0 находится слева от первого символа, позиция 1-слева от второго символа и так далее.

---

<a name="method-geteditboxchanged"></a>

### GetEditBoxChanged()
```php
GetEditBoxChanged(int $index): int
```
Возвращает 1, если поле редактирования только что потеряло фокус, что означает, что текст, возможно, изменился и вряд ли изменится снова в краткосрочной перспективе.

---

<a name="method-geteditboxx"></a>

### GetEditBoxX()
```php
GetEditBoxX(int $index): float
```
Возвращает текущую позицию X поля редактирования. Это верхний левый угол фактического поля ввода текста, любая граница будет простираться влево от этой точки.

---

<a name="method-geteditboxactive"></a>

### GetEditBoxActive()
```php
GetEditBoxActive(int $index): int
```
Возвращает 1, если поле редактирования включено и может быть нажато, 0, если поле редактирования отключено и не может быть изменено.

---

<a name="method-getdrawingtime"></a>

### GetDrawingTime()
```php
GetDrawingTime(): float
```
Возвращает время, потраченное на замену backbuffer и (при необходимости) ожидание, пока GPU догонит готовый к следующему кадру.

---

<a name="method-getdocumentspath"></a>

### GetDocumentsPath()
```php
GetDocumentsPath(): string
```
Возвращает каталог, содержащий документы текущих пользователей. На Windows это будет что-то вроде "C:\Users\Me\My Документы", на iOS это будет просто каталог записи приложения. По умолчанию все приложения записываются в указанную системой папку настроек приложения, например "C:\Users\Me\AppData" в Windows", "/home/user/.config" в Linux и защищенная папка данных приложения на Android. Там, где это возможно, содержимое пути к документам видно пользователю, например, на Android 10, а ниже будет папка sdcard. iOS и Android 11 и выше не могут предоставить общедоступное место для записи, поэтому вместо этого будет возвращен каталог записи приложения, который не виден пользователю.

---

<a name="method-getdisplayaspect"></a>

### GetDisplayAspect()
```php
GetDisplayAspect(): float
```
Возвращает текущее соотношение сторон экрана. Это не соотношение сторон используемой системы координат, вместо этого это значение растягивает систему координат в нужную форму. Объяснение системы координат см. в разделе SetVirtualResolution.

---

<a name="method-getdirectiony"></a>

### GetDirectionY()
```php
GetDirectionY(): float
```
Возвращает текущее значение направления в направлении Y. Направление-это эмулируемое значение, которое будет использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.

---

<a name="method-geteditboxexists"></a>

### GetEditBoxExists()
```php
GetEditBoxExists(int $index): int
```
Возвращает 1, если существует поле редактирования с заданным идентификатором, и 0 в противном случае.

---

<a name="method-getdirectionx"></a>

### GetDirectionX()
```php
GetDirectionX(): float
```
Возвращает текущее значение направления в направлении X. Направление-это эмулируемое значение, которое будет использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.

---

<a name="method-getdirectionspeed"></a>

### GetDirectionSpeed()
```php
GetDirectionSpeed(): float
```
Возвращает текущую скорость направления в виде абсолютного значения от 0 до 1,4, это используется с GetDirectionAngle для определения экстента направления. Направление-это эмулируемое значение, которое будет использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.

---

<a name="method-getdeviceplatform"></a>

### GetDevicePlatform()
```php
GetDevicePlatform(): int
```
На Android это возвращает 0, если это приложение работает на устройстве Google, или 1, если оно работает на устройстве Amazon. На всех других платформах это возвращает 0.

---

<a name="method-getdevicetype"></a>

### GetDeviceType()
```php
GetDeviceType(): string
```
Возвращает строку, содержащую конкретную строку устройства, это будет отличаться для каждой платформы, например, в Windows она будет возвращать версию ОС "vista"," 7"," xp " и т. Д. На iOS он вернет имя устройства iOS "ipad1,1", "ipod2,1", "iphone1,2" и т. Д. Для Android он вернет модель устройства "nexus 7" и т. Д. Для Mac он вернет версию ОС "10.7", "10.8" и т. Д. Эта строка всегда будет строчной

---

<a name="method-getdrawingsetuptime"></a>

### GetDrawingSetupTime()
```php
GetDrawingSetupTime(): float
```
Возвращает количество секунд и долей секунд, затраченных на подготовку мира к рисованию. Это включает в себя вычисление того, что видно, преобразование спрайтов в их положение на экране и отправку вершин в графический процессор.

---

<a name="method-getdevicename"></a>

### GetDeviceName()
```php
GetDeviceName(): string
```
Эта команда устарела, пожалуйста, используйте GetDeviceBaseName и GetDeviceType вместо этого. Возвращает строку, содержащую имя текущей платформы, например "windows". При работе с iOS возвращается больше информации,например,на iPad 1 "ios|iPad1,1" и на iPod 2-го поколения: "ios|iPod2, 1" и на iPhone 3G: "ios|iPhone1, 2". Первое число-это главный номер модели, второе - второстепенный номер модели.

---

<a name="method-getdevicenetworktype"></a>

### GetDeviceNetworkType()
```php
GetDeviceNetworkType(): int
```
Возвращает тип сетевого подключения устройства к Интернету. Возвращает 0, если используется мобильное соединение, 1, если используется соединение Wi-Fi или Ethernet, или -1, если тип сети не может быть определен. В настоящее время реализовано только на iOS и Android, другие платформы вернут -1.

---

<a name="method-getdevicelanguage"></a>

### GetDeviceLanguage()
```php
GetDeviceLanguage(): string
```
Возвращает строку, содержащую язык текущего устройства в виде "en", "fr", "de" и т. Д.

---

<a name="method-getdeviceipv6"></a>

### GetDeviceIPv6()
```php
GetDeviceIPv6(): string
```
Возвращает IPv6-адрес текущего устройства, который может быть использован другими устройствами для подключения к этому устройству. Чтобы получить IPv4-адрес, используйте вместо него GetDeviceIP.

---

<a name="method-getdeviceip"></a>

### GetDeviceIP()
```php
GetDeviceIP(): string
```
Возвращает IPv4-адрес текущего устройства, который может быть использован другими устройствами для подключения к этому устройству. Чтобы получить IPv6-адрес, используйте вместо него GetDeviceIPv6.

---

<a name="method-getdeviceid"></a>

### GetDeviceID()
```php
GetDeviceID(): string
```
Возвращает строку, которая может быть использована для идентификации этого устройства

---

<a name="method-getdirectionangle"></a>

### GetDirectionAngle()
```php
GetDirectionAngle(): float
```
Возвращает текущий угол направления относительно x=0, y=-1 (вверх). Угол будет находиться в диапазоне 0-360. Направление-это эмулируемое значение, которое будет использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.

---

<a name="method-getdeviceheight"></a>

### GetDeviceHeight()
```php
GetDeviceHeight(): int
```
Возвращает высоту в пикселях backbuffer текущего устройства. Это значение изменится, если ориентация устройства изменится с книжной на альбомную, но только в том случае, если изменения ориентации разрешены.

---

<a name="method-getdevicewidth"></a>

### GetDeviceWidth()
```php
GetDeviceWidth(): int
```
Возвращает ширину в пикселях backbuffer текущего устройства. Это значение изменится, если ориентация устройства изменится с книжной на альбомную, но только в том случае, если изменения ориентации разрешены.

---

<a name="method-getdevicedpi"></a>

### GetDeviceDPI()
```php
GetDeviceDPI(): int
```
Получает точки на дюйм (также называемые Пикселями на дюйм) экрана устройства. Это работает только на iOS и Android, другие платформы вернут 0. В iOS это значение жестко закодировано устройством, поэтому, если будет выпущено новое устройство, для получения точного значения потребуется обновление AGK. Тем временем будет сформирована оценочная стоимость.

---

<a name="method-getdevicecameratype"></a>

### GetDeviceCameraType()
```php
GetDeviceCameraType(int $cameraID): int
```
Возвращает 1, если данный идентификатор камеры является задней камерой, 2, если это фронтальная камера, или 0, если это неизвестно.

---

<a name="method-getdevicebasename"></a>

### GetDeviceBaseName()
```php
GetDeviceBaseName(): string
```
Возвращает строку, содержащую имя текущей платформы. Это будет относиться только к базовой платформе, то есть "windows", "ios", "android", "mac", "linux" или "html5". Используйте GetDeviceType, чтобы получить дополнительную информацию о конкретном устройстве. Эта строка всегда будет строчной.

---

<a name="method-getdaysfromunix"></a>

### GetDaysFromUnix()
```php
GetDaysFromUnix(int $unixtime): int
```
Возвращает дни заданного значения времени unix (от 1 до 31). Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным.

---

<a name="method-getdayofweek"></a>

### GetDayOfWeek()
```php
GetDayOfWeek(): int
```
Возвращает целое число, представляющее текущий день недели в диапазоне 0-6 с 0 как воскресенье, 1 как понедельник и т. Д.

---

<a name="method-getcurrenttime"></a>

### GetCurrentTime()
```php
GetCurrentTime(): string
```
Возвращает строку, представляющую текущее время в формате HH-MM-SS, например 15:23:04.

---

<a name="method-getcurrenteditbox"></a>

### GetCurrentEditBox()
```php
GetCurrentEditBox(): int
```
Возвращает ИДЕНТИФИКАТОР текущего активного поля редактирования, только одно поле редактирования может фокусироваться одновременно. Если в данный момент ни одно поле редактирования не имеет фокуса, оно возвращает 0.

---

<a name="method-getcurrentdir"></a>

### GetCurrentDir()
```php
GetCurrentDir(): string
```
Эта команда устарела и была заменена GetFolder.

---

<a name="method-getcurrentdate"></a>

### GetCurrentDate()
```php
GetCurrentDate(): string
```
Возвращает строку, представляющую текущую дату в формате ГГГГ-ММ-ДД, например 2012-01-09.

---

<a name="method-getcontactworldx"></a>

### GetContactWorldX()
```php
GetContactWorldX(): float
```
Возвращает положение X точки контакта в мировых координатах.

---

<a name="method-getcontactspriteid2"></a>

### GetContactSpriteID2()
```php
GetContactSpriteID2(): int
```
Возвращает идентификатор второго спрайта, участвующего в этом контакте. Если эта половина контакта находится с элементом, не связанным со спрайтом, то это вернет 0.

---

<a name="method-getcontactspriteid1"></a>

### GetContactSpriteID1()
```php
GetContactSpriteID1(): int
```
Возвращает идентификатор первого спрайта, участвующего в этом контакте. Если эта половина контакта находится с элементом, не связанным со спрайтом, то это вернет 0.

---

<a name="method-getconsentstatusadmob"></a>

### GetConsentStatusAdMob()
```php
GetConsentStatusAdMob(): int
```
Возвращает текущий статус согласия пользователя, он возвращает одно из следующих значений: -2 = LoadConsentStatusAdMob еще не был вызван, вы должны вызвать его, прежде чем продолжить -1 = LoadConsentStatusAdMob находится в процессе загрузки статуса согласия пользователя, пожалуйста, подождите 0 = Пользователь еще не был спрошен, AdMob ads по умолчанию не будет использовать личную информацию, вызовите RequestConsentAdMob, чтобы запросить согласие пользователя 1 = Пользователь отказался от согласия, любые показанные объявления AdMob не будут использовать личную информацию 2 = Пользователь дал согласие, любые показанные объявления AdMob будут использовать личную информацию

---

<a name="method-getcolorred"></a>

### GetColorRed()
```php
GetColorRed(int $color): int
```
Возвращает красный компонент составного значения цвета, созданного с помощью MakeColor

---

<a name="method-getcolorgreen"></a>

### GetColorGreen()
```php
GetColorGreen(int $color): int
```
Возвращает зеленый компонент составного значения цвета, созданного с помощью MakeColor

---

<a name="method-getcolorblue"></a>

### GetColorBlue()
```php
GetColorBlue(int $color): int
```
Возвращает синий компонент составного значения цвета, созданного с помощью MakeColor

---

<a name="method-getclouddatavariable"></a>

### GetCloudDataVariable()
```php
GetCloudDataVariable(string $varName, string $defaultValue): string
```
Возвращает значение переменной облачных данных по имени. Если переменная не существует, то вместо нее будет возвращено значение по умолчанию, переданное по умолчанию. Если вы вызываете эту команду из уровня 2, то вы должны удалить возвращенную строку, когда закончите с ней, вызвав agk::DeleteString.

---

<a name="method-getclouddatachanged"></a>

### GetCloudDataChanged()
```php
GetCloudDataChanged(): int
```
Возвращает 1 если облачные данные изменились из-за того, что другое устройство изменило значение, оно будет оставаться 1 до тех пор, пока вы не вызовете GetCloudDataVariable. В противном случае возвращает 0. Это не станет 1, когда вы измените значение локально.

---

<a name="method-getclouddataallowed"></a>

### GetCloudDataAllowed()
```php
GetCloudDataAllowed(): int
```
Возвращает 1, если команды облачных данных доступны для использования. Возвращает 0, если пользователь еще не решил, разрешить или заблокировать доступ, это будет предложено в SetupCloudData, если это применимо. Возвращает -1, если пользователь специально отказал в доступе. Возвращает значение -2, если пользователь не вошел в систему или на устройстве нет iCloud или Google Диска. Вы можете предложить пользователю войти в систему и включить их при первом запуске вашего приложения или когда он решит включить облачное резервное копирование в ваших собственных настройках приложения. Если эта команда возвращает -3 на Android, то данные Google cloud повреждены и должны быть очищены в настройках диска.

---

<a name="method-getclipboardtext"></a>

### GetClipboardText()
```php
GetClipboardText(): string
```
Получает любой текст, который в данный момент хранится в буфере обмена устройства, текст остается в буфере обмена, поэтому он все еще может быть использован другими приложениями. Буфер обмена такой же, как и тот, который используется функцией копирования/вставки устройства.

---

<a name="method-getchosenimage"></a>

### GetChosenImage()
```php
GetChosenImage(): int
```
Возвращает ИДЕНТИФИКАТОР вновь выбранного изображения, выбранного с помощью ShowChooseImageScreen. Если это возвращает 0, то пользователь отменил процесс или вы еще не запустили его с помощью ShowChooseImageScreen. После того как вы вызвали эту команду для получения идентификатора изображения, она будет возвращать 0 до тех пор, пока ShowChooseImageScreen не будет вызван снова.

---

<a name="method-getcontactworldy"></a>

### GetContactWorldY()
```php
GetContactWorldY(): float
```
Возвращает положение точки контакта Y в мировых координатах.

---

<a name="method-getcharbufferlength"></a>

### GetCharBufferLength()
```php
GetCharBufferLength(): int
```
Возвращает текущую длину буфера символов без его изменения. Обратите внимание, что это длина в символах, а не в байтах, которая может отличаться, когда строка содержит символы юникода.

---

<a name="method-getcharbuffer"></a>

### GetCharBuffer()
```php
GetCharBuffer(): string
```
Возвращает строку всех символов, нажатых с момента последнего вызова этой команды, после вызова которой буфер очищается. Это работает только на устройствах с физической клавиатурой. Буфер ограничен 1024 символами, после чего дополнительные символы будут проигнорированы. В Tier 2 строка кодируется в UTF-8 и должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.

---

<a name="method-getcapturedimage"></a>

### GetCapturedImage()
```php
GetCapturedImage(): int
```
Эта функция устарела, вместо нее используйте SetDeviceCameraToImage. Возвращает ИДЕНТИФИКАТОР только что захваченного изображения, созданного с помощью ShowImageCaptureScreen. Если это возвращает 0, то пользователь отменил процесс или вы еще не запустили его с помощью ShowImageCaptureScreen. После того как вы вызвали эту команду для получения идентификатора изображения, она будет возвращать 0 до тех пор, пока ShowImageCaptureScreen не будет вызван снова.

---

<a name="method-getcameraz"></a>

### GetCameraZ()
```php
GetCameraZ(int $cameraID): float
```
Возвращает текущее положение Z камеры.

---

<a name="method-getcamerax"></a>

### GetCameraX()
```php
GetCameraX(int $cameraID): float
```
Возвращает текущее положение X камеры.

---

<a name="method-getcameray"></a>

### GetCameraY()
```php
GetCameraY(int $cameraID): float
```
Возвращает текущее положение Y камеры.

---

<a name="method-getcameraworldz"></a>

### GetCameraWorldZ()
```php
GetCameraWorldZ(int $cameraID): float
```
Возвращает текущее Z-положение камеры после всех преобразований, вызванных FixCameraToObject.

---

<a name="method-getcameraworldy"></a>

### GetCameraWorldY()
```php
GetCameraWorldY(int $cameraID): float
```
Возвращает текущее положение Y камеры после всех преобразований, вызванных FixCameraToObject.

---

<a name="method-getcameraworldx"></a>

### GetCameraWorldX()
```php
GetCameraWorldX(int $cameraID): float
```
Возвращает текущее положение X камеры после всех преобразований, вызванных FixCameraToObject.

---

<a name="method-getcameraquaty"></a>

### GetCameraQuatY()
```php
GetCameraQuatY(int $cameraID): float
```
Возвращает Y-компоненту текущего вращения камеры, преобразованную в кватернион.

---

<a name="method-getcameraquatz"></a>

### GetCameraQuatZ()
```php
GetCameraQuatZ(int $cameraID): float
```
Возвращает Z-компоненту текущего вращения камеры, преобразованную в кватернион.

---

<a name="method-getcameraquatx"></a>

### GetCameraQuatX()
```php
GetCameraQuatX(int $cameraID): float
```
Возвращает компонент X текущего вращения камеры, преобразованный в кватернион.

---

<a name="method-getcamerafov"></a>

### GetCameraFOV()
```php
GetCameraFOV(int $cameraID): float
```
Возвращает текущее поле зрения для указанной камеры

---

<a name="method-getcameraexists"></a>

### GetCameraExists()
```php
GetCameraExists(): int
```
Возвращает 1, если текущее устройство имеет камеру, и 0, если нет. На некоторых платформах эта команда перечисляет аппаратные устройства для проверки камеры, которая может быть медленной. Не рекомендуется называть это каждый кадр. В Windows эта команда успешно обнаружит новую камеру, подключенную во время работы приложения.

---

<a name="method-getcameraangley"></a>

### GetCameraAngleY()
```php
GetCameraAngleY(int $cameraID): float
```
Возвращает Y-компоненту текущего поворота камеры, преобразованную в углы Эйлера.

---

<a name="method-getcameraanglez"></a>

### GetCameraAngleZ()
```php
GetCameraAngleZ(int $cameraID): float
```
Возвращает Z-компоненту текущего поворота камеры, преобразованную в углы Эйлера.

---

<a name="method-getcameraanglex"></a>

### GetCameraAngleX()
```php
GetCameraAngleX(int $cameraID): float
```
Возвращает X-компоненту текущего поворота камеры, преобразованную в углы Эйлера.

---

<a name="method-getbuttonstate"></a>

### GetButtonState()
```php
GetButtonState(int $index): int
```
Эта функция возвращает 1, если указанная кнопка в данный момент удерживается нажатой. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут использоваться для команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5 соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая появится на экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа гарантированно имеет способ активации кнопок AGK.

---

<a name="method-getbuttonpressed"></a>

### GetButtonPressed()
```php
GetButtonPressed(int $index): int
```
Эта функция возвращает 1, если указанная кнопка только что была нажата, а затем возвращает 0, когда кнопка удерживается нажатой. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут использоваться для команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5 соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая появится на экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа гарантированно имеет способ активации кнопок AGK.

---

<a name="method-getbuttonreleased"></a>

### GetButtonReleased()
```php
GetButtonReleased(int $index): int
```
Эта функция возвращает 1, если указанная кнопка только что была отпущена, а затем возвращает 0, когда кнопка поднята. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут использоваться для команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5 соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая появится на экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа гарантированно имеет способ активации кнопок AGK.

---

<a name="method-getbroadcastmessage"></a>

### GetBroadcastMessage()
```php
GetBroadcastMessage(int $iID): int
```
Проверяет прослушиватель вещания на наличие любых передач. Возвращает 0, если ничего не было получено. Возвращает идентификатор сообщения если что-то было получено, вы можете получить доступ к содержимому этого сообщения с помощью команд сетевого сообщения. Сообщение должно быть удалено, когда вы закончите чтение.

---

<a name="method-getapprunning"></a>

### GetAppRunning()
```php
GetAppRunning(int $appID): int
```
Возвращает 1, если указанный идентификатор приложения все еще работает, и 0, если это не так.

---

<a name="method-getappname"></a>

### GetAppName()
```php
GetAppName(): string
```
Возвращает имя exe-файла.

---

<a name="method-getapppackagename"></a>

### GetAppPackageName()
```php
GetAppPackageName(): string
```
На Android это возвращает имя пакета, используемое при экспорте приложения, например, для AGK Player это будет com.thegamecreators.agk_player2. В iOS он возвращает идентификатор пакета, используемый для приложения, например, для AGK Player это будет com.thegamecreators.agk2player. На всех других платформах это в настоящее время возвращает пустую строку. Если вы вызываете это из уровня 2, то возвращаемая строка должна быть удалена, когда она больше не нужна.

---

<a name="method-getappinstalled"></a>

### GetAppInstalled()
```php
GetAppInstalled(string $packageName): int
```
Возвращает 1, если указанное приложение установлено и включено на устройстве. Для Android это должно быть имя пакета приложения, например com.faceboook.катана для приложения Facebook. В настоящее время это работает только на Android

---

<a name="method-getcameraquatw"></a>

### GetCameraQuatW()
```php
GetCameraQuatW(int $cameraID): float
```
Возвращает W-компонент текущего вращения камеры, преобразованный в кватернион.

---

<a name="method-getaccelerometerexists"></a>

### GetAccelerometerExists()
```php
GetAccelerometerExists(): int
```
Возвращает 1, если текущее устройство имеет акселерометр, который в настоящее время поддерживается AGK, и 0, если нет.

---

<a name="method-get3dvectoryfromscreen"></a>

### Get3DVectorYFromScreen()
```php
Get3DVectorYFromScreen(float $x, float $y): float
```
Преобразует 2D-точку на экране в вектор, указывающий в 3D-мир. Вектор нормализуется на 1 единицу длины, чтобы расширить его в мир, просто умножьте его на желаемое расстояние.  Если камера использует ортогональную проекционную матрицу, то эта команда ведет себя несколько иначе, поскольку все точки на экране будут производить один и тот же вектор, направленный в сторону от камеры, но каждый из них исходит из другой точки в трехмерном пространстве. Это отличается от перспективной проекции, где все векторы начинаются в положении камеры и расходятся веером по мере удаления от камеры. Поэтому при использовании ортогональной проекционной матрицы эта команда вместо этого возвращает боковой ненормализованный вектор из положения камеры в точку в 3D-пространстве, с которой должен начинаться вектор. Затем это может быть объединено с вектором, который указывает в сторону от камеры, чтобы создать луч, брошенный в сцену.

---

<a name="method-get3dphysicstotalobjects"></a>

### Get3DPhysicsTotalObjects()
```php
Get3DPhysicsTotalObjects(): int
```
Возвращает общее количество физических объектов в мире.

---

<a name="method-get3dphysicstotaljoints"></a>

### Get3DPhysicsTotalJoints()
```php
Get3DPhysicsTotalJoints(): int
```
Возвращает общее количество суставов в физическом мире

---

<a name="method-get3dphysicsraycastnumhits"></a>

### Get3DPhysicsRayCastNumHits()
```php
Get3DPhysicsRayCastNumHits(int $rayID): int
```
Возвращает общее количество попаданий луча по его длине.

---

<a name="method-get3dphysicsraycastfraction"></a>

### Get3DPhysicsRayCastFraction()
```php
Get3DPhysicsRayCastFraction(int $rayID): float
```
Возвращает расстояние вдоль луча до столкновения, где 1.0 = полная длина, 0.0 = начало.

---

<a name="method-get3dphysicsraycastobjecthit"></a>

### Get3DPhysicsRayCastObjectHit()
```php
Get3DPhysicsRayCastObjectHit(int $rayID, float $fractionIndex): int
```
Возвращает идентификатор объекта, пораженного лучом по индексу.

---

<a name="method-get3dphysicsraycastnormalvector"></a>

### Get3DPhysicsRayCastNormalVector()
```php
Get3DPhysicsRayCastNormalVector(int $rayID, int $returnVec3ID): void
```
Заполняет переданный вектор значениями нормалей от луча. сначала создайте физический луч, а затем бросьте его перед вызовом Get3DPhysicsRayCastNormalVector().

---

<a name="method-get3dvectorxfromscreen"></a>

### Get3DVectorXFromScreen()
```php
Get3DVectorXFromScreen(float $x, float $y): float
```
Преобразует 2D-точку на экране в вектор, указывающий в 3D-мир. Вектор нормализуется на 1 единицу длины, чтобы расширить его в мир, просто умножьте его на желаемое расстояние.  Если камера использует ортогональную проекционную матрицу, то эта команда ведет себя несколько иначе, поскольку все точки на экране будут производить один и тот же вектор, направленный в сторону от камеры, но каждый из них исходит из другой точки в трехмерном пространстве. Это отличается от перспективной проекции, где все векторы начинаются в положении камеры и расходятся веером по мере удаления от камеры. Поэтому при использовании ортогональной проекционной матрицы эта команда вместо этого возвращает боковой ненормализованный вектор из положения камеры в точку в 3D-пространстве, с которой должен начинаться вектор. Затем это может быть объединено с вектором, который указывает в сторону от камеры, чтобы создать луч, брошенный в сцену.

---

<a name="method-get3dphysicsraycastcontactposition"></a>

### Get3DPhysicsRayCastContactPosition()
```php
Get3DPhysicsRayCastContactPosition(int $rayID, float $fractionIndex, int $outVec3ID): int
```
Возвращает true, если есть контактный вектор, и заполняет вектор outVec3ID. Сначала создайте вектор с помощью CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен результатами.

---

<a name="method-get3dphysicsragdollfromboneobject"></a>

### Get3DPhysicsRagdollFromBoneObject()
```php
Get3DPhysicsRagdollFromBoneObject(int $objID): int
```
Возвращает идентификатор объекта модели с ragdoll, который содержит переданный объект ragdoll bone.

---

<a name="method-get3dvectorzfromscreen"></a>

### Get3DVectorZFromScreen()
```php
Get3DVectorZFromScreen(float $x, float $y): float
```
Преобразует 2D-точку на экране в вектор, указывающий в 3D-мир. Вектор нормализуется на 1 единицу длины, чтобы расширить его в мир, просто умножьте его на желаемое расстояние.  Если камера использует ортогональную проекционную матрицу, то эта команда ведет себя несколько иначе, поскольку все точки на экране будут производить один и тот же вектор, направленный в сторону от камеры, но каждый из них исходит из другой точки в трехмерном пространстве. Это отличается от перспективной проекции, где все векторы начинаются в положении камеры и расходятся веером по мере удаления от камеры. Поэтому при использовании ортогональной проекционной матрицы эта команда вместо этого возвращает боковой ненормализованный вектор из положения камеры в точку в 3D-пространстве, с которой должен начинаться вектор. Затем это может быть объединено с вектором, который указывает в сторону от камеры, чтобы создать луч, брошенный в сцену.

---

<a name="method-get3dphysicsragdollexist"></a>

### Get3DPhysicsRagdollExist()
```php
Get3DPhysicsRagdollExist(int $objID): int
```
Возвращает true, если для объекта существует тряпичная кукла.

---

<a name="method-get3dphysicsjointrotationvector"></a>

### Get3DPhysicsJointRotationVector()
```php
Get3DPhysicsJointRotationVector(int $jointID): int
```
Возвращает угол поворота суставов X в градусах

---

<a name="method-get3dphysicsraycastclosestcontactposition"></a>

### Get3DPhysicsRayCastClosestContactPosition()
```php
Get3DPhysicsRayCastClosestContactPosition(int $rayID, int $outVec3ID): int
```
Возвращает true, если существует ближайший контактный вектор, и заполняет вектор outVec3ID. Сначала создайте вектор с помощью CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен результатами.

---

<a name="method-get3dphysicsjointpositionvector"></a>

### Get3DPhysicsJointPositionVector()
```php
Get3DPhysicsJointPositionVector(int $jointID): int
```
Возвращает идентификатор вектора

---

<a name="method-get3dphysicsraycastclosestobjecthit"></a>

### Get3DPhysicsRayCastClosestObjectHit()
```php
Get3DPhysicsRayCastClosestObjectHit(int $rayID): int
```
Верните ближайший объект, пораженный лучом.

---

<a name="method-get3dphysicscharactercontrollermaxslope"></a>

### Get3DPhysicsCharacterControllerMaxSlope()
```php
Get3DPhysicsCharacterControllerMaxSlope(int $objID): float
```
Возвращает максимальный наклон в градусах.

---

<a name="method-get3dphysicscharactercontrollergravity"></a>

### Get3DPhysicsCharacterControllerGravity()
```php
Get3DPhysicsCharacterControllerGravity(int $objID): float
```
Возвращает контроллер гравитации.

---

<a name="method-get3dphysicscharactercontrollerexists"></a>

### Get3DPhysicsCharacterControllerExists()
```php
Get3DPhysicsCharacterControllerExists(int $objID): int
```
Возвращает 1, если объект имеет контроллер, в противном случае 0.

---

<a name="method-get3dphysicsactiveobjects"></a>

### Get3DPhysicsActiveObjects()
```php
Get3DPhysicsActiveObjects(): int
```
Возвращает общее количество активных объектов в физическом мире.

---

<a name="method-get3dparticlesz"></a>

### Get3DParticlesZ()
```php
Get3DParticlesZ(int $ID): float
```
Возвращает текущее Z - положение излучателя, это точка, из которой будут появляться новые частицы. Невозможно получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.

---

<a name="method-get3dparticlesx"></a>

### Get3DParticlesX()
```php
Get3DParticlesX(int $ID): float
```
Возвращает текущее положение X излучателя, это точка, из которой будут появляться новые частицы. Невозможно получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.

---

<a name="method-get3dparticlesy"></a>

### Get3DParticlesY()
```php
Get3DParticlesY(int $ID): float
```
Возвращает текущее положение Y излучателя, это точка, из которой будут появляться новые частицы. Невозможно получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.

---

<a name="method-get3dparticlesvisible"></a>

### Get3DParticlesVisible()
```php
Get3DParticlesVisible(int $ID): int
```
Возвращает 0, если данные частицы были установлены как невидимые с помощью Set3DParticlesVisible, или 1, если они в данный момент установлены как видимые (по умолчанию). Это не проверяет, находятся ли частицы в видимом окне просмотра.

---

<a name="method-get3dparticlessize"></a>

### Get3DParticlesSize()
```php
Get3DParticlesSize(int $ID): float
```
Возвращает текущий размер всех частиц в мировых координатах. Дополнительные сведения об установке размера частиц см. в разделе Set3DParticlesSize.

---

<a name="method-get3dparticlesmaxreached"></a>

### Get3DParticlesMaxReached()
```php
Get3DParticlesMaxReached(int $ID): int
```
Возвращает 1, если излучатель испустил количество частиц, указанное в Set3DParticlesMax, и все испущенные частицы с тех пор умерли, в противном случае возвращает 0. Если максимальное значение равно -1, то оно всегда будет возвращать 0. Чтобы сбросить счетчик и заставить излучатель снова начать излучать, используйте Reset3DParticleCount.

---

<a name="method-get3dparticleslife"></a>

### Get3DParticlesLife()
```php
Get3DParticlesLife(int $ID): float
```
Возвращает текущую жизнь частиц в секундах. Невозможно получить текущую жизнь отдельных частиц. Это значение не зависит от частоты кадров.

---

<a name="method-get3dphysicsjointenabled"></a>

### Get3DPhysicsJointEnabled()
```php
Get3DPhysicsJointEnabled(int $jointID): int
```
Возвращает порог разрыва соединения.

---

<a name="method-get3dparticlesexists"></a>

### Get3DParticlesExists()
```php
Get3DParticlesExists(int $ID): int
```
Возвращает 1, если 3D-излучатель частиц существует с заданным идентификатором, и 0, если нет.

---

<a name="method-get3dparticlesdirectionz"></a>

### Get3DParticlesDirectionZ()
```php
Get3DParticlesDirectionZ(int $ID): float
```
Возвращает z-компоненту направления излучателя, которое является базовым направлением движения частиц при их создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения Set3DParticlesDirection.

---

<a name="method-get3dparticlesdirectiony"></a>

### Get3DParticlesDirectionY()
```php
Get3DParticlesDirectionY(int $ID): float
```
Возвращает y-компоненту направления излучателя, которое является базовым направлением движения частиц при их создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения Set3DParticlesDirection.

---

<a name="method-get3dparticlesdirectionx"></a>

### Get3DParticlesDirectionX()
```php
Get3DParticlesDirectionX(int $ID): float
```
Возвращает X-компоненту направления излучателя, которое является базовым направлением движения частиц при их создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения Set3DParticlesDirection.

---

<a name="method-get3dparticlesdirectionrange2"></a>

### Get3DParticlesDirectionRange2()
```php
Get3DParticlesDirectionRange2(int $ID): float
```
Возвращает угол второго излучателя в градусах. Это значение представляет собой величину отклонения частицы от направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 360 означает, что частица может двигаться в любом направлении в этой плоскости при излучении.

---

<a name="method-get3dparticlesactive"></a>

### Get3DParticlesActive()
```php
Get3DParticlesActive(int $ID): int
```
Возвращает 0, если данные частицы были приостановлены с помощью Set3DParticlesActive, или 1, если они в данный момент обновляются как обычно (по умолчанию).

---

<a name="method-get3dparticlesdirectionrange1"></a>

### Get3DParticlesDirectionRange1()
```php
Get3DParticlesDirectionRange1(int $ID): float
```
Возвращает первый угол излучателя в градусах. Это значение представляет собой величину отклонения частицы от направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 360 означает, что частица может двигаться в любом направлении в этой плоскости при излучении.

---

<a name="method-gamecentersubmitscore"></a>

### GameCenterSubmitScore()
```php
GameCenterSubmitScore(int $iScore, string $szBoardID): void
```
Отправляет счет на именованную доску лидеров, которая должна соответствовать идентификатору таблицы лидеров, присвоенному вашей доске в iTunes connect, Google Game Services или GameCircle.

---

<a name="method-gamecentersubmitachievement"></a>

### GameCenterSubmitAchievement()
```php
GameCenterSubmitAchievement(string $szAchievementID, int $iPercentageComplete): void
```
Изменение прогресса пользователей при достижении именованного достижения имя должно совпадать с идентификатором достижения, присвоенным этому достижению в iTunes connect, Google Game Services или GameCircle. Значения iPercentageComplete должны находиться в диапазоне от 0 до 100. Однако для инкрементных достижений это значение фактически является числом завершенных шагов и может находиться за пределами этого диапазона. Это значение будет перезаписывать текущий процент или выполненные шаги достижения.

---

<a name="method-gamecentershowleaderboard"></a>

### GameCenterShowLeaderBoard()
```php
GameCenterShowLeaderBoard(string $szBoardID): void
```
Показывает пользователю именованную таблицу лидеров, имя которой должно совпадать с идентификатором таблицы лидеров, присвоенным вашей доске в iTunes connect, Google Game Services или GameCircle.

---

<a name="method-gamecentersetup"></a>

### GameCenterSetup()
```php
GameCenterSetup(): void
```
Вызовите этот вызов один раз, чтобы настроить приложение для дальнейших команд Game Center.

---

<a name="method-get3dparticlesfrequency"></a>

### Get3DParticlesFrequency()
```php
Get3DParticlesFrequency(int $ID): float
```
Возвращает текущую частоту генерации частиц в частицах в секунду. Это значение не зависит от частоты кадров.

---

<a name="method-gamecenterlogin"></a>

### GameCenterLogin()
```php
GameCenterLogin(): void
```
Вызовите это один раз, чтобы войти в систему пользователя в Game Center (iOS) или Google Play Games (Android), если они вошли в систему до того, как это произойдет в фоновом режиме и не прерывает пользователя, в противном случае появится всплывающее окно с просьбой войти в систему и предоставить разрешение на продолжение.

---

<a name="method-gamecenterachievementsreset"></a>

### GameCenterAchievementsReset()
```php
GameCenterAchievementsReset(): void
```
Еще не функционирует

---

<a name="method-gamecenterachievementsshow"></a>

### GameCenterAchievementsShow()
```php
GameCenterAchievementsShow(): void
```
Показывает пользователю свои достижения и прогресс.

---

<a name="method-gamecenterlogout"></a>

### GameCenterLogout()
```php
GameCenterLogout(): void
```
Вызовите эту функцию, чтобы вывести пользователя из Google Play Games. После этого вы можете снова вызвать GameCenterLogin. На Game Center (iOS) это никак не влияет, пользователь должен выйти из приложения Game Center.

---

<a name="method-flushsocket"></a>

### FlushSocket()
```php
FlushSocket(int $socketID): int
```
Немедленно отправляет все ожидающие данные на удаленный хост. Если вы не вызовете этот вызов, то данные будут вечно ждать в буфере, пока вы не запишете в сокет более 1400 байт, после чего он автоматически будет сброшен. Каждый раз, когда вы вызываете эту команду, будет отправлен новый пакет, поэтому при отправке нескольких значений вы не должны вызывать его после каждого значения, так как это приведет к потере пропускной способности сети. Вы должны записать все значения, а затем сбросить их, чтобы они были отправлены вместе. Если нет данных, ожидающих отправки, эта команда ничего не делает. Возвращает 1, если сокет был успешно сброшен, 0, если сокет отключен.

---

<a name="method-floor"></a>

### Floor()
```php
Floor(float $a): int
```
Округляет поплавок до следующего наименьшего целого числа. Это отличается от Trunc при использовании отрицательных чисел, Trunc( -1.6 ) равен -1, а Floor( -1.6 ) равен -2.

---

<a name="method-fixtexttoscreen"></a>

### FixTextToScreen()
```php
FixTextToScreen(int $iTextIndex, int $mode): void
```
По умолчанию текстовые объекты создаются в мировых координатах, и SetViewOffset можно использовать для перемещения по всему миру. Используйте эту команду, чтобы вместо этого зафиксировать текст на экране, чтобы он перемещался вместе с видовым окном при перемещении видового окна. Вы все еще можете изменить положение текста, закрепленного на экране, это влияет только на то, что происходит при перемещении видового экрана.

---

<a name="method-fixspritetoscreen"></a>

### FixSpriteToScreen()
```php
FixSpriteToScreen(int $iSpriteIndex, int $mode): void
```
По умолчанию спрайты создаются в мировых координатах, и SetViewOffset можно использовать для перемещения по всему миру. Используйте эту команду, чтобы вместо этого зафиксировать спрайт на экране, чтобы он перемещался вместе с видовым окном при перемещении видового окна. Вы все еще можете изменить положение спрайта, который закреплен на экране, это влияет только на то, что происходит при перемещении видового экрана. Вы не должны использовать команды физики или столкновения для спрайтов, закрепленных на экране, так как их отладочные формы не будут выстраиваться в линию и будут мешать физическим спрайтам, не закрепленным на экране.

---

<a name="method-fixskeleton2dtoscreen"></a>

### FixSkeleton2DToScreen()
```php
FixSkeleton2DToScreen(int $iSkeleton, int $mode): void
```
Фиксирует указанный скелет на экране так, чтобы он не был затронут SetViewOffset

---

<a name="method-fixparticlestoscreen"></a>

### FixParticlesToScreen()
```php
FixParticlesToScreen(int $ID, int $mode): void
```
Фиксация частиц на экране гарантирует, что они не будут затронуты прокруткой видового экрана.

---

<a name="method-fixobjecttoobject"></a>

### FixObjectToObject()
```php
FixObjectToObject(int $objID, int $toObjID): void
```
Фиксирует объект к другому объекту, так что любое движение родителя также влияет на ребенка. Фиксируемый объект использует свое текущее положение, поворот и масштаб в качестве смещения по отношению к родительскому объекту. Например, если родитель был помещен в 10,5,0 и объект был закреплен на нем с текущей позицией 0,10,0, то ребенок теперь унаследует позицию родителя, объединит ее со своей собственной, и ребенок будет помещен в 10,15,0. То же самое относится к вращению и масштабированию, поэтому, если родитель был повернут вокруг оси Y, то и ребенок будет вращаться на ту же величину. Обратите внимание, что использование GetObjectY на дочернем объекте будет показывать только его локальное положение относительно родительского (в этом случае он вернет 10). Чтобы получить конечную мировую позицию ребенка, используйте GetObjectWorldY на нем, который в этом случае вернет 15. Нет предела количеству объектов, которые объект может зафиксировать на себе, и нет предела тому, чтобы объекты были зафиксированы на объектах, которые фиксированы на других объектах, просто не создавайте никаких циклов. Чтобы остановить фиксацию объекта к чему-либо, установите toObjID в 0, и он снова станет независимым.

---

<a name="method-fixobjecttobone"></a>

### FixObjectToBone()
```php
FixObjectToBone(int $objID, int $toObjID, int $toBoneIndex): void
```
Аналогично FixObjectToObject, за исключением того, что родитель будет костью в другом объекте.

---

<a name="method-fixeditboxtoscreen"></a>

### FixEditBoxToScreen()
```php
FixEditBoxToScreen(int $index, int $fix): void
```
По умолчанию спрайты и поля редактирования создаются в мировых координатах, а SetViewOffset можно использовать для перемещения по всему миру. Используйте эту команду, чтобы вместо этого зафиксировать поле редактирования на экране, чтобы оно перемещалось вместе с видовым окном при перемещении видового окна. Вы все еще можете изменить положение поля редактирования, закрепленного на экране, оно влияет только на то, что происходит при перемещении окна просмотра.

---

<a name="method-fixobjectpivot"></a>

### FixObjectPivot()
```php
FixObjectPivot(int $objID): void
```
Сбрасывает положение и вращение объекта на 0, сохраняя при этом вершины объекта там, где они находятся. Это можно использовать для изменения центра вращения объекта или настройки его ориентации по умолчанию, когда его вращение равно 0. Эта команда изменяет вершины сеток объекта, поэтому не рекомендуется вызывать ее каждый кадр, если только целевая платформа не является достаточно мощной, то есть Windows, Mac или Linux.

---

<a name="method-firebasesetup"></a>

### FirebaseSetup()
```php
FirebaseSetup(): void
```
Запускает систему Firebase analytics и отслеживание некоторых автоматизированных событий. Дополнительные события можно отслеживать с помощью FirebaseLogEvent. Вы должны включить конфигурационный файл Google Services, созданный при настройке проекта Firebase, который можно добавить во время экспорта для Android или iOS. Если вы не укажете свой собственный конфигурационный файл google services во время экспорта, то все ваши данные отслеживания будут отправлены в наш проект AGK Firebase и проигнорированы. Аналогично, если вы используете эти команды во время трансляции, то данные отслеживания будут отправлены в проект AGK и проигнорированы.

---

<a name="method-firebaselogevent"></a>

### FirebaseLogEvent()
```php
FirebaseLogEvent(string $event_name): void
```
Говорит Firebase записать событие, которое произошло в вашем приложении, например, разблокировку достижения. Они появятся на странице аналитики проекта Firebase. Обратите внимание, что имена событий не должны содержать тире или пробелы, иначе они не будут зарегистрированы.

---

<a name="method-finishpulleyjoint"></a>

### FinishPulleyJoint()
```php
FinishPulleyJoint(float $gnd1x, float $gnd1y, float $gnd2x, float $gnd2y, float $a1x, float $a1y, float $a2x, float $a2y): int
```
Создает соединение шкива между двумя спрайтами. Это вторая половина двухкомандной установки. Из-за количества требуемых параметров вы должны сначала вызвать CreatePulleyJoint2 с начальным набором параметров для создания соединения. Эта команда возвращает идентификатор нового соединения.

---

<a name="method-findstringreverse"></a>

### FindStringReverse()
```php
FindStringReverse(string $str, string $findStr): int
```
Возвращает индекс первого вхождения findStr в заданную строку, начиная с конца строки и двигаясь назад. Используйте начальное значение -1, чтобы начать с самого конца строки независимо от ее длины. Индекс 1-это первый символ в строке, возвращающий 0, если он не найден. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.

---

<a name="method-fixspritetoskeleton2d"></a>

### FixSpriteToSkeleton2D()
```php
FixSpriteToSkeleton2D(int $spriteID, int $iSkeletonID, int $bone, int $zorder): void
```
Прикрепляет указанный спрайт к заданному идентификатору скелета и кости. Идентификатор кости можно найти с помощью команды GetSkeleton2DBone. Когда спрайт прикреплен к кости скелета, его положение и вращение становятся относительно положения кости. Например, если положение спрайта равно 0,0, то он будет нарисован в том же положении, что и кость, но если положение равно 0,10, то спрайт будет нарисован над костью относительно кости, то есть если кость повернута влево на 90 градусов, то "выше" кости будет находиться слева от экрана в мировых координатах.  ZOrder может быть задан для рисования спрайта между двумя существующими спрайтами скелета, любое целочисленное значение является допустимым и соответствует текущему порядку спрайтов в скелете. Например, Z-порядок 0 всегда будет рисовать перед первым спрайтом в Z-порядке скелета, значение 1 всегда будет рисовать перед вторым спрайтом в скелете и так далее. Обратите внимание, что на это не влияют другие спрайты, которые вы прикрепили к скелету, он учитывает только те спрайты, которые изначально были загружены вместе со скелетом. Например, если вы прикрепили к скелету два новых спрайта с z-порядком, равным 1, то они оба будут нарисованы между первым и вторым спрайтами в исходном скелете. Любые спрайты, прикрепленные к скелету с использованием одного и того же значения zorder, будут нарисованы в том порядке, в котором они были прикреплены.  Пока этот спрайт прикреплен к скелету, он будет удален из обычных процедур рисования и нарисован только тогда, когда скелет виден. Вы все еще можете заставить спрайт рисовать, вызвав DrawSprite, но он не будет упорядочен с другими спрайтами в скелете.  Чтобы отделить спрайт от скелета, вызовите эту команду с 0 в качестве skeletonID, параметры bone ID и zorder в этом случае не имеют значения.

---

<a name="method-findstringcount"></a>

### FindStringCount()
```php
FindStringCount(string $str, string $findStr, int $ignoreCase, int $start): int
```
Возвращает количество раз, когда findStr появляется в данной строке. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.

---

<a name="method-findstring"></a>

### FindString()
```php
FindString(string $str, string $findStr): int
```
Возвращает индекс первого вхождения findStr в заданную строку. Индекс 1-это первый символ в строке, возвращающий 0, если он не найден. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.

---

<a name="method-finalize3dphysicsragdoll"></a>

### Finalize3DPhysicsRagDoll()
```php
Finalize3DPhysicsRagDoll(): void
```
Заканчивает строительство тряпичной куклы. Вызовите эту команду, когда вы добавите все кости и суставы для вашей тряпичной куклы. Убедитесь, что вы сначала вызвали Create3DPhysicsRagDoll, прежде чем вызывать эту команду.

---

<a name="method-fileisopen"></a>

### FileIsOpen()
```php
FileIsOpen(int $iFileID): int
```
Возвращает 1, если данный файл был успешно открыт, и 0, если нет. Вы можете использовать GetErrorOccurred, чтобы проверить, было ли это результатом ошибки, и GetLastError, чтобы получить указанную ошибку.

---

<a name="method-fileeof"></a>

### FileEOF()
```php
FileEOF(int $iFileID): int
```
Возвращает 1, если данный файл достиг конца своего потока данных, и 0 в противном случае. Используется только при чтении.

---

<a name="method-facebookshowlikebutton"></a>

### FacebookShowLikeButton()
```php
FacebookShowLikeButton(string $szURL, int $iX, int $iY, int $iWidth, int $iHeight): void
```
Эта команда в настоящее время не поддерживается

---

<a name="method-facebooksetup"></a>

### FacebookSetup()
```php
FacebookSetup(string $szID): void
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-fixcameratoobject"></a>

### FixCameraToObject()
```php
FixCameraToObject(int $cameraID, int $objID): void
```
Фиксирует камеру на объекте таким образом, что любое движение объекта также влияет на камеру. Камера использует свое текущее положение, поворот и масштаб в качестве смещения по отношению к объекту. Например, если объект был помещен в 10,5,0 и к нему была прикреплена камера с текущим положением 0,10,0, то камера теперь унаследует положение объекта, объединит его со своим собственным, и камера будет помещена в 10,15,0. То же самое относится к вращению и масштабированию, поэтому, если объект был повернут вокруг оси Y, то камера будет вращаться на ту же величину. Обратите внимание, что использование GetCameraY покажет только его локальное положение относительно родительского объекта (в этом случае он вернет 10). Чтобы получить конечное мировое положение камеры, используйте GetCameraWorldY, который в этом случае вернет 15. Нет предела количеству объектов или камер, которые объект может зафиксировать на себе, и нет предела тому, что объекты фиксируются на объектах, которые фиксируются на других объектах, просто не создавайте никаких петель. Чтобы остановить фиксацию камеры к чему-либо, установите ObjId в 0, и она снова станет независимой.

---

<a name="method-facebookpostonmywall"></a>

### FacebookPostOnMyWall()
```php
FacebookPostOnMyWall(mixed $szLink, mixed $szPicture, mixed $szName, mixed $szCaption, mixed $szDescription): void
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает. Вы можете использовать ShareText или ShareImage, чтобы дать пользователю возможность поделиться своей информацией.

---

<a name="method-facebookpostonfriendswall"></a>

### FacebookPostOnFriendsWall()
```php
FacebookPostOnFriendsWall(mixed $szID, mixed $szLink, mixed $szPicture, mixed $szName, mixed $szCaption, mixed $szDescription): void
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookgetusername"></a>

### FacebookGetUserName()
```php
FacebookGetUserName(): string
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookgetuserid"></a>

### FacebookGetUserID()
```php
FacebookGetUserID(): string
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookgetfriendsstate"></a>

### FacebookGetFriendsState()
```php
FacebookGetFriendsState(): int
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookgetfriendsname"></a>

### FacebookGetFriendsName()
```php
FacebookGetFriendsName(mixed $iIndex): string
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookgetfriendsid"></a>

### FacebookGetFriendsID()
```php
FacebookGetFriendsID(mixed $iIndex): string
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookgetfriendscount"></a>

### FacebookGetFriendsCount()
```php
FacebookGetFriendsCount(): int
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebooklogout"></a>

### FacebookLogout()
```php
FacebookLogout(): void
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebooklogin"></a>

### FacebookLogin()
```php
FacebookLogin(): void
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookgetfriends"></a>

### FacebookGetFriends()
```php
FacebookGetFriends(): void
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookinvitefriend"></a>

### FacebookInviteFriend()
```php
FacebookInviteFriend(mixed $szID, mixed $szMessage): void
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookgetaccesstoken"></a>

### FacebookGetAccessToken()
```php
FacebookGetAccessToken(): string
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookdownloadfriendsphoto"></a>

### FacebookDownloadFriendsPhoto()
```php
FacebookDownloadFriendsPhoto(mixed $iIndex): void
```
Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает

---

<a name="method-facebookactivateapptracking"></a>

### FacebookActivateAppTracking()
```php
FacebookActivateAppTracking(): void
```
Facebook Facebook Facebook SDK Активирует отслеживание в SDK Facebook, это полезно, если вы используете рекламу Facebook, так как это будет связывать установки с рекламой, ранее увиденной и нажатой на Facebook. Обратите внимание, что в iOS эта функция требует IDFA (рекламный идентификатор), и вы должны объявить об этом, если отправляете приложение в Apple. Apple спросит, используете ли вы IDFA и для чего вы его используете. Для отслеживания установки с помощью рекламы Facebook вы ДОЛЖНЫ поставить галочки "Приписать установку этого приложения ранее показанной рекламе" и "Приписать действие, предпринятое в этом приложении, ранее показанной рекламе". Если вы также используете AdMob, Amazon Ads или Chartboost в своем приложении, вы также должны поставить галочку "Показывать рекламу в приложении". Эта команда не требует, чтобы пользователь входил в систему.

---

<a name="method-facebookdestroylikebutton"></a>

### FacebookDestroyLikeButton()
```php
FacebookDestroyLikeButton(): void
```
Эта команда в настоящее время не поддерживается

---

<a name="method-fmod"></a>

### FMod()
```php
FMod(float $a, float $b): float
```
Возвращает остаток от деления с плавающей запятой a/b.

---

<a name="method-extractzipasync"></a>

### ExtractZipASync()
```php
ExtractZipASync(string $zipfilename, string $path, string $password): void
```
Эта команда делает то же самое, что и ExtractZip, за исключением того, что она возвращается немедленно, а извлечение zip выполняется в потоке в фоновом режиме. Вы можете использовать GetZipExtractProgress и GetZipExtractComplete, чтобы проверить его прогресс. Если вы вызовете эту команду во время извлечения zip-файла, то ничего не произойдет. Если указанный почтовый индекс не имеет пароля, то используйте пустую строку.

---

<a name="method-extractzip"></a>

### ExtractZip()
```php
ExtractZip(string $zipfilename, string $path): void
```
Извлекает zip-файл в указанный каталог. Все папки, созданные внутри zip-файла, будут созданы в процессе извлечения. Если zip - файл защищен паролем, укажите пароль для его извлечения. Если вы укажете неправильный пароль, извлеченные файлы из zip-архива будут пусты. Локальный путь к файлу находится относительно текущего каталога, установленного с помощью SetFolder, если только вы не начинаете путь с прямой косой черты, и в этом случае путь будет относительно корня каталога записи на текущей платформе.

---

<a name="method-enablecleardepth"></a>

### EnableClearDepth()
```php
EnableClearDepth(int $clear): void
```
Задает, следует ли очищать буфер глубины при вызове Sync или Swap. По умолчанию это значение равно true. Отключать это не рекомендуется, так как все, что использует буфер глубины, будет появляться только в течение одного кадра, а затем, похоже, исчезнет. Эта функция может не иметь никакого влияния на мобильные устройства.

---

<a name="method-encodeqrcode"></a>

### EncodeQRCode()
```php
EncodeQRCode(string $text, int $errormode): int
```
Кодирует данный текст в QR - код и возвращает новый идентификатор изображения, содержащий этот код. Вы можете выбрать количество исправлений ошибок, включенных в код, чтобы часть QR-кода была повреждена, но все еще была читабельной. Чем выше режим коррекции ошибок, тем больше вероятность того, что поврежденный или скрытый QR-код будет считан правильно, но более высокие режимы коррекции ошибок могут привести к увеличению QR-кода. Уровень 0 по-прежнему обеспечивает минимальный уровень исправления ошибок, а не никакой.

---

<a name="method-enableclearcolor"></a>

### EnableClearColor()
```php
EnableClearColor(int $clear): void
```
Задает, следует ли очищать буфер кадров при вызове Sync или Swap. По умолчанию это значение равно true. Единственная причина вызвать эту команду-это если у вас есть фоновый спрайт или набор спрайтов, которые полностью закрывают экран, так что цвет фона никогда не будет виден. В этих случаях некоторые графические процессоры могут извлечь выгоду из отключения четкого цвета. Обратите внимание, что во многих случаях последний нарисованный кадр останется на экране, однако это не гарантировано, и вы не должны создавать эффекты, которые полагаются на него, так как они могут не работать в будущем и не будут работать на мобильных устройствах. Для создания эффектов, сохраняющих содержимое предыдущего кадра, рекомендуется использовать SetRenderToImage для захвата выходных данных одного кадра, а затем нарисовать его в следующем кадре, то есть вы визуализируете все до изображения 1, затем в следующем кадре вы вставляете изображение 1 в фон новой цели рендеринга, а затем рисуете новый кадр. Например, нарисуйте все в кадре 1 к изображению 1, затем в кадре 2 вы нарисуете изображение 1 с полноэкранным четырехугольным объектом к изображению 2, а затем нарисуете все в кадре 2 к изображению 2. Затем вы можете поменять местами цели рендеринга так, чтобы в кадре 3 вы нарисовали изображение 2 с полноэкранным квадратом обратно в изображение 1, затем нарисуйте объекты в кадре 3 на изображение 1. Продолжайте чередовать изображение 1 и 2, чтобы в кадре 4 сначала было нарисовано изображение 1 с полноэкранным квадратом на изображение 2, а затем нарисуйте все в кадре 4 на изображение 2. Важно не продолжать рисовать все на одном и том же изображении, то есть рисовать кадр 1 на изображении 1, затем кадр 2 на изображении 1 и так далее, потому что мобильные устройства используют внутренний отложенный рендеринг, который будет держать все увеличивающийся список вещей, которые нужно нарисовать на изображении 1. Если изображение никогда не будет очищено, то производительность снизится.

---

<a name="method-drawtext"></a>

### DrawText()
```php
DrawText(int $iTextIndex): void
```
Сразу же рисует текст в backbuffer в его текущем положении, размере и повороте. Это полезно, если вы хотите настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться дважды в окончательном рендеринге.

---

<a name="method-drawsprite"></a>

### DrawSprite()
```php
DrawSprite(int $iSpriteIndex): void
```
Немедленно рисует спрайт в backbuffer в его текущем положении, размере и вращении. Это полезно, если вы хотите настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться дважды в окончательном рендеринге.

---

<a name="method-drawobject"></a>

### DrawObject()
```php
DrawObject(int $objID): void
```
Немедленно рисует объект к текущей цели рендеринга в его текущем положении, размере и повороте. Это полезно, если вы хотите нарисовать определенные объекты, такие как небесные ящики, перед любыми другими объектами. В этом случае обязательно сделайте объект невидимым для вызовов Render() или Sync (), иначе объект может появиться дважды.

---

<a name="method-drawparticles"></a>

### DrawParticles()
```php
DrawParticles(int $ID): void
```
Немедленно притягивает излучатель частиц к обратному буферу в его текущем положении, размере и вращении. Это полезно, если вы хотите настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться дважды в окончательном рендеринге.

---

<a name="method-drawbox"></a>

### DrawBox()
```php
DrawBox(float $x, float $y, float $x2, float $y2, int $color1, int $color2, int $color3, int $color4, int $filled): void
```
Рисует 2D-прямоугольник из одной точки экрана в другую с выбранным цветом с помощью линий. Линии появляются над всеми другими чертежами, кроме команды Print, и могут использоваться с функцией getImage или SetRenderToImage для создания новых изображений. Координаты XY находятся в экранных координатах, поэтому команда SetViewOffset на них не влияет. Цвета могут быть созданы с помощью команды MakeColor или с помощью побитовых операторов типа so, mycolor = (blue

---

<a name="method-drawline"></a>

### DrawLine()
```php
DrawLine(float $x, float $y, float $x2, float $y2, int $color1, int $color2): void
```
Рисует 2D-линию из одной точки экрана в другую с выбранным цветом. Линии появляются над всеми другими чертежами, кроме команды Print, и могут использоваться с функцией getImage для создания новых изображений. Координаты XY находятся в экранных координатах, поэтому команда SetViewOffset на них не влияет.

---

<a name="method-drawellipse"></a>

### DrawEllipse()
```php
DrawEllipse(float $x, float $y, float $radiusx, float $radiusy, int $color1, int $color2, int $filled): void
```
Рисует 2D-эллипс с центром в координатах, заданных выбранным цветом или градиентом. 2D-фигуры появляются над всеми другими чертежами, кроме команды Print, и могут использоваться с функцией getImage для создания новых изображений. Координаты XY находятся в экранных координатах, поэтому команда SetViewOffset на них не влияет.

---

<a name="method-downloadexpansionfile"></a>

### DownloadExpansionFile()
```php
DownloadExpansionFile(): void
```
Запускает загрузку любого файла расширения, необходимого этой платформе и приложению, в настоящее время применимого только к Android. Если загрузка уже началась, это не имеет никакого эффекта. Вы можете использовать GetExpansionFileProgress для проверки хода загрузки и GetExpanionFileState для проверки ее завершения. После вызова этой команды вы должны дождаться, пока GetExpanionFileState вернет -1 (ошибка) или 3 (завершение) при отображении индикатора выполнения.

---

<a name="method-draw3dparticles"></a>

### Draw3DParticles()
```php
Draw3DParticles(int $ID): void
```
Немедленно притягивает частицы к backbuffer в его текущем положении, размере и вращении. Это полезно, если вы хотите настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться дважды в окончательном рендеринге.

---

<a name="method-deletevideo"></a>

### DeleteVideo()
```php
DeleteVideo(): void
```
Останавливает любое воспроизводимое видео и удаляет любое загруженное видео из памяти.

---

<a name="method-deletevirtualbutton"></a>

### DeleteVirtualButton()
```php
DeleteVirtualButton(int $index): void
```
Удаляет виртуальную кнопку по заданному индексу. Никакие другие команды виртуальных кнопок не могут быть вызваны для этого индекса, если он не будет воссоздан с помощью AddVirtualButton.

---

<a name="method-deletevirtualjoystick"></a>

### DeleteVirtualJoystick()
```php
DeleteVirtualJoystick(int $index): void
```
Удаляет виртуальный джойстик и удаляет его с экрана. Никакие другие команды виртуального джойстика не могут быть вызваны на этом индексе, если он не воссоздан с помощью AddVirtualJoystick.

---

<a name="method-deletevector3"></a>

### DeleteVector3()
```php
DeleteVector3(int $vectorID): void
```
Удаляет вектор

---

<a name="method-deletetweenchain"></a>

### DeleteTweenChain()
```php
DeleteTweenChain(int $chainID): void
```
Удаляет цепочку и останавливает всех подростков, которые были связаны с ней. Любые подростки, которые были добавлены к нему, не затрагиваются и могут быть использованы в будущих цепочках.

---

<a name="method-deletetween"></a>

### DeleteTween()
```php
DeleteTween(int $tweenID): void
```
Удалите заданный идентификатор анимации. Это может быть использовано для всех типов твинов, спрайтов, текста, объектов и т. Д.

---

<a name="method-deletesprite"></a>

### DeleteSprite()
```php
DeleteSprite(int $iSpriteIndex): void
```
Удаляет спрайт с заданным идентификатором.

---

<a name="method-deletesound"></a>

### DeleteSound()
```php
DeleteSound(int $iID): void
```
Удалите звук по указанному номеру звука. Это также приведет к удалению всех экземпляров звука.

---

<a name="method-deletesocketlistener"></a>

### DeleteSocketListener()
```php
DeleteSocketListener(int $listenerID): void
```
Останавливает прослушиватель сокета от получения соединений и освобождает идентификатор для повторного использования. Если какие-либо соединения все еще находятся в очереди и еще не собраны с помощью GetSocketListenerConnection, то они будут закрыты и удалены.

---

<a name="method-deleteskeleton2d"></a>

### DeleteSkeleton2D()
```php
DeleteSkeleton2D(int $iSkeleton): void
```
Удаляет скелет с указанным идентификатором. Если в этом идентификаторе нет скелета, то ничего не происходит.

---

<a name="method-deletesocket"></a>

### DeleteSocket()
```php
DeleteSocket(int $socketID): void
```
Удаляет идентификатор сокета, чтобы его можно было использовать снова. Если розетка в данный момент подключена, то сначала соединение закрывается.

---

<a name="method-deletesharedvariable"></a>

### DeleteSharedVariable()
```php
DeleteSharedVariable(string $varName): void
```
Удаляет общую переменную по имени. Если переменная не существует, то это ничего не даст. Как только переменная будет удалена, LoadSharedVariable вернет значение по умолчанию для любых запросов на ее загрузку.

---

<a name="method-deleteudplistener"></a>

### DeleteUDPListener()
```php
DeleteUDPListener(int $listenerID): void
```
Удаляет указанный UDP-listenere и освобождает порт, который он использовал.

---

<a name="method-deletepointlight"></a>

### DeletePointLight()
```php
DeletePointLight(int $lightID): void
```
Удаляет указанный точечный свет. Если точечный свет не существует, эта команда ничего не делает.

---

<a name="method-deletephysicsforce"></a>

### DeletePhysicsForce()
```php
DeletePhysicsForce(int $iForceIndex): void
```
Удаляет указанную глобальную силу.

---

<a name="method-deletetext"></a>

### DeleteText()
```php
DeleteText(int $iTextIndex): void
```
Удаляет текстовый объект.

---

<a name="method-deleteparticles"></a>

### DeleteParticles()
```php
DeleteParticles(int $ID): void
```
Удаляет излучатель частиц и все его частицы. Если какие-либо частицы были в данный момент видны, они мгновенно исчезнут.

---

<a name="method-deleteobjectwithchildren"></a>

### DeleteObjectWithChildren()
```php
DeleteObjectWithChildren(int $objID): void
```
Удаляет объект с заданным идентификатором, если объект не существует, то эта команда ничего не делает. Эта команда также удаляет все дочерние объекты, которые были созданы при загрузке этого объекта, если вы не хотите их удалять, то вместо этого используйте DeleteObject. Если вы используете эту команду для объекта, который был загружен с помощью LoadObject, то он удаляет его как обычно.

---

<a name="method-deleteobjecttree"></a>

### DeleteObjectTree()
```php
DeleteObjectTree(int $objID): void
```
Удаляет объект с заданным идентификатором, если объект не существует, то эта команда ничего не делает. Эта команда также удаляет все дочерние объекты, созданные при загрузке этого объекта, и все объекты, которые в данный момент прикреплены к этому объекту, из использования FixObjectToObject или FixObjectToBone.

---

<a name="method-deleteobject"></a>

### DeleteObject()
```php
DeleteObject(int $objID): void
```
Удаляет объект с заданным идентификатором, если объект не существует, то эта команда ничего не делает. Обратите внимание, что если объект был загружен с помощью LoadObjectWithChildren, то все дочерние объекты, созданные в ходе этого процесса загрузки, не будут удалены этой командой. Вы можете использовать GetObjectChildID для получения и удаления этих объектов вручную или использовать DeleteObjectWithChildren для удаления всего, что было создано при загрузке этого объекта.

---

<a name="method-deletenetworkmessage"></a>

### DeleteNetworkMessage()
```php
DeleteNetworkMessage(int $iMsgID): void
```
Удаляет сетевое сообщение, это должно быть вызвано для сообщений, полученных от сетевых устройств, и сообщений, которые не были отправлены на сетевое устройство (если код решает отказаться от отправки сообщения). Сообщения, которые были созданы и отправлены, будут обработаны и удалены сетевым кодом и не должны быть удалены с помощью этой команды.

---

<a name="method-deletenetworkclient"></a>

### DeleteNetworkClient()
```php
DeleteNetworkClient(int $iNetID, int $client): void
```
Удаляет отключенный клиент из списка клиентов. Если эта функция вызывается на клиенте, который не отключен, она вызовет ошибку и не повлияет на клиента. Не удаляет клиент сразу, фоновый код может занять несколько кадров, чтобы обойти его удаление. Вызов этой команды несколько раз на отключенном клиенте не должен вызывать проблем.

---

<a name="method-deletemusicogg"></a>

### DeleteMusicOGG()
```php
DeleteMusicOGG(int $musicID): void
```
Удаляет музыкальный файл и освобождает идентификатор для повторного использования.

---

<a name="method-deletemusic"></a>

### DeleteMusic()
```php
DeleteMusic(int $iID): void
```
Удаляет музыкальный файл из списка воспроизведения.

---

<a name="method-deletememblock"></a>

### DeleteMemblock()
```php
DeleteMemblock(int $memID): void
```
Удаляет memblock с заданным идентификатором. Если memblock не существует или уже был удален, то эта команда ничего не делает.

---

<a name="method-deleteshader"></a>

### DeleteShader()
```php
DeleteShader(int $shaderID): void
```
Удаляет шейдер и освобождает идентификатор. Шейдер в данный момент не должен быть назначен ни одному объекту, сетке, квадрату или спрайту, иначе он может вызвать сбой при попытке рисования.

---

<a name="method-deleteimage"></a>

### DeleteImage()
```php
DeleteImage(int $iImageIndex): void
```
Удалите изображение из глобального хранилища, используя его идентификатор.

---

<a name="method-deletejoint"></a>

### DeleteJoint()
```php
DeleteJoint(int $iJointIndex): void
```
Удаляет соединение и позволяет соединенным спрайтам снова свободно перемещаться. Стыки следует удалять перед спрайтами. Зубчатые соединения должны быть удалены до тех соединений, от которых они зависят. Удаление несуществующего соединения не приведет к ошибке.

---

<a name="method-deletefont"></a>

### DeleteFont()
```php
DeleteFont(int $iFontID): void
```
Удаляет шрифт с заданным идентификатором. Шрифт в настоящее время не должен использоваться никакими текстовыми объектами.

---

<a name="method-deletehttpconnection"></a>

### DeleteHTTPConnection()
```php
DeleteHTTPConnection(int $iHTTP): void
```
Удаляет ранее созданное HTTP-соединение.

---

<a name="method-deletefolder"></a>

### DeleteFolder()
```php
DeleteFolder(string $szName): void
```
Удаляет папку по текущему пути. По умолчанию это определяется командой SetFolder. Вы также можете использовать имя файла, начинающееся с "raw:", чтобы удалить папку в любом месте файловой системы, например DeleteFolder("raw:C:\Temp\MyFolder"). Для успешного выполнения этой команды папка должна быть пустой.

---

<a name="method-deletebroadcastlistener"></a>

### DeleteBroadcastListener()
```php
DeleteBroadcastListener(int $iID): void
```
Удаляет широковещательный прослушиватель и освобождает порт для прослушивания на нем чего-то другого.

---

<a name="method-deleteeditbox"></a>

### DeleteEditBox()
```php
DeleteEditBox(int $index): void
```
Удаляет любое поле редактирования с заданным идентификатором.

---

<a name="method-deleteclouddatavariable"></a>

### DeleteCloudDataVariable()
```php
DeleteCloudDataVariable(string $varName): void
```
Удаляет переменную с указанным именем и удаляет все данные, хранящиеся в облаке для этой переменной. Если переменная не существует, то это ничего не делает.

---

<a name="method-deletealltext"></a>

### DeleteAllText()
```php
DeleteAllText(): void
```
Удаляет все текстовые объекты, созданные с помощью CreateText. Это также сбрасывает идентификатор автотекста до 10000.

---

<a name="method-deleteallsprites"></a>

### DeleteAllSprites()
```php
DeleteAllSprites(): void
```
Удаляет все спрайты, созданные с помощью CreateSprite, CreateDummySprite или LoadSprite. Это также сбрасывает идентификатор автоматического спрайта до 10000.

---

<a name="method-deleteallobjects"></a>

### DeleteAllObjects()
```php
DeleteAllObjects(): void
```
Удаляет все объекты, созданные с идентификатором. Это также сбрасывает идентификатор автоматического объекта до 10000.

---

<a name="method-deleteallimages"></a>

### DeleteAllImages()
```php
DeleteAllImages(): void
```
Удаляет все изображения, загруженные LoadImage или LoadSubImage. Это также сбрасывает автоматический идентификатор изображения до 10000.

---

<a name="method-delete3dphysicsworld"></a>

### Delete3DPhysicsWorld()
```php
Delete3DPhysicsWorld(): void
```
Удаляет весь мир 3D - физики.

---

<a name="method-delete3dphysicsstaticplane"></a>

### Delete3DPhysicsStaticPlane()
```php
Delete3DPhysicsStaticPlane(int $planeID): void
```
Удаляет статическую плоскость.

---

<a name="method-deleteadvert"></a>

### DeleteAdvert()
```php
DeleteAdvert(): void
```
Очищает ранее показанное объявление.

---

<a name="method-delete3dphysicsray"></a>

### Delete3DPhysicsRay()
```php
Delete3DPhysicsRay(int $rayID): void
```
Удаляет физический луч и все связанные с ним данные.

---

<a name="method-delete3dphysicsragdoll"></a>

### Delete3DPhysicsRagdoll()
```php
Delete3DPhysicsRagdoll(int $objID): void
```
Удаляет тряпичную куклу для объекта.

---

<a name="method-deletefile"></a>

### DeleteFile()
```php
DeleteFile(string $szFile): void
```
Удаляет данный файл из папки записи. Пути к файлам должны быть относительными, а не абсолютными, вы не можете удалять файлы из папки приложения или из другого места на диске.

---

<a name="method-delete3dphysicsjoint"></a>

### Delete3DPhysicsJoint()
```php
Delete3DPhysicsJoint(int $jointID): void
```
Удаляет физический стык

---

<a name="method-delete3dphysicscharactercontroller"></a>

### Delete3DPhysicsCharacterController()
```php
Delete3DPhysicsCharacterController(int $objID): void
```
Удаляет контроллер для объекта.

---

<a name="method-delete3dphysicspickjoint"></a>

### Delete3DPhysicsPickJoint()
```php
Delete3DPhysicsPickJoint(int $jointID): void
```
Удаляет соединение кирки.

---

<a name="method-delete3dparticles"></a>

### Delete3DParticles()
```php
Delete3DParticles(int $ID): void
```
Удаляет 3D-излучатель частиц и все его частицы. Если какие-либо частицы были в данный момент видны, они мгновенно исчезнут.

---

<a name="method-decodeqrcode"></a>

### DecodeQRCode()
```php
DecodeQRCode(int $image): string
```
Попытка декодировать QR - код и вернуть строку, закодированную в нем. Возвращает пустую строку, если он не смог найти QR-код на изображении или не смог его декодировать. Несколько QR-кодов на изображении, скорее всего, приведут к сбою декодирования.

---

<a name="method-debug3dphysicscharactercontroller"></a>

### Debug3DPhysicsCharacterController()
```php
Debug3DPhysicsCharacterController(int $objID, int $isDebug): void
```
Показывает объекты капсулы, представляющие контроллер.

---

<a name="method-debug3dphysicsworld"></a>

### Debug3DPhysicsWorld()
```php
Debug3DPhysicsWorld(): void
```
Вызовите цикл перед физикой шага. Рисует отладочное наложение 3D-физического мира. Примечание: Эта команда в настоящее время не работает, требуется возможность рисовать каркас в AGK.

---

<a name="method-createzip"></a>

### CreateZip()
```php
CreateZip(int $zipID, string $filename): void
```
Создает zip-файл в указанном месте и открывает его готовым для добавления файлов. Файлы не могут быть прочитаны или извлечены из zip-файла с помощью этой команды. Используйте ExtractZip для извлечения файлов из него. Путь к файлу относится к текущему каталогу, установленному с помощью SetFolder, если только вы не начинаете путь с прямой косой черты, и в этом случае путь будет относительно корня каталога записи на текущей платформе.

---

<a name="method-createweldjoint"></a>

### CreateWeldJoint()
```php
CreateWeldJoint(int $iSpriteIndex1, int $iSpriteIndex2, float $x, float $y, int $colConnected): int
```
Создает сварное соединение между двумя спрайтами. Сварное соединение пытается ограничить все относительные перемещения и вращения между двумя спрайтами. Укажите единственную опорную точку в мировых координатах со спрайтами, уже находящимися в нужных позициях. Соединение не является идеальным креплением, и при достаточно большом усилии спрайты могут сдвинуться с места. Точка привязки может быть смещена от центральных положений спрайта. Соединение может быть удалено системой, если какой-либо из спрайтов, которые он соединяет, будет удален.

---

<a name="method-createvector3"></a>

### CreateVector3()
```php
CreateVector3(): int
```
Создает вектор и заполняет его переданными значениями. Возвращает идентификатор вектора

---

<a name="method-createtweentext"></a>

### CreateTweenText()
```php
CreateTweenText(int $tweenID, float $duration): void
```
Создает текстовую анимацию с заданной длительностью и возвращает для нее идентификатор. Эта анимация-всего лишь шаблон, который может быть применен к нескольким текстовым объектам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с текстовым твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.

---

<a name="method-createudplistener"></a>

### CreateUDPListener()
```php
CreateUDPListener(string $ip, int $port): int
```
Создает прослушиватель UDP, который будет получать UDP-пакеты по указанному IP-адресу и порту. Значение порта должно находиться в диапазоне от 1 до 65535, хотя значения ниже 1024, скорее всего, будут защищены операционной системой. Если порт уже занят, то эта команда завершится ошибкой и вернет 0. IP-адрес может быть адресом IPv4 или IPv6 и может использоваться для привязки к одному входящему сетевому соединению, когда устройство имеет более одного IP-адреса. Для привязки к любому IP-адресу используйте IP-адрес "anyip4" или "anyip6". Один прослушиватель UDP может прослушивать либо IPv4, либо IPv6-адрес, но не оба одновременно. Для прослушивания обоих вы должны создать два прослушивателя, один для IPv4 и один для IPv6, в этом случае они оба могут использовать один и тот же порт. Эта команда вернет идентификатор прослушивателя, который вы можете использовать для ссылки на него в будущих командах.

---

<a name="method-createtweensprite"></a>

### CreateTweenSprite()
```php
CreateTweenSprite(int $tweenID, float $duration): void
```
Создает анимацию спрайта с заданной длительностью и возвращает для нее идентификатор. Эта анимация-просто шаблон, который может быть применен к нескольким спрайтам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с текстовым твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.

---

<a name="method-createtweencustom"></a>

### CreateTweenCustom()
```php
CreateTweenCustom(int $tweenID, float $duration): void
```
Создает пользовательскую анимацию с заданной длительностью и возвращает для нее идентификатор. Эта анимация не связана ни с каким элементом, и ее значения можно считывать во время работы. Это делает его полезным для управления значениями, которые не покрываются ни одним из других шаблонов анимации. Все типы твинов используют одно и то же пространство идентификаторов, поэтому пользовательский твин с идентификатором 1 не может существовать одновременно со спрайтовым твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, до 4 значений с плавающей точкой и 4 целочисленных значений, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.

---

<a name="method-createtweenobject"></a>

### CreateTweenObject()
```php
CreateTweenObject(int $tweenID, float $duration): void
```
Создает объект tween с заданной длительностью и возвращает для него ИДЕНТИФИКАТОР. Эта анимация-просто шаблон, который может быть применен к нескольким объектам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с объектным твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.

---

<a name="method-delete3dphysicsbody"></a>

### Delete3DPhysicsBody()
```php
Delete3DPhysicsBody(int $objID): void
```
Удаляет физическое тело из мира и удаляет его.

---

<a name="method-createtweenchar"></a>

### CreateTweenChar()
```php
CreateTweenChar(int $tweenID, float $duration): void
```
Создает символ tween с заданной длительностью и возвращает для него ИДЕНТИФИКАТОР. Это может быть применено к отдельным символам текстового объекта. Эта анимация-всего лишь шаблон, который может быть применен к нескольким текстовым символам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с char-твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.

---

<a name="method-createtweencamera"></a>

### CreateTweenCamera()
```php
CreateTweenCamera(int $tweenID, float $duration): void
```
Создает анимацию камеры с заданной длительностью и возвращает для нее идентификатор. Эта анимация-всего лишь шаблон, который может быть применен к нескольким камерам или цепочкам одновременно. Все типы твинов используют одно и то же пространство идентификаторов, поэтому твин камеры с идентификатором 1 не может существовать одновременно с твином объекта с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.

---

<a name="method-createtweenchain"></a>

### CreateTweenChain()
```php
CreateTweenChain(int $chainID): void
```
Создает цепочку твинов, которую можно использовать для заказа подростков, чтобы они играли один за другим. Цепочка анимаций может содержать несколько спрайтов, символов, объектов и т. Д., Так что анимация камеры может быть запущена после завершения анимации спрайтов или наоборот. Несколько цепочек могут быть применены к одним и тем же спрайтам, объектам или другим объектам до тех пор, пока цепочки не изменяют один и тот же параметр одновременно. Например, если цепочка 1 начинается с изменения значения X спрайта и воспроизводится одновременно с цепочкой 2, которая также начинает изменять значение X того же спрайта, то одна цепочка перезапишет изменения другой. В противном случае несколько цепочек на одном и том же спрайте будут работать правильно.

---

<a name="method-createtext"></a>

### CreateText()
```php
CreateText(int $iTextIndex, string $string): void
```
Создает текстовый объект для отображения текста на экране с помощью пустого идентификатора, возвращает используемый идентификатор. По умолчанию текст рисуется на глубине 9 выше глубины спрайтов по умолчанию (10). Любые спрайты, установленные на глубину 8 или меньше, будут отображаться над текстом. Вы можете переопределить это с помощью SetTextDepth, чтобы установить свой собственный порядок розыгрыша.

---

<a name="method-crouch3dphysicscharactercontroller"></a>

### Crouch3DPhysicsCharacterController()
```php
Crouch3DPhysicsCharacterController(int $objID): void
```
Приседает контроллер

---

<a name="method-createsprite"></a>

### CreateSprite()
```php
CreateSprite(int $iSpriteIndex, int $iImageIndex): void
```
Создает спрайт в пустом идентификаторе спрайта с изображением, используемым при рендеринге, и возвращает используемый идентификатор спрайта. По умолчанию спрайты создаются с глубиной 10, имеют размер, используя данное изображение в качестве направляющей, и позиционируются на 0,0, используя их верхний левый угол. Вы можете использовать идентификатор изображения 0 для создания пустого спрайта, нарисованного только цветом. Если назначенное изображение имеет альфа-пиксели, то спрайт создается с режимом прозрачности 1, в противном случае он использует режим прозрачности 0 (непрозрачный)

---

<a name="method-createsoundfromoggmemblock"></a>

### CreateSoundFromOGGMemblock()
```php
CreateSoundFromOGGMemblock(int $soundID, int $memID): void
```
Создает звук из мемблока. Memblock должен существовать, это создает новый звук и возвращает идентификатор. Это не повлияет ни на какие уже воспроизводимые звуковые экземпляры, только на будущие. Memblock должен содержать допустимый OGG-файл, например загруженный CreateMemblockFromFile(memID, "sound.ogg")

---

<a name="method-createsocketlistener"></a>

### CreateSocketListener()
```php
CreateSocketListener(string $szIP, int $port): int
```
Создает прослушиватель сокетов, который прослушивает на указанном порту входящие соединения сокетов. Когда соединение происходит, оно будет удерживаться в очереди до тех пор, пока вы не получите его с помощью GetSocketListenerConnection. Если вы хотите отклонить соединение, вы должны получить его, а затем удалить. Прослушиватель будет продолжать принимать соединения до тех пор, пока он не будет удален. Если ваше устройство имеет несколько сетевых интерфейсов, то вы можете указать, какой из них будет прослушиваться с помощью параметра IP-адрес. Для прослушивания всех интерфейсов используйте пустую строку в качестве IP-адреса. Если устройство имеет оба адреса IPv4 и IPv6, то слушатель может слушать только один или другой, а не оба. Для прослушивания соединений IPv4 и IPv6 необходимо создать два прослушивателя: один для соединений IPv4 и один для соединений IPv6. Соединения из любого из них будут вести себя точно так же после того, как они будут подключены. Чтобы создать прослушиватель IPv6, передайте IPv6 IP-адрес CreateSocketListener или "anyip6" для прослушивания любого подходящего IPv6-адреса. Если вы передадите пустую строку или "anyip4" в качестве IP-адреса, то он будет прослушивать IPv4-соединения. Вы можете иметь несколько активных слушателей одновременно, но все они должны использовать разные порты или IP-адреса. При выборе номера порта следует избегать низких значений, так как они часто будут использоваться другими приложениями и сервисами. Если что-то уже прослушивает порт, то ваша попытка прослушать его потерпит неудачу. Возвращает 0, если он не смог начать прослушивание.

---

<a name="method-createsoundfrommemblock"></a>

### CreateSoundFromMemblock()
```php
CreateSoundFromMemblock(int $soundID, int $memID): void
```
Создает звук из мемблока. Memblock должен существовать, это создает новый звук и возвращает идентификатор. Это не повлияет ни на какие уже воспроизводимые звуковые экземпляры, только на будущие. Первые 2 байта memlbock хранят количество каналов (1 или 2 поддерживаемых), следующие 2 байта хранят биты на выборку (8 или 16 поддерживаемых), следующие 4 байта хранят выборки в секунду, например 44100. Следующие 4 байта-это количество кадров в звуковых данных, размер звуковых данных в байтах можно вычислить из этого с помощью формулы numFrames*(BitsPerSample/8)*channels. В 2-канальном звуке кадр содержит 2 сэмпла, по одному для каждого канала. В моно-звуке кадр содержит 1 образец. Остальная часть memblock-это необработанные звуковые данные, например, в 8-битном стереозвуке с 3 кадрами необработанные данные будут выглядеть так. смещение байта 0 = Кадр 1, смещение байта данных левого канала 1 = Кадр 1, смещение байта данных правого канала 2 = Кадр 2, смещение байта данных левого канала 3 = Кадр 2, смещение байта данных правого канала 4 = Кадр 3, смещение байта данных левого канала 5 = Кадр 3, данные правого канала Возвращают идентификатор нового звука.

---

<a name="method-createskeleton2d"></a>

### CreateSkeleton2D()
```php
CreateSkeleton2D(int $iSkeleton): void
```
Создает 2D-скелет, который можно использовать для анимации спрайтов с помощью костей. В настоящее время эта команда не очень полезна, так как существует не так много команд для настройки скелета. Вместо этого скелеты должны быть загружены с помощью LoadSkeleton2DFromSpineFile

---

<a name="method-createropejoint"></a>

### CreateRopeJoint()
```php
CreateRopeJoint(int $iJointIndex, int $iSpriteIndex1, int $iSpriteIndex2, float $x, float $y, float $x2, float $y2, float $maxLength, int $colConnected): void
```
Создает соединение веревки между двумя спрайтами. Канатное соединение обеспечивает максимальное расстояние между спрайтами без каких-либо других ограничений. Это не мешает им сближаться. Укажите две опорные точки в мировых координатах с максимальной длиной, которую вы хотите разрешить, текущее положение спрайтов не влияет на инициализацию соединения. Опорные точки могут быть смещены от позиций спрайтов. Соединение может быть удалено системой, если какой-либо из спрайтов, которые он соединяет, будет удален.

---

<a name="method-createrevolutejoint"></a>

### CreateRevoluteJoint()
```php
CreateRevoluteJoint(int $iJointIndex, int $iSpriteIndex1, int $iSpriteIndex2, float $x, float $y, int $colConnected): void
```
Создает революционное соединение между двумя спрайтами. Поворотное соединение позволяет спрайтам вращаться только вокруг заданной точки. Укажите единственную опорную точку в мировых координатах, где спрайты уже находятся в нужном относительном положении. Точка привязки может быть смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение поддерживает двигатели и ограничения.

---

<a name="method-createpulleyjoint2"></a>

### CreatePulleyJoint2()
```php
CreatePulleyJoint2(int $iSpriteIndex1, int $iSpriteIndex2, float $ratio, int $colConnected): void
```
Создает соединение шкива между двумя спрайтами. Это первая половина двухкомандной установки. Из - за количества требуемых параметров вы должны вызвать FinishPulleyJoint с остальными параметрами для создания соединения. Эта команда ничего не возвращает, идентификатор соединения возвращается FinishPulleyJoint.

---

<a name="method-createpulleyjoint"></a>

### CreatePulleyJoint()
```php
CreatePulleyJoint(int $iJointIndex, int $iSpriteIndex1, int $iSpriteIndex2, float $gnd1x, float $gnd1y, float $gnd2x, float $gnd2y, float $a1x, float $a1y, float $a2x, float $a2y, float $ratio, int $colConnected): void
```
Создает соединение шкива между двумя спрайтами. Опорные точки-это координаты мирового пространства, которые прикрепляют соединение к спрайту, опорные точки не обязательно должны находиться в центре спрайта или где-то рядом с ним, но эта точка станет новым центром вращения на то время, пока спрайт прикреплен к шкиву. Точки заземления находятся там, где трос шкива прикрепится к воображаемым шкивам и останется неподвижным в течение всего срока службы соединения, они не должны находиться в одном и том же месте. Значение коэффициента определяет передаточное отношение между двумя сторонами шкива, например, значение 2 будет означать, что спрайт 1 движется с удвоенной скоростью спрайта 2, но будет испытывать половину силы, приложенной к спрайту 2.

---

<a name="method-createprismaticjoint"></a>

### CreatePrismaticJoint()
```php
CreatePrismaticJoint(int $iJointIndex, int $iSpriteIndex1, int $iSpriteIndex2, float $x, float $y, float $vx, float $vy, int $colConnected): void
```
Создает призматическое соединение между двумя спрайтами. Призматическое соединение позволяет спрайтам двигаться только вдоль заданной оси относительно друг друга. Его можно представить как поршень, на каждом конце которого спрайты не могут вращаться. Это похоже на линейное соединение, за исключением того, что предотвращается относительное вращение. Укажите единственную опорную точку в мировых координатах, чтобы спрайты уже находились в нужном относительном положении, на минимальном расстоянии поршня. С этого момента спрайтам будет позволено разделяться вдоль заданной оси и вращаться как единое целое, но не вращаться относительно друг друга. Точка привязки может быть смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение поддерживает двигатели и ограничения.

---

<a name="method-createpointlight"></a>

### CreatePointLight()
```php
CreatePointLight(int $lightID, float $x, float $y, float $z, float $radius, int $red, int $green, int $blue): void
```
Создает точечный свет, который светит одинаково во всех направлениях. Это влияет на все объекты, использующие внутренний шейдер по умолчанию с SetObjectLightMode равным 1. Если вы используете пользовательский шейдер, то AGK добавит функции освещения в ваш шейдер во время загрузки, если вы ссылаетесь на них, см. Руководство по шейдерам для получения дополнительной информации об этом. По умолчанию свет создается в режиме вершин, это быстрее, чем в пиксельном режиме, но более низкого качества. Чтобы изменить это, используйте SetPointLightMode. Значения цвета должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать свет.

---

<a name="method-createphysicsforce"></a>

### CreatePhysicsForce()
```php
CreatePhysicsForce(float $x, float $y, float $power, float $limit, float $range, int $fade): int
```
Создает глобальную силу, которая влияет на все физические спрайты. Можно настроить либо на привлечение, либо на отталкивание спрайтов из определенного места. Он возвращает идентификатор силы, который можно использовать для последующего изменения или удаления силы. Силы продолжают действовать до тех пор, пока они не будут удалены.

---

<a name="method-createparticles"></a>

### CreateParticles()
```php
CreateParticles(int $ID, float $x, float $y): void
```
Создает излучатель частиц в свободном ID и в заданном месте в мировых координатах. Он возвращает идентификатор, используемый для создания излучателя. Излучатели частиц создают поток маленьких спрайтов, которые длятся фиксированное количество времени, прежде чем исчезнуть. Частицы могут подвергаться воздействию сил в течение своей жизни с помощью AddParticlesForce. Они также могут менять цвет с течением времени с помощью AddParticlesColorKeyFrame. Частицы не могут быть изменены по отдельности и вести себя как группа, используя одну и ту же текстуру и глубину. Это позволяет AGK рисовать их более эффективно, чем аналогичное количество обычных спрайтов.

---

<a name="method-createobjectquad"></a>

### CreateObjectQuad()
```php
CreateObjectQuad(): int
```
Создает плоскость, которая заполнит весь экран и может быть использована для рендеринга полноэкранных шейдеров.

---

<a name="method-createobjectplane"></a>

### CreateObjectPlane()
```php
CreateObjectPlane(float $width, float $height): int
```
Создает трехмерную двустороннюю плоскость с заданными шириной (X) и высотой (Y). Плоскость создается в плоскости XY и не имеет размера в направлении Z.

---

<a name="method-createobjectfrommeshmemblock"></a>

### CreateObjectFromMeshMemblock()
```php
CreateObjectFromMeshMemblock(int $objID, int $memID): void
```
Создает объект с одной сеткой, построенной из данного memblock. Любые последующие изменения в memblock не повлияют на сетку, вы должны вызвать SetObjectMeshFromMemblock, чтобы изменить существующую сетку. Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда должен быть кратен 4 по соображениям выравнивания, сама строка может иметь немного меньше символов, но всегда округляется до ближайшего кратного 4 для значения длины строки. например, строка длины 5 должна иметь значение длины строки 8. Обратите внимание, что строка из 4 символов имеет нулевой терминатор на конце, что делает ее длиной 5, поэтому, даже если она уже имеет кратное 4 символам значение длины, она должна использовать значение длины 8 из-за нулевого терминатора. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник.

---

<a name="method-createrenderimage"></a>

### CreateRenderImage()
```php
CreateRenderImage(int $imageID, int $width, int $height, int $format, int $mipmap): void
```
Создает пустое изображение, пригодное для рендеринга, и возвращает идентификатор для ссылки на него. Это можно использовать с SetRenderToImage для рисования вещей на изображениях. Вы можете создавать изображения RGBA для обычного рендеринга или изображения глубины для захвата буфера глубины на устройствах, которые его поддерживают. Вы также можете использовать mipmapping на этом изображении или нет, это переопределяет глобальную команду SetGenerateMipmaps() только для этого изображения, это связано с тем, что mipmaps на визуализированных изображениях могут быть хитом производительности, поэтому их не следует использовать без необходимости. Mip-карты должны быть необходимы только в том случае, если вы собираетесь использовать это изображение для текстурирования объектов в вашей сцене, если вы используете это изображение только для полноэкранных шейдеров, вы не должны использовать mip-карты на нем.

---

<a name="method-createobjectcylinder"></a>

### CreateObjectCylinder()
```php
CreateObjectCylinder(int $objID, float $height, float $diameter, int $segments): void
```
Создает 3D-цилиндр с заданным диаметром и высотой, а также необязательным количеством полигонов. Параметр segments определяет, сколько столбцов полигонов составляет цилиндр и должно быть не менее 3. Формула для вычисления общего числа полигонов, используемых в цилиндре, равна 3*сегментам. Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.

---

<a name="method-createobjectfromheightmap"></a>

### CreateObjectFromHeightMap()
```php
CreateObjectFromHeightMap(string $szImageFile, float $width, float $height, float $length, int $smoothing, int $split): int
```
Создает объект из заданной карты высот, полезный для создания рельефа. Изображение должно быть PNG 8-битным в оттенках серого или RGB, если это RGB, то считывается только красный канал. В будущем может быть добавлена поддержка 16-битных оттенков серого. Объект будет иметь один УФ-канал с диапазоном от 0 до 1, отображенным на всю местность. Если вы хотите изменить это, то вы можете использовать SetObjectUVOffset и SetObjectUVScale или использовать шейдер, который умножает UV-координаты на заданную величину. Шейдер также можно использовать для создания нескольких УФ-каналов из этого одного канала, применяя к каждому из них различные масштабные коэффициенты. Для удаления артефактов шага рекомендуется использовать значение сглаживания 1, при необходимости корректируя его. Значение split позволяет создавать несколько сеток, которые могут повысить производительность, так как невидимые сетки не будут нарисованы. Значение разделения указывает, сколько сеток нужно создать вдоль каждого ребра, например, значение разделения 5 создаст в общей сложности 5x5 = 25 сеток. В отличие от других объектов, данные о столкновениях не генерируются по умолчанию на этом объекте, так как он может потреблять много памяти, используйте SetObjectCollisionMode, если вы хотите включить его. Для ландшафтов больше 1024x1024 это не рекомендуется на мобильных устройствах, и вы должны использовать GetObjectHeightMapHeight вместо этого, если это возможно. Включение физики для этого объекта будет использовать еще больше памяти и не рекомендуется на местности больше 1024x1024 на любой платформе.

---

<a name="method-createobjectsphere"></a>

### CreateObjectSphere()
```php
CreateObjectSphere(float $diameter, int $rows, int $columns): int
```
Создает 3D-сферу с заданным диаметром и необязательным количеством полигонов. Параметр rows определяет, сколько рядов полигонов составляет сферу и должно быть не менее 2. Параметр columns определяет, сколько столбцов полигонов составляет сферу и должно быть не менее 3. Формула для расчета общего количества полигонов, используемых в сфере, равна 2*столбцам*(строкам-1)

---

<a name="method-createobjectcone"></a>

### CreateObjectCone()
```php
CreateObjectCone(int $objID, float $height, float $diameter, int $segments): void
```
Создает 3D-конус с заданным диаметром и высотой, а также необязательное количество полигонов. Параметр segments определяет, сколько столбцов полигонов составляет конус и должно быть не менее 3. Формула для вычисления общего числа полигонов, используемых в конусе, равна 2*сегментам. Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.

---

<a name="method-createobjectcapsule"></a>

### CreateObjectCapsule()
```php
CreateObjectCapsule(float $diameter, float $height, int $axis): int
```
Создает примитив Капсулы.

---

<a name="method-createobjectfromrawheightmap"></a>

### CreateObjectFromRawHeightMap()
```php
CreateObjectFromRawHeightMap(int $objID, string $szFilename, float $width, float $height, float $length, int $smoothing, int $split, int $rawWidth, int $rawHeight): void
```
Создает объект из заданной карты высот .raw или .dat, полезной для создания рельефа. Файл должен содержать необработанные 16-битные данные. Если вы используете расширение ".dat" в szFilename, он будет ожидать, что это 32-битная необработанная карта высоты GameGuru, и преобразует ее в 16-битную. Если файл не является картой высоты GameGuru, то вы должны изменить расширение на ".raw". Если вы конвертируете файл GameGuru height map (.dat), то rawWidth и rawHeight всегда должны быть равны 1024. Объект будет иметь один УФ-канал с диапазоном от 0 до 1, отображенным на всю местность. Если вы хотите изменить это, то вы можете использовать SetObjectUVOffset и SetObjectUVScale или использовать шейдер, который умножает UV-координаты на заданную величину. Шейдер также можно использовать для создания нескольких УФ-каналов из этого одного канала, применяя к каждому из них различные масштабные коэффициенты. Обычно при использовании 16-битных данных вам не нужно устанавливать значение сглаживания, но если оно еще не было сглажено, отрегулируйте его по мере необходимости. Значение split позволяет создавать несколько сеток, которые могут повысить производительность, так как невидимые сетки не будут нарисованы. Значение разделения указывает, сколько сеток нужно создать вдоль каждого ребра, например, значение разделения 5 создаст в общей сложности 5x5 = 25 сеток. В отличие от других объектов, данные о столкновениях не генерируются по умолчанию на этом объекте, так как он может потреблять много памяти, используйте SetObjectCollisionMode, если вы хотите включить его. Для ландшафтов больше 1024x1024 это не рекомендуется на мобильных устройствах, и вы должны использовать GetObjectHeightMapHeight вместо этого, если это возможно. Включение физики для этого объекта будет использовать еще больше памяти и не рекомендуется на местности больше 1024x1024 на любой платформе.

---

<a name="method-createobjectbox"></a>

### CreateObjectBox()
```php
CreateObjectBox(int $objID, float $width, float $height, float $length): void
```
Создает 3D-окно с заданными шириной (X), высотой (Y) и длиной (Z). Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.

---

<a name="method-createobjectfromobjectmesh"></a>

### CreateObjectFromObjectMesh()
```php
CreateObjectFromObjectMesh(int $fromObjID, int $meshIndex): int
```
Создает объект путем копирования одной сетки из другого объекта. Объект может содержать много сеток, и использование CloneObject скопирует их все. Используйте эту команду, если вы хотите скопировать только одну сетку. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes включительно.

---

<a name="method-createmousejoint"></a>

### CreateMouseJoint()
```php
CreateMouseJoint(int $iSpriteIndex, float $x, float $y, float $maxForce): int
```
Создает соединение мыши между точкой и спрайтом. Это обычно используется при перетаскивании фигуры указателем мыши и попытке переместить спрайт в заданную точку с помощью силы до максимального заданного значения. Укажите точку привязки в мировых координатах, которая будет выступать в качестве начальной точки удержания спрайта. Любое дальнейшее изменение в целевом положении будет пытаться переместить эту точку спрайта в новое место. Используйте SetJointMouseTarget для изменения местоположения целевой позиции.

---

<a name="method-createnetworkmessage"></a>

### CreateNetworkMessage()
```php
CreateNetworkMessage(): int
```
Создает сетевое сообщение, которое может быть отправлено на другое сетевое устройство. Он возвращает идентификатор, который можно использовать для взаимодействия с сообщением. Сообщения, созданные таким образом, могут быть только добавлены, а не прочитаны. После передачи в сеть идентификатор сообщения уничтожается и обрабатывается фоновым сетевым кодом.

---

<a name="method-creatememblockfromobjectmesh"></a>

### CreateMemblockFromObjectMesh()
```php
CreateMemblockFromObjectMesh(int $memID, int $objID, int $meshIndex): void
```
Создает memblock из сетки объектов. Объект может содержать одну или несколько сеток, индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes включительно. Сетка копируется в memblock, поэтому любые изменения в memblock не влияют сразу на сетку, вы должны использовать одну из других команд, таких как SetObjectMeshFromMemblock, чтобы скопировать memblock обратно в сетку. Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда будет кратен 4, чтобы упростить проблемы выравнивания, сама строка может иметь немного меньше символов и быть дополнена нулевыми терминаторами, но прочитайте все указанные байты, и вы получите правильную строку длины. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник. Если вы планируете регулярно вносить изменения в сетку, вы должны сохранить memblock после использования SetObjectMeshFromMemblock вместо того, чтобы регенерировать его из объекта каждый раз, когда вы хотите внести изменения. Затем снова вызовите SetObjectMeshFromMemblock, когда вы хотите перенести свои новые изменения на объект.

---

<a name="method-creatememblockfromimage"></a>

### CreateMemblockFromImage()
```php
CreateMemblockFromImage(int $memID, int $imageID): void
```
Создает memblock из загруженного изображения, субизображения atlas не поддерживаются. Изображение должно существовать и не подвержено влиянию этой команды. Первые 4 байта memlbock хранят ширину изображения, следующие 4 байта хранят высоту изображения, следующие 4 байта хранят битовую глубину, в настоящее время это всегда будет 32. После этого необработанные данные изображения начинаются в формате RGBA, причем каждый компонент хранится в одном байте, поэтому каждый пиксель занимает 4 байта. Размер данных изображения может быть вычислен по ширине*высоте*4 байта (на данный момент битовая глубина может быть принята равной 32 битам = 4 байтам). Обратите внимание, что из-за малого формата endian чтение данных изображения с байтами вернет смещения 0=R, 1=G, 2=B, 3=A, но чтение их всех как одного целого числа приведет к значению с A как наиболее значимым байтом, за которым следует B, затем G, затем R как наименее значимый байт. Пиксельные данные начинаются в верхнем левом углу изображения и продолжаются слева направо, а затем сверху вниз, в результате чего изображение сохраняется в виде последовательности строк, заканчивающихся в правом нижнем углу. Возвращает идентификатор, который можно использовать для ссылки на этот memblock в других командах.

---

<a name="method-creatememblockfromfile"></a>

### CreateMemblockFromFile()
```php
CreateMemblockFromFile(int $memID, string $filename): void
```
Создает memblock из файла без какой-либо обработки данных файла, memblock будет байт за байтом копией файла. Возвращает идентификатор, который может быть использован для ссылки на этот memblock позже. Вы можете использовать относительные пути в имени файла для чтения из вложенных папок или использовать SetFolder для первого просмотра. Вы можете использовать абсолютные пути, добавив косую черту в начало имени файла, в этом случае папка, установленная с помощью SetFolder, игнорируется. Например /media/file.txt будет читать его из папки media, даже если SetFolder был использован для перехода к /media/somefolder

---

<a name="method-creatememblock"></a>

### CreateMemblock()
```php
CreateMemblock(int $size): int
```
Создает раздел памяти заданного размера для доступа на чтение или запись. Содержимое памяти не определено, пока вы не запишете в нее. Memblock не должен уже существовать с выбранным вами memID.

---

<a name="method-createlinejoint"></a>

### CreateLineJoint()
```php
CreateLineJoint(int $iJointIndex, int $iSpriteIndex1, int $iSpriteIndex2, float $x, float $y, float $vx, float $vy, int $colConnected): void
```
Создает соединение линий между двумя спрайтами. Соединение линий позволяет спрайтам двигаться только вдоль заданной оси относительно друг друга, свободно вращаясь на обоих концах. Он похож на призматический шарнир, за исключением того, что допускается относительное вращение. Укажите единственную опорную точку в мировых координатах со спрайтами уже в нужном относительном положении, на минимальном расстоянии поршня. С этого момента спрайтам будет позволено разделиться вдоль заданной оси относительно друг друга. Точка привязки может быть смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение поддерживает двигатели и ограничения. Box2D переименовал это соединение в Колесное соединение, и теперь оно содержит пружинный компонент для имитации колеса автомобиля. Имя команды AGK останется прежним для обратной совместимости, однако функциональность может измениться

---

<a name="method-createimagefrompngmemblock"></a>

### CreateImageFromPNGMemblock()
```php
CreateImageFromPNGMemblock(int $memID): int
```
Создает изображение из memblock. Мемблок должен существовать, если образ существует, он будет перезаписан, если нет, то будет создан. Memblock должен содержать допустимый PNG-файл, например загруженный CreateMemblockFromFile(memID, "image.png")

---

<a name="method-createhttpconnection"></a>

### CreateHTTPConnection()
```php
CreateHTTPConnection(): int
```
Создает HTTP - соединение, готовое к использованию позже. Возвращает идентификатор, используемый для ссылки на него позже.

---

<a name="method-createimagecolor"></a>

### CreateImageColor()
```php
CreateImageColor(int $red, int $green, int $blue, int $alpha): int
```
Создает изображение размером 1x1 пиксель заданного цвета. Это может быть использовано для текстурирования любого объекта или спрайта сплошным цветом.

---

<a name="method-createmusicfromoggmemblock"></a>

### CreateMusicFromOGGMemblock()
```php
CreateMusicFromOGGMemblock(int $musicID, int $memID): void
```
Создает музыкальную сущность из мемблока. Мемблок должен существовать. Это создаст новый идентификатор музыки и вернет его memblock должен содержать допустимый файл OGG, например загруженный с CreateMemblockFromFile(memID, "music.ogg")

---

<a name="method-creatememblockfromsound"></a>

### CreateMemblockFromSound()
```php
CreateMemblockFromSound(int $memID, int $soundID): void
```
Создает memblock из загруженного звукового файла. Звуковой файл должен быть загружен с помощью LoadSound и не подвержен влиянию этой команды. Первые 2 байта memlbock хранят количество каналов (1 или 2 поддерживаемых), следующие 2 байта хранят биты на выборку (8 или 16 поддерживаемых), следующие 4 байта хранят выборки в секунду, например 44100. Следующие 4 байта-это количество кадров в звуковых данных, размер звуковых данных в байтах можно вычислить из этого с помощью формулы numFrames*(BitsPerSample/8)*channels. В 2-канальном звуке кадр содержит 2 сэмпла, по одному для каждого канала. В моно-звуке кадр содержит 1 образец. Остальная часть memblock-это необработанные звуковые данные, например, в 8-битном стереозвуке с 3 кадрами необработанные данные будут выглядеть так. смещение байта 0 = Кадр 1, смещение байта данных левого канала 1 = Кадр 1, Смещение байта данных правого канала 2 = Кадр 2, Смещение байта данных левого канала 3 = Кадр 2, смещение байта данных правого канала 4 = Кадр 3, смещение байта данных левого канала 5 = Кадр 3, данные правого канала Продолжительность звука может быть рассчитана по следующей формуле: numFrames/samplesPerSecond. Эта команда не работает с идентификаторами звуковых экземпляров, а только с идентификаторами звуковых файлов. Возвращает идентификатор, который может быть использован для ссылки на этот memblock в других командах.

---

<a name="method-createfullscreenadvert"></a>

### CreateFullscreenAdvert()
```php
CreateFullscreenAdvert(): void
```
Эта команда устарела, вместо нее следует использовать ShowFullscreenAdvertAdMob, ShowFullscreenAdvertChartboost или ShowFullscreenAdvertAmazon. Создает полноэкранную (интерстициальную) рекламу для получения дохода. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью одной из других команд, таких как SetAdMobDetails, SetChartboostDetails или SetAmazonAdDetails Не все платформы поддерживают всех поставщиков рекламы, поэтому установка как можно большего количества данных учетной записи позволит AGK выбрать подходящее объявление для этой платформы. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае эта команда ничего не сделает. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа для конкретного поставщика с помощью GetFullscreenAdvertLoadedAdMob, GetFullscreenAdvertLoadedChartboost или GetFullscreenAdvertLoadedAmazon. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено.

---

<a name="method-createfilefrommemblock"></a>

### CreateFileFromMemblock()
```php
CreateFileFromMemblock(string $filename, int $memID): void
```
Создает файл из memblock без какой-либо обработки данных memblock, файл будет байт за байтом копией данных memblock. Вы можете использовать относительные пути в имени файла для записи в подпапки или использовать SetFolder для просмотра там в первую очередь. Вы можете использовать абсолютные пути, добавив косую черту в начало имени файла, в этом случае папка, установленная с помощью SetFolder, игнорируется. Например /media/file.txt поместит его в папку media, даже если SetFolder был использован для перехода к /media/somefolder

---

<a name="method-createeditbox"></a>

### CreateEditBox()
```php
CreateEditBox(int $index): void
```
Создайте поле редактирования, которое можно расположить в любом месте экрана. Он возвращает идентификатор, используемый для ссылки на это поле редактирования позже.

---

<a name="method-createdummysprite"></a>

### CreateDummySprite()
```php
CreateDummySprite(): int
```
Создает спрайт в заданном идентификаторе спрайта, возвращает используемый идентификатор спрайта. Фиктивные спрайты ведут себя как обычные спрайты, но не имеют никакого изображения или другого визуального аспекта. Они не будут нарисованы, даже если им присвоено изображение. Они полезны для добавления физических объектов в сцену без необходимости визуального сопровождения физической формы. При желании вы можете использовать команды физического контакта и обратной связи, чтобы выяснить, что поразило эти скрытые физические формы. Если вам не нужно знать, что попало в ваши скрытые фигуры, то вы можете добавить их все в один фиктивный спрайт, используя команды AddSpriteShape для лучшей производительности. SetSpriteShape не будет работать с фиктивными спрайтами, так как у них нет изображения для вычисления фигуры, фигуры должны быть определены вручную с помощью SetSpriteShapeBox, SetSpriteShapeCircle или SetSpriteShapePolygon. Фиктивные спрайты не будут обновлять свой сохраненный угол и положение с помощью последних версий физики, поэтому вызовы GetSpriteX, GetSpriteY или GetSpriteAngle вернут последнее заданное вами значение. Установка положения спрайта обновит физическое тело до заданного вами положения.

---

<a name="method-createdistancejoint"></a>

### CreateDistanceJoint()
```php
CreateDistanceJoint(int $iSpriteIndex1, int $iSpriteIndex2, float $x, float $y, float $x2, float $y2, int $colConnected): int
```
Создает дистанционное соединение между двумя спрайтами. Дистанционное соединение удерживает спрайты на определенном расстоянии друг от друга, позволяя им свободно вращаться вокруг опорных точек. Укажите две опорные точки в мировых координатах, чтобы спрайты уже находились на нужном расстоянии друг от друга. Опорные точки могут быть смещены от позиций спрайтов. Соединение может быть удалено системой, если какой-либо из спрайтов, которые он соединяет, будет удален.

---

<a name="method-createbroadcastlistener"></a>

### CreateBroadcastListener()
```php
CreateBroadcastListener(int $port): int
```
Широковещательные передачи являются специальными сетевыми коммуникациями, поскольку они не используют адрес назначения и вместо этого принимаются всеми устройствами в сети. Широковещательные пакеты не пересылаются маршрутизаторами, поэтому могут использоваться только в локальной сети или, точнее, в локальной подсети. Это может быть полезно для обнаружения устройств, поскольку одно устройство может отправить широковещательный пакет, содержащий его IP-адрес, а другое устройство может принять его, прочитать IP-адрес и подключиться обратно к первому устройству, чтобы создать двустороннее соединение. Сети AGK транслируются таким образом на порт 45631 и отправляют пакет, содержащий имя сети, которая была размещена другим устройством AGK. С помощью широковещательного прослушивателя вы можете получать эти сообщения, извлекать имена сетей и отображать их пользователю, чтобы он мог выбрать, к какой сети он хочет подключиться. Если устройство находится в сети IPv6, то эти правила немного меняются. CreateBroadcastListener должен быть вызван с многоадресным адресом, который начинается с ff, например ff02::1, и широковещательный прослушиватель будет принимать только пакеты, отправленные на этот многоадресный адрес. Если адрес не указан, то вещатель будет получать только широковещательные передачи IPv4. Если вы передадите адрес "anyip6", то широковещательный прослушиватель будет прослушивать многоадресный адрес AGK "FF02::41:474B", который используется для обнаружения именованной сети на порту 45631. Возвращает идентификатор, который можно использовать для взаимодействия с этим широковещательным слушателем.

---

<a name="method-createadvertex"></a>

### CreateAdvertEx()
```php
CreateAdvertEx(int $type, int $horz, int $vert, int $test, float $offsetx, float $offsety): void
```
Создает рекламу для получения дохода. Перед вызовом этой функции вы должны задать данные своего рекламного аккаунта с помощью одной из других команд, таких как SetAdMobDetails. Не все платформы поддерживают всех поставщиков рекламы, поэтому установка как можно большего количества реквизитов учетной записи позволит AGK выбрать подходящее объявление для этой платформы. Эта реклама обычно представляет собой баннер размером 320х50, отображаемый где-то на краю вашего приложения. Создание объявления, когда оно уже существует, заменит существующее объявление. Это расширенная версия команды CreateAdvert, которая принимает необязательные значения смещения для позиционирования объявления. Параметр type можно использовать для выбора размера баннера: 0=Banner(320x50), 1=LargeBanner, 2=MediumRectangle, 3=FullBanner, 4=Leaderboard, 5=SmartBanner, 6=FluidBanner

---

<a name="method-createimagefrommemblock"></a>

### CreateImageFromMemblock()
```php
CreateImageFromMemblock(int $memID): int
```
Создает изображение из memblock. Мемблок должен существовать, если образ существует, он будет перезаписан, если нет, то будет создан. Первые 4 байта memlbock хранят ширину изображения, следующие 4 байта хранят высоту изображения, следующие 4 байта хранят битовую глубину, в настоящее время это должно быть 32. После этого необработанные данные изображения начинаются в формате RGBA, причем каждый компонент хранится в одном байте, поэтому каждый пиксель занимает 4 байта. Размер данных изображения может быть вычислен по ширине*высоте*4 байта (на данный момент битовая глубина может быть принята равной 32 битам = 4 байтам). Обратите внимание, что из-за малого формата endian запись данных изображения байтами приведет к смещениям 0=R, 1=G, 2=B, 3=A, но запись их всех в виде одного целого числа будет интерпретироваться как значение с A как наиболее значимым байтом, за которым следует B, затем G, затем R как наименее значимый байт. Пиксельные данные начинаются в верхнем левом углу изображения и продолжаются слева направо, а затем сверху вниз, в результате чего изображение сохраняется в виде последовательности строк, заканчивающихся в правом нижнем углу. Эта команда использует большую пропускную способность графического процессора, поэтому не рекомендуется вызывать эту команду каждый кадр на больших изображениях.

---

<a name="method-createadvert"></a>

### CreateAdvert()
```php
CreateAdvert(int $type, int $horz, int $vert, int $test): void
```
Создает рекламу для получения дохода. Перед вызовом этой функции вы должны задать данные своего рекламного аккаунта с помощью одной из других команд, таких как SetAdMobDetails. Не все платформы поддерживают всех поставщиков рекламы, поэтому установка как можно большего количества реквизитов учетной записи позволит AGK выбрать подходящее объявление для этой платформы. Эта реклама обычно представляет собой баннер размером 320х50, отображаемый где-то на краю вашего приложения. Создание объявления, когда оно уже существует, заменит существующее объявление. Параметр type можно использовать для выбора размера баннера: 0=Banner(320x50), 1=LargeBanner, 2=MediumRectangle, 3=FullBanner, 4=Leaderboard, 5=SmartBanner, 6=FluidBanner

---

<a name="method-create3dphysicsworld"></a>

### Create3DPhysicsWorld()
```php
Create3DPhysicsWorld(): void
```
Вы должны создать физический мир, прежде чем вызывать какие-либо другие физические команды. Create3DPhysicsWorld Создает физический мир, используя масштабный коэффициент по умолчанию 40. Эта функция создаст физический мир с другим масштабным коэффициентом. Масштаб-это не размер мира, это фактор, с помощью которого все передаваемые данные уменьшаются, чтобы преобразовать их в шкалу физики Пули для физических вычислений. Затем данные из Bullet масштабируются до того, как они будут переданы в AGK 3D world. Масштабный коэффициент по умолчанию будет правильным, если ваш средний размер символа составляет 72 единицы AGK. Тогда гравитация по умолчанию -10,0 метра в секунду на оси Y даст правильный визуальный результат. Решатель физики пуль имеет минимальный размер для объектов. Объекты ниже этого размера вызовут нестабильность в работе решателя. При масштабном коэффициенте по умолчанию 40 наименьший размер, который может обрабатывать решатель, составляет около 3,5 единиц AGK. Чтобы вычислить масштабный коэффициент, сначала определите рост вашего персонажа в метрах, символ высотой 72 единицы будет равен 1,8288 метра (или 6 футов). Затем разделите высоту персонажа в единицах на высоту символов в метрах, для этого примера масштабный коэффициент будет равен (72 / 1.8) = 40.

---

<a name="method-create3dphysicsstaticplane"></a>

### Create3DPhysicsStaticPlane()
```php
Create3DPhysicsStaticPlane(float $normalX, float $normalY, float $normalZ, float $offsetPosition): int
```
Создает статическую плоскость. Возвращает статический идентификатор плоскости

---

<a name="method-create3dphysicsstaticbody"></a>

### Create3DPhysicsStaticBody()
```php
Create3DPhysicsStaticBody(int $objID): void
```
Удаляет существующее физическое тело и создает статическую форму столкновения треугольной сетки и физическое тело для объекта.

---

<a name="method-creategearjoint"></a>

### CreateGearJoint()
```php
CreateGearJoint(int $iJointIndex, int $iJoint1, int $iJoint2, float $ratio): void
```
Создает зубчатое соединение между двумя существующими соединениями. Зубчатое соединение позволяет внешнему виду двух существующих соединений быть зафиксированными вместе в идеальном трении. Спрайты, которые будут соединены, будут спрайтом 2 на обоих суставах, спрайт 1 на обоих суставах должен быть статическим спрайтом. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение должно быть удалено до того, как будут удалены все соединения, от которых оно зависит.

---

<a name="method-create3dphysicsray"></a>

### Create3DPhysicsRay()
```php
Create3DPhysicsRay(): int
```
Возвращает идентификатор созданного луча.

---

<a name="method-create3dphysicssliderjoint"></a>

### Create3DPhysicsSliderJoint()
```php
Create3DPhysicsSliderJoint(int $objA, int $objB, int $positionVec3, int $rotationVec3): int
```
Создает соединение ползунков между объектами a и b. Параметр rotationVec3 должен быть осью в виде (0,1,0) для вертикали, (1,0,0) для горизонтали вдоль оси X, (0,0,1) для горизонтали вдоль оси Z или любой их комбинации. Вектор вращения не нуждается в нормализации. Возвращает идентификатор соединения.

---

<a name="method-create3dphysicsragdoll"></a>

### Create3DPhysicsRagDoll()
```php
Create3DPhysicsRagDoll(int $objID, float $objTotalWeight): void
```
Начинается создание физической тряпичной куклы для объекта. Вы должны добавить по крайней мере одну кость к ragdoll, прежде чем вызывать Finalize3DPhysicsRagDoll(). Кости моделей должны иметь нулевое вращение в положении по умолчанию/первом кадре анимации.

---

<a name="method-create3dphysicspickjoint"></a>

### Create3DPhysicsPickJoint()
```php
Create3DPhysicsPickJoint(int $objID, int $positionVec3): int
```
Возвращает идентификатор соединения

---

<a name="method-create3dphysicskinematicbody"></a>

### Create3DPhysicsKinematicBody()
```php
Create3DPhysicsKinematicBody(int $objID): void
```
Удаляет существующее физическое тело и создает форму столкновения коробки и кинематическое физическое тело для объекта. Кинематическое тело может быть перемещено с помощью команд agk для позиционирования и вращения объектов. Примечание: Кинематическое тело может взаимодействовать только с динамическим телом и будет проходить через статическое тело.

---

<a name="method-create3dphysicshingejoint"></a>

### Create3DPhysicsHingeJoint()
```php
Create3DPhysicsHingeJoint(int $objA, int $objB, int $positionVec3, int $rotationVec3, int $disableCollisions): int
```
Создает шарнирное соединение между объектами a и b. Параметр rotationVec3 должен быть осью в виде (0,1,0) для вертикали, (1,0,0) для горизонтали вдоль оси X, (0,0,1) для горизонтали вдоль оси Z или любой их комбинации. Вектор вращения не нуждается в нормализации. Возвращает идентификатор соединения.

---

<a name="method-create3dphysicsfixedjoint"></a>

### Create3DPhysicsFixedJoint()
```php
Create3DPhysicsFixedJoint(int $objA, int $objB, int $positionVec3): int
```
Создает фиксированное соединение между объектами a и b. Возвращает идентификатор соединения.

---

<a name="method-create3dphysicscharactercontroller"></a>

### Create3DPhysicsCharacterController()
```php
Create3DPhysicsCharacterController(int $objID, int $axis, int $objOffsetVec3, int $objOrientationVec3, float $crouchScale): void
```
Создает 3D-физический контроллер символов для модели. Контроллер символов может быть создан на оси X, Y или Z. Например, стоящий символ будет находиться на оси Y. Лежащий персонаж может быть на X или Z. Если модель имеет смещение от начала координат, objOffsetVec3 необходим для выравнивания символьного контроллера с объектом. Если объект не обращен лицом вниз к положительной оси Z, используйте objOrientationVec3 для настройки. Шкала приседания регулирует размер капсулы приседания в соответствии с высотой вашей модели приседания.

---

<a name="method-create3dphysicsdynamicbody"></a>

### Create3DPhysicsDynamicBody()
```php
Create3DPhysicsDynamicBody(int $objID): void
```
Удаляет существующее физическое тело и создает динамическое тело для объекта с коробчатой формой столкновения и массой 5,0 В зависимости от размера объекта.

---

<a name="method-create3dphysicsconetwistjoint"></a>

### Create3DPhysicsConeTwistJoint()
```php
Create3DPhysicsConeTwistJoint(int $objA, int $objB, int $positionVec3, int $rotationVec3, int $disableCollisions): int
```
Создает конусообразное скручивающее соединение между объектами а и в. Параметр rotationVec3 должен быть осью в виде (0,1,0) для вертикали, (1,0,0) для горизонтали вдоль оси X, (0,0,1) для горизонтали вдоль оси Z или любой их комбинации. Вектор вращения не нуждается в нормализации. Шарнир будет вращаться вдоль заданной оси и свободно вращаться внутри конуса вдоль этой оси. Пределы конуса можно задать с помощью Set3DPhysicsJointConeTwistLimits. Возвращает идентификатор соединения.

---

<a name="method-create3dphysics6dofjoint"></a>

### Create3DPhysics6DOFJoint()
```php
Create3DPhysics6DOFJoint(int $objA, int $objB, int $positionVec3, float $rotationVec3): int
```
Создает соединение 6 степеней свободы между объектами a и b. Возвращает идентификатор соединения.

---

<a name="method-create3dparticles"></a>

### Create3DParticles()
```php
Create3DParticles(int $ID, float $x, float $y, float $z): void
```
Создает излучатель частиц с заданным идентификатором и заданным местоположением в мировых координатах. Излучатели частиц создают поток маленьких спрайтов, которые длятся фиксированное количество времени, прежде чем исчезнуть. Частицы могут подвергаться воздействию сил в течение своей жизни с помощью Add3DParticlesForce. Они также могут менять цвет с течением времени с помощью Add3DParticleColorKeyFrame. Частицы не могут быть изменены по отдельности и вести себя как группа, используя одну и ту же текстуру. Это позволяет AGK рисовать их более эффективно, чем аналогичное количество обычных объектов.

---

<a name="method-countstringtokens2"></a>

### CountStringTokens2()
```php
CountStringTokens2(string $str, string $delimiter): int
```
Подсчитывает количество токенов, разделенных указанным разделителем, например строка, содержащая "first:second:third", имеет три токена, разделенных ":". Аналогично CountStringTokens, за исключением того, что эта команда принимает только один символ в качестве разделителя и распознает пустые поля. Например, "first:second::fourth" имеет четыре токена, а третий-пустую строку.

---

<a name="method-countwindowsdrives"></a>

### CountWindowsDrives()
```php
CountWindowsDrives(): int
```
Возвращает количество дисков, доступных в данный момент на этих устройствах, применяется только к Windows. Другие платформы вернут 0.

---

<a name="method-countstringtokens"></a>

### CountStringTokens()
```php
CountStringTokens(string $str, string $delimiters): int
```
Подсчитывает количество токенов, разделенных заданным набором разделителей, например строка, содержащая "first:second:third", имеет три токена, разделенных ":" и "first:second;third", имеет три токена, разделенных разделителями ":;". Вы можете иметь несколько разделителей между каждым токеном, например "first:;second:third" является допустимым и имеет три токена. Эта команда полезна для разделения слов в предложении, которое может быть разделено как пробелом, так и пунктуацией.

---

<a name="method-cosrad"></a>

### CosRad()
```php
CosRad(float $a): float
```
Возвращает косинус значения в радианах.

---

<a name="method-cos"></a>

### Cos()
```php
Cos(float $a): float
```
Возвращает косинус значения в градусах.

---

<a name="method-copyimage"></a>

### CopyImage()
```php
CopyImage(int $fromImage, int $x, int $y, int $width, int $height): int
```
Копирует часть данного изображения в новое изображение. Значения x, y, width, height выражены в пикселях и представляют собой часть изображения, которую вы хотите скопировать в новое изображение. Новое изображение будет иметь тот же размер, что и заданные значения ширины и высоты. Если изображение уже существует с заданным новым идентификатором, его необходимо удалить перед вызовом этой команды. Это медленная команда, и ее не следует вызывать каждый кадр.

---

<a name="method-copynetworkmessage"></a>

### CopyNetworkMessage()
```php
CopyNetworkMessage(int $iFromMsgID): int
```
Создает сетевое сообщение, которое является копией существующего сообщения. Он возвращает идентификатор, который можно использовать для взаимодействия с сообщением. Сообщения, созданные таким образом, могут быть прочитаны с самого начала или добавлены, и источником сообщения может быть либо созданное вами сообщение, либо полученное вами. Новое сообщение становится полностью независимым от исходного сообщения и может быть отправлено с помощью SendNetworkMessage, не затрагивая оригинал.

---

<a name="method-copymemblock"></a>

### CopyMemblock()
```php
CopyMemblock(int $memSrcID, int $memDstID, int $srcOffset, int $dstOffset, int $size): void
```
Копирует часть одного мемблока в другой. Оба memblocks должны существовать и могут быть разных размеров.

---

<a name="method-connectsocket"></a>

### ConnectSocket()
```php
ConnectSocket(string $szIP, int $port, int $timeout): int
```
Создает сокет и пытается подключиться к указанному IP-адресу. Это создаст TCP-соединение, которое затем можно будет использовать для отправки и получения данных. Эта команда немедленно вернется и подключится в фоновом режиме, вы должны использовать GetSocketConnected, чтобы проверить, успешно ли подключается сокет или нет. Вы должны указать значение тайм-аута, достаточное для подключения сокета, обычно 3000 миллисекунд-это хорошее значение, но для соединений с высокой задержкой может потребоваться больше времени. Если время ожидания соединения истекло, то эта команда вернет 0. Номер порта должен совпадать с портом прослушивания устройства, к которому вы подключаетесь. Это работает немного по-другому при экспорте в HTML5, он использует WebSocket, который отправляет заголовок стиля HTTP и требует ответа стиля HTTP для подключения.

---

<a name="method-completerawjoystickdetection"></a>

### CompleteRawJoystickDetection()
```php
CompleteRawJoystickDetection(): void
```
Ждет завершения обнаружения физических джойстиков, в некоторых системах это может занять несколько секунд, поэтому запускается в отдельном потоке вдоль основного приложения. Если вы не используете ни одну из реальных команд джойстика (включая джойстик AGK), вы можете игнорировать эту команду и позволить обнаружению джойстика завершиться, когда ему заблагорассудится. Однако если вы хотите использовать команды джойстика в своем приложении, вы должны вызвать эту команду, чтобы убедиться, что общее количество подключенных джойстиков найдено. После этого первоначального процесса обнаружения подключение дополнительных джойстиков не будет обнаружено.

---

<a name="method-comparestring"></a>

### CompareString()
```php
CompareString(string $str, string $str2, int $ignoreCase, int $maxChars): int
```
Возвращает 1, если две строки равны друг другу, в противном случае возвращает 0. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру. Используйте параметр maxChars, чтобы указать максимальное количество символов для проверки, если строки совпадают после того, как было проверено много символов, то они считаются равными. Используйте значение -1 для проверки всех символов независимо от длины.

---

<a name="method-closezip"></a>

### CloseZip()
```php
CloseZip(int $zipID): void
```
Закрывает zip-файл, открытый с помощью CreateZip. Это завершает работу zip-файла и позволяет открыть его для извлечения.

---

<a name="method-closerawfolder"></a>

### CloseRawFolder()
```php
CloseRawFolder(int $ID): void
```
Закрывает ранее открытую папку и освобождает список файлов, который был сгенерирован для нее. Фактические изменения файловой системы не производятся, то есть папка не удерживается открытой в файловой системе. Папка читается полностью во время OpenRawFolder, поэтому она не должна существовать в файловой системе после вызова этой команды.

---

<a name="method-closenetwork"></a>

### CloseNetwork()
```php
CloseNetwork(int $iNetID): void
```
Отключается от указанной сети. Идентификатор освобождается и больше не может использоваться в других сетевых командах.

---

<a name="method-closehttpconnection"></a>

### CloseHTTPConnection()
```php
CloseHTTPConnection(int $iHTTP): void
```
Закрывает соединение с сервером, дальнейшие соединения могут быть созданы, если вы снова вызовете SetHTTPHost.

---

<a name="method-closefile"></a>

### CloseFile()
```php
CloseFile(int $iFileID): void
```
Закрывает файл и очищает идентификатор, используемый для его создания, никакие другие команды файла не могут быть вызваны с этим идентификатором.

---

<a name="method-clonesprite"></a>

### CloneSprite()
```php
CloneSprite(int $iOtherSprite): int
```
Клонирует спрайт в заданный идентификатор спрайта. Новый спрайт будет находиться точно в том же положении, что и оригинал. Любые физические значения или формы, присвоенные спрайту, не будут скопированы. Новый спрайт не будет настроен на физику.

---

<a name="method-cloneobject"></a>

### CloneObject()
```php
CloneObject(int $objID): int
```
Копирует объект в новый идентификатор, новый объект полностью отделен от исходного объекта. Клонирование экземпляра объекта приведет к созданию другого экземпляра, который совместно использует данные вершин с исходным объектом.

---

<a name="method-clearurlschemetext"></a>

### ClearURLSchemeText()
```php
ClearURLSchemeText(): void
```
Очищает сохраненный в данный момент текст схемы URL - адреса, чтобы вы могли сигнализировать о том, что действовали в соответствии с ним. Это не обязательно, но может сделать ваш код проще, если вам не нужно помнить, что вы имели дело с событием схемы URL.

---

<a name="method-cleartweenchain"></a>

### ClearTweenChain()
```php
ClearTweenChain(int $chainID): void
```
Опустошает цепочку всех подростков и останавливает тех, кто бежал. Любые подростки, которые были добавлены к нему, не затрагиваются и могут быть использованы в будущих цепочках.

---

<a name="method-clearspriteshapes"></a>

### ClearSpriteShapes()
```php
ClearSpriteShapes(int $iSpriteIndex): void
```
Удаляет все дополнительные фигуры, примененные к спрайту, и сохраняет только базовую фигуру в shapeID 1.

---

<a name="method-clearspriteanimationframes"></a>

### ClearSpriteAnimationFrames()
```php
ClearSpriteAnimationFrames(int $iSpriteIndex): void
```
Удаляет все анимационные кадры из спрайта, возвращая его в один спрайт изображения. Если вы добавили изображения по отдельности в спрайт с помощью AddSpriteAnimationFrame, то изображение спрайта будет неопределенным, и рекомендуется назначить ему новое изображение.

---

<a name="method-clearparticlesscales"></a>

### ClearParticlesScales()
```php
ClearParticlesScales(int $ID): void
```
Очищает все модификаторы размера, которые были назначены эмиттеру, частицы будут поддерживать любой размер, который они в настоящее время имеют.

---

<a name="method-clearparticlesforces"></a>

### ClearParticlesForces()
```php
ClearParticlesForces(int $ID): void
```
Очищает все силы, назначенные этому излучателю. Все силы немедленно перестанут влиять на частицы.

---

<a name="method-clearparticlescolors"></a>

### ClearParticlesColors()
```php
ClearParticlesColors(int $ID): void
```
Очищает все цвета, которые были назначены излучателю, частицы будут поддерживать любой цвет, который они имеют в данный момент.

---

<a name="method-clear3dparticlesforces"></a>

### Clear3DParticlesForces()
```php
Clear3DParticlesForces(int $ID): void
```
Очищает все силы, назначенные этому излучателю. Все силы немедленно перестанут влиять на частицы.

---

<a name="method-clear3dparticlesscales"></a>

### Clear3DParticlesScales()
```php
Clear3DParticlesScales(int $ID): void
```
Очищает все модификаторы размера, которые были назначены эмиттеру, частицы будут поддерживать любой размер, который они в настоящее время имеют.

---

<a name="method-chr"></a>

### Chr()
```php
Chr(int $unicodevalue): string
```
Возвращает строку переданного значения Unicode.

---

<a name="method-clear3dparticlescolors"></a>

### Clear3DParticlesColors()
```php
Clear3DParticlesColors(int $ID): void
```
Очищает все цвета, которые были назначены излучателю, частицы будут поддерживать любой цвет, который они имеют в данный момент.

---

<a name="method-clearpointlights"></a>

### ClearPointLights()
```php
ClearPointLights(): void
```
Удаляет все точечные огни.

---

<a name="method-clearscreen"></a>

### ClearScreen()
```php
ClearScreen(): void
```
Очищает задний буфер и буфер глубины всего рисунка и заполняет его выбранным прозрачным цветом, установленным SetClearColor. Это не влияет на то, что видно на экране, если только Swap не вызывается для отображения заднего буфера на экран. Это позволяет вам нарисовать некоторые вещи в backbuffer, использовать getImage для хранения результата, а затем ClearScreen для рисования чего-то еще.

---

<a name="method-chooserawfile"></a>

### ChooseRawFile()
```php
ChooseRawFile(string $ext, int $returnFullPath): string
```
Предоставляет пользователю возможность выбрать файл, хранящийся на его текущей платформе (только для Windows/Mac), например фото или звуковой файл. Если пользователь отменит операцию, будет возвращена пустая строка, в противном случае файл будет скопирован в текущий каталог приложений и возвращено имя файла, чтобы его можно было использовать в вашем приложении. Вы можете указать дополнительный фильтр расширений, чтобы ограничить типы файлов, которые пользователь будет видеть при просмотре. Например, использование фильтра расширения "*.wav" ограничит пользователя выбором файлов .wav. Для нескольких расширений разделите их точкой с запятой, например "*.wav;*.mp3;*.png". Если эта команда используется в tier 2, возвращаемая строка должна быть удалена, когда вы закончите с ней, даже если это пустая строка. Нулевая строка не будет возвращена. Если вы установите returnFullPath равным 1, то файл не будет скопирован в папку записи, вместо этого вам будет возвращен полный путь, и вы можете загрузить его с помощью префикса "raw:" с обычными файловыми командами.

---

<a name="method-checkpermission"></a>

### CheckPermission()
```php
CheckPermission(string $szPermission): int
```
Только для Android все остальные платформы вернут 1 и ничего не сделают. Проверяет, предоставил ли пользователь вашему приложению указанное разрешение на использование определенных команд Android. Разрешения следующие: "writeExternal" - используется командами SaveSharedVariable и любыми путями "raw:", которые обращаются к SD-карте. "Location" - используется командами GPS "Camera" - используется командой SetDeviceCameraToImage "RecordAudio" - используется командой StartScreenRecording и для канала AR camera Эта команда вернет 0, если у вас нет разрешения и пользователя еще не спросили, вы должны вызвать requestPermission, если вам это нужно. Эта команда возвращает 1 если пользователь находится в процессе запроса разрешения, вы должны дождаться ответа, продолжая вызывать эту команду. Он вернет -1, если пользователь отклонил разрешение, или 2, если пользователь предоставил разрешение. Если пользователь отклоняет ваш запрос, вы можете спросить еще раз, но сначала вы должны объяснить, почему ваше приложение нуждается в нем, чтобы они могли сделать осознанный выбор. Если они все еще отвергают его, вы обычно не должны спрашивать в третий раз. После первой попытки Android предоставит пользователю возможность никогда не разрешать это разрешение. В этом случае эта команда всегда будет возвращать -1, а requestPermission ничего не сделает. Пользователю придется зайти в настройки приложения устройства, чтобы отменить это решение. Любое разрешение, не указанное здесь, не требует от вас запроса разрешения пользователя, оно будет автоматически предоставлено при установке, если ваше приложение этого требует. Все разрешения, которые использует ваше приложение, даже те, которые требуют запроса, должны быть указаны в диалоговом окне экспорта APK, установив соответствующие флажки.

---

<a name="method-ceil"></a>

### Ceil()
```php
Ceil(float $a): int
```
Округляет поплавок до следующего по величине целого числа. Это отличается от Trunc при использовании положительных чисел, Trunc( 1.6 ) равен 1, а Ceil( 1.6 ) равен 2.

---

<a name="method-cancelzipextract"></a>

### CancelZipExtract()
```php
CancelZipExtract(): void
```
Останавливает любое асинхронное извлечение zip-файла, которое выполняется в данный момент, это может занять некоторое время, чтобы закончить текущий файл, а затем он остановится. Как только он завершится, GetZipExtractComplete вернет 1, а GetZipExtractProgress останется на том же значении, на котором он был в данный момент.

---

<a name="method-cancellocalnotification"></a>

### CancelLocalNotification()
```php
CancelLocalNotification(int $iID): void
```
Отменяет уведомление, запланированное этим приложением

---

<a name="method-cleardepthbuffer"></a>

### ClearDepthBuffer()
```php
ClearDepthBuffer(): void
```
Очищает буфер глубины всех объектов. Это очистит буфер, даже если очистка глубины была отключена с помощью EnableClearDepth.

---

<a name="method-calculatespritephysicscom"></a>

### CalculateSpritePhysicsCOM()
```php
CalculateSpritePhysicsCOM(int $iSpriteIndex): void
```
Пересчитывает COM на основе фигур, прикрепленных к спрайту, если вы переопределили COM, это вернет его обратно в местоположение, определенное AGK. Если COM сильно отличается от точки смещения, спрайт может показаться нестабильным, так как он будет вести себя как несбалансированный волчок.

---

<a name="method-cacherewardadchartboost"></a>

### CacheRewardAdChartboost()
```php
CacheRewardAdChartboost(): void
```
Кэширует полноэкранную видеорекламу награды для последующего отображения с помощью Chartboost. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetChartboostDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление уже было кэшировано, то это ничего не даст. В отличие от AdMob, reward videos не будет автоматически запускать кэширование с помощью Chartboost, если вы не вызовете эту команду. Это связано с тем, что Chartboost использует одни и те же детали как для интерстициальных, так и для наградных видео, поэтому AGK не может заранее знать, какие именно вы используете. Поскольку видеореклама может использовать много мобильных данных, процесс их кэширования не будет запущен автоматически. Вам нужно сделать это только один раз, после того как видеореклама с вознаграждением будет показана, новая будет автоматически кэширована. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetRewardAdLoadedChartboost.

---

<a name="method-bin"></a>

### Bin()
```php
Bin(int $i): string
```
Преобразует целочисленное значение в строку, содержащую его двоичное представление. Например, Bin(7) вернет строку, содержащую "111". Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.

---

<a name="method-bytelen"></a>

### ByteLen()
```php
ByteLen(string $strin): int
```
Возвращает количество байтов в данной строке. Обратите внимание, что для строк, закодированных в UTF-8, это может быть не равно количеству символов в строке, так как каждый символ может использовать до 4 байт. Чтобы определить количество символов в строке, используйте команду Len.

---

<a name="method-addzipentry"></a>

### AddZipEntry()
```php
AddZipEntry(int $zipID, string $path, string $zipPath): void
```
Добавляет локальный файл в zip-файл. Переменная path-это путь к локальному файлу, переменная ZipPath-это путь, который будет использоваться внутри zip-файла, это единственный способ добавить папки в zip-файл (добавив файл с ZipPath, например "folder1/myfile.txt"). Локальный путь к файлу находится относительно текущего каталога, установленного с помощью SetFolder, если только вы не начинаете путь с прямой косой черты, и в этом случае путь будет относительно корня каталога записи на текущей платформе.

---

<a name="method-asc"></a>

### Asc()
```php
Asc(string $strin): int
```
Преобразует одну символьную строку в значение Unicode, которое она представляет.

---

<a name="method-addvirtualjoystick"></a>

### AddVirtualJoystick()
```php
AddVirtualJoystick(int $index, float $x, float $y, float $size): void
```
Создает экранный джойстик, которым можно управлять с помощью сенсорного экрана, мыши или другого указательного устройства. Они отделены от физических джойстиков, так что у вас может быть виртуальный джойстик с идентификатором 1 и реальный джойстик с идентификатором 1. У вас может быть до 4 виртуальных джойстиков на экране одновременно. Если виртуальный джойстик находится на экране и при нажатии или касании джойстик захватит это событие, а GetRawMouseLeftState вернет 0 (вверх), и событие касания не будет сгенерировано для этого действия.

---

<a name="method-addtweenchaintext"></a>

### AddTweenChainText()
```php
AddTweenChainText(int $chainID, int $tweenID, int $textID, float $delay): void
```
Применяет данный идентификатор анимации к заданному идентификатору текстового объекта с необязательной задержкой и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким текстовым объектам одновременно, просто вызовите эту команду снова с другим идентификатором текстового объекта. Текстовый объект не будет изменен до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на текстовом объекте, текст будет соответствующим образом корректировать свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-addtweenchainsprite"></a>

### AddTweenChainSprite()
```php
AddTweenChainSprite(int $chainID, int $tweenID, int $spriteID, float $delay): void
```
Применяет данный идентификатор анимации к заданному идентификатору спрайта с необязательной задержкой и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким спрайтам одновременно, просто вызовите эту команду снова с другим идентификатором спрайта. Спрайт не будет изменен до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на спрайте, то спрайт соответствующим образом скорректирует свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-addtweenchainobject"></a>

### AddTweenChainObject()
```php
AddTweenChainObject(int $chainID, int $tweenID, int $objectID, float $delay): void
```
Применяет данный идентификатор анимации к заданному идентификатору объекта с необязательной задержкой и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким объектам одновременно, просто вызовите эту команду снова с другим идентификатором объекта. Объект не будет изменен до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на объекте, объект соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-addtweenchaincustom"></a>

### AddTweenChainCustom()
```php
AddTweenChainCustom(int $chainID, int $tweenID, float $delay): void
```
Добавляет данный пользовательский идентификатор анимации в конец цепочки с необязательной задержкой. Анимация не начнется до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации, она соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-addtweenchainchar"></a>

### AddTweenChainChar()
```php
AddTweenChainChar(int $chainID, int $tweenID, int $textID, int $charID, float $delay): void
```
Применяет заданный идентификатор анимации к заданному символу в текстовом объекте с необязательной задержкой и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким символам одновременно, просто вызовите эту команду снова с другим символом или текстовым идентификатором. Символ не будет изменен до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на символе, то символ соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-addspriteshapepolygon"></a>

### AddSpriteShapePolygon()
```php
AddSpriteShapePolygon(int $iSpriteIndex, int $numPoints, int $index, float $x, float $y): void
```
Добавляет новую форму к спрайту в дополнение к уже имеющимся. Эти дополнительные фигуры применимы только к физическим спрайтам и должны быть добавлены после того, как спрайт был настроен на использование физики. Полигон определяется набором точек (от 2 до 12) относительно смещения текущего спрайта. Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено от этой точки. Точки определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой фигуры. Это приведет к пересчету значений массы и центра масс спрайта.

---

<a name="method-addspriteshapecircle"></a>

### AddSpriteShapeCircle()
```php
AddSpriteShapeCircle(int $iSpriteIndex, float $x, float $y, float $radius): void
```
Добавляет новую форму к спрайту в дополнение к уже имеющимся. Эти дополнительные фигуры применимы только к физическим спрайтам и должны быть добавлены после того, как спрайт был настроен на использование физики. Окружность определяется путем указания ее центральной точки относительно текущего смещения спрайта и радиуса. Например, если круг должен быть центрирован в точке смещения спрайта, он будет указан в позиции 0,0. Любое другое значение будет смещать круг от спрайта. Радиус определяется в координатах x, поскольку мировые координаты не обязательно представляют размер элементов на экране (например, 10 единиц в X могут быть не такими же видимыми размерами, как 10 единиц в Y). Это приведет к пересчету значений массы и центра масс спрайта.

---

<a name="method-addspriteshapechain"></a>

### AddSpriteShapeChain()
```php
AddSpriteShapeChain(int $iSpriteIndex, int $numPoints, int $index, int $loop, float $x, float $y): void
```
Добавляет новую форму к спрайту в дополнение к уже имеющимся. Фигуры могут быть добавлены, даже если спрайт не настроен на физику. Цепочка определяется набором точек (не менее 2) относительно смещения текущего спрайта. Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено от этой точки. Цепи являются жесткими и могут быть использованы для создания полых вогнутых полигонов или 2D-ландшафтов. Установите параметр loop равным 1, чтобы соединить два конца цепочки вместе, создав полый многоугольник. Точки определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой фигуры. Это приведет к пересчету значений массы и центра масс спрайта.

---

<a name="method-addvirtualbutton"></a>

### AddVirtualButton()
```php
AddVirtualButton(int $index, float $x, float $y, float $size): void
```
Создает экранную кнопку, которой можно управлять с помощью сенсорного экрана, мыши или другого указательного устройства. Они отделены от физических кнопок джойстика или клавиш клавиатуры, так что у вас может быть виртуальная кнопка с идентификатором 1 и реальная кнопка джойстика с идентификатором 1. У вас может быть до 100 виртуальных кнопок на экране одновременно. Если виртуальная кнопка находится на экране и нажата или тронута, то кнопка захватит это событие, а GetRawMouseLeftState вернет 0 (вверх), и событие касания не будет сгенерировано для этого действия.

---

<a name="method-addspriteshapebox"></a>

### AddSpriteShapeBox()
```php
AddSpriteShapeBox(int $iSpriteIndex, float $x, float $y, float $x2, float $y2, float $angle): void
```
Добавляет новую форму к спрайту в дополнение к уже имеющимся. Эти дополнительные фигуры применимы только к физическим спрайтам и должны быть добавлены после того, как спрайт был настроен на использование физики. Поле определяется путем указания его верхних левых и нижних правых координат в пространстве спрайтов относительно его текущего смещения. Например, если текущее смещение спрайта равно 0,0, то верхний левый угол коробки будет равен 0,0, но если смещение спрайта равно середине спрайта (по умолчанию), то верхний левый угол будет равен-width/2,-height/2. Вы также можете указать угол смещения коробки относительно текущего поворота спрайта. Это приведет к пересчету значений массы и центра масс спрайта.

---

<a name="method-addparticlesscalekeyframe"></a>

### AddParticlesScaleKeyFrame()
```php
AddParticlesScaleKeyFrame(int $ID, float $time, float $scale): void
```
Добавляет изменение размера в определенный момент жизни частицы. Значения шкалы относительны к значению, заданному SetParticlesSize, поэтому шкала 2 означает удвоение ее нормального размера, а 0,5-половину ее нормального размера. Масштаб, добавленный со временем=1, сделает частицу равной заданному размеру, когда она была жива в течение 1 секунды. Частица постепенно преобразуется из своего текущего размера в следующий.

---

<a name="method-addspriteanimationframe"></a>

### AddSpriteAnimationFrame()
```php
AddSpriteAnimationFrame(int $iSpriteIndex, int $iImageIndex): void
```
Добавляет изображение в спрайт в качестве нового анимационного кадра. Индексы фреймов начинаются с 1 и постепенно увеличиваются. Это изображение может быть совместно использовано несколькими спрайтами либо в виде отдельных изображений, либо в виде анимационных кадров, а также может быть частью текстуры атласа. В качестве альтернативы, если у вас есть все ваши анимационные кадры на одном изображении, вы можете использовать более быстрый SetSpriteAnimation, который позволяет избежать изменений изображения во время рендеринга, изменяя UV-координаты для изменения кадра.

---

<a name="method-addparticlesforce"></a>

### AddParticlesForce()
```php
AddParticlesForce(int $ID, float $starttime, float $endtime, float $x, float $y): void
```
Добавляет силу, которая будет действовать в данный момент в жизни каждой частицы. Например, сила, установленная для начала в момент времени 2 и окончания в момент времени 3, начнет воздействовать на частицы, когда они будут живы в течение 2 секунд. Он будет продолжать действовать на эти частицы до тех пор, пока они не оживут в течение 3 секунд. Влияние силы определяется величинами x и y, которые представляют ускорение в единицах в секунду. Например, сила с x=5 будет регулировать горизонтальную скорость частицы, добавляя 5 единиц за каждую секунду, когда сила активна, если сила активна только в течение 0,5 секунды, то частица будет двигаться на 2,5 единицы в секунду быстрее вправо. Несколько сил могут действовать на частицу одновременно, если их временные интервалы перекрываются.

---

<a name="method-addparticlescolorkeyframe"></a>

### AddParticlesColorKeyFrame()
```php
AddParticlesColorKeyFrame(int $ID, float $time, int $red, int $green, int $blue, int $alpha): void
```
Добавляет изменение цвета в определенный момент жизни частицы. Например, цвет, добавленный со временем=1, сделает частицу равной данному цвету, когда она была жива в течение 1 секунды. Если цветовая интерполяция включена с помощью SetParticlesColorInterpolation, частица постепенно преобразуется из своего текущего цвета в следующий. Например, если вы добавите три цвета: красный, когда время=1, зеленый, когда время=2, и синий, когда время=3, то частица начнет свою жизнь как красный (поскольку это ближайший цвет) и останется полностью красной, пока ей не исполнится 1 секунда. Когда частице от 1 до 2 секунд, она будет постепенно меняться с красного на зеленый, пока ей не исполнится 2 секунды, в этот момент она полностью зеленая. Когда частице от 2 до 3 секунд, она будет постепенно меняться от зеленого до синего, пока ей не исполнится 3 секунды, в этот момент она полностью синяя. Частица останется полностью синей до конца своей жизни, так как никакие другие цвета не были добавлены.

---

<a name="method-addobjectshapesphere"></a>

### AddObjectShapeSphere()
```php
AddObjectShapeSphere(int $objID, int $positionVec3, float $diameter): void
```
Добавляет форму столкновения сфер к составной форме. Сначала установите форму объектов в составную форму столкновения с помощью SetObjectShapeCompound().

---

<a name="method-addobjectshapecylinder"></a>

### AddObjectShapeCylinder()
```php
AddObjectShapeCylinder(int $objID, int $positionVec3, int $rotationVec3, int $sizeVec3, int $axis): void
```
Добавляет форму столкновения цилиндров к сложной форме. Сначала установите форму объектов в составную форму столкновения с помощью SetObjectShapeCompound().

---

<a name="method-addobjectshapecone"></a>

### AddObjectShapeCone()
```php
AddObjectShapeCone(int $objID, int $positionVec3, int $rotationVec3, int $sizeVec3, int $axis): void
```
Добавляет форму столкновения конуса к сложной форме. Сначала установите форму объектов в составную форму столкновения с помощью SetObjectShapeCompound().

---

<a name="method-addobjectshapecapsule"></a>

### AddObjectShapeCapsule()
```php
AddObjectShapeCapsule(int $objID, int $positionVec3, int $rotationVec3, int $sizeVec3, int $axis): void
```
Добавляет форму столкновения капсул к сложной форме. Сначала установите форму объектов в составную форму столкновения с помощью SetObjectShapeCompound().

---

<a name="method-addtweenchaincamera"></a>

### AddTweenChainCamera()
```php
AddTweenChainCamera(int $chainID, int $tweenID, int $cameraID, float $delay): void
```
Применяет данный идентификатор анимации к данному идентификатору камеры с дополнительной задержкой и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким камерам одновременно, просто вызовите эту команду еще раз с другим идентификатором камеры. Камера не будет изменена до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на камере, камера соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.

---

<a name="method-addobjectshapebox"></a>

### AddObjectShapeBox()
```php
AddObjectShapeBox(int $objID, int $positionVec3, int $rotationVec3, int $sizeVec3): void
```
Добавляет форму столкновения коробок к составной форме. Сначала установите форму объектов в составную форму столкновения с помощью SetObjectShapeCompound().

---

<a name="method-addobjectmeshfrommemblock"></a>

### AddObjectMeshFromMemblock()
```php
AddObjectMeshFromMemblock(int $objID, int $memID): void
```
Добавляет новую сетку к объекту, построенному из данного memblock. Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда должен быть кратен 4 по соображениям выравнивания, сама строка может иметь немного меньше символов, но всегда округляется до ближайшего кратного 4 для значения длины строки. например, строка длины 5 должна иметь значение длины строки 8. Обратите внимание, что строка из 4 символов имеет нулевой терминатор на конце, что делает ее длиной 5, поэтому, даже если она уже имеет кратное 4 символам значение длины, она должна использовать значение длины 8 из-за нулевого терминатора. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник.

---

<a name="method-addnetworkmessagestring"></a>

### AddNetworkMessageString()
```php
AddNetworkMessageString(int $iMsgID, string $value): void
```
Добавляет строку к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных CreateNetworkMessage, или для сообщений, полученных из сети.

---

<a name="method-addnetworkmessagefloat"></a>

### AddNetworkMessageFloat()
```php
AddNetworkMessageFloat(int $iMsgID, float $value): void
```
Добавляет поплавок к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных CreateNetworkMessage, или для сообщений, полученных из сети.

---

<a name="method-addnetworkmessagebyte"></a>

### AddNetworkMessageByte()
```php
AddNetworkMessageByte(int $iMsgID, int $value): void
```
Добавляет байт без знака к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных CreateNetworkMessage, или для сообщений, полученных из сети.

---

<a name="method-addhttpheader"></a>

### AddHTTPHeader()
```php
AddHTTPHeader(int $iHTTP, string $headerName, string $headerValue): void
```
Добавляет указанный заголовок ко всем будущим запросам. Если заголовок уже существует, то его значение будет перезаписано новым значением. Если заголовок является стандартным заголовком, который обычно присутствует, то его значение будет перезаписано значением, которое вы даете. Если заголовок является стандартным заголовком, который обычно присутствует, а значение, которое вы даете, является пустой строкой, то стандартный заголовок будет удален. Не добавляйте двоеточие ни в одно из полей, оно будет добавлено автоматически между ними. Обратите внимание, что эта команда не работает в версии HTML5.

---

<a name="method-addnetworkmessageinteger"></a>

### AddNetworkMessageInteger()
```php
AddNetworkMessageInteger(int $iMsgID, int $value): void
```
Добавляет целое число к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных CreateNetworkMessage, или для сообщений, полученных из сети.

---

<a name="method-add3dparticlesforce"></a>

### Add3DParticlesForce()
```php
Add3DParticlesForce(int $ID, float $starttime, float $endtime, float $x, float $y, float $z): void
```
Добавляет силу, которая будет действовать в данный момент в жизни каждой частицы. Например, сила, установленная для начала в момент времени 2 и окончания в момент времени 3, начнет воздействовать на частицы, когда они будут живы в течение 2 секунд. Он будет продолжать действовать на эти частицы до тех пор, пока они не оживут в течение 3 секунд. Влияние силы определяется величинами x, y и z, которые представляют ускорение в единицах в секунду. Например, сила с x=5 будет регулировать горизонтальную скорость частицы, добавляя 5 единиц за каждую секунду, когда сила активна, если сила активна только в течение 0,5 секунды, то частица будет двигаться на 2,5 единицы в секунду быстрее в направлении X. Несколько сил могут действовать на частицу одновременно, если их временные интервалы перекрываются.

---

<a name="method-add3dparticlescolorkeyframe"></a>

### Add3DParticlesColorKeyFrame()
```php
Add3DParticlesColorKeyFrame(int $ID, float $time, int $red, int $green, int $blue, int $alpha): void
```
Добавляет изменение цвета в определенный момент жизни частицы. Например, цвет, добавленный со временем=1, сделает частицу равной данному цвету, когда она была жива в течение 1 секунды. Если цветовая интерполяция включена с помощью Set3DParticlesColorInterpolation, частица постепенно преобразуется из своего текущего цвета в следующий. Например, если вы добавите три цвета: красный, когда время=1, зеленый, когда время=2, и синий, когда время=3, то частица начнет свою жизнь как красный (поскольку это ближайший цвет) и останется полностью красной, пока ей не исполнится 1 секунда. Когда частице от 1 до 2 секунд, она будет постепенно меняться с красного на зеленый, пока ей не исполнится 2 секунды, в этот момент она полностью зеленая. Когда частице от 2 до 3 секунд, она будет постепенно меняться от зеленого до синего, пока ей не исполнится 3 секунды, в этот момент она полностью синяя. Частица останется полностью синей до конца своей жизни, так как никакие другие цвета не были добавлены.

---

<a name="method-activatesmartwatch"></a>

### ActivateSmartWatch()
```php
ActivateSmartWatch(string $szReserved): void
```
Попытка подключения к смарт-часам, подключенным к текущему устройству. Он будет пытаться поддерживать это соединение в течение всего срока службы приложения, например, если часы непарные, а затем отремонтированы, то ваше приложение автоматически подключится к часам. Таким образом, вам нужно только один раз вызвать эту команду в начале вашего приложения.  В настоящее время работает только на iOS. Чтобы создать приложение watch, вам нужно будет использовать Tier 2 project interpreter_ios и добавить в него приложение watch.

---

<a name="method-abs"></a>

### Abs()
```php
Abs(float $a): float
```
Возвращает абсолютное значение, то есть положительную версию числа.

---

<a name="method-atanrad"></a>

### ATanRad()
```php
ATanRad(float $a): float
```
Возвращает арктангенс значения в радианах в диапазоне от pi/2 до pi/2.

---

<a name="method-add3dphysicsragdollbone"></a>

### Add3DPhysicsRagDollBone()
```php
Add3DPhysicsRagDollBone(int $startBoneID, int $endBoneID, float $diameter, int $collisionGroup, int $collisionMask): int
```
Создает костную капсулу тряпичной куклы между начальным и конечным расположением костей объектов. Возвращает идентификатор кости рэгдолла. Если эта команда не сможет создать кость, она вернет значение -1.

---

<a name="method-add3dparticlesscalekeyframe"></a>

### Add3DParticlesScaleKeyFrame()
```php
Add3DParticlesScaleKeyFrame(int $ID, float $time, float $scale): void
```
Добавляет изменение размера в определенный момент жизни частицы. Значения шкалы относятся к значению, заданному Set3DParticlesSize, поэтому шкала 2 означает удвоение ее нормального размера, а 0,5-половину ее нормального размера. Масштаб, добавленный со временем=1, заставит частицу постепенно трансформироваться в заданную, пока она не будет жива в течение 1 секунды, когда она будет соответствовать заданному размеру. Затем частица постепенно преобразуется из этого размера в следующий (если следующий размер существует).

---

<a name="method-atanfull"></a>

### ATanFull()
```php
ATanFull(float $x, float $y): float
```
Возвращает угол в градусах между x=0 y=-1 (вверх) и заданным вектором по часовой стрелке. Возвращает значение от 0 до 360. Эта команда является собственностью AGK и полезна в 2D-ситуациях. Если вы ищете эквивалент atan2 в C++, используйте вместо этого команду AGK ATan2.

---

<a name="method-atan2rad"></a>

### ATan2Rad()
```php
ATan2Rad(float $y, float $x): float
```
Возвращает угол вектора x,y в радианах в диапазоне от pi до pi. Это точно соответствует функции C++ atan2.

---

<a name="method-atan"></a>

### ATan()
```php
ATan(float $a): float
```
Возвращает арктангенс значения в градусах в диапазоне от -90 до 90.

---

<a name="method-asin"></a>

### ASin()
```php
ASin(float $a): float
```
Возвращает арксин значения в градусах.

---

<a name="method-arsetup"></a>

### ARSetup()
```php
ARSetup(): void
```
Доступно только на iOS и Android. Эта команда настраивает функции AR устройства, если они доступны. Используйте команду ARGetStatus, чтобы проверить, было ли это успешно. Эта команда должна быть вызвана перед любыми другими командами AR, если установка не удалась, вы можете вызвать эту команду снова, чтобы попытаться выполнить установку снова.  Настройка AR возьмет на себя управление 3D-камерой, включая проекционную матрицу, поэтому любые изменения, внесенные вами в положение камеры, поворот, FOV, будут перезаписаны системой AR при вызове рендеринга или синхронизации. Однако вы все еще можете управлять ближними и дальними значениями камеры с помощью SetCameraRange, который будет сохраняться в системе AR.  При использовании AR и размещении или калибровке 3D - объектов система координат 1 единица AGK равна 1 метру.

---

<a name="method-arsetplanedetectionmode"></a>

### ARSetPlaneDetectionMode()
```php
ARSetPlaneDetectionMode(int $mode): void
```
Устанавливает режим обнаружения плоскости для AR, по умолчанию он включен. Обнаруженные самолеты можно обнаружить с помощью команды ARGetPlanes.

---

<a name="method-arsetlightestimationmode"></a>

### ARSetLightEstimationMode()
```php
ARSetLightEstimationMode(int $mode): void
```
Устанавливает режим оценки освещенности для AR, по умолчанию он включен. Это попытка выработать окружающий свет в реальном мире, чтобы вы могли правильно освещать свои виртуальные объекты.

---

<a name="method-atanfullrad"></a>

### ATanFullRad()
```php
ATanFullRad(float $x, float $y): float
```
Возвращает угол в радианах между x=0 y=-1 (вверх) и заданным вектором по часовой стрелке. Возвращает значение от 0 до 2*PI. Эта команда является собственностью AGK и полезна в 2D-ситуациях. Если вы ищете эквивалент atan2 в C++, используйте вместо этого команду AGK ATan2Rad.

---

<a name="method-arhittestfinish"></a>

### ARHitTestFinish()
```php
ARHitTestFinish(): void
```
Очищает ресурсы, используемые во время тестирования хитов, это должно быть вызвано, когда вы закончите проверку результатов теста хитов. Если вы не вызовете его, то он будет вызван автоматически, когда вы выполните еще один тест попадания или уничтожите сеанс AR.

---

<a name="method-arhittest"></a>

### ARHitTest()
```php
ARHitTest(float $screenX, float $screenY): int
```
Бросает луч в реальный мир и обнаруживает любые попадания с самолетов или точек слежения, обнаруженных в мире. Возвращает количество обнаруженных хитов, хиты будут упорядочены с ближайшим первым. Координаты должны находиться в пространстве экрана, например значения, возвращаемые из GetPointerX и GetPointerY. Когда вы закончите проверку результатов этого теста попадания, вы должны вызвать ARHitTestFinish, чтобы освободить все использованные ресурсы. Если нет, то это будет сделано автоматически при следующем вызове ARHitTest.

---

<a name="method-atan2"></a>

### ATan2()
```php
ATan2(float $y, float $x): float
```
Возвращает угол вектора x,y в градусах в диапазоне от -180 до 180. Это точно соответствует функции C++ atan2 с градусами.

---

<a name="method-asinrad"></a>

### ASinRad()
```php
ASinRad(float $a): float
```
Возвращает арксин значения в радианах.

---

<a name="method-argetplanesfinish"></a>

### ARGetPlanesFinish()
```php
ARGetPlanesFinish(): void
```
Очищает все ресурсы, используемые при вызове ARGetPlanes, вы должны вызвать его, когда закончите проверку результатов. Если нет, то он будет вызван автоматически при следующем вызове ARGetPlanes или уничтожении сеанса AR.

---

<a name="method-argetplanes"></a>

### ARGetPlanes()
```php
ARGetPlanes(int $reserved): int
```
Запрашивает сеанс AR для всех самолетов, отслеживаемых в настоящее время в мире, они обнаруживаются с течением времени, если включен режим ARSetPlaneDetectionMode. Возвращает количество найденных плоскостей. Это может быть использовано для отображения обнаруженных плоскостей пользователю путем создания некоторых плоских объектов с помощью CreateObjectPlane и размещения их в заданном положении, с заданным поворотом и размером. Когда вы закончите проверку результатов, вам следует вызвать ARGetPlanesFinish, чтобы очистить все ресурсы, используемые при проверке.

---

<a name="method-argetplanez"></a>

### ARGetPlaneZ()
```php
ARGetPlaneZ(int $index): float
```
Возвращает Z-компоненту центра данной плоскости. Эта точка может со временем смещаться относительно реальной картины мира, поэтому ее следует регулярно проверять и обновлять, если вы используете ее для отображения видимого представления плоскости.

---

<a name="method-argetplaney"></a>

### ARGetPlaneY()
```php
ARGetPlaneY(int $index): float
```
Возвращает Y-компоненту центра данной плоскости. Эта точка может со временем смещаться относительно реальной картины мира, поэтому ее следует регулярно проверять и обновлять, если вы используете ее для отображения видимого представления плоскости.

---

<a name="method-argetplanesizez"></a>

### ARGetPlaneSizeZ()
```php
ARGetPlaneSizeZ(int $index): float
```
Возвращает Z-компоненту размера данной плоскости. Это может быть использовано для масштабирования 3D-объекта в соответствии с визуальным представлением обнаруженной плоскости.

---

<a name="method-argetplanesizex"></a>

### ARGetPlaneSizeX()
```php
ARGetPlaneSizeX(int $index): float
```
Возвращает компонент X размера данной плоскости. Это может быть использовано для масштабирования 3D-объекта в соответствии с визуальным представлением обнаруженной плоскости.

---

<a name="method-argetplaneanglez"></a>

### ARGetPlaneAngleZ()
```php
ARGetPlaneAngleZ(int $index): float
```
Возвращает Z-компоненту вращения данной плоскости. Это может быть использовано для поворота 3D-объекта в соответствии с визуальным представлением обнаруженной плоскости.

---

<a name="method-argetplaneangley"></a>

### ARGetPlaneAngleY()
```php
ARGetPlaneAngleY(int $index): float
```
Возвращает Y-компоненту вращения данной плоскости. Это может быть использовано для поворота 3D-объекта в соответствии с визуальным представлением обнаруженной плоскости.

---

<a name="method-argetplaneanglex"></a>

### ARGetPlaneAngleX()
```php
ARGetPlaneAngleX(int $index): float
```
Возвращает X-компоненту вращения данной плоскости. Это может быть использовано для поворота 3D-объекта в соответствии с визуальным представлением обнаруженной плоскости.

---

<a name="method-argetstatus"></a>

### ARGetStatus()
```php
ARGetStatus(): int
```
Возвращает текущее состояние процесса настройки AR. 0=ARSetup еще не вызван, -1=AR недоступен на этом устройстве или установка не удалась, -2=Пользователь отклонил установку ARCore, 1=ARCore install in progress, 2=AR setup successful.

---

<a name="method-argetlightestimate"></a>

### ARGetLightEstimate()
```php
ARGetLightEstimate(): float
```
Возвращает расчетное значение освещенности для текущего кадра, это будет значение от 0.0 до 1.0. Лучше всего использовать это значение для установки цвета окружающего света с помощью SetAmbientColor со значением 1.0, соответствующим значению цвета 255,255,255.

---

<a name="method-argethittestz"></a>

### ARGetHitTestZ()
```php
ARGetHitTestZ(int $index): float
```
Возвращает Z-компоненту заданного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Эта точка должна использоваться только в течение короткого времени, например, для отображения эффекта частицы, так как она будет дрейфовать относительно реального мира. Если вы планируете использовать эту 3D-точку для позиционирования долгоживущего объекта в мире, то вместо этого вы должны создать якорь из этого результата теста попадания, чтобы он не дрейфовал.

---

<a name="method-argethittesty"></a>

### ARGetHitTestY()
```php
ARGetHitTestY(int $index): float
```
Возвращает компонент Y данного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Эта точка должна использоваться только в течение короткого времени, например, для отображения эффекта частицы, так как она будет дрейфовать относительно реального мира. Если вы планируете использовать эту 3D-точку для позиционирования долгоживущего объекта в мире, то вам следует создать якорь из этого результата теста попадания, чтобы он не дрейфовал.

---

<a name="method-argethittesttype"></a>

### ARGetHitTestType()
```php
ARGetHitTestType(int $index): int
```
Возвращает тип обнаруженной поверхности: 1=плоскость, обычно горизонтальная, 0=точка, обычно стена или другой объект, -1=неизвестно.

---

<a name="method-argetplanex"></a>

### ARGetPlaneX()
```php
ARGetPlaneX(int $index): float
```
Возвращает X-компоненту центра данной плоскости. Эта точка может со временем смещаться относительно реальной картины мира, поэтому ее следует регулярно проверять и обновлять, если вы используете ее для отображения видимого представления плоскости.

---

<a name="method-argethittestnormalz"></a>

### ARGetHitTestNormalZ()
```php
ARGetHitTestNormalZ(int $index): float
```
Возвращает Z-компоненту нормали данного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Для плоскостей на земле нормаль будет указывать прямо вверх в трехмерном пространстве, для точек, обнаруженных на стенах или других объектах, нормаль будет указывать в сторону от обнаруженной поверхности.

---

<a name="method-argethittestnormaly"></a>

### ARGetHitTestNormalY()
```php
ARGetHitTestNormalY(int $index): float
```
Возвращает Y-компоненту нормали данного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Для плоскостей на земле нормаль будет указывать прямо вверх в трехмерном пространстве, для точек, обнаруженных на стенах или других объектах, нормаль будет указывать в сторону от обнаруженной поверхности.

---

<a name="method-arfixobjecttoanchor"></a>

### ARFixObjectToAnchor()
```php
ARFixObjectToAnchor(int $objID, int $anchorID): void
```
Прикрепляет объект к якорю таким же образом, как работает FixObjectToObject. Положение и вращение объекта будут добавлены к положению и вращению якоря. Так, например, объект в положении 0,0,0 будет находиться непосредственно над положением якоря, тогда как если бы объект имел положение 0,2,0, то объект был бы расположен на 2 метра выше положения якоря. Нет ограничений на количество объектов, которые могут быть прикреплены к якорю, и объекты все еще могут быть прикреплены к объекту, прикрепленному к якорю. Например, объект 1 может быть закреплен на якоре, а объект 2-на объекте 1. Чтобы удалить объект из якоря, вызовите эту команду с идентификатором якоря 0. Затем объект будет помещен в мир в его заданном положении, например, положение 0,0,0 поместит его в начало мира.

---

<a name="method-argetanchorstatus"></a>

### ARGetAnchorStatus()
```php
ARGetAnchorStatus(int $anchorID): int
```
Возвращает текущее состояние отслеживания данного якоря. 0=остановлено, 1=приостановлено, 2=отслеживается, -1=не знаю. Якоря могут перестать отслеживать, если камера теряет связь с миром, это может произойти, если камера не видит достаточно объектов, чтобы понять, как движется сцена. Например, глядя на пустую стену. Когда якорь останавливается или приостанавливает отслеживание, он сохраняет свое текущее положение и вращение, но это больше не коррелирует с мировым положением, которое он отслеживал, поэтому якорь может казаться дрейфующим относительно мира. Когда якорь возобновит слежение, он должен вернуться в свое правильное мировое положение.

---

<a name="method-ardeleteanchor"></a>

### ARDeleteAnchor()
```php
ARDeleteAnchor(int $anchorID): void
```
Удаляет указанный якорь и освобождает все ресурсы, которые он использовал. Если какие-либо объекты были прикреплены к якорю при его удалении, то они вернутся в непривязанное состояние и будут помещены в мировые координаты

---

<a name="method-argethittestx"></a>

### ARGetHitTestX()
```php
ARGetHitTestX(int $index): float
```
Возвращает компонент X данного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Эта точка должна использоваться только в течение короткого времени, например, для отображения эффекта частицы, так как она будет дрейфовать относительно реального мира. Если вы планируете использовать эту 3D-точку для позиционирования долгоживущего объекта в мире, то вместо этого вы должны создать якорь из этого результата теста попадания, чтобы он не дрейфовал.

---

<a name="method-argethittestnormalx"></a>

### ARGetHitTestNormalX()
```php
ARGetHitTestNormalX(int $index): float
```
Возвращает X-компоненту нормали данного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Для плоскостей на земле нормаль будет указывать прямо вверх в трехмерном пространстве, для точек, обнаруженных на стенах или других объектах, нормаль будет указывать в сторону от обнаруженной поверхности.

---

<a name="method-ardrawbackground"></a>

### ARDrawBackground()
```php
ARDrawBackground(): void
```
You must call this command if you want the AR camera feed to be drawn to the screen. If you do not then the camera will still track as if it were moving around the real world but the camera feed will not be seen inside the app. This may be useful if you want to render a purely virtual reality but still use the AR camera tracking functionality. The best time to call this command is just before calling Render or Sync.

---

<a name="method-ardestroy"></a>

### ARDestroy()
```php
ARDestroy(): void
```
Destroys the AR session and any resources allocated during setup. After you can not call any AR commands, except ARGetStatus and ARSetup. You may call ARSetup to recreate an AR session. There is no limit on the number of times you can create and destroy the AR session.  Currently on Android this command may take up to 5 seconds, apparently this will be improved ina future version of Google's ARCore.