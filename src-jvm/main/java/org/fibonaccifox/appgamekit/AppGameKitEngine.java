package org.fibonaccifox.appgamekit;

import php.runtime.annotation.Reflection.Name;
import php.runtime.annotation.Reflection.Namespace;
import php.runtime.annotation.Reflection.Signature;
import php.runtime.env.Environment;
import php.runtime.lang.BaseObject;
import php.runtime.reflection.ClassEntity;

/**
 * Класс описания методов, реализованных в AppGameKit для <b>x64</b> и
 * <b>x86</b> битных систем.
 * 
 * @autor FibonacciFox
 * @version 0.9
 */
@Name("AppGameKit")
@Namespace(AppGameKitExtension.NS)
public class AppGameKitEngine extends BaseObject {

        {
                try {
                        System.loadLibrary("AppGameKit");
                } catch (UnsatisfiedLinkError e) {
                        System.load(System.getProperty("user.dir") + "/" + System.mapLibraryName("AppGameKit"));
                }
        }

        public AppGameKitEngine(Environment env) {
                super(env);
        }

        protected AppGameKitEngine(ClassEntity entity) {
                super(entity);
        }

        public AppGameKitEngine(Environment env, ClassEntity clazz) {
                super(env, clazz);
        }

        /**
         * Возвращает преобразованный путь для загрузки файлов в AppGameKit
         * 
         * @param fileName - путь до файла
         * @return String
         */
        @Signature
        public String getPath(String fileName) {
                String dir = System.getProperty("user.dir");
                return "raw:" + dir + "/media/" + fileName;
        }

        /**
         * Обновить окно Windows
         * 
         * @return void
         */
        @Signature
        public native void UpdateWindow();

        /**
         * Показать окно Windows
         * 
         * @return void
         */
        @Signature
        public native void ShowWindow();

        /**
         * Инициализируем OpenGL для отрисовки в стороннее окно
         * 
         * @param hWnd
         */
        @Signature
        public native void InitGL(int hWnd);

        /**
         * Инициализируем AppGameKit
         * 
         * @return void
         */
        @Signature
        public native void Init();

        /**
         * Creates an anchor from the given hit test result which can be used to track a
         * spot in the real world over time. Anchors automatically adjust their position
         * to attempt to stay fixed to a point detected in the real world, this allows
         * you to place an object there without it drifting too much. Returns an ID you
         * can use to reference this anchor later. The hit test result does not need to
         * exist after creating an anchor from it, you can safely clean up the hit test
         * results afterwards. The anchor will persist and use some tracking resources
         * until you specifically delete it with ARDeleteAnchor or you destroy the AR
         * session.
         *
         * @param index - The index of the hit test result to use, starting with index 1
         * @return int
         */
        @Signature
        public native int ARCreateAnchorFromHitTest(int index);

        /**
         * Creates an anchor from the given plane's center which can be used to track a
         * spot in the real world over time. Anchors automatically adjust their position
         * to attempt to stay fixed to a point detected in the real world, this allows
         * you to place an object there without it drifting too much. Returns an ID you
         * can use to reference this anchor later. The plane result does not need to
         * exist after creating an anchor from it, you can safely call ARGetPlanesFinish
         * afterwards. The anchor will persist and use some tracking resources until you
         * specifically delete it with ARDeleteAnchor or you destroy the AR session.
         *
         * @param index - The index of the plane to use, starting with index 1
         * @return int
         */
        @Signature
        public native int ARCreateAnchorFromPlane(int index);

        /**
         * Returns the arccosine of a value in radians.
         *
         * @param a - The value to pass into the arccosine function.
         * @return float
         */
        @Signature
        public native float ACosRad(float a);

        /**
         * Returns the arccosine of a value in degrees.
         *
         * @param a - The value to pass into the arccosine function.
         * @return float
         */
        @Signature
        public native float ACos(float a);

        /**
         * This is an optional command that will reset the camera to the AR assigned
         * values. This could be useful if you change the camera position or rotation
         * but then want to know the AR values for these settings. You do not need to
         * call this command as the values will be reset to the AR values by Render or
         * Sync anyway.
         *
         * @return void
         */
        @Signature
        public native void ARControlCamera();

        /**
         * Writes a string to the given file, which must have been opened for writing.
         * Note that this command is not meant for human readable files and should only
         * be used for files that will later be read with ReadString2. To create human
         * readable files use WriteLine This uses a different method from WriteString
         * that will be faster for AGK to read later, but it is not compatible with
         * ReadString, you must use ReadString2 to read strings written with
         * WriteString2
         *
         * @param iFileID - The ID of the file to modify.
         * @param str     - The string to write.
         * @return void
         */
        @Signature
        public native void WriteString2(int iFileID, String str);

        /**
         * Writes a null terminated string to the given file, which must have been
         * opened for writing. Note that this command is not meant for human readable
         * files and should only be used for files that will later be read with
         * ReadString. To create human readable files use WriteLine
         *
         * @param iFileID - The ID of the file to modify.
         * @param str     - The string to write.
         * @return void
         */
        @Signature
        public native void WriteString(int iFileID, String str);

        /**
         * Writes a 4 byte integer to the given file, which must have been opened for
         * writing. Note that this command is not meant for human readable files and
         * should only be used for files that will later be read with ReadInteger. To
         * create human readable files use WriteLine
         *
         * @param iFileID - The ID of the file to modify.
         * @param i       - The integer to write.
         * @return void
         */
        @Signature
        public native void WriteInteger(int iFileID, int i);

        /**
         * Writes a 4 byte float to the given file, which must have been opened for
         * writing. Note that this command is not meant for human readable files and
         * should only be used for files that will later be read with ReadFloat. To
         * create human readable files use WriteLine
         *
         * @param iFileID - The ID of the file to modify.
         * @param f       - The float to write.
         * @return void
         */
        @Signature
        public native void WriteFloat(int iFileID, float f);

        /**
         * Writes a 1 byte unsigned integer (0-255) to the given file, which must have
         * been opened for writing. Note that this command is not meant for human
         * readable files and should only be used for files that will later be read with
         * ReadByte. To create human readable files use WriteLine
         *
         * @param iFileID - The ID of the file to modify.
         * @param b       - The byte to write.
         * @return void
         */
        @Signature
        public native void WriteByte(int iFileID, int b);

        /**
         * Converts a world Y coordinate into a screen Y coordinate based on the current
         * view offset and zoom. When the SetViewOffset is 0,0 and the SetViewZoom is
         * 1.0 world and screen coordinates are the same. For example when the view is
         * offset by 20 pixels down, an object at 0,0 in the world will appear at -20
         * (off screen) above the screen.
         *
         * @param y - The world Y coordinate to convert.
         * @return float
         */
        @Signature
        public native float WorldToScreenY(float y);

        /**
         * Converts a world X coordinate into a screen X coordinate based on the current
         * view offset and zoom. When the SetViewOffset is 0,0 and the SetViewZoom is
         * 1.0 world and screen coordinates are the same. For example when the view is
         * offset by 20 pixels to the right, an object at 0,0 in the world will appear
         * at -20 (off screen) to the left.
         *
         * @param x - The world X coordinate to convert.
         * @return float
         */
        @Signature
        public native float WorldToScreenX(float x);

        /**
         * Opens the given file in an the external application suitable for its file
         * type. Typically this is a default app chosen by the user. The file should be
         * in your read or write folder, you should provide the filename as if you were
         * loading the file. Currently this only works on Windows, iOS, and Android.
         *
         * @param szFilename - The path to the file to open
         * @return void
         */
        @Signature
        public native void ViewFile(String szFilename);

        /**
         * Converts a string into an floating point value. For example ValFloat("1.045")
         * would return the value 1.045
         *
         * @param str - The string to convert to an integer.
         * @return float
         */
        @Signature
        public native float ValFloat(String str);

        /**
         * Vibrates the device for the specified number of seconds. Works on iOS and
         * Android. Note that on iOS the length value is ignored and only a short
         * vibration will occur, this is due to Apple restrictions.
         *
         * @param seconds - The time in seconds to vibrate
         * @return void
         */
        @Signature
        public native void VibrateDevice(float seconds);

        /**
         * Converts a string into an integer value. For example Val("10") would return
         * the value 10.
         *
         * @param str - The string to convert to an integer.
         * @return int
         */
        @Signature
        public native int Val(String str);

        /**
         * Converts a string into an integer value. For example Val("10") would return
         * the value 10.
         *
         * @param str  - The string to convert to an integer.
         * @param base - The base that the string number is in.
         * @return int
         */
        @Signature
        public native int Val(String str, int base);

        /**
         * Since version 2.0.20 AGK has a new font system that can display more
         * characters and render characters more smoothly, however to preserve backwards
         * compatibility this is turned off by default. To use the new system set this
         * command to 1. This only affects the default font where you haven't set one
         * yourself.
         *
         * @param mode - 1=use new default fonts, 0=use old default fonts
         * @return void
         */
        @Signature
        public native void UseNewDefaultFonts(int mode);

        /**
         * Updates a specific tween that has been started. The time value allows you to
         * control how quickly the tween advances, and in most cases the result of
         * GetFrameTime should be used. The time can be set negative so that the tween
         * will play in reverse until it reaches its start point, however it will not
         * stop playing when it reaches the beginning and will instead wait for the time
         * to become positive again or wait for you to stop it manually. The tween must
         * have already been started on the given sprite with PlayTweenSprite or nothing
         * will happen. If you have started a lot of tweens playing, then updating each
         * tween individually will be a lot more expensive than using UpdateAllTweens.
         *
         * @param tweenID  - The ID of the tween to update
         * @param spriteID - The ID of the sprite to update
         * @param fTime    - The time to advance the tween
         * @return void
         */
        @Signature
        public native void UpdateTweenSprite(int tweenID, int spriteID, float fTime);

        /**
         * Updates a specific tween that has been started. The time value allows you to
         * control how quickly the tween advances, and in most cases the result of
         * GetFrameTime should be used. The time can be set negative so that the tween
         * will play in reverse until it reaches its start point, however it will not
         * stop playing when it reaches the beginning and will instead wait for the time
         * to become positive again or wait for you to stop it manually. The tween must
         * have already been started on the given text with PlayTweenText or nothing
         * will happen. If you have started a lot of tweens playing, then updating each
         * tween individually will be a lot more expensive than using UpdateAllTweens.
         *
         * @param tweenID - The ID of the tween to update
         * @param textID  - The ID of the text to update
         * @param fTime   - The time to advance the tween
         * @return void
         */
        @Signature
        public native void UpdateTweenText(int tweenID, int textID, float fTime);

        /**
         * Updates a specific tween that has been started. The time value allows you to
         * control how quickly the tween advances, and in most cases the result of
         * GetFrameTime should be used. The time can be set negative so that the tween
         * will play in reverse until it reaches its start point, however it will not
         * stop playing when it reaches the beginning and will instead wait for the time
         * to become positive again or wait for you to stop it manually. The tween must
         * have already been started on the given object with PlayTweenObject or nothing
         * will happen. If you have started a lot of tweens playing, then updating each
         * tween individually will be a lot more expensive than using UpdateAllTweens.
         *
         * @param tweenID  - The ID of the tween to update
         * @param objectID - The ID of the object to update
         * @param fTime    - The time to advance the tween
         * @return void
         */
        @Signature
        public native void UpdateTweenObject(int tweenID, int objectID, float fTime);

        /**
         * Converts the string to upper case characters.
         *
         * @param strin - The string to convert
         * @return String
         */
        @Signature
        public native String Upper(String strin);

        /**
         * Updates a specific tween that has been started. The time value allows you to
         * control how quickly the tween advances, and in most cases the result of
         * GetFrameTime should be used. The time can be set negative so that the tween
         * will play in reverse until it reaches its start point, however it will not
         * stop playing when it reaches the beginning and will instead wait for the time
         * to become positive again or wait for you to stop it manually. The tween must
         * have already been started on the given camera with PlayTweenCamera or nothing
         * will happen. If you have started a lot of tweens playing, then updating each
         * tween individually will be a lot more expensive than using UpdateAllTweens.
         *
         * @param tweenID  - The ID of the tween to update
         * @param cameraID - The ID of the object to update
         * @param fTime    - The time to advance the tween
         * @return void
         */
        @Signature
        public native void UpdateTweenCamera(int tweenID, int cameraID, float fTime);

        /**
         * Updates a specific tween that has been started. The time value allows you to
         * control how quickly the tween advances, and in most cases the result of
         * GetFrameTime should be used. The time can be set negative so that the tween
         * will play in reverse until it reaches its start point, however it will not
         * stop playing when it reaches the beginning and will instead wait for the time
         * to become positive again or wait for you to stop it manually. If you have
         * started a lot of tweens playing, then updating each tween individually will
         * be a lot more expensive than using UpdateAllTweens.
         *
         * @param tweenID - The ID of the tween to update
         * @param fTime   - The time to advance the tween
         * @return void
         */
        @Signature
        public native void UpdateTweenCustom(int tweenID, float fTime);

        /**
         * Updates a specific tween that has been started. The time value allows you to
         * control how quickly the tween advances, and in most cases the result of
         * GetFrameTime should be used. The time can be set negative so that the tween
         * will play in reverse until it reaches its start point, however it will not
         * stop playing when it reaches the beginning and will instead wait for the time
         * to become positive again or wait for you to stop it manually. The tween must
         * have already been started on the given character with PlayTweenChar or
         * nothing will happen. If you have started a lot of tweens playing, then
         * updating each tween individually will be a lot more expensive than using
         * UpdateAllTweens.
         *
         * @param tweenID - The ID of the tween to update
         * @param textID  - The ID of the text to update
         * @param charID  - The index of the character, indices start at 0, if out of
         *                range it will be ignored
         * @param fTime   - The time to advance the tween
         * @return void
         */
        @Signature
        public native void UpdateTweenChar(int tweenID, int textID, int charID, float fTime);

        /**
         * Writes a CR(\n) terminated string to the given file, which must have been
         * opened for writing.
         *
         * @param iFileID - The ID of the file to modify.
         * @param str     - The string to write.
         * @return void
         */
        @Signature
        public native void WriteLine(int iFileID, String str);

        /**
         * Updates all tweens started on individual items and chains. The time value
         * allows you to control how quickly the tweens advance, and in most cases the
         * result of GetFrameTime should be used. The time can be set negative so that
         * any playing tweens will play in reverse until they reach their start points,
         * however they will not stop playing when they reach the beginning and will
         * instead wait for the time to become positive again or wait for you to stop
         * them manually.
         *
         * @param fTime - The time to advance the tweens
         * @return void
         */
        @Signature
        public native void UpdateAllTweens(float fTime);

        /**
         * Sets new position of pick joint.
         *
         * @param jointID      - ID of Joint
         * @param positionVec3 - Id of the position Vector
         * @return void
         */
        @Signature
        public native void Update3DPhysicsPickJoint(int jointID, int positionVec3);

        /**
         * Immediately advances the particle emitter by the given amount of time. If you
         * want to advance a high frequency emitter by a large time period such as 1
         * second you should call this command multiple times with a small time value
         * such as 0.02 so that it creates new particles in batches and spreads them out
         * evenly. Calling it once with a large time value of 1 second would create a
         * huge batch of particles all at once and move them together as a blob instead
         * of spreading them out.
         *
         * @param ID   - The ID of the emitter to check.
         * @param time - The time in seconds to advance the emitter.
         * @return void
         */
        @Signature
        public native void Update3DParticles(int ID, float time);

        /**
         * Called automatically. This is an advanced command to take control of the
         * update process. Normally Update calls this and Update2D() to update
         * everything in the world. This command only updates the 3D objects such as 3D
         * models.
         *
         * @param time - the time in seconds to move everything along. Can be fractions
         *             of seconds.
         * @return void
         */
        @Signature
        public native void Update3D(float time);

        /**
         * Updates all 2D and 3D objects based on the given time, animation, physics,
         * etc. If time is 0 it uses the last frame time to step the simulation. If you
         * have already called StepPhysics this frame it will not be called again for
         * this frame. Called automatically by Sync, you may either use Sync or
         * Update(), Render(), Swap() to manually sync. If you wish to have more control
         * you can break this down further by replacing Update with Update2D, Update3D()
         *
         * @param time - the time in seconds to move everything along. Can be fractions
         *             of seconds.
         * @return void
         */
        @Signature
        public native void Update(float time);

        /**
         * Updates the given tween chain. The time value allows you to control how
         * quickly the chain advances, and in most cases the result of GetFrameTime
         * should be used. The time can be set negative so that the chain and the tweens
         * it contains will play in reverse until it reaches the start point, however it
         * will not stop playing when it reaches the beginning and will instead wait for
         * the time to become positive again or wait for you to stop it manually.
         *
         * @param chainID - The ID of the chain to update
         * @param fTime   - The time to advance the chain
         * @return void
         */
        @Signature
        public native void UpdateTweenChain(int chainID, float fTime);

        /**
         * If for any reason the device dimensions may have changed (e.g. a change in
         * orientation rotates the viewspace to a new size) call this function to update
         * the internal values.
         *
         * @param w - The new width
         * @param h - The new height
         * @return void
         */
        @Signature
        public native void UpdateDeviceSize(int w, int h);

        /**
         * Immediately advances the particle emitter by the given amount of time. If you
         * want to advance a high frequency emitter by a large time period such as 1
         * second you should call this command multiple times with a small time value
         * such as 0.02 so that it creates new particles in batches and spreads them out
         * evenly. Calling it once with a large time value of 1 second would create a
         * huge batch of particles all at once and move them together as a blob instead
         * of spreading them out.
         *
         * @param ID   - The ID of the emitter to check.
         * @param time - The time in seconds to advance the emitter.
         * @return void
         */
        @Signature
        public native void UpdateParticles(int ID, float time);

        /**
         * Uses a smooth curve to move from start to end, this avoids a sudden start and
         * stop. This is just a helper function to avoid having to remember the integer
         * value for this which is 1.
         *
         * @return int
         */
        @Signature
        public native int TweenSmooth1();

        /**
         * Called automatically. This is an advanced command to take control of the
         * update process. Normally Update calls this and Update3D() to update
         * everything in the world. This command only updates the 2D objects such as
         * sprites and text.
         *
         * @param time - the time in seconds to move everything along. Can be fractions
         *             of seconds.
         * @return void
         */
        @Signature
        public native void Update2D(float time);

        /**
         * Uses linear interpolation to move from start to end, this is the simplest
         * form of interpolation. This is just a helper function to avoid having to
         * remember the integer value for this which is 0.
         *
         * @return int
         */
        @Signature
        public native int TweenLinear();

        /**
         * Uses a smooth curve to move towards the end, similar to TweenEaseOut1 but
         * more exaggerated. This is just a helper function to avoid having to remember
         * the integer value for this which is 6.
         *
         * @return int
         */
        @Signature
        public native int TweenEaseOut2();

        /**
         * Uses a smooth curve to move from start to end, similar to TweenSmooth1 but
         * more exaggerated. This is just a helper function to avoid having to remember
         * the integer value for this which is 2.
         *
         * @return int
         */
        @Signature
        public native int TweenSmooth2();

        /**
         * Uses a smooth curve to move from the start, this avoids a sudden start but
         * still ends abruptly. This is just a helper function to avoid having to
         * remember the integer value for this which is 3.
         *
         * @return int
         */
        @Signature
        public native int TweenEaseIn1();

        /**
         * Uses a bounce affect at the end of the interpolation. This is just a helper
         * function to avoid having to remember the integer value for this which is 7.
         *
         * @return int
         */
        @Signature
        public native int TweenBounce();

        /**
         * Returns a string with all characters removed after a given character. The
         * original string is unmodified and a new string is returned with the
         * characters removed. This searches backwards from the end of the string to the
         * beginning and at the first occurrence of the character removes it and
         * everything after it. Note that if you are calling this command from tier 2
         * then the returned string must be deleted when you are done with it.
         *
         * @param str       - The string to modify
         * @param character - The character to look for, must be a single character
         * @return String
         */
        @Signature
        public native String TruncateString(String str, String character);

        /**
         * Returns the integer part of a float value with no rounding either way.
         *
         * @param a - The value to truncate.
         * @return int
         */
        @Signature
        public native int Trunc(float a);

        /**
         * Uses an elastic affect at the end of the interpolation. This is the only
         * interpolation method that exceeds the given range and is not suitable for
         * colors. This is just a helper function to avoid having to remember the
         * integer value for this which is 8.
         *
         * @return int
         */
        @Signature
        public native int TweenOvershoot();

        /**
         * Initialises the Text To Speech engine on the device so that it can produce
         * audio. Note that this may not be immediate, you should check
         * GetTextToSpeechReady to see if it has finished setting up. Calling other text
         * to speech commands when it is not ready will be ignored. Currently only works
         * on iOS and Android.
         *
         * @return void
         */
        @Signature
        public native void TextToSpeechSetup();

        /**
         * Uses a smooth curve to move towards the end, this avoids a sudden stop but
         * still starts abruptly. This is just a helper function to avoid having to
         * remember the integer value for this which is 5.
         *
         * @return int
         */
        @Signature
        public native int TweenEaseOut1();

        /**
         * Uses a smooth curve to move from the start, similar to TweenEaseIn1 but more
         * exaggerated. This is just a helper function to avoid having to remember the
         * integer value for this which is 4.
         *
         * @return int
         */
        @Signature
        public native int TweenEaseIn2();

        /**
         * Returns the tangent of a value in radians.
         *
         * @param a - The value to pass into the tangent function.
         * @return float
         */
        @Signature
        public native float TanRad(float a);

        /**
         * Returns the tangent of a value in degrees.
         *
         * @param a - The value to pass into the tangent function.
         * @return float
         */
        @Signature
        public native float Tan(float a);

        /**
         * Displays the back buffer to the screen and clears the backbuffer for the next
         * frame, updates global time variables. Called automatically by Sync, you may
         * either use Sync or Update, Render, Swap one after the other to manually sync.
         *
         * @return void
         */
        @Signature
        public native void Swap();

        /**
         * Returns a string with all characters in "chars" removed from the ends of the
         * string. The original string is unmodified and a new string is returned with
         * the characters removed. This can be used to remove extra whitespace from the
         * ends of an input string. Note that if you are calling this command from tier
         * 2 then the returned string must be deleted when you are done with it.
         *
         * @param str   - The string to modify
         * @param chars - The characters to remove
         * @return String
         */
        @Signature
        public native String TrimString(String str, String chars);

        /**
         * Get the number of seconds and fractions of seconds since the app was started.
         * Accurate to milliseconds, but due to floating point inaccuracies the longer
         * the app is running the less accurate this becomes. More specifically the time
         * value has about 7 significant figures of accuracy, so as the number of
         * seconds gets higher the number of decimal places decreases. If you only need
         * the time to the nearest second then this value will be fine up to about
         * 16,000,000 seconds. Calling this command will internally make a system call
         * to get the amount of time passed, so it will change every time you call it.
         *
         * @return float
         */
        @Signature
        public native float Timer();

        /**
         * Converts a UTF-8 string to a Base64 string. If you are calling this command
         * from tier 2 this string must be deleted when you are done with it.
         *
         * @param input - The string to convert
         * @return String
         */
        @Signature
        public native String StringToBase64(String input);

        /**
         * Immediately terminates the specified app. This should only be used in extreme
         * cases as the app is not given a chance to clean up or finish what it is
         * doing.
         *
         * @param appID - The app ID to terminate, returned from RunApp()
         * @return void
         */
        @Signature
        public native void TerminateApp(int appID);

        /**
         * Converts a value into a string, if you are calling this command from tier 2
         * this string must be deleted when you are done with it.
         *
         * @param valueFloat - Value to convert into a string.
         * @return String
         */
        // НЕ РАБОТАЕТ @Signature
        public native String Str(float valueFloat);

        /**
         * Converts a value into a string, if you are calling this command from tier 2
         * this string must be deleted when you are done with it.
         *
         * @param valueFloat - Value to convert into a string.
         * @param decimals   - The number of places after the decimal point to include.
         * @return String
         */
        @Signature
        public native String Str(float valueFloat, int decimals);

        /**
         * Converts a value into a string, if you are calling this command from tier 2
         * this string must be deleted when you are done with it.
         *
         * @param valueInt - Value to convert into a string.
         * @return String
         */
        @Signature
        public native String Str(int valueInt);

        /**
         * Stops the video and removes it from view, using PlayVideo will start it from
         * the beginning.
         *
         * @return void
         */
        @Signature
        public native void StopVideo();

        /**
         * Stops a given tween ID if it is playing on a given sprite. If the tween is
         * not playing or has finished then this command has no effect. If the sprite
         * was in the middle of an interpolation it will remain at its current position,
         * it will not skip to the end or return to the beginning.
         *
         * @param tweenID  - ID of the tween to stop
         * @param spriteID - ID of the sprite to stop
         * @return void
         */
        @Signature
        public native void StopTweenSprite(int tweenID, int spriteID);

        /**
         * Stops a given tween ID if it is playing on a given text object. If the tween
         * is not playing or has finished then this command has no effect. If the text
         * was in the middle of an interpolation it will remain at its current position,
         * it will not skip to the end or return to the beginning.
         *
         * @param tweenID - ID of the tween to stop
         * @param textID  - ID of the text object to stop
         * @return void
         */
        @Signature
        public native void StopTweenText(int tweenID, int textID);

        /**
         * Stops a given tween ID if it is playing on a given object. If the tween is
         * not playing or has finished then this command has no effect. If the object
         * was in the middle of an interpolation it will remain at its current position,
         * it will not skip to the end or return to the beginning.
         *
         * @param tweenID  - ID of the tween to stop
         * @param objectID - ID of the object to stop
         * @return void
         */
        @Signature
        public native void StopTweenObject(int tweenID, int objectID);

        /**
         * Updates the scene with the latest information, draws all sprites, updates
         * global objects, and swaps the backbuffer into view. Does not draw sprites you
         * have created using pointers in tier 2, you must draw these manually by
         * calling the sprite's Draw function or assigning them to a sprite manager for
         * batch drawing.
         *
         * @return void
         */
        @Signature
        public native void Sync();

        /**
         * Stops a given tween ID if it is playing on a given character of a text
         * object. If the tween is not playing or has finished then this command has no
         * effect. If the character was in the middle of an interpolation it will remain
         * at its current position, it will not skip to the end or return to the
         * beginning.
         *
         * @param tweenID - ID of the tween to stop
         * @param textID  - ID of the text object containing the character
         * @param charID  - The index of the character to stop, indices start at 0, if
         *                out of range it will be ignored
         * @return void
         */
        @Signature
        public native void StopTweenChar(int tweenID, int textID, int charID);

        /**
         * Returns a string with all characters in "chars" removed from it. The original
         * string is unmodified and a new string is returned with the characters
         * removed. For example StripString("my string", "yn") would return "m strig".
         * Note that if you are calling this command from tier 2 then the returned
         * string must be deleted when you are done with it.
         *
         * @param str   - The string to modify
         * @param chars - The characters to remove
         * @return String
         */
        @Signature
        public native String StripString(String str, String chars);

        /**
         * Stops a given tween ID if it is playing on a given camera. If the tween is
         * not playing or has finished then this command has no effect. If the camera
         * was in the middle of an interpolation it will remain at its current position,
         * it will not skip to the end or return to the beginning.
         *
         * @param tweenID  - ID of the tween to stop
         * @param cameraID - ID of the camera to stop
         * @return void
         */
        @Signature
        public native void StopTweenCamera(int tweenID, int cameraID);

        /**
         * Stops the animation of a sprite, maintaining the values used to set it up.
         *
         * @param iSpriteIndex - The ID of the sprite to stop animating.
         * @return void
         */
        @Signature
        public native void StopSprite(int iSpriteIndex);

        /**
         * Immediately stops any text that is being spoken and removes all items from
         * the queue. Currently only works on iOS and Android.
         *
         * @return void
         */
        @Signature
        public native void StopSpeaking();

        /**
         * Stops a given custom tween ID if it is playing. If the tween is not playing
         * or has finished then this command has no effect. If the tween was in the
         * middle of an interpolation its values will remain at their current values, it
         * will not skip to the end or return to the beginning.
         *
         * @param tweenID - ID of the tween to stop
         * @return void
         */
        @Signature
        public native void StopTweenCustom(int tweenID);

        /**
         * Stops the current instance if it hasn't already. This deletes the instance
         * and its ID cannot be used again. The instance ID is the value returned from
         * PlaySound when you initiated the playing of the sound.
         *
         * @param iID - The ID of the instance to check
         * @return void
         */
        @Signature
        public native void StopSoundInstance(int iID);

        /**
         * Stops the given chain. If an item was in the middle of an interpolation it
         * will stay at its current position, it will not skip to the end or return to
         * the beginning. Playing the chain again will start it from the beginning.
         *
         * @param chainID - ID of the chain to modify
         * @return void
         */
        @Signature
        public native void StopTweenChain(int chainID);

        /**
         * This command stops and hides any text entry prompt previously started with
         * StartTextInput command.
         *
         * 
         * @return void
         */
        @Signature
        public native void StopTextInput();

        /**
         * Stop the skeleton animating
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @return void
         */
        @Signature
        public native void StopSkeleton2DAnimation(int iSkeleton);

        /**
         * Stops any current screen recording. If the recording has already stopped then
         * this has no effect. On iOS this will prompt the user to edit and/or save the
         * video, they can also choose to discard it. On Android the user sees no change
         * and the video is silently saved in the background.
         *
         * @return void
         */
        @Signature
        public native void StopScreenRecording();

        /**
         * Stops any animation that is currently playing on the object and leaves the
         * bones in their current position. If the object is currently tweening then the
         * tween will also be stopped with the bones left mid-tween.
         *
         * @param objID - The ID of the object to modify.
         * @return void
         */
        @Signature
        public native void StopObjectAnimation(int objID);

        /**
         * Not yet functional.
         *
         * @return void
         */
        @Signature
        public native void StopSoundRecording();

        /**
         * Stops the music file and resets its position to the beginning of the file.
         *
         * @param musicID - The ID of the music file to stop
         * @return void
         */
        @Signature
        public native void StopMusicOGG(int musicID);

        /**
         * Stop the sound currently playing at the specified sound number.
         *
         * @param iID - The sound number to stop.
         * @return void
         */
        @Signature
        public native void StopSound(int iID);

        /**
         * Stops GPS location updates, use this to save battery power when you no longer
         * need a location.
         *
         * @return void
         */
        @Signature
        public native void StopGPSTracking();

        /**
         * Stops any playing music, the music can then only be restarted by calling
         * PlayMusic.
         *
         * 
         * @return void
         */
        @Signature
        public native void StopMusic();

        /**
         * Steps the physics simulation by a defined amount of time. This time value is
         * in seconds and may include fractions of seconds. Stepping the physics
         * simulation by a large time value (greater than say 0.1) may result in
         * undefined behaviour and physics objects moving through each other. It is not
         * required that you call this command in your game loop, if you do not call it,
         * Sync or Update will call it for you with the last frame time to allow the
         * physics simulation to catch up in real time. If you do call StepPhysics then
         * it will not be called for you by Sync or Update for that frame, this allows
         * you to do your own physics timing if you prefer. By using a fixed time step
         * every frame your physics will perform exactly the same across all devices and
         * all frame rates, but a reduction in fps will result in the physics appearing
         * to go slower, as it will always step the same amount of time whether the
         * frame was quick or slow to draw. Using a variable step for each frame will
         * keep physics moving at the same speed regardless of frame rate, but it will
         * no longer be deterministic across devices and different frame rates. For
         * example if your game depends on a physics entity falling and bouncing to the
         * same height each time it is run then you should use a fixed time step. If the
         * position of physics objects is not important to you game logic then a
         * variable time step may be best.
         *
         * @param time - The step time in seconds
         * @return void
         */
        @Signature
        public native void StepPhysics(float time);

        /**
         * Call before the Sync() command at the bottom of the loop. This will step the
         * physics world. Keeps physics constant regardless of framerate. Not calling
         * this command will pause the physics world action.
         *
         * @return void
         */
        @Signature
        public native void Step3DPhysicsWorld();

        /**
         * This command pops up a text entry prompt over your app whilst your app
         * continues in the background. Accepted characters are ASCII values in the
         * range 32 to 126 inclusive, unless you have activated the new default fonts
         * with UseNewDefaultFonts, in which case any Unicode characters can be used. If
         * a virtual keyboard is required for text entry on this device then it will be
         * displayed over your app. You cannot assume that any part of your app will be
         * visible whilst text entry is in progress, although your code will continue
         * running. When the user has finished entering text GetTextInputCompleted will
         * return 1 and GetTextInputCancelled will let you know if they completed the
         * text entry or cancelled it. On keyboard based devices cancelling is done with
         * the escape key whilst completing is done with the enter key. If successful
         * you can get the inputted text with GetTextInput.
         *
         * @param initial - The initial string to display to the user that they can
         *                edit.
         * @return void
         */
        @Signature
        public native void StartTextInput(String initial);

        /**
         * This command pops up a text entry prompt over your app whilst your app
         * continues in the background. Accepted characters are ASCII values in the
         * range 32 to 126 inclusive, unless you have activated the new default fonts
         * with UseNewDefaultFonts, in which case any Unicode characters can be used. If
         * a virtual keyboard is required for text entry on this device then it will be
         * displayed over your app. You cannot assume that any part of your app will be
         * visible whilst text entry is in progress, although your code will continue
         * running. When the user has finished entering text GetTextInputCompleted will
         * return 1 and GetTextInputCancelled will let you know if they completed the
         * text entry or cancelled it. On keyboard based devices cancelling is done with
         * the escape key whilst completing is done with the enter key. If successful
         * you can get the inputted text with GetTextInput.
         *
         * 
         * @return void
         */
        @Signature
        public native void StartTextInput();

        /**
         * Starts recording the screen and saving it to a file. Currently only supported
         * on iOS 9.0 and above and Android 5.0 and above. On iOS the filename is
         * ignored as the device will always save the recording in the camera roll. On
         * Android the microphone parameter can be set to 1 to record audio from the
         * device microphone during the recording. A value of 0 will produce a silent
         * video as Android does not support recording audio directly from the app.
         * However the audio output from the app may be audible through the microphone
         * when using mode 1. Recording through the microphone requires that you enable
         * the "RecordAudio" permission when exporting your APK. On iOS a microphone
         * value of 1 will record both the app audio output and the microphone, a value
         * of 0 will only record the app audio. On Android 6 and below the recording may
         * stop at any time, for example if the app is sent to the background, or if
         * another activity is activated such as an In App Purchase. On Android 7 and
         * above the recording will pause when the app is in the background and resume
         * when the app resumes. On iOS the recording will continue after such
         * interruptions, until StopScreenRecording is called.
         *
         * @param szFilename - The path to save the video, should end in .mp4, can be a
         *                   "raw:" file path
         * @param microphone - 1 to record from the microphone, 0 to record from the
         *                   device
         * @return void
         */
        @Signature
        public native void StartScreenRecording(String szFilename, int microphone);

        /**
         * Starts the process of getting a GPS location if possible on the current
         * device. This may produce a permission request on some platforms the first
         * time you call it. If the user denies permission then GetGPSSensorExists may
         * return 0 from then on. You should only call this command when the user is
         * doing an activity they know will require a location, otherwise they may deny
         * it and never get asked again (they will have to go into their device settings
         * to enable it). This command will consume a lot of battery power, so use
         * StopGPSTracking when you no longer need a location. This command works on
         * iOS, Android, Mac, and Windows 7 and above. It may take some time from
         * calling this command to get an accurate location from GetRawGPSLatitude and
         * GetRawGPSLongitude.
         *
         * @return void
         */
        @Signature
        public native void StartGPSTracking();

        /**
         * Stands the controller
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void Stand3DPhysicsCharacterController(int objID);

        /**
         * Returns the square root of a float value.
         *
         * @param a - The value to square root.
         * @return float
         */
        @Signature
        public native float Sqrt(float a);

        /**
         * Casts a ray through a particular sprite (can be physics or non physics) and
         * stores the result of any intersection. Results of a ray cast can be retrieved
         * using the other ray cast functions such as GetRayCastNormalX. If the ray
         * starts inside a shape that shape will not be counted in the results. This
         * function is special in that it also works on all sprites even those that do
         * not have physics turned on, but the sprite must have been assigned a shape
         * using one of the sprite shape commands. Returns 1 if there was a collision, 0
         * if not.
         *
         * @param sprite - The sprite ID to check for intersection with the ray.
         * @param x      - The X coordinate of the start point in world coordinates.
         * @param y      - The Y coordinate of the start point in world coordinates.
         * @param x2     - The X coordinate of the end point in world coordinates.
         * @param y2     - The Y coordinate of the end point in world coordinates.
         * @return int
         */
        @Signature
        public native int SpriteRayCastSingle(int sprite, float x, float y, float x2, float y2);

        /**
         * Casts a ray through all sprites that have a shape (including physics sprites)
         * and stores the result of any intersection. Results of a ray cast can be
         * retrieved using the other ray cast functions such as GetRayCastNormalX.
         * Physics sprites will only use the main shape assigned to the sprite using
         * SetSpriteShape, to check compound shapes use PhysicsRayCast. If the ray
         * starts inside a shape that shape will not be counted in the results. Sprites
         * must be assigned a shape using one of the sprite shape commands or it will
         * not be included in the collision results. This function is slower than the
         * physics ray casts as it cannot make use of optimized structures that
         * represent where the sprites are in the world relative to the ray. This
         * function filters the sprites that are checked so only sprites of a certain
         * group are checked. By default sprites are created in group 0. This function
         * can only keep track of sprites created using CreateSprite, if you have
         * manually allocated memory for sprites you will need to cycle through your
         * list of sprites with SpriteRayCastSingle or use the physics version. Returns
         * 1 if there was a collision, 0 if not.
         *
         * @param group - The group ID to check for intersection with the ray, can be
         *              negative.
         * @param x     - The X coordinate of the start point in world coordinates.
         * @param y     - The Y coordinate of the start point in world coordinates.
         * @param x2    - The X coordinate of the end point in world coordinates.
         * @param y2    - The Y coordinate of the end point in world coordinates.
         * @return int
         */
        @Signature
        public native int SpriteRayCastGroup(int group, float x, float y, float x2, float y2);

        /**
         * Casts a ray through all sprites that have a shape (including physics sprites)
         * and stores the result of any intersection. Results of a ray cast can be
         * retrieved using the other ray cast functions such as GetRayCastNormalX.
         * Physics sprites will only use the main shape assigned to the sprite using
         * SetSpriteShape, to check compound shapes use PhysicsRayCast. If the ray
         * starts inside a shape that shape will not be counted in the results. Sprites
         * must be assigned a shape using one of the sprite shape commands or it will
         * not be included in the collision results. This function is slower than the
         * physics only ray casts as it cannot make use of optimized structures that
         * represent where the sprites are in the world relative to the ray. This
         * function can only keep track of sprites created using CreateSprite, if you
         * have manually allocated memory for sprites you will need to cycle through
         * your list of sprites with SpriteRayCastSingle or use the physics version.
         * Returns 1 if there was a collision, 0 if not.
         *
         * @param x  - The X coordinate of the start point in world coordinates.
         * @param y  - The Y coordinate of the start point in world coordinates.
         * @param x2 - The X coordinate of the end point in world coordinates.
         * @param y2 - The Y coordinate of the end point in world coordinates.
         * @return int
         */
        @Signature
        public native int SpriteRayCast(float x, float y, float x2, float y2);

        /**
         * Casts a sphere collision shape along the length of the ray. Returns 1 if the
         * specified object has been hit and 0 if it has not.
         *
         * @param objID      - object ID
         * @param rayID      - The ID of the ray which is returned by calling
         *                   Create3DPhysicsRay().
         * @param fromVec3ID - The ID of the vector holding the start point
         * @param toVec3ID   - The ID of the vector holding the end point
         * @param radius     - The radius of the sphere
         * @return int
         */
        @Signature
        public native int SphereCast3DPhysicsObject(int objID, int rayID, int fromVec3ID, int toVec3ID, float radius);

        /**
         * Casts a sphere collision shape along the length of the ray.
         *
         * @param rayID      - The ID of the ray which is returned by calling
         *                   Create3DPhysicsRay().
         * @param fromVec3ID - The ID of the vector holding the start point
         * @param toVec3ID   - The ID of the vector holding the end point
         * @param radius     - The radius of the sphere
         * @return void
         */
        @Signature
        public native void SphereCast3DPhysics(int rayID, int fromVec3ID, int toVec3ID, float radius);

        /**
         * Queues the given text for speaking. If some text is already being spoken then
         * the given text will be spoken after the current speech has finished. This
         * command can be called multiple times in quick succession to queue up a lot of
         * text. You can call IsSpeaking to check when the queue is empty and all text
         * has been spoken, or cancelled. Note that there may be a delay on the first
         * call to this command when an unfamiliar language has been set with
         * SetSpeechLanguage. For example using French on a device setup for English
         * will attempt to download the French language engine before starting to speak
         * the text. If the app is sent to the background then speech will stop and all
         * text will be removed from the queue. You can specify an optional delay in
         * milliseconds to make the device wait before starting to say the text.
         * Currently only works on iOS and Android.
         *
         * @param text - The text to speak
         * @return void
         */
        @Signature
        public native void Speak(String text);

        /**
         * Queues the given text for speaking. If some text is already being spoken then
         * the given text will be spoken after the current speech has finished. This
         * command can be called multiple times in quick succession to queue up a lot of
         * text. You can call IsSpeaking to check when the queue is empty and all text
         * has been spoken, or cancelled. Note that there may be a delay on the first
         * call to this command when an unfamiliar language has been set with
         * SetSpeechLanguage. For example using French on a device setup for English
         * will attempt to download the French language engine before starting to speak
         * the text. If the app is sent to the background then speech will stop and all
         * text will be removed from the queue. You can specify an optional delay in
         * milliseconds to make the device wait before starting to say the text.
         * Currently only works on iOS and Android.
         *
         * @param text  - The text to speak
         * @param delay - The amount of time in milliseconds to wait before starting the
         *              speech output
         * @return void
         */
        @Signature
        public native void Speak(String text, int delay);

        /**
         * Casts a ray through all sprites that have a shape (including physics sprites)
         * and stores the result of any intersection. Results of a ray cast can be
         * retrieved using the other ray cast functions such as GetRayCastNormalX.
         * Physics sprites will only use the main shape assigned to the sprite using
         * SetSpriteShape, to check compound shapes use PhysicsRayCast. If the ray
         * starts inside a shape that shape will not be counted in the results. Sprites
         * must be assigned a shape using one of the sprite shape commands or it will
         * not be included in the collision results. This function is slower than the
         * physics ray casts as it cannot make use of optimized structures that
         * represent where the sprites are in the world relative to the ray. This
         * function filters the sprites that are checked so only sprites of certain
         * categories are checked. The category parameter is a bitwise field that uses
         * the lower 16 bits to represent each of the possible 16 categories used when
         * setting up a sprite. The default value of all 1s means all categories will be
         * included, whereas a value of all 0s means no categories will be included. You
         * can set individual bits to set which ones should be checked. This function
         * can only keep track of sprites created using CreateSprite, if you have
         * manually allocated memory for sprites you will need to cycle through your
         * list of sprites with SpriteRayCastSingle or use the physics version. Returns
         * 1 if there was a collision, 0 if not.
         *
         * @param category - The categories to check for intersection with the ray,
         *                 bitwise field using the lower most 16 bits.
         * @param x        - The X coordinate of the start point in world coordinates.
         * @param y        - The Y coordinate of the start point in world coordinates.
         * @param x2       - The X coordinate of the end point in world coordinates.
         * @param y2       - The Y coordinate of the end point in world coordinates.
         * @return int
         */
        @Signature
        public native int SpriteRayCastCategory(int category, float x, float y, float x2, float y2);

        /**
         * Creates a string of spaces equal to the length passed in.
         *
         * @param length - The length of the string of spaces to create
         * @return String
         */
        @Signature
        public native String Spaces(int length);

        /**
         * Suspend the app for a specified number of milliseconds. It is not recommended
         * that you use this command to suspend an app for more than the time of one
         * frame (roughly 17 milliseconds).
         *
         * @param milliseconds - The number of milliseconds to sleep.
         * @return void
         */
        @Signature
        public native void Sleep(int milliseconds);

        /**
         * Returns the sine of a value in radians.
         *
         * @param a - The value to pass into the sine function.
         * @return float
         */
        @Signature
        public native float SinRad(float a);

        /**
         * Returns the sine of a value in degrees.
         *
         * @param a - The value to pass into the sine function.
         * @return float
         */
        @Signature
        public native float Sin(float a);

        /**
         * Removes any occurrences of ../ or ..\ and shortens the path appropriately by
         * removing folders. Also replaces all back slashes with forward slashes, as
         * forward slashes will work on any platform. This works with both relative and
         * absolute paths, if the path is absolute then all occurrences of ../ will be
         * removed even if there are too many. If the path is relative then any
         * occurrences of ../ that start the path will not be removed. For example the
         * relative path "../../MyFile.txt" cannot be simplified further, whereas
         * "C:/../../MyFile.txt" will be converted to "C:/MyFile.txt". The path may
         * begin with the prefix "raw:" or not, both are accepted. If you are using this
         * function in Tier 2 then you must delete the returned string with
         * agk::DeleteString() when you are done with it.
         *
         * @param szPath - The path to simplify
         * @return String
         */
        @Signature
        public native String SimplifyPath(String szPath);

        /**
         * Creates a fullscreen reward video advert for revenue generation using
         * Chartboost. Before calling this function you must have set your ad account
         * details with SetChartboostDetails. Both iOS and Android use caching to
         * preload ads before displaying them. If an ad has been loaded when you call
         * this command then it will be displayed immediately, otherwise it will attempt
         * to load an ad for next time you call this command. For Chartboost you must
         * start the caching process manually with CacheRewardAdChartboost, you only
         * need to call this once. After a reward video ad has been displayed a new one
         * will be cached automatically. Failure to load an ad may be because the ad
         * provider has run out of ads to show to users in a particular country. You can
         * check if an ad is waiting to be displayed with GetRewardAdLoadedChartboost.
         * Your app will be paused when the advert is displayed, and will resume when
         * the advert is dismissed. Check GetRewardAdRewardedChartboost to see if the
         * user completed watching the reward ad and should be rewarded. It will be set
         * to 0 when you call this command, and then set to 1 when they have finished
         * watching
         *
         * @return void
         */
        @Signature
        public native void ShowRewardAdChartboost();

        /**
         * Creates a fullscreen reward video advert for revenue generation using AdMob.
         * Before calling this function you must have set your ad account details with
         * SetAdMobRewardAdDetails. Both iOS and Android use caching to preload ads
         * before displaying them. If an ad has been loaded when you call this command
         * then it will be displayed immediately, otherwise it will attempt to load an
         * ad for next time you call this command. Failure to load an ad may be because
         * the ad provider has run out of ads to show to users in a particular country.
         * You can check if an ad is waiting to be displayed with
         * GetRewardAdLoadedAdMob. Your app will be paused when the advert is displayed,
         * and will resume when the advert is dismissed. Check GetRewardAdRewardedAdMob
         * to see if the user completed watching the reward ad and should be rewarded.
         * It will be set to 0 when you call this command, and then set to 1 when they
         * have finished watching
         *
         * @return void
         */
        @Signature
        public native void ShowRewardAdAdMob();

        /**
         * Creates a fullscreen (interstitial) advert for revenue generation using
         * Chartboost. Before calling this function you must have set your ad account
         * details with SetChartboostDetails. Both iOS and Android use caching to
         * preload ads before displaying them. If an ad has been loaded when you call
         * this command then it will be displayed immediately, otherwise it will attempt
         * to load an ad for next time you call this command. Failure to load an ad may
         * be because the ad provider has run out of ads to show to users in a
         * particular country. You can check if an ad is waiting to be displayed with
         * GetFullscreenAdvertLoadedChartboost. Your app will be paused when the advert
         * is displayed, and will resume when the advert is dismissed.
         *
         * @return void
         */
        @Signature
        public native void ShowFullscreenAdvertChartboost();

        /**
         * Creates a fullscreen (interstitial) advert for revenue generation using
         * Amazon Ads. Before calling this function you must have set your ad account
         * details with SetAmazonAdDetails. Both iOS and Android use caching to preload
         * ads before displaying them. If an ad has been loaded when you call this
         * command then it will be displayed immediately, otherwise it will attempt to
         * load an ad for next time you call this command. Failure to load an ad may be
         * because the ad provider has run out of ads to show to users in a particular
         * country. You can check if an ad is waiting to be displayed with
         * GetFullscreenAdvertLoadedAmazon. Your app will be paused when the advert is
         * displayed, and will resume when the advert is dismissed.
         *
         * @return void
         */
        @Signature
        public native void ShowFullscreenAdvertAmazon();

        /**
         * This function has been deprecated, use SetDeviceCameraToImage instead.
         * Presents the user with an option to take a photo with the device camera, if
         * available. If the device does not have a camera, or otherwise cannot be used,
         * this will return 0 and your app will continue as normal. This does not
         * immediately capture the image, depending on the platform your app may
         * continue running in the background whilst the user is taking a photo, or it
         * may pause execution whilst the photo is taken. In any case you must assume
         * your app continues running but is no longer visible, use IsCapturingImage to
         * check when the user returns from the image capture process, and
         * GetCapturedImage to discover the result of the process. This does not
         * currently work on Mac.
         *
         * @return int
         */
        @Signature
        public native int ShowImageCaptureScreen();

        /**
         * Creates a fullscreen (interstitial) advert for revenue generation using
         * AdMob. Before calling this function you must have set your ad account details
         * with SetAdMobDetails. Both iOS and Android use caching to preload ads before
         * displaying them. If an ad has been loaded when you call this command then it
         * will be displayed immediately, otherwise it will attempt to load an ad for
         * next time you call this command. Failure to load an ad may be because the ad
         * provider has run out of ads to show to users in a particular country. You can
         * check if an ad is waiting to be displayed with
         * GetFullscreenAdvertLoadedAdMob. Your app will be paused when the advert is
         * displayed, and will resume when the advert is dismissed.
         *
         * @return void
         */
        @Signature
        public native void ShowFullscreenAdvertAdMob();

        /**
         * Presents the user with an option to choose an image stored on their current
         * platform, for example a photo on a phone or an image saved on a PC. This does
         * not immediately capture the image, depending on the platform your app may
         * continue running in the background whilst the user is choosing an image, or
         * it may pause execution whilst the image is chosen. In any case you must
         * assume your app continues running but is no longer visible, use
         * IsChoosingImage to check when the user returns from the image choosing
         * process, and GetChosenImage to discover the result of the process. This
         * function returns 1 if it was successful in displaying the choose screen, 0
         * otherwise.
         *
         * @return int
         */
        @Signature
        public native int ShowChooseImageScreen();

        /**
         * Sends the given text to the operating system which will then ask the user how
         * they want to share the text, e.g. through Facebook, Twitter, etc. This only
         * works on iOS and Android.
         *
         * @param szText - The text to share
         * @return void
         */
        @Signature
        public native void ShareText(String szText);

        /**
         * Sends the given image to the operating system which will then ask the user
         * how they want to share the image, e.g. through Facebook, Twitter, etc. The
         * file should be in your read or write folder, or you can use a "raw:" path to
         * load from anywhere, you should provide the filename as if you were loading
         * the file. This only works on iOS and Android.
         *
         * @param szFilename - The filename of the image to share
         * @return void
         */
        @Signature
        public native void ShareImage(String szFilename);

        /**
         * Hashes a string using the SHA256 algorithm to produce a 32 character
         * hexadecimal string. This is a one way hash function that can be used with
         * salting (appending a secret string) for passwords or tamper detection in
         * parameters passed to a server. If you are calling this function from Tier 2
         * then you must delete the returned string with agk::DeleteString when you are
         * done with it.
         *
         * @param str - The string to hash
         * @return String
         */
        @Signature
        public native String Sha256(String str);

        /**
         * Sends the specified image to the SnapChat app on the current device, along
         * with an optional sticker file, caption, and URL. The user can then modify the
         * image using the SnapChat app and decide whether to share it with friends. If
         * the user does not have the SnapChat app installed then the app store will be
         * opened instead on the SnapChat app page. This command will only work on
         * Android and iOS 10 or above
         *
         * @param imageFile   - The path to the image you want to share
         * @param stickerFile - The path to a sticker image to add to the image, can be
         *                    an empty string
         * @param caption     - The caption to add to the image, can be an empty string
         * @param url         - The URL to add to the image, can be an empty string
         * @return void
         */
        @Signature
        public native void ShareSnapChatImage(String imageFile, String stickerFile, String caption, String url);

        /**
         * Sends the given image and text to the operating system which will then ask
         * the user how they want to share the text, e.g. through Facebook, Twitter,
         * etc. The image file should be in your read or write folder, or you can use a
         * "raw:" path to load from anywhere, you should provide the filename as if you
         * were loading the file. This only works on iOS and Android.
         *
         * @param szFilename - The filename of the image to share
         * @param szText     - The text to share
         * @return void
         */
        @Signature
        public native void ShareImageAndText(String szFilename, String szText);

        /**
         * Sends the given file to the operating system which will then ask the user how
         * they want to share it, e.g. through email, NFC, etc. The file can be in your
         * read or write folder, or you can use a "raw:" path to load from anywhere, you
         * should provide the filename as if you were loading the file. This only works
         * on iOS and Android.
         *
         * @param szFilename - The path to the file to share
         * @return void
         */
        @Signature
        public native void ShareFile(String szFilename);

        /**
         * Hashes a string using the SHA1 algorithm to produce a 40 character
         * hexadecimal string. This is a one way hash function that can be used with
         * salting (appending a secret string) for passwords or tamper detection in
         * parameters passed to a server. If you are calling this function from Tier 2
         * then you must delete the returned string with agk::DeleteString with
         * DeleteString() when you are done with it.
         *
         * @param str - The string to hash
         * @return String
         */
        @Signature
        public native String Sha1(String str);

        /**
         * Hashes a string using the SHA512 algorithm to produce a 64 character
         * hexadecimal string. This is a one way hash function that can be used with
         * salting (appending a secret string) for passwords or tamper detection in
         * parameters passed to a server. If you are calling this function from Tier 2
         * then you must delete the returned string with agk::DeleteString when you are
         * done with it.
         *
         * @param str - The string to hash
         * @return String
         */
        @Signature
        public native String Sha512(String str);

        /**
         * Sets up the device to use cloud data on compatible platforms, currently only
         * Android and iOS support this feature. Cloud data can be used to share
         * settings across multiple devices running the same app. For example saving
         * some app settings or progress on one device using the cloud data commands
         * will make them available (after a short period of time) on all other devices
         * on the same platform. Note that data does not cross platforms, so data saved
         * on iOS is not available on Android, and data saved on Android is not
         * available on iOS. On iOS this uses iCloud Drive to store the data, so the
         * user must be logged in to iCloud and have iCloud Drive turned on, you can
         * detect if these have been done with GetCloudDataAllowed. You must also add
         * iCloud to your provisioning profile, but you do not need to create any
         * containers. You must use this provisioning profile when exporting your app.
         * On iOS you are limited to 1MB of storage. On Android this uses Android Drive
         * AppData so the user must be logged in with a Google account on the device.
         * You must also add a Google API project for your app here https:
         * console.developers.google.com and create an OAuth client ID in the
         * credentials section. Tell it that the request is coming from Android, give it
         * a name of your choice, and tell it your app package name. You will need give
         * it the SHA-1 fignerprint of the keystore file that you will use to sign your
         * APK, this is so it can check that only APKs signed by you can use the
         * generated OAuth client ID. The "keytool" program is part of the Java
         * Development Kit (JDK). Once created you do not need to do anything with the
         * OAuth token, it will be used automatically when you call the Cloud Data
         * commands. On Android any data you store will count against a user's Google
         * Drive storage limit, they cannot access the files stored by your app but they
         * can clear the app data in their Drive settings. Broadcast apps will use the
         * AGK Player data store and will share variables across all your broadcast
         * apps, so be aware of overwriting values if two of your apps share the same
         * variable name. Data you store in the AGK Player data store will only be
         * visible to you and your devices. This command must be called before any other
         * cloud data commands, except GetCloudDataAllowed which can be called at any
         * time. On Android you should ask the user if they want to store data in their
         * Drive before calling setup, as this command may ask the user to login to
         * their Google Account.
         *
         * @param reserved - Reserved, must be an empty string
         * @return void
         */
        @Signature
        public native void SetupCloudData(String reserved);

        /**
         * Sets the window title for those platforms that run in a window (e.g. Windows,
         * Mac).
         *
         * @param szTitle - The text to use for the window title.
         * @return void
         */
        @Signature
        public native void SetWindowTitle(String szTitle);

        /**
         * This sets the window size for platforms that support it, such as Windows and
         * Mac. This will not affect mobile devices. In fullscreen mode the width and
         * height will be ignored and the desktop resolution will be used. By default
         * the window size will be adjusted so it always fits on screen, including
         * making room for the taskbar on Windows. This means that your final window
         * size may be slightly smaller than your chosen size. You can override this by
         * setting the allowOverSized parameter to 1, which will remove all bounds
         * checks and allow you to create windows larger than the current screen. When
         * the fullscreen parameter is set to 1 then the allowOverSized parameter has no
         * effect.
         *
         * @param width          - The desired width of the window in pixels.
         * @param height         - The desired height of the window in pixels.
         * @param fullscreen     - 1 to use a full screen mode, 0 for a normal window.
         * @param allowOverSized - 1 to allow the window size to exceed the visible
         *                       screen, 0 to shrink it to fit where necessary
         * @return void
         */
        @Signature
        public native void SetWindowSize(int width, int height, int fullscreen, int allowOverSized);

        /**
         * This sets the window size for platforms that support it, such as Windows and
         * Mac. This will not affect mobile devices. In fullscreen mode the width and
         * height will be ignored and the desktop resolution will be used. By default
         * the window size will be adjusted so it always fits on screen, including
         * making room for the taskbar on Windows. This means that your final window
         * size may be slightly smaller than your chosen size. You can override this by
         * setting the allowOverSized parameter to 1, which will remove all bounds
         * checks and allow you to create windows larger than the current screen. When
         * the fullscreen parameter is set to 1 then the allowOverSized parameter has no
         * effect.
         *
         * @param width      - The desired width of the window in pixels.
         * @param height     - The desired height of the window in pixels.
         * @param fullscreen - 1 to use a full screen mode, 0 for a normal window.
         * @return void
         */
        @Signature
        public native void SetWindowSize(int width, int height, int fullscreen);

        /**
         * This sets the window position for platforms that support it, such as Windows
         * and Mac. If the window is currently full screen then this will have no
         * affect. This will not affect mobile devices.
         *
         * @param x - The desired X position of the window in pixels.
         * @param y - The desired Y position of the window in pixels.
         * @return void
         */
        @Signature
        public native void SetWindowPosition(int x, int y);

        /**
         * The default approach for the coordinate system in AGK is to use a percentage
         * based system where 0,0 represents the top left corner and 100,100 the bottom
         * right. The alternative approach is to treat the platform with a fixed
         * resolution e.g. 320 x 480. Any platforms that don't match this resolution
         * will be scaled to fit as much as possible with black borders where necessary.
         *
         * @param iWidth  - the number of units to use across the width of the rendering
         *                area
         * @param iHeight - the number of units to use across the height of the
         *                rendering area
         * @return void
         */
        @Signature
        public native void SetVirtualResolution(int iWidth, int iHeight);

        /**
         * This sets the window sets whether the user is allowed to resize the window,
         * by default this is set to 0
         *
         * @param mode - 0 to disable resizing, 1 to allow resizing
         * @return void
         */
        @Signature
        public native void SetWindowAllowResize(int mode);

        /**
         * Sets whether the joystick is visible on screen, this does not affect its
         * ability to accept input, use SetVirtualJoystickActive to affect if a virtual
         * joystick will accept input. An invisible joystick can still be active.
         *
         * @param index   - The ID of the virtual joystick to set.
         * @param visible - 1 to display the joystick, 0 to hide it.
         * @return void
         */
        @Signature
        public native void SetVirtualJoystickVisible(int index, int visible);

        /**
         * Sets the diameter of the virtual joystick in screen coordinates. Resizing a
         * virtual joystick whilst it is in use will alter the current X and Y values
         * being returned.
         *
         * @param index - The ID of the virtual joystick to set.
         * @param size  - The new diameter of the joystick in screen coordinates.
         * @return void
         */
        @Signature
        public native void SetVirtualJoystickSize(int index, float size);

        /**
         * Sets the position of the virtual joystick in screen coordinates. You can use
         * GetVirtualWidth and GetVirtualHeight to find the current bounds of the
         * screen. The joystick will be centered on the given x and y position. Moving a
         * virtual joystick whilst it is in use will alter the current X and Y values
         * being returned.
         *
         * @param index - The ID of the virtual joystick to set.
         * @param x     - The x coordinate of the new position.
         * @param y     - The y coordinate of the new position.
         * @return void
         */
        @Signature
        public native void SetVirtualJoystickPosition(int index, float x, float y);

        /**
         * Sets the image used by the outer (fixed) portion of the joystick. You can use
         * an image ID of 0 to return it to the default image.
         *
         * @param index   - The ID of the virtual joystick to set.
         * @param imageID - The image ID to use for this joystick.
         * @return void
         */
        @Signature
        public native void SetVirtualJoystickImageOuter(int index, int imageID);

        /**
         * Sets the image used by the inner (moveable) portion of the joystick. You can
         * use an image ID of 0 to return it to the default image.
         *
         * @param index   - The ID of the virtual joystick to set.
         * @param imageID - The image ID to use for this joystick.
         * @return void
         */
        @Signature
        public native void SetVirtualJoystickImageInner(int index, int imageID);

        /**
         * Sets whether the joystick will capture mouse and touch events. If set to 0 it
         * will not capture input and will not update its X and Y values, they will
         * return to 0. This will not affect the virtual joystick's visibility, use
         * SetVirtualJoystickVisible to change if it is visible.
         *
         * @param index  - The ID of the virtual joystick to set.
         * @param active - 1 to allow input, 0 to deactivate it.
         * @return void
         */
        @Signature
        public native void SetVirtualJoystickActive(int index, int active);

        /**
         * Sets the transparency of the virtual joystick on screen. The virtual joystick
         * is composed of two parts the inner movable part, and the outer static part.
         * Alpha1 sets the transparency of the outer part in the range 0-255 with 255
         * being fully opaque. Alpha2 sets the transparency of the inner part in the
         * range 0-255.
         *
         * @param index  - The ID of the virtual joystick to set.
         * @param alpha1 - The alpha value of the outer part of the joystick.
         * @param alpha2 - The alpha value of the inner part of the joystick.
         * @return void
         */
        @Signature
        public native void SetVirtualJoystickAlpha(int index, int alpha1, int alpha2);

        /**
         * Sets whether the virtual is visible on screen, this does not affect its
         * ability to accept input, use SetVirtualButtonActive to affect if a virtual
         * button will accept input. An invisible button can still be active.
         *
         * @param index   - The ID of the virtual button to set.
         * @param visible - 1 to show the button, 0 to hide it.
         * @return void
         */
        @Signature
        public native void SetVirtualButtonVisible(int index, int visible);

        /**
         * Sets the text displayed in the center of the button.
         *
         * @param index - The ID of the virtual button to set.
         * @param str   - The text to display.
         * @return void
         */
        @Signature
        public native void SetVirtualButtonText(int index, String str);

        /**
         * Sets the size of the virtual button in screen coordinates.
         *
         * @param index - The ID of the virtual button to set.
         * @param sizeX - The new X size of the button in screen coordinates.
         * @param sizeY - The new Y size of the button in screen coordinates.
         * @return void
         */
        @Signature
        public native void SetVirtualButtonSize(int index, float sizeX, float sizeY);

        /**
         * Sets the size of the virtual button in screen coordinates.
         *
         * @param index - The ID of the virtual button to set.
         * @param size  - The new diameter of the button in screen coordinates.
         * @return void
         */
        @Signature
        public native void SetVirtualButtonSize(int index, float size);

        /**
         * Sets the position of the virtual button in screen coordinates. You can use
         * GetVirtualWidth and GetVirtualHeight to find the current bounds of the
         * screen. The button will be centered on the given x and y position.
         *
         * @param index - The ID of the virtual button to set.
         * @param x     - The x coordinate of the new position in screen coordinates.
         * @param y     - The y coordinate of the new position in screen coordinates.
         * @return void
         */
        @Signature
        public native void SetVirtualButtonPosition(int index, float x, float y);

        /**
         * Sets the image used by the button when it is not being pressed. You can use
         * an image ID of 0 to return it to the default image.
         *
         * @param index   - The ID of the virtual button to set.
         * @param imageID - The image ID to use for this button.
         * @return void
         */
        @Signature
        public native void SetVirtualButtonImageUp(int index, int imageID);

        /**
         * Sets the image used by the button when it is pressed. You can use an image ID
         * of 0 to return it to the default image.
         *
         * @param index   - The ID of the virtual button to set.
         * @param imageID - The image ID to use for this button.
         * @return void
         */
        @Signature
        public native void SetVirtualButtonImageDown(int index, int imageID);

        /**
         * Sets the dead zone for all virtual joysticks so that any X or Y value below
         * the given threshold will return 0 instead. This value must be between 0 and
         * 1, by default it is set to 0.15.
         *
         * @param threshold - The value below which 0 will be returned.
         * @return void
         */
        @Signature
        public native void SetVirtualJoystickDeadZone(float threshold);

        /**
         * Sets the color of the virtual button at the given index. By default buttons
         * are greyscale so that they can accept various colors. Colors should be
         * specified in the range 0-255.
         *
         * @param index - The ID of the virtual button to set.
         * @param red   - The red component of the new color.
         * @param green - The green component of the new color.
         * @param blue  - The blue component of the new color.
         * @return void
         */
        @Signature
        public native void SetVirtualButtonColor(int index, int red, int green, int blue);

        /**
         * Sets whether the virtual will capture mouse and touch events. If set to 0 it
         * will not capture input and will not update its pressed state, it will return
         * to 0 (up). This will not affect the virtual button's visibility, use
         * SetVirtualButtonVisible to change if it is visible.
         *
         * @param index  - The ID of the virtual button to set.
         * @param active - 1 to accept input, 0 to deactivate it.
         * @return void
         */
        @Signature
        public native void SetVirtualButtonActive(int index, int active);

        /**
         * Sets the zoom mode from top left corner or centered. By default the view
         * zooms from its top left corner, maintaining the views offset in world
         * coordinates. For example a view with an offset of 20,20 will maintain its top
         * left corner at 20,20 in world coordinates no matter what zoom value is given.
         * However, centered zoom keeps the center of the view stationary whilst scaling
         * everything else around it, making the offset value more difficult to judge.
         * In this mode the top left corner will only be at 20,20 when the zoom value is
         * 1.0, for other zoom values the top left corner will be scaled away from the
         * offset point. For example, assume a world size of 100,100 units, a zoom level
         * of 1.0, and a view offset of 0,0. The view will be displaying world
         * coordinates 0,0 (its top left corner) to 100,100 (at its bottom right
         * corner), with a zoom value of 2.0 and top left zooming the view will now show
         * world coordinates 0,0 to 50,50 in the same space making everything look
         * bigger. In centered zooming the view would instead show 25,25 to 75,75
         * maintaining the center of the view over the point 50,50 in world coordinates.
         *
         * @param mode - 0=top left, 1=centered
         * @return void
         */
        @Signature
        public native void SetViewZoomMode(int mode);

        /**
         * Zooms the screen viewport relative to the world, for example a view zoom of
         * 2.0 will double the size of anything currently in view. A value of 1.0
         * returns everything to normal size. Using this command will automatically
         * disable the four physics walls surrounding the screen. You can also fix
         * sprites to the screen so that they do not change size by using
         * FixSpriteToScreen. This command can either zoom towards the view's top left
         * corner or towards the view's center, see SetViewZoomMode for details.
         *
         * @param zoom - The zoom level for scrolling sprites
         * @return void
         */
        @Signature
        public native void SetViewZoom(float zoom);

        /**
         * Offset the screen viewport relative to the world, for example a view offset
         * of 0,20 will move the screen down by 20 pixels showing any sprite that was
         * previously positioned just off the bottom of the screen. This can be useful
         * for scrolling games where you want to move the view across a level. Using
         * this command will automatically disable the four physics walls surrounding
         * the screen. You can also fix sprites to the screen so that they move along
         * with it by using FixSpriteToScreen. The view offset values position the top
         * left corner of the view in the world, while SetViewZoom determines how much
         * of the world the view can see.
         *
         * @param x - The x offset for the view
         * @param y - The y offset for the view
         * @return void
         */
        @Signature
        public native void SetViewOffset(float x, float y);

        /**
         * Sets the volume of the video from 0 (muted) to 100 (full volume)
         *
         * @param volume - The volume of the video in the range 0-100.
         * @return void
         */
        @Signature
        public native void SetVideoVolume(float volume);

        /**
         * Sets the width, height, and position of the video whilst it is playing. Can
         * be called before or during playback. The coordinates are in AGK screen
         * coordinates based on your chosen virtual resolution. The aspect ratio is not
         * preserved and will be stretched to fit your chosen dimensions. To find the
         * actual size of the video in pixels use GetVideoWidth and GetVideoHeight. An
         * exception to the stretching is Windows which will always keep the aspect
         * ratio of the original video and add black borders where necessary.
         *
         * @param x      - The x coordinate to position the top left corner of the video
         * @param y      - The y coordinate to position the top left corner of the video
         * @param width  - The width to display the video
         * @param height - The height to display the video
         * @return void
         */
        @Signature
        public native void SetVideoDimensions(float x, float y, float width, float height);

        /**
         * Sets the transparency of the virtual button at the given index. The alpha
         * value should be in the range 0-255 where 255 is fully opaque.
         *
         * @param index - The ID of the virtual button to set.
         * @param alpha - The new alpha value for this button.
         * @return void
         */
        @Signature
        public native void SetVirtualButtonAlpha(int index, int alpha);

        /**
         * Sets whether vertical sync should be turned on or off. This is the preferred
         * method of limiting the frame rate as it will link the frame rate to the
         * monitor refresh rate and avoid tearing or stuttering. Using this command with
         * mode 1 will override any currently set refresh rate from SetSyncRate,
         * otherwise these two commands would fight each other for control of the frame
         * rate, instead AGK will use the VSync refresh rate which is typically 60
         * frames per second, but depends on the monitor. On Linux, Mac, and HTML5 you
         * can use a value greater than 1 to skip refreshes, for example if the monitor
         * refresh rate is 60Hz then a mode value of 1 would limit the app to 60fps, but
         * a mode value of 2 would skip every other refresh which would limit the app to
         * 30fps.
         *
         * @param mode - 1 to turn vsync on, 0 to turn it off.
         * @return void
         */
        @Signature
        public native void SetVSync(int mode);

        /**
         * Sets the X parameter of the given tween ID. A Tween can modify several
         * parameters of a text object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many text objects or chains at the same time with PlayTweenText or
         * AddTweenChainText. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginX        - The starting X value for the text, the text will be
         *                      positioned here when playing starts
         * @param endX          - The end X value for the text, the text will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the text is moving
         *                      from beginX to endX
         * @return void
         */
        @Signature
        public native void SetTweenTextX(int tweenID, float beginX, float endX, int interpolation);

        /**
         * Sets the Spacing parameter of the given tween ID. A Tween can modify several
         * parameters of a text object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many text objects or chains at the same time with PlayTweenText or
         * AddTweenChainText. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginSP       - The starting Spacing value for the text, the text will
         *                      have this spacing when playing starts
         * @param endSP         - The end Spacing value for the text, the text will have
         *                      this spacing when playing ends
         * @param interpolation - The interpolation method whilst the text is moving
         *                      from beginSP to endSP
         * @return void
         */
        @Signature
        public native void SetTweenTextSpacing(int tweenID, float beginSP, float endSP, int interpolation);

        /**
         * Seeks the video to the given position. This is not guaranteed to be 100%
         * accurate, the device may choose to seek to the nearest keyframe, which may be
         * up to 10 seconds before or after your chosen time.
         *
         * @param seconds - The position in the video to seek to
         * @return void
         */
        @Signature
        public native void SetVideoPosition(float seconds);

        /**
         * Sets the Size parameter of the given tween ID. A Tween can modify several
         * parameters of a text object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many text objects or chains at the same time with PlayTweenText or
         * AddTweenChainText. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginS        - The starting Size value for the text, the text will be
         *                      this size when playing starts
         * @param endS          - The end Size value for the text, the text will be this
         *                      size when playing ends
         * @param interpolation - The interpolation method whilst the text is moving
         *                      from beginS to endS
         * @return void
         */
        @Signature
        public native void SetTweenTextSize(int tweenID, float beginS, float endS, int interpolation);

        /**
         * Sets the Red parameter of the given tween ID. A Tween can modify several
         * parameters of a text object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many text objects or chains at the same time with PlayTweenText or
         * AddTweenChainText. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginR        - The starting Red color for the text, the text will be
         *                      this color when playing starts
         * @param endR          - The end Red color for the text, the text will be this
         *                      color when playing ends
         * @param interpolation - The interpolation method whilst the text is moving
         *                      from beginR to endR
         * @return void
         */
        @Signature
        public native void SetTweenTextRed(int tweenID, int beginR, int endR, int interpolation);

        /**
         * Fills the specified vector.
         *
         * @param vectorID - Id of Vector
         * @param x        - The x component of the vector
         * @param y        - The y component of the vector
         * @param z        - The z component of the vector
         * @return void
         */
        @Signature
        public native void SetVector3(int vectorID, float x, float y, float z);

        /**
         * Sets the Line Spacing parameter of the given tween ID. A Tween can modify
         * several parameters of a text object at the same time. Set the begin value and
         * the end value and an interpolation method. A tween is just a template that
         * can be applied to many text objects or chains at the same time with
         * PlayTweenText or AddTweenChainText. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginLSP      - The starting Line Spacing value for the text, the text
         *                      will have this spacing when playing starts
         * @param endLSP        - The end Line Spacing value for the text, the text will
         *                      have this spacing when playing ends
         * @param interpolation - The interpolation method whilst the text is moving
         *                      from beginLSP to endLSP
         * @return void
         */
        @Signature
        public native void SetTweenTextLineSpacing(int tweenID, float beginLSP, float endLSP, int interpolation);

        /**
         * Sets the Green parameter of the given tween ID. A Tween can modify several
         * parameters of a text object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many text objects or chains at the same time with PlayTweenText or
         * AddTweenChainText. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginG        - The starting Green color for the text, the text will
         *                      be this color when playing starts
         * @param endG          - The end Green color for the text, the text will be
         *                      this color when playing ends
         * @param interpolation - The interpolation method whilst the text is moving
         *                      from beginG to endG
         * @return void
         */
        @Signature
        public native void SetTweenTextGreen(int tweenID, int beginG, int endG, int interpolation);

        /**
         * Sets the Blue parameter of the given tween ID. A Tween can modify several
         * parameters of a text object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many text objects or chains at the same time with PlayTweenText or
         * AddTweenChainText. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginB        - The starting Blue color for the text, the text will be
         *                      this color when playing starts
         * @param endB          - The end Blue color for the text, the text will be this
         *                      color when playing ends
         * @param interpolation - The interpolation method whilst the text is moving
         *                      from beginB to endB
         * @return void
         */
        @Signature
        public native void SetTweenTextBlue(int tweenID, int beginB, int endB, int interpolation);

        /**
         * Sets the Angle parameter of the given tween ID. A Tween can modify several
         * parameters of a text object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many text objects or chains at the same time with PlayTweenText or
         * AddTweenChainText. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginA        - The starting Angle value for the text, the text will
         *                      be rotated at this angle when playing starts
         * @param endA          - The end Angle value for the text, the text will be
         *                      rotated at this angle when playing ends
         * @param interpolation - The interpolation method whilst the text is moving
         *                      from beginA to endA
         * @return void
         */
        @Signature
        public native void SetTweenTextAngle(int tweenID, float beginA, float endA, int interpolation);

        /**
         * Sets the Y parameter of the given tween ID. A Tween can modify several
         * parameters of a text object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many text objects or chains at the same time with PlayTweenText or
         * AddTweenChainText. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginY        - The starting Y value for the text, the text will be
         *                      positioned here when playing starts
         * @param endY          - The end Y value for the text, the text will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the text is moving
         *                      from beginY to endY
         * @return void
         */
        @Signature
        public native void SetTweenTextY(int tweenID, float beginY, float endY, int interpolation);

        /**
         * Sets the Y parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. This modifies the position of the sprite using its top
         * left corner. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginY        - The starting Y value for the sprite, the sprite will
         *                      be positioned here when playing starts
         * @param endY          - The end Y value for the sprite, the sprite will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the sprite is moving
         *                      from beginY to endY
         * @return void
         */
        @Signature
        public native void SetTweenSpriteY(int tweenID, float beginY, float endY, int interpolation);

        /**
         * Sets the X parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. This modifies the position of the sprite using its
         * offset point, usually the center of the sprite. Available interpolation
         * methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginX        - The starting X value for the sprite, the sprite will
         *                      be positioned here when playing starts
         * @param endX          - The end X value for the sprite, the sprite will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the sprite is moving
         *                      from beginX to endX
         * @return void
         */
        @Signature
        public native void SetTweenSpriteXByOffset(int tweenID, float beginX, float endX, int interpolation);

        /**
         * Sets the X parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. This modifies the position of the sprite using its top
         * left corner. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginX        - The starting X value for the sprite, the sprite will
         *                      be positioned here when playing starts
         * @param endX          - The end X value for the sprite, the sprite will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the sprite is moving
         *                      from beginX to endX
         * @return void
         */
        @Signature
        public native void SetTweenSpriteX(int tweenID, float beginX, float endX, int interpolation);

        /**
         * Sets the SizeX parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginSX       - The starting SizeX value for the sprite, the sprite
         *                      will be this size when playing starts
         * @param endSX         - The end SizeX value for the sprite, the sprite will be
         *                      this size when playing ends
         * @param interpolation - The interpolation method whilst the sprite is moving
         *                      from beginSX to endSX
         * @return void
         */
        @Signature
        public native void SetTweenSpriteSizeX(int tweenID, float beginSX, float endSX, int interpolation);

        /**
         * Sets the SizeY parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginSY       - The starting SizeY value for the sprite, the sprite
         *                      will be this size when playing starts
         * @param endSY         - The end SizeY value for the sprite, the sprite will be
         *                      this size when playing ends
         * @param interpolation - The interpolation method whilst the sprite is moving
         *                      from beginSX to endSX
         * @return void
         */
        @Signature
        public native void SetTweenSpriteSizeY(int tweenID, float beginSY, float endSY, int interpolation);

        /**
         * Sets the Red parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginR        - The starting Red color for the sprite (0 to 255), the
         *                      sprite will be this color when playing starts
         * @param endR          - The end Red color for the sprite (0 to 255), the
         *                      sprite will be this color when playing ends
         * @param interpolation - The interpolation method whilst the sprite is moving
         *                      from beginR to endR
         * @return void
         */
        @Signature
        public native void SetTweenSpriteRed(int tweenID, int beginR, int endR, int interpolation);

        /**
         * Sets the Green parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginG        - The starting Green color for the sprite (0 to 255),
         *                      the sprite will be this color when playing starts
         * @param endG          - The end Green color for the sprite (0 to 255), the
         *                      sprite will be this color when playing ends
         * @param interpolation - The interpolation method whilst the sprite is moving
         *                      from beginG to endG
         * @return void
         */
        @Signature
        public native void SetTweenSpriteGreen(int tweenID, int beginG, int endG, int interpolation);

        /**
         * Sets the Alpha parameter of the given tween ID. A Tween can modify several
         * parameters of a text object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many text objects or chains at the same time with PlayTweenText or
         * AddTweenChainText. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginA        - The starting Alpha color for the text, the text will
         *                      be this color when playing starts
         * @param endA          - The end Alpha color for the text, the text will be
         *                      this color when playing ends
         * @param interpolation - The interpolation method whilst the text is moving
         *                      from beginA to endA
         * @return void
         */
        @Signature
        public native void SetTweenTextAlpha(int tweenID, int beginA, int endA, int interpolation);

        /**
         * Sets the Y parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. This modifies the position of the sprite using its
         * offset point, usually the center of the sprite. Available interpolation
         * methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginY        - The starting Y value for the sprite, the sprite will
         *                      be positioned here when playing starts
         * @param endY          - The end Y value for the sprite, the sprite will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the sprite is moving
         *                      from beginY to endY
         * @return void
         */
        @Signature
        public native void SetTweenSpriteYByOffset(int tweenID, float beginY, float endY, int interpolation);

        /**
         * Sets the Alpha parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginA        - The starting Alpha color for the sprite (0 to 255),
         *                      the sprite will be this color when playing starts
         * @param endA          - The end Alpha color for the sprite (0 to 255), the
         *                      sprite will be this color when playing ends
         * @param interpolation - The interpolation method whilst the sprite is moving
         *                      from beginA to endA
         * @return void
         */
        @Signature
        public native void SetTweenSpriteAlpha(int tweenID, int beginA, int endA, int interpolation);

        /**
         * Sets the Z parameter of the given tween ID. A Tween can modify several
         * parameters of an object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many objects or chains at the same time with PlayTweenObject or
         * AddTweenChainObject. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginZ        - The starting Z value for the object, the object will
         *                      be positioned here when playing starts
         * @param endZ          - The end Z value for the object, the object will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginZ to endZ
         * @return void
         */
        @Signature
        public native void SetTweenObjectZ(int tweenID, float beginZ, float endZ, int interpolation);

        /**
         * Sets the X parameter of the given tween ID. A Tween can modify several
         * parameters of an object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many objects or chains at the same time with PlayTweenObject or
         * AddTweenChainObject. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginX        - The starting X value for the object, the object will
         *                      be positioned here when playing starts
         * @param endX          - The end X value for the object, the object will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginX to endX
         * @return void
         */
        @Signature
        public native void SetTweenObjectX(int tweenID, float beginX, float endX, int interpolation);

        /**
         * Sets the Blue parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginB        - The starting Blue color for the sprite (0 to 255), the
         *                      sprite will be this color when playing starts
         * @param endB          - The end Blue color for the sprite (0 to 255), the
         *                      sprite will be this color when playing ends
         * @param interpolation - The interpolation method whilst the sprite is moving
         *                      from beginB to endB
         * @return void
         */
        @Signature
        public native void SetTweenSpriteBlue(int tweenID, int beginB, int endB, int interpolation);

        /**
         * Sets the ScaleZ parameter of the given tween ID. The scale is absolute so a
         * value of 1.0 will be normal size, whilst 2.0 would be two times bigger. A
         * Tween can modify several parameters of an object at the same time. Set the
         * begin value and the end value and an interpolation method. A tween is just a
         * template that can be applied to many objects or chains at the same time with
         * PlayTweenObject or AddTweenChainObject. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginSZ       - The starting ScaleY value for the object, the object
         *                      will be rotated to this angle when playing starts
         * @param endSZ         - The end ScaleY value for the object, the object will
         *                      be rotated to this angle when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginSZ to endSZ
         * @return void
         */
        @Signature
        public native void SetTweenObjectScaleZ(int tweenID, float beginSZ, float endSZ, int interpolation);

        /**
         * Sets the Angle parameter of the given tween ID. A Tween can modify several
         * parameters of a sprite at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many sprites or chains at the same time with PlayTweenSprite or
         * AddTweenChainSprite. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginA        - The starting Angle value for the sprite, the sprite
         *                      will be rotated at this angle when playing starts
         * @param endA          - The end Angle value for the sprite, the sprite will be
         *                      rotated at this angle when playing ends
         * @param interpolation - The interpolation method whilst the sprite is rotating
         *                      from beginA to endA
         * @return void
         */
        @Signature
        public native void SetTweenSpriteAngle(int tweenID, float beginA, float endA, int interpolation);

        /**
         * Sets the ScaleX parameter of the given tween ID. The scale is absolute so a
         * value of 1.0 will be normal size, whilst 2.0 would be two times bigger. A
         * Tween can modify several parameters of an object at the same time. Set the
         * begin value and the end value and an interpolation method. A tween is just a
         * template that can be applied to many objects or chains at the same time with
         * PlayTweenObject or AddTweenChainObject. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginSX       - The starting ScaleX value for the object, the object
         *                      will be rotated to this angle when playing starts
         * @param endSX         - The end ScaleX value for the object, the object will
         *                      be rotated to this angle when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginSX to endSX
         * @return void
         */
        @Signature
        public native void SetTweenObjectScaleX(int tweenID, float beginSX, float endSX, int interpolation);

        /**
         * Sets the Red parameter of the given tween ID in the range 0 to 255. A Tween
         * can modify several parameters of an object at the same time. Set the begin
         * value and the end value and an interpolation method. A tween is just a
         * template that can be applied to many objects or chains at the same time with
         * PlayTweenObject or AddTweenChainObject. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginR        - The starting Red color for the object, the object will
         *                      be this color when playing starts
         * @param endR          - The end Red color for the object, the object will be
         *                      this color when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginR to endR
         * @return void
         */
        @Signature
        public native void SetTweenObjectRed(int tweenID, int beginR, int endR, int interpolation);

        /**
         * Sets the Green parameter of the given tween ID in the range 0 to 255. A Tween
         * can modify several parameters of an object at the same time. Set the begin
         * value and the end value and an interpolation method. A tween is just a
         * template that can be applied to many objects or chains at the same time with
         * PlayTweenObject or AddTweenChainObject. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginG        - The starting Green color for the object, the object
         *                      will be this color when playing starts
         * @param endG          - The end Green color for the object, the object will be
         *                      this color when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginG to endG
         * @return void
         */
        @Signature
        public native void SetTweenObjectGreen(int tweenID, int beginG, int endG, int interpolation);

        /**
         * Sets the Y parameter of the given tween ID. A Tween can modify several
         * parameters of an object at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many objects or chains at the same time with PlayTweenObject or
         * AddTweenChainObject. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginY        - The starting Y value for the object, the object will
         *                      be positioned here when playing starts
         * @param endY          - The end Y value for the object, the object will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginY to endY
         * @return void
         */
        @Signature
        public native void SetTweenObjectY(int tweenID, float beginY, float endY, int interpolation);

        /**
         * Sets the Blue parameter of the given tween ID in the range 0 to 255. A Tween
         * can modify several parameters of an object at the same time. Set the begin
         * value and the end value and an interpolation method. A tween is just a
         * template that can be applied to many objects or chains at the same time with
         * PlayTweenObject or AddTweenChainObject. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginB        - The starting Blue color for the object, the object
         *                      will be this color when playing starts
         * @param endB          - The end Blue color for the object, the object will be
         *                      this color when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginB to endB
         * @return void
         */
        @Signature
        public native void SetTweenObjectBlue(int tweenID, int beginB, int endB, int interpolation);

        /**
         * Sets the ScaleY parameter of the given tween ID. The scale is absolute so a
         * value of 1.0 will be normal size, whilst 2.0 would be two times bigger. A
         * Tween can modify several parameters of an object at the same time. Set the
         * begin value and the end value and an interpolation method. A tween is just a
         * template that can be applied to many objects or chains at the same time with
         * PlayTweenObject or AddTweenChainObject. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginSY       - The starting ScaleY value for the object, the object
         *                      will be rotated to this angle when playing starts
         * @param endSY         - The end ScaleY value for the object, the object will
         *                      be rotated to this angle when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginSY to endSY
         * @return void
         */
        @Signature
        public native void SetTweenObjectScaleY(int tweenID, float beginSY, float endSY, int interpolation);

        /**
         * Sets the Euler AngleZ parameter of the given tween ID. A Tween can modify
         * several parameters of an object at the same time. Set the begin value and the
         * end value and an interpolation method. A tween is just a template that can be
         * applied to many objects or chains at the same time with PlayTweenObject or
         * AddTweenChainObject. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginAZ       - The starting AngleZ value for the object, the object
         *                      will be rotated to this angle when playing starts
         * @param endAZ         - The end AngleZ value for the object, the object will
         *                      be rotated to this angle when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginAZ to endAZ
         * @return void
         */
        @Signature
        public native void SetTweenObjectAngleZ(int tweenID, float beginAZ, float endAZ, int interpolation);

        /**
         * Sets the Euler AngleY parameter of the given tween ID. A Tween can modify
         * several parameters of an object at the same time. Set the begin value and the
         * end value and an interpolation method. A tween is just a template that can be
         * applied to many objects or chains at the same time with PlayTweenObject or
         * AddTweenChainObject. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginAY       - The starting AngleY value for the object, the object
         *                      will be rotated to this angle when playing starts
         * @param endAY         - The end AngleY value for the object, the object will
         *                      be rotated to this angle when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginAY to endAY
         * @return void
         */
        @Signature
        public native void SetTweenObjectAngleY(int tweenID, float beginAY, float endAY, int interpolation);

        /**
         * Sets the Euler AngleX parameter of the given tween ID. A Tween can modify
         * several parameters of an object at the same time. Set the begin value and the
         * end value and an interpolation method. A tween is just a template that can be
         * applied to many objects or chains at the same time with PlayTweenObject or
         * AddTweenChainObject. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginAX       - The starting AngleX value for the object, the object
         *                      will be rotated to this angle when playing starts
         * @param endAX         - The end AngleX value for the object, the object will
         *                      be rotated to this angle when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginAX to endAX
         * @return void
         */
        @Signature
        public native void SetTweenObjectAngleX(int tweenID, float beginAX, float endAX, int interpolation);

        /**
         * Sets the second integer value of the given custom tween ID. A Tween can
         * modify several parameters at the same time. Set the begin value and the end
         * value and an interpolation method. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param begin         - The starting point for this value
         * @param end           - The end point for this value
         * @param interpolation - The interpolation method whilst the value is moving
         *                      from begin to end
         * @return void
         */
        @Signature
        public native void SetTweenCustomInteger2(int tweenID, int begin, int end, int interpolation);

        /**
         * Sets the third integer value of the given custom tween ID. A Tween can modify
         * several parameters at the same time. Set the begin value and the end value
         * and an interpolation method. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param begin         - The starting point for this value
         * @param end           - The end point for this value
         * @param interpolation - The interpolation method whilst the value is moving
         *                      from begin to end
         * @return void
         */
        @Signature
        public native void SetTweenCustomInteger3(int tweenID, int begin, int end, int interpolation);

        /**
         * Changes a tween's duration after it has been created. If the tween is
         * currently running or is part of a chain that is currently running, then
         * changing its duration may produce unexpected results.
         *
         * @param tweenID  - ID of the tween to change, can be any type of tween
         * @param duration - The new duration to use in seconds
         * @return void
         */
        @Signature
        public native void SetTweenDuration(int tweenID, float duration);

        /**
         * Sets the Alpha parameter of the given tween ID in the range 0 to 255. A Tween
         * can modify several parameters of an object at the same time. Set the begin
         * value and the end value and an interpolation method. A tween is just a
         * template that can be applied to many objects or chains at the same time with
         * PlayTweenObject or AddTweenChainObject. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginA        - The starting Alpha color for the object, the object
         *                      will be this color when playing starts
         * @param endA          - The end ALpha color for the object, the object will be
         *                      this color when playing ends
         * @param interpolation - The interpolation method whilst the object is moving
         *                      from beginA to endA
         * @return void
         */
        @Signature
        public native void SetTweenObjectAlpha(int tweenID, int beginA, int endA, int interpolation);

        /**
         * Sets the first integer value of the given custom tween ID. A Tween can modify
         * several parameters at the same time. Set the begin value and the end value
         * and an interpolation method. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param begin         - The starting point for this value
         * @param end           - The end point for this value
         * @param interpolation - The interpolation method whilst the value is moving
         *                      from begin to end
         * @return void
         */
        @Signature
        public native void SetTweenCustomInteger1(int tweenID, int begin, int end, int interpolation);

        /**
         * Sets the fourth float value of the given custom tween ID. A Tween can modify
         * several parameters at the same time. Set the begin value and the end value
         * and an interpolation method. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param begin         - The starting point for this value
         * @param end           - The end point for this value
         * @param interpolation - The interpolation method whilst the value is moving
         *                      from begin to end
         * @return void
         */
        @Signature
        public native void SetTweenCustomFloat4(int tweenID, float begin, float end, int interpolation);

        /**
         * Sets the fourth integer value of the given custom tween ID. A Tween can
         * modify several parameters at the same time. Set the begin value and the end
         * value and an interpolation method. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param begin         - The starting point for this value
         * @param end           - The end point for this value
         * @param interpolation - The interpolation method whilst the value is moving
         *                      from begin to end
         * @return void
         */
        @Signature
        public native void SetTweenCustomInteger4(int tweenID, int begin, int end, int interpolation);

        /**
         * Sets the third float value of the given custom tween ID. A Tween can modify
         * several parameters at the same time. Set the begin value and the end value
         * and an interpolation method. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param begin         - The starting point for this value
         * @param end           - The end point for this value
         * @param interpolation - The interpolation method whilst the value is moving
         *                      from begin to end
         * @return void
         */
        @Signature
        public native void SetTweenCustomFloat3(int tweenID, float begin, float end, int interpolation);

        /**
         * Sets the first float value of the given custom tween ID. A Tween can modify
         * several parameters at the same time. Set the begin value and the end value
         * and an interpolation method. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param begin         - The starting point for this value
         * @param end           - The end point for this value
         * @param interpolation - The interpolation method whilst the value is moving
         *                      from begin to end
         * @return void
         */
        @Signature
        public native void SetTweenCustomFloat1(int tweenID, float begin, float end, int interpolation);

        /**
         * Sets the Y parameter of the given tween ID. A Tween can modify several
         * parameters of a character at the same time. Set the begin value and the end
         * value and an interpolation method. Character positions ar relative to the
         * parent text object. A tween is just a template that can be applied to many
         * characters or chains at the same time, including from different text objects,
         * with PlayTweenChar or AddTweenChainChar. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginY        - The starting Y value for the character, the character
         *                      will be positioned here when playing starts
         * @param endY          - The end Y value for the character, the character will
         *                      be positioned here when playing ends
         * @param interpolation - The interpolation method whilst the character is
         *                      moving from beginY to endY
         * @return void
         */
        @Signature
        public native void SetTweenCharY(int tweenID, float beginY, float endY, int interpolation);

        /**
         * Sets the second float value of the given custom tween ID. A Tween can modify
         * several parameters at the same time. Set the begin value and the end value
         * and an interpolation method. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param begin         - The starting point for this value
         * @param end           - The end point for this value
         * @param interpolation - The interpolation method whilst the value is moving
         *                      from begin to end
         * @return void
         */
        @Signature
        public native void SetTweenCustomFloat2(int tweenID, float begin, float end, int interpolation);

        /**
         * Sets the X parameter of the given tween ID. A Tween can modify several
         * parameters of a character at the same time. Set the begin value and the end
         * value and an interpolation method. Character positions ar relative to the
         * parent text object. A tween is just a template that can be applied to many
         * characters or chains at the same time, including from different text objects,
         * with PlayTweenChar or AddTweenChainChar. Available interpolation methods are
         * TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
         * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
         * TweenOvershoot() Use an interpolation method of -1 to turn off interpolation
         * on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginX        - The starting X value for the character, the character
         *                      will be positioned here when playing starts
         * @param endX          - The end X value for the character, the character will
         *                      be positioned here when playing ends
         * @param interpolation - The interpolation method whilst the character is
         *                      moving from beginX to endX
         * @return void
         */
        @Signature
        public native void SetTweenCharX(int tweenID, float beginX, float endX, int interpolation);

        /**
         * Sets the Red parameter of the given tween ID. A Tween can modify several
         * parameters of a character at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many characters or chains at the same time, including from
         * different text objects, with PlayTweenChar or AddTweenChainChar. Available
         * interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(),
         * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(),
         * TweenBounce(), TweenOvershoot() Use an interpolation method of -1 to turn off
         * interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginR        - The starting Red value for the character, the
         *                      character will be this color when playing starts
         * @param endR          - The end Red value for the character, the character
         *                      will be this color when playing ends
         * @param interpolation - The interpolation method whilst the character is
         *                      moving from beginR to endR
         * @return void
         */
        @Signature
        public native void SetTweenCharRed(int tweenID, int beginR, int endR, int interpolation);

        /**
         * Sets the Blue parameter of the given tween ID. A Tween can modify several
         * parameters of a character at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many characters or chains at the same time, including from
         * different text objects, with PlayTweenChar or AddTweenChainChar. Available
         * interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(),
         * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(),
         * TweenBounce(), TweenOvershoot() Use an interpolation method of -1 to turn off
         * interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginB        - The starting Blue value for the character, the
         *                      character will be this color when playing starts
         * @param endB          - The end Blue value for the character, the character
         *                      will be this color when playing ends
         * @param interpolation - The interpolation method whilst the character is
         *                      moving from beginB to endB
         * @return void
         */
        @Signature
        public native void SetTweenCharBlue(int tweenID, int beginB, int endB, int interpolation);

        /**
         * Sets the Green parameter of the given tween ID. A Tween can modify several
         * parameters of a character at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many characters or chains at the same time, including from
         * different text objects, with PlayTweenChar or AddTweenChainChar. Available
         * interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(),
         * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(),
         * TweenBounce(), TweenOvershoot() Use an interpolation method of -1 to turn off
         * interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginG        - The starting Green value for the character, the
         *                      character will be this color when playing starts
         * @param endG          - The end Green value for the character, the character
         *                      will be this color when playing ends
         * @param interpolation - The interpolation method whilst the character is
         *                      moving from beginG to endG
         * @return void
         */
        @Signature
        public native void SetTweenCharGreen(int tweenID, int beginG, int endG, int interpolation);

        /**
         * Sets the Angle parameter of the given tween ID. A Tween can modify several
         * parameters of a character at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many characters or chains at the same time, including from
         * different text objects, with PlayTweenChar or AddTweenChainChar. Available
         * interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(),
         * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(),
         * TweenBounce(), TweenOvershoot() Use an interpolation method of -1 to turn off
         * interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginA        - The starting Angle value for the character, the
         *                      character will be rotated at this angle when playing
         *                      starts
         * @param endA          - The end Angle value for the character, the character
         *                      will be rotated at this angle when playing ends
         * @param interpolation - The interpolation method whilst the character is
         *                      moving from beginA to endA
         * @return void
         */
        @Signature
        public native void SetTweenCharAngle(int tweenID, float beginA, float endA, int interpolation);

        /**
         * Sets the Alpha parameter of the given tween ID. A Tween can modify several
         * parameters of a character at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many characters or chains at the same time, including from
         * different text objects, with PlayTweenChar or AddTweenChainChar. Available
         * interpolation methods are TweenLinear(), TweenSmooth1(), TweenSmooth2(),
         * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(),
         * TweenBounce(), TweenOvershoot() Use an interpolation method of -1 to turn off
         * interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginA        - The starting Alpha value for the character, the
         *                      character will be this color when playing starts
         * @param endA          - The end Alpha value for the character, the character
         *                      will be this color when playing ends
         * @param interpolation - The interpolation method whilst the character is
         *                      moving from beginA to endA
         * @return void
         */
        @Signature
        public native void SetTweenCharAlpha(int tweenID, int beginA, int endA, int interpolation);

        /**
         * Sets the Y parameter of the given tween ID. A Tween can modify several
         * parameters of a camera at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many cameras or chains at the same time with PlayTweenCamera or
         * AddTweenChainCamera. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginY        - The starting Y value for the camera, the camera will
         *                      be positioned here when playing starts
         * @param endY          - The end Y value for the camera, the camera will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the camera is moving
         *                      from beginY to endY
         * @return void
         */
        @Signature
        public native void SetTweenCameraY(int tweenID, float beginY, float endY, int interpolation);

        /**
         * Sets the Z parameter of the given tween ID. A Tween can modify several
         * parameters of a camera at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many cameras or chains at the same time with PlayTweenCamera or
         * AddTweenChainCamera. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginZ        - The starting Z value for the camera, the camera will
         *                      be positioned here when playing starts
         * @param endZ          - The end Z value for the camera, the camera will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the camera is moving
         *                      from beginZ to endZ
         * @return void
         */
        @Signature
        public native void SetTweenCameraZ(int tweenID, float beginZ, float endZ, int interpolation);

        /**
         * Sets the X parameter of the given tween ID. A Tween can modify several
         * parameters of a camera at the same time. Set the begin value and the end
         * value and an interpolation method. A tween is just a template that can be
         * applied to many cameras or chains at the same time with PlayTweenCamera or
         * AddTweenChainCamera. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginX        - The starting X value for the camera, the camera will
         *                      be positioned here when playing starts
         * @param endX          - The end X value for the camera, the camera will be
         *                      positioned here when playing ends
         * @param interpolation - The interpolation method whilst the camera is moving
         *                      from beginX to endX
         * @return void
         */
        @Signature
        public native void SetTweenCameraX(int tweenID, float beginX, float endX, int interpolation);

        /**
         * Sets the Field Of View parameter of the given tween ID. A Tween can modify
         * several parameters of a camera at the same time. Set the begin value and the
         * end value and an interpolation method. A tween is just a template that can be
         * applied to many cameras or chains at the same time with PlayTweenCamera or
         * AddTweenChainCamera. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginF        - The starting FOV value for the camera, the camera will
         *                      have this FOV value when playing starts
         * @param endF          - The end FOV value for the camera, the camera will have
         *                      this FOV value when playing ends
         * @param interpolation - The interpolation method whilst the camera is moving
         *                      from beginF to endF
         * @return void
         */
        @Signature
        public native void SetTweenCameraFOV(int tweenID, float beginF, float endF, int interpolation);

        /**
         * Sets the Euler AngleY parameter of the given tween ID. A Tween can modify
         * several parameters of a camera at the same time. Set the begin value and the
         * end value and an interpolation method. A tween is just a template that can be
         * applied to many cameras or chains at the same time with PlayTweenCamera or
         * AddTweenChainCamera. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginAY       - The starting Euler AngleY value for the camera, the
         *                      camera will be rotated to this angle when playing starts
         * @param endAY         - The end Euler AngleY value for the camera, the camera
         *                      will be rotated to this angle when playing ends
         * @param interpolation - The interpolation method whilst the camera is moving
         *                      from beginAY to endAY
         * @return void
         */
        @Signature
        public native void SetTweenCameraAngleY(int tweenID, float beginAY, float endAY, int interpolation);

        /**
         * Sets the Euler AngleZ parameter of the given tween ID. A Tween can modify
         * several parameters of a camera at the same time. Set the begin value and the
         * end value and an interpolation method. A tween is just a template that can be
         * applied to many cameras or chains at the same time with PlayTweenCamera or
         * AddTweenChainCamera. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginAZ       - The starting Euler AngleZ value for the camera, the
         *                      camera will be rotated to this angle when playing starts
         * @param endAZ         - The end Euler AngleZ value for the camera, the camera
         *                      will be rotated to this angle when playing ends
         * @param interpolation - The interpolation method whilst the camera is moving
         *                      from beginAZ to endAZ
         * @return void
         */
        @Signature
        public native void SetTweenCameraAngleZ(int tweenID, float beginAZ, float endAZ, int interpolation);

        /**
         * This command is deprecated, orientation transitions are now controlled by the
         * device.
         *
         * @param mode - the transition mode to use.
         * @return void
         */
        @Signature
        public native void SetTransitionMode(int mode);

        /**
         * Sets the Euler AngleX parameter of the given tween ID. A Tween can modify
         * several parameters of a camera at the same time. Set the begin value and the
         * end value and an interpolation method. A tween is just a template that can be
         * applied to many cameras or chains at the same time with PlayTweenCamera or
         * AddTweenChainCamera. Available interpolation methods are TweenLinear(),
         * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
         * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Use an
         * interpolation method of -1 to turn off interpolation on this value
         *
         * @param tweenID       - ID of the tween to modify
         * @param beginAX       - The starting Euler AngleX value for the camera, the
         *                      camera will be rotated to this angle when playing starts
         * @param endAX         - The end Euler AngleX value for the camera, the camera
         *                      will be rotated to this angle when playing ends
         * @param interpolation - The interpolation method whilst the camera is moving
         *                      from beginAX to endAX
         * @return void
         */
        @Signature
        public native void SetTweenCameraAngleX(int tweenID, float beginAX, float endAX, int interpolation);

        /**
         * Updates the Y position of a text object in world coordinates, by default the
         * text is positioned using its top left corner. When using right alignment the
         * text is positioned using its top right corner. When using center alignment
         * the text is positioned using a point halfway along its top edge.
         *
         * @param iTextIndex - The ID of the text object to update.
         * @param fY         - The new Y position.
         * @return void
         */
        @Signature
        public native void SetTextY(int iTextIndex, float fY);

        /**
         * Jumps a tween chain to the specified position in its time line. If the tween
         * chain is currently playing then the interpolation will evaluate the given
         * time value and update the necessary objects. If the tween chain is not
         * playing then this command has no effect as calling PlayTweenChain resets the
         * time to 0. If the time happens to fall on a delay between tweens then the
         * interpolation will remain unchanged until the delay is passed.
         *
         * @param chainID - ID of the chain to modify
         * @param time    - The time in seconds to jump to in the tween chain
         * @return void
         */
        @Signature
        public native void SetTweenChainTime(int chainID, float time);

        /**
         * Sets whether the text is drawn during screen refreshes.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param bVisible   - 1 to draw this text, 0 to hide it.
         * @return void
         */
        @Signature
        public native void SetTextVisible(int iTextIndex, int bVisible);

        /**
         * Set the text transparency to a particular setting, with a choice of no
         * transparency, alpha transparency, and additive blending. By default text is
         * created with alpha transparency.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param mode       - The transparency mode for this text, 0=off, 1=alpha
         *                   transparency, 2=additive blending
         * @return void
         */
        @Signature
        public native void SetTextTransparency(int iTextIndex, int mode);

        /**
         * Sets the spacing between letters. A value of 0 puts no gap between the letter
         * bounding boxes, a positive value increases this gap, a negative value
         * overlaps the letters. If each character is built with some space either side
         * of it in the font image then that is the default amount of spacing and this
         * command will increase or decrease the spacing from that.
         *
         * @param iTextIndex - The ID of the text object to update.
         * @param fSpacing   - The new spacing to use.
         * @return void
         */
        @Signature
        public native void SetTextSpacing(int iTextIndex, float fSpacing);

        /**
         * Updates the string of a text object, the new text will be displayed on the
         * next screen refresh.
         *
         * @param iTextIndex - The ID of the text object to update.
         * @param string     - The new string to use.
         * @return void
         */
        @Signature
        public native void SetTextString(int iTextIndex, String string);

        /**
         * Sets the size of the text object, default is 4. This value represents the
         * height of each character in world units. The width of each character is
         * dependant on the font and is calculated to match the given size.
         *
         * @param iTextIndex - The ID of the text object to update.
         * @param fSize      - The new size of the text.
         * @return void
         */
        @Signature
        public native void SetTextSize(int iTextIndex, float fSize);

        /**
         * Updates the X position of a text object in world coordinates, by default the
         * text is positioned using its top left corner. When using right alignment the
         * text is positioned using its top right corner. When using center alignment
         * the text is positioned using a point halfway along its top edge.
         *
         * @param iTextIndex - The ID of the text object to update.
         * @param fX         - The new X position.
         * @return void
         */
        @Signature
        public native void SetTextX(int iTextIndex, float fX);

        /**
         * Updates the position of a text object in world coordinates, by default the
         * text is positioned using its top left corner. When using right alignment the
         * text is positioned using its top right corner. When using center alignment
         * the text is positioned using a point halfway along its top edge.
         *
         * @param iTextIndex - The ID of the text object to update.
         * @param fX         - The new X position.
         * @param fY         - The new Y position.
         * @return void
         */
        @Signature
        public native void SetTextPosition(int iTextIndex, float fX, float fY);

        /**
         * Sets the maximum width the text object will use to draw, any characters that
         * extend beyond this value will wrap onto a new line.
         *
         * @param iTextIndex - The ID of the text object to modify
         * @param width      - The maximum width the text will use
         * @return void
         */
        @Signature
        public native void SetTextMaxWidth(int iTextIndex, float width);

        /**
         * Sets the maximum number of characters that can be entered in the fullscreen
         * edit box. Use 0 for unlimited.
         *
         * @param max - The maximum number of characters.
         * @return void
         */
        @Signature
        public native void SetTextInputMaxChars(int max);

        /**
         * Sets the font to use for this text object. AGK has a built in font that it
         * uses for text objects, this allows you to override it. If you are setting all
         * your text objects to the same font you should use SetTextDefaultFontImage
         * instead as this will save some processing time. The image should contain all
         * white characters surrounded by a transparent alpha channel. Fully transparent
         * pixels should also contain white in their RGB components. The font image may
         * either be fixed width or variable width. For fixed width the font image must
         * be laid out in a grid of 16 characters across and 6 characters down, starting
         * with the ascii character 32 (space) in the top left and proceeding left to
         * right, top to bottom, ending with ascii character 127 (DEL) in the bottom
         * right. The image width must be divisible by 16 and the image height must be
         * divisible by 6. For variable width the image must be an atlas texture
         * accompanied by a subimages.txt file that states the location of each
         * character on the image. The AGK will look for images "32" up to and including
         * "127" in the subimages file and any not found will default to the space
         * character (32). Variable height characters are not supported and all
         * characters must be the same height with any necessary padding included in the
         * font image. As of version 2.0.20 you can use SetTextFont to use TrueType
         * fonts instead of bitmap fonts. You must choose one or the other, setting a
         * bitmap font will remove the Truetype font, and setting a TrueType font will
         * remove the bitmap font.
         *
         * @param iTextIndex - The ID of the text object to modify
         * @param iImageID   - The image containing the new font.
         * @return void
         */
        @Signature
        public native void SetTextFontImage(int iTextIndex, int iImageID);

        /**
         * Clips the text to the specified world coordinates when drawn. Use the values
         * 0,0,0,0 to turn off the text scissor
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param x          - The x coordinate of the top left corner of the box to use
         *                   as a clip boundary.
         * @param y          - The y coordinate of the top left corner of the box to use
         *                   as a clip boundary.
         * @param x2         - The x coordinate of the bottom right corner of the box to
         *                   use as a clip boundary.
         * @param y2         - The y coordinate of the bottom right corner of the box to
         *                   use as a clip boundary.
         * @return void
         */
        @Signature
        public native void SetTextScissor(int iTextIndex, float x, float y, float x2, float y2);

        /**
         * Sets the spacing between text lines. A value of 0 puts no gap between the
         * lines, a positive value increases this gap, a negative value overlaps the
         * lines. If each character is built with some space above and below it in the
         * font image then that is the default amount of spacing and this command will
         * increase or decrease the spacing from that.
         *
         * @param iTextIndex - The ID of the text object to update.
         * @param fSpacing   - The new spacing to use.
         * @return void
         */
        @Signature
        public native void SetTextLineSpacing(int iTextIndex, float fSpacing);

        /**
         * Sets the image filter for all text objects and print functions that are using
         * the default font when the text image is smaller than the screen space it
         * occupies. Nearest filtering chooses the closest pixel to display and can look
         * blocky. Linear filtering blends the 4 closest pixels and can look blurry.
         *
         * @param mode - The filtering mode to use, 0=nearest, 1=linear
         * @return void
         */
        @Signature
        public native void SetTextDefaultMinFilter(int mode);

        /**
         * Sets the TrueType font to use for this text object. The font must have been
         * loaded with LoadFont from a TrueType font file. This is different from the
         * old bitmap fonts in that it supports unicode characters and the characters
         * will usually appear sharper on screen at all sizes. Note that resizing a text
         * object that is using a TrueType font will redraw all the characters from the
         * font file onto an image for drawing, for large text sizes using hundreds of
         * different unicode characters this could be a slow process but in normal use
         * it is usually not noticeable. Recently used sizes are kept for a short period
         * of time so if you are frequently switching between two or three text sizes
         * then no redrawing will need to be done and it will be faster. Use a font ID
         * of 0 to use the built in TrueType font that supports a wide range of unicode
         * characters.
         *
         * @param iTextIndex - The ID of the text object to change.
         * @param iFontID    - The ID of the font to use.
         * @return void
         */
        @Signature
        public native void SetTextFont(int iTextIndex, int iFontID);

        /**
         * Sets the image filter for all text objects and print functions that are using
         * the default font when the text image is larger than the screen space it
         * occupies. Nearest filtering chooses the closest pixel to display and can look
         * blocky. Linear filtering blends the 4 closest pixels and can look blurry.
         *
         * @param mode - The filtering mode to use, 0=nearest, 1=linear
         * @return void
         */
        @Signature
        public native void SetTextDefaultMagFilter(int mode);

        /**
         * Sets the default font to use for text objects. The AGK has a built in font
         * that it uses for text objects, this allows you to override it. If you do
         * choose to override it you must do so before creating any text objects. You
         * can set the font on a per text basis using SetTextFontImage. The image should
         * contain all white characters surrounded by a transparent alpha channel. Fully
         * transparent pixels should also contain white in their RGB components. The
         * font image may either be fixed width or variable width. For fixed width the
         * font image must be laid out in a grid of 16 characters across and 6
         * characters down, starting with the ascii character 32 (space) in the top left
         * and proceeding left to right, top to bottom, ending with ascii character 127
         * (DEL) in the bottom right. The image width must be divisible by 16 and the
         * image height must be divisible by 6. For variable width the image must be an
         * atlas texture accompanied by a subimages.txt file that states the location of
         * each character on the image. The AGK will look for images "32" up to and
         * including "127" in the subimages file and any not found will default to the
         * space character (32).
         *
         * @param iImageID - The image containing the new font.
         * @return void
         */
        @Signature
        public native void SetTextDefaultFontImage(int iImageID);

        /**
         * Sets the extended font to use for this text object. The extended font is for
         * non standard characters above ascii value 127 and can be set separately to
         * the standard characters so you can have multiple images for the extended set
         * and a base image for the normal font characters. AGK has a built in extended
         * font that it uses for text objects with characters 128 to 255, this command
         * allows you to override it. If you are setting all your text objects to the
         * same extended font you should use SetTextDefaultExtendedFontImage instead as
         * this will save some processing time. The image should contain all white
         * characters surrounded by a transparent alpha channel. Fully transparent
         * pixels should also contain white in their RGB components. The font image may
         * either be fixed width or variable width. For fixed width the font image must
         * be laid out in a grid of 16 characters across and 8 characters down, starting
         * with the ascii character 32 (space) in the top left and proceeding left to
         * right, top to bottom, ending with ascii character 127 (DEL) in the bottom
         * right. The image width must be divisible by 16 and the image height must be
         * divisible by 6. For variable width the image must be an atlas texture
         * accompanied by a subimages.txt file that states the location of each
         * character on the image. The AGK will look for images "32" up to and including
         * "127" in the subimages file and any not found will default to the space
         * character (32). Variable height characters are not supported and all
         * characters must be the same height with any necessary padding included in the
         * font image. If this text object is using a TrueType font then this command
         * has no affect, the TrueType font handles both normal and extended (unicode)
         * characters.
         *
         * @param iTextIndex - The ID of the text object to modify
         * @param iImageID   - The image containing the new font.
         * @return void
         */
        @Signature
        public native void SetTextExtendedFontImage(int iTextIndex, int iImageID);

        /**
         * Sets the draw order for the text between 0-10000, 0 being the front of the
         * screen, 10000 being the back. Anything more than 10000 will result in the
         * text being clipped from view. By default text is set to depth 9 and appears
         * above all other sprites in the scene, setting a greater depth will cause the
         * text to be sorted into the transparent draw order list which may decrease
         * performance. Use depth 0 for best performance.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iDepth     - The depth this text should be drawn at.
         * @return void
         */
        @Signature
        public native void SetTextDepth(int iTextIndex, int iDepth);

        /**
         * Sets the default extended font to use for text objects. The extended font is
         * for non standard characters above ascii value 127 and can be set separately
         * to the standard characters so you can have multiple images for the extended
         * set and a base image for the normal font characters. The AGK has a built in
         * extended font for characters 128 to 255 that it uses for text objects, this
         * allows you to override it. If you do choose to override it you must do so
         * before creating any text objects. You can set the font on a per text basis
         * using SetTextExtendedFontImage. The image should contain all white characters
         * surrounded by a transparent alpha channel. Fully transparent pixels should
         * also contain white in their RGB components. The extended font image may
         * either be fixed width or variable width. For fixed width the font image must
         * be laid out in a grid of 16 characters across and 8 characters down, starting
         * with the ascii character 128 in the top left and proceeding left to right,
         * top to bottom, ending with ascii character 255 in the bottom right. The image
         * width must be divisible by 16 and the image height must be divisible by 8.
         * For variable width the image must be an atlas texture accompanied by a
         * subimages.txt file that states the location of each character on the image.
         * The AGK will look for images "128" up to and including "255" in the subimages
         * file and any not found will default to the space character (32).
         *
         * @param iImageID - The image containing the new font.
         * @return void
         */
        @Signature
        public native void SetTextDefaultExtendedFontImage(int iImageID);

        /**
         * Set the red component of the text color. The value should be in the range
         * 0-255.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iRed       - The red component of the color.
         * @return void
         */
        @Signature
        public native void SetTextColorRed(int iTextIndex, int iRed);

        /**
         * Set the green component of the text color. The value should be in the range
         * 0-255.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iGreen     - The green component of the color.
         * @return void
         */
        @Signature
        public native void SetTextColorGreen(int iTextIndex, int iGreen);

        /**
         * Set the Y position of an individual character relative to the text position
         * set earlier. The character will be positioned using its top left corner. If
         * any of the following commands are called the position of all characters will
         * be reset to a straight line: SetTextPosition, SetTextX, SetTextY,
         * SetTextSize, SetTextSpacing, SetTextAlignment. Positioning characters within
         * a text object is more efficient than positioning lots of small text objects
         * each containing a character as all the characters can be drawn in a single
         * draw call.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iCharIndex - The index of the character to modify, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @param y          - The new Y position of the character, relative to the
         *                   current text position.
         * @return void
         */
        @Signature
        public native void SetTextCharY(int iTextIndex, int iCharIndex, float y);

        /**
         * Set the color of the text, the values should be in the range 0-255. This will
         * set all characters in the text to be this color. You can set individual
         * characters using SetTextCharColor.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iRed       - The red component of the color.
         * @param iGreen     - The green component of the color.
         * @param iBlue      - The blue component of the color.
         * @param iAlpha     - The alpha component of the color.
         * @return void
         */
        @Signature
        public native void SetTextColor(int iTextIndex, int iRed, int iGreen, int iBlue, int iAlpha);

        /**
         * Set the X position of an individual character relative to the text position
         * set earlier. The character will be positioned using its top left corner. If
         * any of the following commands are called the position of all characters will
         * be reset to a straight line: SetTextPosition, SetTextX, SetTextY,
         * SetTextSize, SetTextSpacing, SetTextAlignment. Positioning characters within
         * a text object is more efficient than positioning lots of small text objects
         * each containing a character as all the characters can be drawn in a single
         * draw call.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iCharIndex - The index of the character to modify, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @param x          - The new X position of the character, relative to the
         *                   current text position.
         * @return void
         */
        @Signature
        public native void SetTextCharX(int iTextIndex, int iCharIndex, float x);

        /**
         * Set the position of an individual character relative to the text position set
         * earlier. The character will be positioned using its top left corner. If any
         * of the following commands are called the position of all characters will be
         * reset to a straight line: SetTextPosition, SetTextX, SetTextY, SetTextSize,
         * SetTextSpacing, SetTextAlignment. Positioning characters within a text object
         * is more efficient than positioning lots of small text objects each containing
         * a character as all the characters can be drawn in a single draw call.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iCharIndex - The index of the character to modify, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @param x          - The new X position of the character, relative to the
         *                   current text position.
         * @param y          - The new Y position of the character, relative to the
         *                   current text position.
         * @return void
         */
        @Signature
        public native void SetTextCharPosition(int iTextIndex, int iCharIndex, float x, float y);

        /**
         * Sets the green component of the specified character's color. Using the
         * SetTextColor command will override this. Values should be in the range 0-255.
         *
         * @param iTextIndex - The ID of the text object to set.
         * @param iCharIndex - The index of the character to set, indexes start at 0, if
         *                   the index is out of range it will be ignored.
         * @param green      - The new green value to use
         * @return void
         */
        @Signature
        public native void SetTextCharColorGreen(int iTextIndex, int iCharIndex, int green);

        /**
         * Sets the red component of the specified characters color. Using the
         * SetTextColor command will override this. Values should be in the range 0-255.
         *
         * @param iTextIndex - The ID of the text object to set.
         * @param iCharIndex - The index of the character to set, indexes start at 0, if
         *                   the index is out of range it will be ignored.
         * @param red        - The new red value to use
         * @return void
         */
        @Signature
        public native void SetTextCharColorRed(int iTextIndex, int iCharIndex, int red);

        /**
         * Set the blue component of the text color. The value should be in the range
         * 0-255.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iBlue      - The blue component of the color.
         * @return void
         */
        @Signature
        public native void SetTextColorBlue(int iTextIndex, int iBlue);

        /**
         * Sets the color of the specified character. Using the SetTextColor command
         * will override this. Values should be in the range 0-255.
         *
         * @param iTextIndex - The ID of the text object to set.
         * @param iCharIndex - The index of the character to set, indexes start at 0, if
         *                   the index is out of range it will be ignored.
         * @param red        - the red component of the new color.
         * @param green      - the green component of the new color.
         * @param blue       - the blue component of the new color.
         * @param alpha      - the alpha component of the new color.
         * @return void
         */
        @Signature
        public native void SetTextCharColor(int iTextIndex, int iCharIndex, int red, int green, int blue, int alpha);

        /**
         * Sets the blue component of the specified character's color. Using the
         * SetTextColor command will override this. Values should be in the range 0-255.
         *
         * @param iTextIndex - The ID of the text object to set.
         * @param iCharIndex - The index of the character to set, indexes start at 0, if
         *                   the index is out of range it will be ignored.
         * @param blue       - The new blue value to use
         * @return void
         */
        @Signature
        public native void SetTextCharColorBlue(int iTextIndex, int iCharIndex, int blue);

        /**
         * Sets the alpha component of the specified character's color. Using the
         * SetTextColor command will override this. Values should be in the range 0-255.
         *
         * @param iTextIndex - The ID of the text object to set.
         * @param iCharIndex - The index of the character to set, indexes start at 0, if
         *                   the index is out of range it will be ignored.
         * @param alpha      - The new alpha value to use
         * @return void
         */
        @Signature
        public native void SetTextCharColorAlpha(int iTextIndex, int iCharIndex, int alpha);

        /**
         * Set the alpha component of the text color. The value should be in the range
         * 0-255.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iAlpha     - The alpha component of the color.
         * @return void
         */
        @Signature
        public native void SetTextColorAlpha(int iTextIndex, int iAlpha);

        /**
         * Set the angle of an individual character in radians, clockwise. The character
         * will rotate around its center. If any of the following commands are called
         * the rotation of all characters will be reset: SetTextPosition, SetTextX,
         * SetTextY, SetTextSize, SetTextSpacing, SetTextAlignment.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iCharIndex - The index of the character to modify, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @param angle      - The new angle in radians.
         * @return void
         */
        @Signature
        public native void SetTextCharAngleRad(int iTextIndex, int iCharIndex, float angle);

        /**
         * Sets all characters in the text to bold regardless of the current
         * SetTextCharBold state. This setting will remain active until it is changed,
         * setting a new text string will not change it.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param bold       - 1 to use bold, 0 to use normal weight (default)
         * @return void
         */
        @Signature
        public native void SetTextBold(int iTextIndex, int bold);

        /**
         * Set the angle of an individual character in degrees, clockwise. The character
         * will rotate around its center. If any of the following commands are called
         * the rotation of all characters will be reset: SetTextPosition, SetTextX,
         * SetTextY, SetTextSize, SetTextSpacing, SetTextAlignment.
         *
         * @param iTextIndex - The ID of the text to modify.
         * @param iCharIndex - The index of the character to modify, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @param angle      - The new angle in degrees.
         * @return void
         */
        @Signature
        public native void SetTextCharAngle(int iTextIndex, int iCharIndex, float angle);

        /**
         * Updates the angle of the text. If the text is aligned to the left then it
         * will rotate around its top left corner. When using center alignment it will
         * rotate around a point halfway along its top edge. When using right alignment
         * it will rotate around its top eight corner.
         *
         * @param iTextIndex - The ID of the text object to update.
         * @param fAngleRad  - The new angle in radians.
         * @return void
         */
        @Signature
        public native void SetTextAngleRad(int iTextIndex, float fAngleRad);

        /**
         * Updates the angle of the text. If the text is aligned to the left then it
         * will rotate around its top left corner. When using center alignment it will
         * rotate around a point halfway along its top edge. When using right alignment
         * it will rotate around its top eight corner.
         *
         * @param iTextIndex - The ID of the text object to update.
         * @param fAngle     - The new angle in degrees.
         * @return void
         */
        @Signature
        public native void SetTextAngle(int iTextIndex, float fAngle);

        /**
         * Sets how the text should be positioned on screen. Left alignment positions
         * the text using its top left corner, right alignment positions it using its
         * top right corner, and center positions it using a point halfway along its top
         * edge.
         *
         * @param iTextIndex - The ID of the text object to update.
         * @param iMode      - The alignment mode to use. 0=left, 1=center, 2=right
         * @return void
         */
        @Signature
        public native void SetTextAlignment(int iTextIndex, int iMode);

        /**
         * Sets the direction for the global directional light to shine.
         *
         * @param vx - The X component of the new direction.
         * @param vy - The Y component of the new direction.
         * @param vz - The Z component of the new direction.
         * @return void
         */
        @Signature
        public native void SetSunDirection(float vx, float vy, float vz);

        /**
         * Sets the desired rate that frames will be drawn to the screen, in frames per
         * second (fps). Additionally there are two modes to choose from that can limit
         * the CPU, the first (mode=0) sleeps the application between frames to save CPU
         * and battery life where possible. The second (mode=1) uses a continuous loop
         * to check the time before the next frame, which can be more accurate but hogs
         * the CPU. The preferred method of limiting frame rate is SetVSync() which set
         * the refresh rate to the monitor refresh rate, and will prevent any screen
         * tearing or stuttering. Using SetSyncRate will automatically turn VSync off
         * since the two commands would fight each other for control of the frame rate.
         * Use an fps of 0 to remove all limits and draw frames as quickly as possible.
         * This may be up to thousands of frames per second on the most powerful
         * graphics cards. Note that on HTML5 the use of SetSyncRate is highly
         * discouraged as it uses the Javascript SetTimeout function for timing, which
         * can cause inaccurate frame rates and stuttering. On HTML5 the preferred
         * method of frame rate control is SetVSync.
         *
         * @param fps  - The desired frame rate in frames per second, 0 for unlimited.
         * @param mode - 1 to use a possibly more accurate but CPU intensive method, 0
         *             (default) to save CPU and battery.
         * @return void
         */
        @Signature
        public native void SetSyncRate(float fps, int mode);

        /**
         * Sets a new color for the global directional light. Values should be in the
         * range 0-255 but are not limited to it. Values greater than 255 will over
         * saturate things and values less than 0 will take light away.
         *
         * @param red   - The red component of the new color.
         * @param green - The green component of the new color.
         * @param blue  - The blue component of the new color.
         * @return void
         */
        @Signature
        public native void SetSunColor(int red, int green, int blue);

        /**
         * Sets the character to have the bold style. This only applies if the text is
         * using a TrueType font set with SetTextFont. If you use SetTextString then
         * this setting will be reset to 0. You can use SetTextBold to set the entire
         * string to bold.
         *
         * @param iTextIndex - The ID of the text object to set.
         * @param iCharIndex - The index of the character to set, indexes start at 0, if
         *                   the index is out of range it will be ignored.
         * @param bold       - 1 to set the character as bold, 0 to set it as normal
         *                   weight (default)
         * @return void
         */
        @Signature
        public native void SetTextCharBold(int iTextIndex, int iCharIndex, int bold);

        /**
         * Immediately positions the specified sprite to the given X world coordinates.
         * The default world coordinate system has 0,0 as the top left corner, and
         * 100,100 as the bottom right hand corner of the screen (this can be changed
         * using SetVirtualResolution). This command positions the sprite by its top
         * left corner.
         *
         * @param iSpriteIndex - The ID of the sprite to position
         * @param fX           - The X coordinate to position the sprite, can use
         *                     decimal values.
         * @return void
         */
        @Signature
        public native void SetSpriteX(int iSpriteIndex, float fX);

        /**
         * Immediately positions the specified sprite to the given Y world coordinates.
         * The default world coordinate system has 0,0 as the top left corner, and
         * 100,100 as the bottom right hand corner of the screen (this can be changed
         * using SetVirtualResolution). This command positions the sprite by its top
         * left corner.
         *
         * @param iSpriteIndex - The ID of the sprite to position
         * @param fY           - The Y coordinate to position the sprite, can use
         *                     decimal values.
         * @return void
         */
        @Signature
        public native void SetSpriteY(int iSpriteIndex, float fY);

        /**
         * Sets whether this sprite is visible during drawing. It may still update its
         * animation and physics, which are controlled by SetSpriteActive.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param bVisible     - The visibility of this sprite, 1 for visible, 0 for not
         *                     visible.
         * @return void
         */
        @Signature
        public native void SetSpriteVisible(int iSpriteIndex, int bVisible);

        /**
         * Scales the sprites UV coordinates by the given amount. A sprite with UV
         * scaled by 2 will make its texture look twice as big as normal. The UV scale
         * does not affect the UV offset chosen using SetSpriteUVOffset, so that an
         * offset of 0.5 in the U direction will always begin sampling halfway across
         * the texture, the scale defines how far the sprite continues sampling. So with
         * an offset of 0.5, a scale of 2 will make the sprite sample from 0.5 to 1
         * instead of 0.5 to 1.5. By default a sprite is set to use the UV coordinates
         * 0,0 to 1,1 using the full image available to it. However there are several
         * cases where this is changed by the AGK to hide certain limitations. If the
         * texture assigned to the sprite is not a power of 2 width or height the image
         * is increased in size until it is a power of 2 size and the UV coordinates for
         * the sprite reduced so that the sprite only uses the portion of the texture
         * containing the original image. This is because most mobile platforms do not
         * support textures that are not a power of 2 width or height. Therefore
         * offsetting the sprite's UV coordinates in this case will shift the sprite's
         * usage of the texture into the undefined portion which is being used as
         * padding. Additionally if the sprite is using an image that belongs to an
         * atlas texture the sprite's UV coordinates will be set so that it only uses
         * the portion of the texture containing its assigned image. Offsetting the UV
         * coordinates in this case will shift the sprite's usage of the texture into
         * other images that are part of the atlas texture. The same can be said of
         * sprites using an animation contained within a single texture using
         * SetSpriteAnimation. Due to these possibilities it is recommended that UV
         * coordinates only be modified on sprites that are using whole images (not
         * atlas textures) and which are a power of 2 size in both width and height.
         * With these constraints it is possible to use UV values outside 0-1 to clamp
         * or repeat the texture successfully.
         *
         * @param iSpriteIndex - The ID of the sprite to modify
         * @param scaleU       - The amount to scale in the U direction.
         * @param scaleV       - The amount to scale in the V direction.
         * @return void
         */
        @Signature
        public native void SetSpriteUVScale(int iSpriteIndex, float scaleU, float scaleV);

        /**
         * Offsets the sprites UV coordinates by the given amount. For example,
         * offsetting by 0.5 in the U direction will make the sprite begin sampling the
         * texture halfway across the top of the texture instead of the top left corner
         * as normal. UV values outside the range of 0,0 (top left) and 1,1 (bottom
         * right) can either wrap around or clamp the texture, which is decided by the
         * image assigned to the sprite using SetImageWrapU and SetImageWrapV. Clamping
         * or wrapping cannot be set on a per-sprite basis. By default a sprite is set
         * to use the UV coordinates 0,0 to 1,1 using the full image available to it.
         * However there are several cases where this is changed by the AGK to hide
         * certain limitations. If the texture assigned to the sprite is not a power of
         * 2 width or height the image is increased in size until it is a power of 2
         * size and the UV coordinates for the sprite reduced so that the sprite only
         * uses the portion of the texture containing the original image. This is
         * because most mobile platforms do not support textures that are not a power of
         * 2 width or height. Therefore offsetting the sprite's UV coordinates in this
         * case will shift the sprite's usage of the texture into the undefined portion
         * which is being used as padding. Additionally if the sprite is using an image
         * that belongs to an atlas texture the sprite's UV coordinates will be set so
         * that it only uses the portion of the texture containing its assigned image.
         * Offsetting the UV coordinates in this case will shift the sprite's usage of
         * the texture into other images that are part of the atlas texture. The same
         * can be said of sprites using an animation contained within a single texture
         * using SetSpriteAnimation. Due to these possibilities it is recommended that
         * UV coordinates only be modified on sprites that are using whole images (not
         * atlas textures) and which are a power of 2 size in both width and height.
         * With these constraints it is possible to use UV values outside 0-1 to clamp
         * or repeat the texture successfully.
         *
         * @param iSpriteIndex - The ID of the sprite to modify
         * @param u            - The amount to offset the UV coordinates in the U
         *                     direction.
         * @param v            - The amount to offset the UV coordinates in the V
         *                     direction.
         * @return void
         */
        @Signature
        public native void SetSpriteUVOffset(int iSpriteIndex, float u, float v);

        /**
         * Adjusts the UV coordinates of the sprite to create a border that moves the
         * edge of the sprite inwards, away from the edge of the image applied to it.
         * This can be useful for sub images loaded from an atlas texture where images
         * might be packed very closely together. Using a border makes sure that the
         * sprite doesn't accidentally sample from a neighbouring image, you could also
         * fix this by adding space between the images on an atlas texture. By default a
         * sprite uses a border of 0.5 pixels when its image is a sub image, and a
         * border of 0 pixels when its has a normal image. If you have compensated for
         * this yourself by adding spacing to the atlas image then setting the border to
         * 0 removes the default offset and creates a pixel perfect reproduction of the
         * sub image. You may also increase this border by setting the border greater
         * than 0.5 pixels.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param border       - 0=no border, 0.5=half pixel offset, 1=one pixel offset,
         *                     etc
         * @return void
         */
        @Signature
        public native void SetSpriteUVBorder(int iSpriteIndex, float border);

        /**
         * This command overrides the normal UV calculations of the sprites and allows
         * you to set them directly for each vertex. Note that animation using sprite
         * sheets or atlas textures will not function when using this command, and the
         * UV offset and zoom functions will have no effect. You have complete control
         * over the UV coordinates. To undo this use ResetSpriteUV to return to
         * calculated UV coordinates.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param u1           - The U coordinate of the top left vertex.
         * @param v1           - The V coordinate of the top left vertex.
         * @param u2           - The U coordinate of the bottom left vertex.
         * @param v2           - The V coordinate of the bottom left vertex.
         * @param u3           - The U coordinate of the top right vertex.
         * @param v3           - The V coordinate of the top right vertex.
         * @param u4           - The U coordinate of the bottom right vertex.
         * @param v4           - The V coordinate of the bottom right vertex.
         * @return void
         */
        @Signature
        public native void SetSpriteUV(int iSpriteIndex, float u1, float v1, float u2, float v2, float u3, float v3,
                        float u4, float v4);

        /**
         * Set the sprite transparency to a particular setting, with a choice of no
         * transparency, alpha transparency, and additive blending. By default sprites
         * are created with alpha transparency, but if you do not need this it is
         * recommended that you turn transparency off to improve performance.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param mode         - The transparency mode for this sprite, 0=off, 1=alpha
         *                     transparency, 2=additive blending
         * @return void
         */
        @Signature
        public native void SetSpriteTransparency(int iSpriteIndex, int mode);

        /**
         * Sets the sprite animation to a specified speed, can be used whilst the
         * animation is running. Can be set to 0 to temporarily pause the animation.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param fFps         - the rate at which the sprite should update, sprite
         *                     frames will be skipped if the sprite frame rate is too
         *                     high compared to the game frame rate.
         * @return void
         */
        @Signature
        public native void SetSpriteSpeed(int iSpriteIndex, float fFps);

        /**
         * Turns on a special render mode that keeps the sprite on whole pixels only so
         * it does not draw itself across pixel boundaries which may cause flickering as
         * the sprite moves across the screen. As a consequence this may make the sprite
         * appear to jump from the one pixel to the next as it moves instead of smoothly
         * moving across the screen. If the sprite has alpha blended pixels along its
         * edge then snapping is not required and can be turned off. By default this is
         * turned off.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param snap         - 1 to turn snapping on, 0 to turn it off
         * @return void
         */
        @Signature
        public native void SetSpriteSnap(int iSpriteIndex, int snap);

        /**
         * Sets the sprite to a new width and height. In the default coordinate system a
         * width and height of 100,100 would fill the entire drawable screen (this can
         * be changed using SetVirtualResolution). If either width or height is set,
         * with the other set to -1, the -1 value will be recalculated to maintain the
         * image's aspect ratio so it doesn't look stretched. If both width AND height
         * are set to -1, then the sprite will take on the width of the assigned image
         * and calculate its height so it isn't stretched. This function recalculates
         * the sprite's collision shape, which can be a costly process for circle and
         * polygon shapes. A more efficient way to change the size of a sprite is to
         * scale it using the SetSpriteScale function. This function resets the scale of
         * the sprite.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve.
         * @param width        - the width to use for the sprite, use minus 1 to have
         *                     this value calculated.
         * @param height       - the height to use for the sprite, use minus 1 to have
         *                     this value calculated.
         * @return void
         */
        @Signature
        public native void SetSpriteSize(int iSpriteIndex, float width, float height);

        /**
         * Overrides the current auto generated shape for use in collision detection,
         * hit testing, and physics. A shape can be set without turning physics on, and
         * by default all sprites are set to use the box shape, which is the fastest to
         * setup. The circle is defined by specifying its center point relative to the
         * sprite's current offset and a radius. For example, if the circle was to be
         * centered on the sprite's offset point it would be specified at position 0,0.
         * Any other value will offset the circle from the sprite. The radius is defined
         * in x coordinates, due to world coordinates not necessarily representing the
         * size of items on screen (e.g. 10 units in X may not be the same apparent size
         * as 10 units in Y). By default, setting a shape removes all other shapes
         * assigned to the sprite and replaces it with this one. You can set shapes
         * individually by specifying a shapeID greater than 0. Shape IDs start at 1 for
         * the first shape, with 0 meaning delete all existing shapes before creating a
         * new one at ID 1. This command only changes existing shapes, you can add
         * additional shapes by using the AddSpriteShape commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The X coordinate of the center of the circle in sprite
         *                     space.
         * @param y            - The Y coordinate of the center of the circle in sprite
         *                     space.
         * @param radius       - The radius of the circle.
         * @return void
         */
        @Signature
        public native void SetSpriteShapeCircle(int iSpriteIndex, float x, float y, float radius);

        /**
         * Overrides the current auto generated shape for use in collision detection,
         * hit testing, and physics. A shape can be set without turning physics on, and
         * by default all sprites are set to use the box shape, which is the fastest to
         * setup. The circle is defined by specifying its center point relative to the
         * sprite's current offset and a radius. For example, if the circle was to be
         * centered on the sprite's offset point it would be specified at position 0,0.
         * Any other value will offset the circle from the sprite. The radius is defined
         * in x coordinates, due to world coordinates not necessarily representing the
         * size of items on screen (e.g. 10 units in X may not be the same apparent size
         * as 10 units in Y). By default, setting a shape removes all other shapes
         * assigned to the sprite and replaces it with this one. You can set shapes
         * individually by specifying a shapeID greater than 0. Shape IDs start at 1 for
         * the first shape, with 0 meaning delete all existing shapes before creating a
         * new one at ID 1. This command only changes existing shapes, you can add
         * additional shapes by using the AddSpriteShape commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The X coordinate of the center of the circle in sprite
         *                     space.
         * @param y            - The Y coordinate of the center of the circle in sprite
         *                     space.
         * @param radius       - The radius of the circle.
         * @param shapeID      - The ID of the shape to change, first shape is ID 1,
         *                     0=delete existing shapes and replace them with this new
         *                     one
         * @return void
         */
        @Signature
        public native void SetSpriteShapeCircle(int iSpriteIndex, float x, float y, float radius, int shapeID);

        /**
         * Overrides the current auto generated shape for use in collision detection,
         * hit testing, and physics. A shape can be set without turning physics on, and
         * by default all sprites are set to use the box shape, which is the fastest to
         * setup. The polygon is defined by a set of points (between 2 and 12) relative
         * to the current sprite's offset. For example, a point of 0,0 would be centered
         * on the sprite's offset point, any other value will be offset from this point.
         * Points are defined one at a time by calling this command multiple times, with
         * index starting at 0. Once the index equals numPoints-1 then the shape will be
         * created using the previously defined points. Once you start defining points
         * you must complete the process by reaching index=numPoints-1 before defining
         * points for any other shape. By default, setting a shape removes all other
         * shapes assigned to the sprite and replaces it with this one. You can set
         * shapes individually by specifying a shapeID greater than 0. Shape IDs start
         * at 1 for the first shape, with 0 meaning delete all existing shapes before
         * creating a new one at ID 1. This command only changes existing shapes, by
         * default all sprites have a base shape at ID 1. You can add additional shapes
         * by using the AddSpriteShape commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param numPoints    - The number of points to use in the polygon, min 2, max
         *                     12.
         * @param index        - The index of the point to set, if this equals
         *                     numPoints-1 then the shape will be created
         * @param x            - X coordinate of the polygon to be added
         * @param y            - Y coordinate of the polygon to be added
         * @return void
         */
        @Signature
        public native void SetSpriteShapePolygon(int iSpriteIndex, int numPoints, int index, float x, float y);

        /**
         * Overrides the current auto generated shape for use in collision detection,
         * hit testing, and physics. A shape can be set without turning physics on, and
         * by default all sprites are set to use the box shape, which is the fastest to
         * setup. The polygon is defined by a set of points (between 2 and 12) relative
         * to the current sprite's offset. For example, a point of 0,0 would be centered
         * on the sprite's offset point, any other value will be offset from this point.
         * Points are defined one at a time by calling this command multiple times, with
         * index starting at 0. Once the index equals numPoints-1 then the shape will be
         * created using the previously defined points. Once you start defining points
         * you must complete the process by reaching index=numPoints-1 before defining
         * points for any other shape. By default, setting a shape removes all other
         * shapes assigned to the sprite and replaces it with this one. You can set
         * shapes individually by specifying a shapeID greater than 0. Shape IDs start
         * at 1 for the first shape, with 0 meaning delete all existing shapes before
         * creating a new one at ID 1. This command only changes existing shapes, by
         * default all sprites have a base shape at ID 1. You can add additional shapes
         * by using the AddSpriteShape commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param numPoints    - The number of points to use in the polygon, min 2, max
         *                     12.
         * @param index        - The index of the point to set, if this equals
         *                     numPoints-1 then the shape will be created
         * @param x            - X coordinate of the polygon to be added
         * @param y            - Y coordinate of the polygon to be added
         * @param shapeID      - The ID of the shape to change, first shape is ID 1,
         *                     0=delete existing shapes and replace them with this new
         *                     one
         * @return void
         */
        @Signature
        public native void SetSpriteShapePolygon(int iSpriteIndex, int numPoints, int index, float x, float y,
                        int shapeID);

        /**
         * Overrides the current auto generated shape for use in physics. Normal sprite
         * collision and hit testing does not work with the chain shape, it is only for
         * physics. A shape can be set without turning physics on, and by default all
         * sprites are set to use the box shape, which is the fastest to setup. The
         * chain is defined by a set of points (at least 2) relative to the current
         * sprite's offset. For example, a point of 0,0 would be centered on the
         * sprite's offset point, any other value will be offset from this point. Chains
         * are rigid and can be used to create hollow concave polygons, or 2D terrains.
         * Set the loop parameter to 1 to join to two ends of the chain together
         * creating a hollow polygon. Points are defined one at a time by calling this
         * command multiple times, with index starting at 0. Once the index equals
         * numPoints-1 then the shape will be created using the previously defined
         * points. Once you start defining points you must complete the process by
         * reaching index=numPoints-1 before defining points for any other shape. Using
         * a shapeID of 0 removes all other shapes assigned to the sprite and replaces
         * it with this one. You can set shapes individually by specifying a shapeID
         * greater than 0. Shape IDs start at 1 for the first shape. This command only
         * changes existing shapes, by default all sprites have a base shape at ID 1.
         * You can add additional shapes by using the AddSpriteShape commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param numPoints    - The number of points to use in the chain, min 2, no
         *                     maximum.
         * @param index        - The index of the point to set, if it equals numPoints-1
         *                     then the shape will be created
         * @param loop         - 1 to join the two ends of the chain together, 0 to
         *                     leave them unconnected
         * @param x            - X coordinate of the polygon to be added
         * @param y            - Y coordinate of the polygon to be added
         * @param shapeID      - The ID of the shape to change, first shape is ID 1,
         *                     0=delete existing shapes and replace them with this new
         *                     one
         * @return void
         */
        @Signature
        public native void SetSpriteShapeChain(int iSpriteIndex, int numPoints, int index, int loop, float x, float y,
                        int shapeID);

        /**
         * Overrides the current auto generated shape for use in collision detection,
         * hit testing, and physics. A shape can be set without turning physics on, and
         * by default all sprites are set to use the box shape, which is the fastest to
         * setup. The box is defined by specifying its top left and bottom right
         * coordinates in sprite space, relative to the offset of the sprite, by default
         * this is the center of the sprite. For example if the current sprite offset
         * was 0,0 the top left box corner would be 0,0, but if the sprite offset was
         * the middle of the sprite (default) the top left corner would be
         * -width/2,-height/2. You may also specify an angle to offset the box relative
         * to the current sprite rotation. By default, setting a shape removes all other
         * shapes assigned to the sprite and replaces it with this one. You can set
         * shapes individually by specifying a shapeID greater than 0. Shape IDs start
         * at 1 for the first shape, with 0 meaning delete all existing shapes before
         * creating a new one at ID 1. This command only changes existing shapes, by
         * default all sprites have a base shape at ID 1. You can add additional shapes
         * by using the AddSpriteShape commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The X coordinate of the top left corner of the new box
         *                     in sprite space.
         * @param y            - The Y coordinate of the top left corner of the new box
         *                     in sprite space.
         * @param x2           - The X coordinate of the bottom right corner of the new
         *                     box in sprite space.
         * @param y2           - The Y coordinate of the bottom right corner of the new
         *                     box in sprite space.
         * @param angle        - The angle of the box in radians.
         * @param shapeID      - The ID of the shape to change, first shape is ID 1,
         *                     0=delete existing shapes and replace them with this new
         *                     one
         * @return void
         */
        @Signature
        public native void SetSpriteShapeBox(int iSpriteIndex, float x, float y, float x2, float y2, float angle,
                        int shapeID);

        /**
         * Overrides the current auto generated shape for use in collision detection,
         * hit testing, and physics. A shape can be set without turning physics on, and
         * by default all sprites are set to use the box shape, which is the fastest to
         * setup. The box is defined by specifying its top left and bottom right
         * coordinates in sprite space, relative to the offset of the sprite, by default
         * this is the center of the sprite. For example if the current sprite offset
         * was 0,0 the top left box corner would be 0,0, but if the sprite offset was
         * the middle of the sprite (default) the top left corner would be
         * -width/2,-height/2. You may also specify an angle to offset the box relative
         * to the current sprite rotation. By default, setting a shape removes all other
         * shapes assigned to the sprite and replaces it with this one. You can set
         * shapes individually by specifying a shapeID greater than 0. Shape IDs start
         * at 1 for the first shape, with 0 meaning delete all existing shapes before
         * creating a new one at ID 1. This command only changes existing shapes, by
         * default all sprites have a base shape at ID 1. You can add additional shapes
         * by using the AddSpriteShape commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The X coordinate of the top left corner of the new box
         *                     in sprite space.
         * @param y            - The Y coordinate of the top left corner of the new box
         *                     in sprite space.
         * @param x2           - The X coordinate of the bottom right corner of the new
         *                     box in sprite space.
         * @param y2           - The Y coordinate of the bottom right corner of the new
         *                     box in sprite space.
         * @param angle        - The angle of the box in radians.
         * @return void
         */
        @Signature
        public native void SetSpriteShapeBox(int iSpriteIndex, float x, float y, float x2, float y2, float angle);

        /**
         * Sets the shader used to draw this sprite, loaded with LoadSpriteShader or
         * LoadShader. By default sprites are assigned an internal shader that can
         * handle 1 texture and a color. If you use a shader ID of 0 the sprite is
         * assigned the internal shader.
         *
         * @param spriteID - The ID of the sprite to modify.
         * @param shaderID - The ID of the shader to use.
         * @return void
         */
        @Signature
        public native void SetSpriteShader(int spriteID, int shaderID);

        /**
         * Sets the current shape for use in collision detection, hit testing, and
         * physics. A shape can be set without turning physics on, and by default all
         * sprites are set to use the box shape, which is the fastest to setup. If you
         * select no shape (0) then any existing shape will be deleted, and hit testing
         * will use the sprite dimensions instead. Commands that require a shape such as
         * GetspriteCollision will generate a box shape for the sprite if none exists.
         * The shape parameter lets you define what type of bounding box the system
         * should use to detect collisions. Circle will create a perfect circle centered
         * on the sprite's rotation point and big enough to enclose the sprite's visible
         * pixels. Box will create a box around the edges of the sprite, without regard
         * to whether pixels are visible or not. Polygon will create a close fitting
         * convex polygon around the visible pixels of a sprite, with a visible pixel
         * being defined as one with an alpha value greater than 128. This function will
         * not work on dummy sprites as there is no image to use when calculating a
         * shape, in these cases shapes must be specified manually using
         * SetSpriteShapeBox, SetSpriteShapeCircle, or SetSpriteShapePolygon. By
         * default, setting a shape removes all other shapes assigned to the sprite and
         * replaces it with this one. You can set shapes individually by specifying a
         * shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0
         * meaning delete all existing shapes before creating a new one at ID 1. This
         * command only changes existing shapes, by default all sprites have a base
         * shape at ID 1. You can add additional shapes by using the AddSpriteShape
         * commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param shape        - The shape to use for this sprite, 0=no shape, 1=circle,
         *                     2=box, 3=polygon
         * @param shapeID      - The ID of the shape to change, first shape is ID 1,
         *                     0=delete existing shapes and replace them with this new
         *                     one
         * @return void
         */
        @Signature
        public native void SetSpriteShape(int iSpriteIndex, int shape, int shapeID);

        /**
         * Sets the current shape for use in collision detection, hit testing, and
         * physics. A shape can be set without turning physics on, and by default all
         * sprites are set to use the box shape, which is the fastest to setup. If you
         * select no shape (0) then any existing shape will be deleted, and hit testing
         * will use the sprite dimensions instead. Commands that require a shape such as
         * GetspriteCollision will generate a box shape for the sprite if none exists.
         * The shape parameter lets you define what type of bounding box the system
         * should use to detect collisions. Circle will create a perfect circle centered
         * on the sprite's rotation point and big enough to enclose the sprite's visible
         * pixels. Box will create a box around the edges of the sprite, without regard
         * to whether pixels are visible or not. Polygon will create a close fitting
         * convex polygon around the visible pixels of a sprite, with a visible pixel
         * being defined as one with an alpha value greater than 128. This function will
         * not work on dummy sprites as there is no image to use when calculating a
         * shape, in these cases shapes must be specified manually using
         * SetSpriteShapeBox, SetSpriteShapeCircle, or SetSpriteShapePolygon. By
         * default, setting a shape removes all other shapes assigned to the sprite and
         * replaces it with this one. You can set shapes individually by specifying a
         * shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0
         * meaning delete all existing shapes before creating a new one at ID 1. This
         * command only changes existing shapes, by default all sprites have a base
         * shape at ID 1. You can add additional shapes by using the AddSpriteShape
         * commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param shape        - The shape to use for this sprite, 0=no shape, 1=circle,
         *                     2=box, 3=polygon
         * @return void
         */
        @Signature
        public native void SetSpriteShape(int iSpriteIndex, int shape);

        /**
         * Sets whether the global directional light shines or not.
         *
         * @param active - 1 to active it, 0 to deactivate it
         * @return void
         */
        @Signature
        public native void SetSunActive(int active);

        /**
         * Sets the sprite scale as an absolute multiple of its original size. For
         * example a scale value of 2 would double the sprite's size whilst a value of 1
         * will return it to its original size. This function scales from the sprite's
         * center of rotation (its current offset point) so any increase in size will
         * keep the offset point stationary whilst all four sides expand away from it.
         * To scale from the top left corner use SetSpriteScale.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The value to scale the sprite in the X direction.
         * @param y            - The value to scale the sprite in the Y direction.
         * @return void
         */
        @Signature
        public native void SetSpriteScaleByOffset(int iSpriteIndex, float x, float y);

        /**
         * Immediately positions the specified sprite to the given X,Y world
         * coordinates. The default world coordinate system has 0,0 as the top left
         * corner, and 100,100 as the bottom right hand corner of the screen (this can
         * be changed using SetVirtualResolution). This function always positions the
         * sprite using its current offset. For example if the current offset is the
         * center of the sprite this command will place the center of the sprite at the
         * given coordinates.
         *
         * @param iSpriteIndex - The ID of the sprite to position
         * @param fX           - The X coordinate to position the sprite, can use
         *                     decimal values.
         * @param fY           - the Y coordinate to position the sprite, can use
         *                     decimal values.
         * @return void
         */
        @Signature
        public native void SetSpritePositionByOffset(int iSpriteIndex, float fX, float fY);

        /**
         * Immediately sets the sprite's velocity to the given direction. This is an
         * abrupt change that might not look right during the physics simulation, forces
         * and impulses are the preferred approach to influencing velocity.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param vx           - The x component of the new velocity.
         * @param vy           - The y component of the new velocity.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsVelocity(int iSpriteIndex, float vx, float vy);

        /**
         * Immediately positions the specified sprite to the given X,Y world
         * coordinates. The default world coordinate system has 0,0 as the top left
         * corner, and 100,100 as the bottom right hand corner of the screen (this can
         * be changed using SetVirtualResolution). This function always positions the
         * sprite using its top left corner, regardless of the current sprite offset.
         * The top left corner used to position the sprite does not rotate with the
         * sprite, for example as the sprite rotates around its center the imaginary top
         * left corner remains fixed and the sprite's position value does not change.
         *
         * @param iSpriteIndex - The ID of the sprite to position
         * @param fX           - The X coordinate to position the sprite, can use
         *                     decimal values.
         * @param fY           - the Y coordinate to position the sprite, can use
         *                     decimal values.
         * @return void
         */
        @Signature
        public native void SetSpritePosition(int iSpriteIndex, float fX, float fY);

        /**
         * Sets the restitution (bounciness) value to use for this sprite during physics
         * calculations. Should be in the range 0 to 1. Values greater than 1 will
         * result in the sprite gaining energy from collisions which can cause an
         * unstable result. By default this sets all the shapes assigned to this sprite
         * to the same value, you can instead set it on a per shape basis by specifying
         * a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0
         * meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param restitution  - The new restitution value.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsRestitution(int iSpriteIndex, float restitution);

        /**
         * Sets the restitution (bounciness) value to use for this sprite during physics
         * calculations. Should be in the range 0 to 1. Values greater than 1 will
         * result in the sprite gaining energy from collisions which can cause an
         * unstable result. By default this sets all the shapes assigned to this sprite
         * to the same value, you can instead set it on a per shape basis by specifying
         * a shapeID greater than 0. Shape IDs start at 1 for the first shape, with 0
         * meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param restitution  - The new restitution value.
         * @param shapeID      - The ID of the shape to change, 0 to apply the value to
         *                     all shapes
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsRestitution(int iSpriteIndex, float restitution, int shapeID);

        /**
         * Sets the sprite up for automatic collision using the built physics system.
         * Once you have set a sprite to be controlled by physics you should use
         * SetSpritePosition and SetSpriteAngle sparingly as these will interrupt the
         * physics motion of the sprite. You can also use the SetSpritePhysicsVelocity
         * and SetSpritePhysicsAngularVelocity to change the speed and direction of a
         * sprite, but again these will interfere with the physics motion of the sprite.
         * If you wish to influence the position or rotation of a physics sprite you
         * should use the force and torque (rotational force) functions where possible,
         * these will maintain smooth physics motion. The mode parameter lets you choose
         * how the sprite should behave in the physics world. Static means it will never
         * move or rotate, dynamic means it will respond to all collisions and forces it
         * encounters, including gravity and collisions with static objects. Kinematic
         * is a special case which can be thought of as a moving static body, it will
         * not respond to collisions or forces and will continue at its specified
         * velocity forever, but dynamic items will respond to it and effectively be
         * pushed out of the way. The physics shape used is determined by the
         * SetSpriteShape command, which must be called before this command and is
         * expensive to change for circle and polygon shapes as they rebuild a shape
         * from the pixels of the sprite's image. Once you have called this command to
         * determine the mode of the sprite, further calls will ignore the mode values
         * and it will only reactivate a sprite that has been turned off, as the mode
         * cannot be changed whilst the sprite is in the physics system. If you wish to
         * change the mode of a sprite call SetSpritePhysicsDelete, which will delete
         * all its physics settings, then call SetSpritePhysicsOn with the new mode. But
         * doing this too often will slow the system down. All physics sprites should be
         * world sprites (not fixed to the screen), unless SetViewOffset is set to 0,0
         * in which case this doesn't matter. Otherwise debug shapes will not line up
         * and sprites from different view spaces will not interact properly.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param mode         - The physics mode to use for this sprite, 1=static,
         *                     2=dynamic, 3=kinematic
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsOn(int iSpriteIndex, int mode);

        /**
         * Clips the sprite to the specified world coordinates when drawn. Use the
         * values 0,0,0,0 to turn off the sprite scissor
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The x coordinate of the top left corner of the box to
         *                     use as a clip boundary.
         * @param y            - The y coordinate of the top left corner of the box to
         *                     use as a clip boundary.
         * @param x2           - The x coordinate of the bottom right corner of the box
         *                     to use as a clip boundary.
         * @param y2           - The y coordinate of the bottom right corner of the box
         *                     to use as a clip boundary.
         * @return void
         */
        @Signature
        public native void SetSpriteScissor(int iSpriteIndex, float x, float y, float x2, float y2);

        /**
         * Temporarily turns off physics for this sprite, it will no longer move or
         * react to collisions or forces. Use SetSpritePhysicsOn to reactivate the
         * sprite.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsOff(int iSpriteIndex);

        /**
         * This command overrides the calculated mass for this sprite and sets it to a
         * value of your choice, in kilograms. Setting this too low or too high can
         * cause an unstable simulation, especially if a very light object meets a very
         * heavy object. The value range you should use depends on your chosen physics
         * scale. Internally a default mass per object is calculated based on its size.
         * A 1m x 1m box would weigh 1 kg, so because of the default physics scale of 5,
         * a 5 x 5 box in virtual units weighs 1 kg.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param mass         - The new mass value.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsMass(int iSpriteIndex, float mass);

        /**
         * Sets the sprite scale as an absolute multiple of its original size. For
         * example a scale value of 2 would double the sprite's size whilst a value of 1
         * will return it to its original size. This function scales from the top left
         * corner so any increase in size will keep the top and left sides stationary
         * whilst the bottom and right sides move. The sprites center of rotation (its
         * current offset point) will scale with the sprite. To scale from the offset
         * point use SetSpriteScaleByOffset.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The value to scale the sprite in the X direction.
         * @param y            - The value to scale the sprite in the Y direction.
         * @return void
         */
        @Signature
        public native void SetSpriteScale(int iSpriteIndex, float x, float y);

        /**
         * Set this to true if the sprite is likely to be moving very fast, like a
         * bullet, as it will then be checked more thoroughly for collision with other
         * dynamic sprites, using this unnecessarily will affect performance. This is
         * called Continuous Collision Detection (CCD) and applies automatically to
         * collision checks between this sprite and static objects. This command turns
         * CCD on for collision checks between this sprite and dynamic objects. This
         * will not work if global CCD is turned off with SetPhysicsCCD.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param bullet       - 1 to set this sprite as a bullet, 0 to turn it off.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsIsBullet(int iSpriteIndex, int bullet);

        /**
         * Set this to 1 to make the sprite a sensor object. Physics sensors detect
         * collisions and contacts but do not respond to them, they also do not affect
         * anything that hits them. Their only purpose is to detect collisions. If you
         * apply this to a dynamic body it will not collide with anything and most
         * likely fall through the floor and continue falling forever, it is still
         * affected by forces. By default this sets all shapes to the same value, you
         * can set this value on a per shape basis by specifying a shapeID value greater
         * than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
         * apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param sensor       - 1 to set this sprite as a sensor, 0 to make it a normal
         *                     physics object.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsIsSensor(int iSpriteIndex, int sensor);

        /**
         * Set this to 1 to make the sprite a sensor object. Physics sensors detect
         * collisions and contacts but do not respond to them, they also do not affect
         * anything that hits them. Their only purpose is to detect collisions. If you
         * apply this to a dynamic body it will not collide with anything and most
         * likely fall through the floor and continue falling forever, it is still
         * affected by forces. By default this sets all shapes to the same value, you
         * can set this value on a per shape basis by specifying a shapeID value greater
         * than 0. Shape IDs start at 1 for the first shape, with shapeID 0 meaning
         * apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param sensor       - 1 to set this sprite as a sensor, 0 to make it a normal
         *                     physics object.
         * @param shapeID      - the ID of the shape to change, 0 to set all the
         *                     sprite's shapes to this value
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsIsSensor(int iSpriteIndex, int sensor, int shapeID);

        /**
         * Similar to a force but applied only once. Whilst forces are applied
         * continuously over time gradually influencing a sprite's velocity, an impulse
         * simulates the sprite being hit suddenly and immediately changes the velocity
         * with the equivalent power of a similar force applied for 1 second. The
         * impulse consists of a point in world coordinates and a direction, if the
         * point and direction are not in line with the sprite's offset point then it
         * will result in a rotation of the sprite as it is moved by the impulse. The
         * length of the impulse vector determines it strength. If the sprite is
         * constrained by surrounding objects it will impart the impulse onto those
         * objects and may not move itself. Impulses apply acceleration to an object
         * relative to its mass, heavy objects will move less than light objects with
         * the same impulse applied to them.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The X coordinate of the impulse position in world
         *                     coordinates.
         * @param y            - The Y coordinate of the impulse position in world
         *                     coordinates.
         * @param vx           - The X component of the impulse direction.
         * @param vy           - The Y component of the impulse direction.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsImpulse(int iSpriteIndex, float x, float y, float vx, float vy);

        /**
         * Applies a torque to the rotation of the sprite, similar to applying a force
         * to its movement. If the sprite is constrained by surrounding objects it may
         * not rotate unless the torque is large enough to move those objects as well.
         * The torque will last for this frame only, to continue applying this torque
         * you must keep calling this function. The reaction to a torque force is
         * relative to the object's size, large objects will rotate slower than small
         * objects given the same torque.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param torque       - The size of the force to apply to the sprite's
         *                     rotation. may be negative.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsTorque(int iSpriteIndex, float torque);

        /**
         * Applies a force to the sprite that will last for this frame only, to continue
         * applying this force you must keep calling this function. The force consists
         * of a point in world coordinates and a direction, if the point and direction
         * are not in line with the sprite's offset point then it will result in a
         * rotation of the sprite as it is moved by the force. The length of the force
         * vector determines its strength. If the sprite is constrained by surrounding
         * objects it may not move unless the force is large enough to move those
         * objects as well. Forces apply acceleration to an object relative to its mass,
         * heavy objects will move less than light objects with the same force applied
         * to them.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The X coordinate of the force position in world
         *                     coordinates.
         * @param y            - The Y coordinate of the force position in world
         *                     coordinates.
         * @param vx           - The X component of the force direction.
         * @param vy           - The Y component of the force direction.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsForce(int iSpriteIndex, float x, float y, float vx, float vy);

        /**
         * Sets some damping on the sprite's linear movement which may simulate
         * something like wind resistance. A value of 0 represents no damping, a value
         * of 0.75 would reduce the velocity vector by half every second when running at
         * 60 frames per second. Higher values will reduce the speed more quickly.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param damp         - The new damping value.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsDamping(int iSpriteIndex, float damp);

        /**
         * Sets the friction value to use for this sprite during physics calculations.
         * Should be in the range 0 to 1. By default this sets all the shapes assigned
         * to this sprite to the same value, you can instead set it on a per shape basis
         * by specifying a shapeID greater than 0. Shape IDs start at 1 for the first
         * shape, with 0 meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param friction     - The new friction value.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsFriction(int iSpriteIndex, float friction);

        /**
         * Sets the friction value to use for this sprite during physics calculations.
         * Should be in the range 0 to 1. By default this sets all the shapes assigned
         * to this sprite to the same value, you can instead set it on a per shape basis
         * by specifying a shapeID greater than 0. Shape IDs start at 1 for the first
         * shape, with 0 meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param friction     - The new friction value.
         * @param shapeID      - The ID of the shape to change, 0 to apply the value to
         *                     all shapes
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsFriction(int iSpriteIndex, float friction, int shapeID);

        /**
         * Sets whether the physics simulation is allowed to rotate the sprite.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param rotate       - 1 to allow rotation, 0 to prevent it.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsCanRotate(int iSpriteIndex, int rotate);

        /**
         * Sets the center of mass (COM) relative to the sprite's offset. By default the
         * AGK calculates the best location for the COM based on the size and location
         * of all shapes attached to the sprite. Setting it to 0,0 will put the COM on
         * the sprite's offset point (and center of rotation). If the COM is very
         * different from the offset point the sprite may seem unstable as it will
         * behave like an unbalanced spinning top.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The x coordinate of the center of mass.
         * @param y            - The y coordinate of the center of mass.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsCOM(int iSpriteIndex, float x, float y);

        /**
         * Sets the density value to use for the given sprite shape during physics
         * calculations. Default value is 1.0. This affects the mass calculation for the
         * given size of the sprite. This command will recalculate the mass and center
         * of mass for this sprite. Use a shapeID of 0 to apply this density to all
         * shapes or specify a shape ID greater than 0 to apply it only to that shape.
         * Shape IDs start at 1 for the first shape.
         *
         * @param iSpriteIndex - The ID of the sprite to modify
         * @param density      - The new density value, default is 1.0
         * @param shapeID      - The ID of the shape to change, 0 to apply the value to
         *                     all shapes
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsDensity(int iSpriteIndex, float density, int shapeID);

        /**
         * Turns off physics for this sprite and deletes all associated physics settings
         * for this sprite. You can use this to change the mode or shape of a sprite but
         * doing so regularly can affect the performance of the application.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsDelete(int iSpriteIndex);

        /**
         * Immediately sets the sprite's rotational velocity to the given direction.
         * This is an abrupt change that might not look right during the physics
         * simulation, torque and angular impulses are the preferred approach to
         * influencing angular velocity.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param va           - The new angular velocity.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsAngularVelocity(int iSpriteIndex, float va);

        /**
         * Similar to a torque force, but applied only once. Whilst forces are applied
         * continuously over time gradually influencing a sprite's velocity, an impulse
         * simulates the sprite being hit suddenly and immediately changes the angular
         * velocity with the equivalent power of a similar torque force applied for 1
         * second. If the sprite is constrained by surrounding objects it may not rotate
         * unless the impulse is large enough to move those objects as well. The
         * reaction to an impulse is relative to the object's size, large objects will
         * rotate slower than small objects given the same impulse.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param impulse      - The size of the force to apply to the sprite's
         *                     rotation. may be negative.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsAngularImpulse(int iSpriteIndex, float impulse);

        /**
         * Sets some damping on the sprite's angular movement which may simulate
         * something like wind resistance. A value of 0 represents no damping, a value
         * of 0.75 would reduce the angular velocity vector by half every second when
         * running at 60 frames per second. Higher values will reduce the spin more
         * quickly.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param damp         - The new damping value.
         * @return void
         */
        @Signature
        public native void SetSpritePhysicsAngularDamping(int iSpriteIndex, float damp);

        /**
         * The offset point is the point that the sprite will rotate around, with (0,0)
         * being the top left corner and (width,height) being the bottom right corner.
         * The offset can also be used to position the sprite using
         * SetSpritePositionByOffset, whilst SetSpritePosition will always position the
         * sprite using its top left corner. If the sprite is scaled remember to take
         * the scale into account, a sprite created as 10 by 10 units wide scaled by 0.5
         * will have a bottom right corner at 5,5 so to position the offset in the
         * center would mean placing it at 2.5,2.5, when the sprite is scale back up the
         * offset point will scale with it to maintain its relative position. This
         * command forces the recalculation of the sprite's shape due to a new center
         * point, additional shapes are not recalculated so will become distorted from
         * their original definition. It is not recommended calling this command on a
         * sprite already setup for physics. Change the offset before applying physics
         * or additional shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The X distance from the top left corner to offset the
         *                     rotation point.
         * @param y            - The Y distance from the top left corner to offset the
         *                     rotation point.
         * @return void
         */
        @Signature
        public native void SetSpriteOffset(int iSpriteIndex, float x, float y);

        /**
         * Assigns this sprite to a group for filtering collisions (physics or non
         * physics). In physics, sprites of the same positive group ID will always
         * collide, whilst those that share the same negative group ID will never
         * collide. Those with a group ID of zero (default), or differing group IDs move
         * on to the category filter check. When the sprite is not setup for physics
         * this test will only apply to the base shape at shapeID 1. By default this
         * sets all shapes to the same value, you can set this value on a per shape
         * basis by specifying a shapeID value greater than 0. Shape IDs start at 1 for
         * the first shape, with shapeID 0 meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param group        - The group ID to assign to this sprite.
         * @param shapeID      - the ID of the shape to change, 0 to set all the
         *                     sprite's shapes to this value
         * @return void
         */
        @Signature
        public native void SetSpriteGroup(int iSpriteIndex, int group, int shapeID);

        /**
         * Assigns this sprite to a group for filtering collisions (physics or non
         * physics). In physics, sprites of the same positive group ID will always
         * collide, whilst those that share the same negative group ID will never
         * collide. Those with a group ID of zero (default), or differing group IDs move
         * on to the category filter check. When the sprite is not setup for physics
         * this test will only apply to the base shape at shapeID 1. By default this
         * sets all shapes to the same value, you can set this value on a per shape
         * basis by specifying a shapeID value greater than 0. Shape IDs start at 1 for
         * the first shape, with shapeID 0 meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param group        - The group ID to assign to this sprite.
         * @return void
         */
        @Signature
        public native void SetSpriteGroup(int iSpriteIndex, int group);

        /**
         * Sets the sprite to a specific frame, frames start at 1 and end at
         * GetSpriteFrameCount
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param iFrame       - The ID of the frame this sprite should change to, has
         *                     an immediate effect.
         * @return void
         */
        @Signature
        public native void SetSpriteFrame(int iSpriteIndex, int iFrame);

        /**
         * Flips the sprite either horizontally or vertically, (or both). This merely
         * modifies the UV coordinates so that the sprite appears flipped, it does not
         * adjust position or angle values. Note that flipping in both horizontal and
         * vertical directions at the same time gives the appearance of rotation by 180
         * degrees.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param horz         - 1 to flip to sprite horizontally left to right, 0 to
         *                     keep the sprite normal.
         * @param vert         - 1 to flip to sprite vertically top to bottom, 0 to keep
         *                     the sprite normal.
         * @return void
         */
        @Signature
        public native void SetSpriteFlip(int iSpriteIndex, int horz, int vert);

        /**
         * Sets the draw order for the sprite between 0-10000, 0 being the front of the
         * screen, 10000 being the back. Anything above 10000 will result in the sprite
         * being clipped from view. By default sprites are at depth 10. If two sprites
         * occupy the same depth then the order they are drawn is undefined unless
         * SetSortCreated is used to true, in which case sprites at the same depth will
         * be drawn in the order they were created. For maximum performance it is
         * recommended that every sprite has its own depth value unless the order they
         * are drawn is not important, for example physics sprites that won't normally
         * overlap. Note that if you are not using any 3D objects and you are using
         * sprite depths greater then 5000 you should use SetGlobal3DDepth to 10000 to
         * improve performance (essentially bringing all sprites to the front of the 3D
         * renderer).
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param iDepth       - The depth this sprite should be drawn at.
         * @return void
         */
        @Signature
        public native void SetSpriteDepth(int iSpriteIndex, int iDepth);

        /**
         * Set the red component of a sprite.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param iRed         - The red component of the color. The acceptable range is
         *                     from 0 to 255.
         * @return void
         */
        @Signature
        public native void SetSpriteColorRed(int iSpriteIndex, int iRed);

        /**
         * Set the alpha component of a sprite.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param iAlpha       - The alpha component of the color. The acceptable range
         *                     is from 0 to 255. When a value of 0 is used the sprite
         *                     will be invisible. When a value of 255 is used the sprite
         *                     will be fully opaque.
         * @return void
         */
        @Signature
        public native void SetSpriteColorAlpha(int iSpriteIndex, int iAlpha);

        /**
         * Change the sprite image to a new loaded image. If the new image has a
         * different size or shape from the old image the sprite may look distorted as a
         * result, you can fix this by resetting the sprite dimensions using
         * SetSpriteSize. If the sprite is animated you may also need to call
         * SetSpriteAnimation again. In the case of circle and polygon sprites you may
         * set whether the sprite uses this new image to change its collision shape. Box
         * shapes are not affected by image changes. Using this command will clear any
         * animation frames you have set with any of the sprite animation commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param iImageIndex  - The ID of the image to use for this sprite.
         * @param bUpdateShape - Sets whether the collision shape of this sprite should
         *                     be changed to match the new image. ( 1 or 0 )
         * @return void
         */
        @Signature
        public native void SetSpriteImage(int iSpriteIndex, int iImageIndex, int bUpdateShape);

        /**
         * Change the sprite image to a new loaded image. If the new image has a
         * different size or shape from the old image the sprite may look distorted as a
         * result, you can fix this by resetting the sprite dimensions using
         * SetSpriteSize. If the sprite is animated you may also need to call
         * SetSpriteAnimation again. In the case of circle and polygon sprites you may
         * set whether the sprite uses this new image to change its collision shape. Box
         * shapes are not affected by image changes. Using this command will clear any
         * animation frames you have set with any of the sprite animation commands.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param iImageIndex  - The ID of the image to use for this sprite.
         * @return void
         */
        @Signature
        public native void SetSpriteImage(int iSpriteIndex, int iImageIndex);

        /**
         * Set the color of a sprite.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param iRed         - The red component of the color.
         * @param iGreen       - The green component of the color.
         * @param iBlue        - The blue component of the color.
         * @param iAlpha       - The alpha component of the color. The acceptable range
         *                     is from 0 to 255. When a value of 0 is used the sprite
         *                     will be invisible. When a value of 255 is used the sprite
         *                     will be fully opaque.
         * @return void
         */
        @Signature
        public native void SetSpriteColor(int iSpriteIndex, int iRed, int iGreen, int iBlue, int iAlpha);

        /**
         * Sets or removes a category that this sprite can collide with. Sprites are
         * assigned categories using SetSpriteCategoryBit. There are 16 categories, a
         * value of 1 for that category represents that this sprite will collide with
         * sprites from that category and 0 that it will not collide with that category,
         * regardless of which category this sprite itself belongs to. By default all
         * sprites belong to category 1 and collide with all categories. This command is
         * similar to SetSpriteCategoryBits except this command sets one category at a
         * time whilst that command sets them all at once using a bit mask. By default
         * this sets all shapes to the same value, you can set this value on a per shape
         * basis by specifying a shapeID value greater than 0. Shape IDs start at 1 for
         * the first shape, with shapeID 0 meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param category     - The category to set collision on or off for this
         *                     sprite, must be between 1 and 16 inclusive.
         * @param flag         - 1 to set collision on, 0 to turn it off for this
         *                     sprite.
         * @param shapeID      - the ID of the shape to change, 0 to set all the
         *                     sprite's shapes to this value
         * @return void
         */
        @Signature
        public native void SetSpriteCollideBit(int iSpriteIndex, int category, int flag, int shapeID);

        /**
         * Sets or removes a category that this sprite can collide with. Sprites are
         * assigned categories using SetSpriteCategoryBit. There are 16 categories, a
         * value of 1 for that category represents that this sprite will collide with
         * sprites from that category and 0 that it will not collide with that category,
         * regardless of which category this sprite itself belongs to. By default all
         * sprites belong to category 1 and collide with all categories. This command is
         * similar to SetSpriteCategoryBits except this command sets one category at a
         * time whilst that command sets them all at once using a bit mask. By default
         * this sets all shapes to the same value, you can set this value on a per shape
         * basis by specifying a shapeID value greater than 0. Shape IDs start at 1 for
         * the first shape, with shapeID 0 meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param category     - The category to set collision on or off for this
         *                     sprite, must be between 1 and 16 inclusive.
         * @param flag         - 1 to set collision on, 0 to turn it off for this
         *                     sprite.
         * @return void
         */
        @Signature
        public native void SetSpriteCollideBit(int iSpriteIndex, int category, int flag);

        /**
         * Assigns the sprite to zero or more categories for collision filtering
         * (physics and non physics). There are 16 categories, each represented by a
         * single bit in the "categories" parameter, a value of 1 for a bit represents
         * that this sprite is a part of that category and 0 that it does not belong to
         * that category. Sprites can then be set to collide with certain categories
         * using SetSpriteCollideBits regardless of which categories they themselves
         * belong to. By default all sprites belong to category 1 (0x0001 the rightmost
         * bit) and collide with all categories (0xffff). When the sprite is not setup
         * for physics this test will only apply to the base shape at shapeID 1. By
         * default this sets all shapes to the same value, you can set this value on a
         * per shape basis by specifying a shapeID value greater than 0. Shape IDs start
         * at 1 for the first shape, with shapeID 0 meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param categories   - The bitwise field of categories to assign to this
         *                     sprite.
         * @param shapeID      - the ID of the shape to change, 0 to set all the
         *                     sprite's shapes to this value
         * @return void
         */
        @Signature
        public native void SetSpriteCategoryBits(int iSpriteIndex, int categories, int shapeID);

        /**
         * Assigns the sprite to zero or more categories for collision filtering
         * (physics and non physics). There are 16 categories, each represented by a
         * single bit in the "categories" parameter, a value of 1 for a bit represents
         * that this sprite is a part of that category and 0 that it does not belong to
         * that category. Sprites can then be set to collide with certain categories
         * using SetSpriteCollideBits regardless of which categories they themselves
         * belong to. By default all sprites belong to category 1 (0x0001 the rightmost
         * bit) and collide with all categories (0xffff). When the sprite is not setup
         * for physics this test will only apply to the base shape at shapeID 1. By
         * default this sets all shapes to the same value, you can set this value on a
         * per shape basis by specifying a shapeID value greater than 0. Shape IDs start
         * at 1 for the first shape, with shapeID 0 meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param categories   - The bitwise field of categories to assign to this
         *                     sprite.
         * @return void
         */
        @Signature
        public native void SetSpriteCategoryBits(int iSpriteIndex, int categories);

        /**
         * Assigns or removes a sprite from a particular category. There are 16
         * categories that a sprite can belong to, and a sprite can belong to any number
         * at once. This command is similar to SetSpriteCategoryBits except this command
         * sets one category at a time whilst that command sets them all at once using a
         * bit mask. By default this sets all shapes to the same value, you can set this
         * value on a per shape basis by specifying a shapeID value greater than 0.
         * Shape IDs start at 1 for the first shape, with shapeID 0 meaning apply it to
         * all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param category     - The category to change, must be between 1 and 16
         *                     inclusive.
         * @param flag         - 1 to make the sprite a part of this category, 0 to
         *                     remove it.
         * @return void
         */
        @Signature
        public native void SetSpriteCategoryBit(int iSpriteIndex, int category, int flag);

        /**
         * Assigns or removes a sprite from a particular category. There are 16
         * categories that a sprite can belong to, and a sprite can belong to any number
         * at once. This command is similar to SetSpriteCategoryBits except this command
         * sets one category at a time whilst that command sets them all at once using a
         * bit mask. By default this sets all shapes to the same value, you can set this
         * value on a per shape basis by specifying a shapeID value greater than 0.
         * Shape IDs start at 1 for the first shape, with shapeID 0 meaning apply it to
         * all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param category     - The category to change, must be between 1 and 16
         *                     inclusive.
         * @param flag         - 1 to make the sprite a part of this category, 0 to
         *                     remove it.
         * @param shapeID      - the ID of the shape to change, 0 to set all the
         *                     sprite's shapes to this value
         * @return void
         */
        @Signature
        public native void SetSpriteCategoryBit(int iSpriteIndex, int category, int flag, int shapeID);

        /**
         * Initialises the sprite animation with frames from its assigned image, based
         * on a frame width and frame height. The sprite will use the frame width and
         * frame height to extract images of that size from its assigned image beginning
         * in the top left corner and moving from left to right. When it reaches the
         * right hand side of the image it will begin again one row down, moving from
         * left to right again until the frame count is reached or it runs out of space
         * on the image to look for frames. Storing an animation image on an atlas
         * texture is supported. This function is the preferred method of assigning an
         * animation to a sprite as it avoids expensive image changes during rendering.
         * However if all your animation frames are separate images you can use the
         * AddSpriteAnimationFrame to add frames from images individually. Using
         * SetSpriteImage will clear all animation frames you have set here.
         *
         * @param iSpriteIndex - The ID of the sprite to set for animation.
         * @param iFrameWidth  - The width of the frames in pixels on the image.
         * @param iFrameHeight - The height of the frames in pixels on the image.
         * @param iFrameCount  - The number of frames the sprite should attempt to
         *                     retrieve from the image.
         * @return void
         */
        @Signature
        public native void SetSpriteAnimation(int iSpriteIndex, int iFrameWidth, int iFrameHeight, int iFrameCount);

        /**
         * Set the green component of a sprite.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param iGreen       - The green component of the color. The acceptable range
         *                     is from 0 to 255.
         * @return void
         */
        @Signature
        public native void SetSpriteColorGreen(int iSpriteIndex, int iGreen);

        /**
         * Set the blue component of a sprite.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param iBlue        - The blue component of the color. The acceptable range
         *                     is from 0 to 255.
         * @return void
         */
        @Signature
        public native void SetSpriteColorBlue(int iSpriteIndex, int iBlue);

        /**
         * Immediately rotates the specified sprite to the given angle in degrees. By
         * default sprites rotate around their center, see SetSpriteOffset to change
         * this.
         *
         * @param iSpriteIndex - The ID of the sprite to rotate.
         * @param fAng         - The angle to set the sprite in degrees.
         * @return void
         */
        @Signature
        public native void SetSpriteAngle(int iSpriteIndex, float fAng);

        /**
         * Adds additional images to the sprite that can be used with shaders. The image
         * set with SetSpriteImage is used as texture stage 0, and this command will let
         * you set stages 1 to 7. These additional images do not play any part in
         * animation or shape calculations. Note that the sprite will have the same UV
         * coordinates for each texture so it is recommended that the images have the
         * same dimensions, or use power of 2 images to avoid UV conversions on mobile
         * devices where images might be scaled.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param iImageIndex  - The ID of the image to use for this sprite.
         * @param iStage       - The index of the texture stage to use, in the range 1
         *                     to 7.
         * @return void
         */
        @Signature
        public native void SetSpriteAdditionalImage(int iSpriteIndex, int iImageIndex, int iStage);

        /**
         * Uses a bitwise mask to determine which sprite categories this sprite can
         * collide with. Sprites are assigned categories using SetSpriteCategoryBits.
         * There are 16 categories, each represented by a single bit in the "mask"
         * parameter, a value of 1 for a bit represents that this sprite will collide
         * with sprites from that category and 0 that it will not collide with that
         * category, regardless of which category this sprite itself belongs to. By
         * default all sprites belong to category 1 (0x0001 the rightmost bit) and
         * collide with all categories (0xffff). When the sprite is not setup for
         * physics this test will only apply to the base shape at shapeID 1. By default
         * this sets all shapes to the same value, you can set this value on a per shape
         * basis by specifying a shapeID value greater than 0. Shape IDs start at 1 for
         * the first shape, with shapeID 0 meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param mask         - The bitwise mask of categories this sprite can collide
         *                     with during physics calculations.
         * @return void
         */
        @Signature
        public native void SetSpriteCollideBits(int iSpriteIndex, int mask);

        /**
         * Uses a bitwise mask to determine which sprite categories this sprite can
         * collide with. Sprites are assigned categories using SetSpriteCategoryBits.
         * There are 16 categories, each represented by a single bit in the "mask"
         * parameter, a value of 1 for a bit represents that this sprite will collide
         * with sprites from that category and 0 that it will not collide with that
         * category, regardless of which category this sprite itself belongs to. By
         * default all sprites belong to category 1 (0x0001 the rightmost bit) and
         * collide with all categories (0xffff). When the sprite is not setup for
         * physics this test will only apply to the base shape at shapeID 1. By default
         * this sets all shapes to the same value, you can set this value on a per shape
         * basis by specifying a shapeID value greater than 0. Shape IDs start at 1 for
         * the first shape, with shapeID 0 meaning apply it to all shapes.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param mask         - The bitwise mask of categories this sprite can collide
         *                     with during physics calculations.
         * @param shapeID      - the ID of the shape to change, 0 to set all the
         *                     sprite's shapes to this value
         * @return void
         */
        @Signature
        public native void SetSpriteCollideBits(int iSpriteIndex, int mask, int shapeID);

        /**
         * Sets the language to use when speaking text by voice ID. The ID can be found
         * with GetSpeechVoiceID, and is necessary when multiple voices have the same
         * language but with different accents.
         *
         * @param sID - The language to use for speaking text, default is the device's
         *            current language.
         * @return void
         */
        @Signature
        public native void SetSpeechLanguageByID(String sID);

        /**
         * Sets the speaking rate, where 1.0 is normal speed, 2.0 is double speed, 0.5
         * is half speed, and so on. Currently only works on iOS and Android.
         *
         * @param rate - The rate to speak text, default is 1.0
         * @return void
         */
        @Signature
        public native void SetSpeechRate(float rate);

        /**
         * Sets the language to use when speaking text, for example "en_GB" for British
         * English, "en_US" for American English, "fr_FR" for French, and so on. If the
         * language engine is not currently on the device then the device will attempt
         * to download it when Speak is next called, this may introduce a delay before
         * that text is spoken. If the download fails, or no internet connection is
         * available then the default language engine for the current device will be
         * used. Currently only works on iOS and Android.
         *
         * @param lang - The language to use for speaking text, default is the device's
         *             current language.
         * @return void
         */
        @Signature
        public native void SetSpeechLanguage(String lang);

        /**
         * Sets the master sound volume for all sounds. The individual sound volumes
         * will remain intact, but all volumes are multiplied by the master sound volume
         * allowing features such as fading.
         *
         * @param iVol - The master sound volume for all sounds.
         * @return void
         */
        @Signature
        public native void SetSoundSystemVolume(int iVol);

        /**
         * Sets the current volume of the specified instance, between 0 and 100. The
         * instance ID is the value returned from PlaySound when you initiated the
         * playing of the sound.
         *
         * @param iID - The ID of the instance to modify
         * @param vol - The new volume of the instance, 0 to 100
         * @return void
         */
        @Signature
        public native void SetSoundInstanceVolume(int iID, int vol);

        /**
         * Sets the current playback rate of the specified instance, with 1.0 being
         * normal speed, 2.0 being double speed, and so on. Not all devices are
         * guaranteed to support modifying playback rates. Use GetSoundMaxRate and
         * GetSoundMinRate to check the valid ranges for the current device, any values
         * outside this range will be clamped. The instance ID is the value returned
         * from PlaySound when you initiated the playing of the sound.
         *
         * @param iID  - The ID of the instance to modify
         * @param rate - The new playback rate of the instance
         * @return void
         */
        @Signature
        public native void SetSoundInstanceRate(int iID, float rate);

        /**
         * Sets whether the AGK should sort transparent sprites by depth when drawing.
         * This draws sprites at the back of the screen first to achieve the correct
         * blending result when transparent sprites overlap. It is on by default but if
         * your transparent sprites are guaranteed to not overlap you may turn it off to
         * increase performance. This command is deprecated, sorting is now handled
         * automatically.
         *
         * @param sort - Set to 1 to sort transparent sprites by depth, 0 to turn
         *             transparent sorting off.
         * @return void
         */
        @Signature
        public native void SetSortTransparentDepth(int sort);

        /**
         * Immediately rotates the specified sprite to the given angle in radians. By
         * default sprites rotate around their center, see SetSpriteOffset to change
         * this.
         *
         * @param iSpriteIndex - The ID of the sprite to rotate.
         * @param fAng         - The angle to set the sprite in radians.
         * @return void
         */
        @Signature
        public native void SetSpriteAngleRad(int iSpriteIndex, float fAng);

        /**
         * Sets whether this sprite updates its animation and physics every frame, the
         * sprite may be visible or not, which is controlled by SetSpriteVisible.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param bActive      - Set to 1 if this sprite should be updated, 0 if not.
         * @return void
         */
        @Signature
        public native void SetSpriteActive(int iSpriteIndex, int bActive);

        /**
         * Sets whether the AGK should sort sprites by texture when drawing to limit the
         * number of texture changes. This will improve performance on devices that do
         * not cope well with frequent state changes, but may reduce performance if
         * textures on sprites are changed frequently. It is off by default but if you
         * do not change sprite textures, or are using atlas textures it is recommended
         * to turn it on. This command is deprecated, sorting is now handled
         * automatically.
         *
         * @param sort - Set to 1 to sort sprites by texture. default=0
         * @return void
         */
        @Signature
        public native void SetSortTextures(int sort);

        /**
         * Sets whether the AGK should sort opaque sprites by depth when drawing. This
         * draws sprites at the front of the screen first, which fills the depth buffer
         * so later sprites behind can be skipped. This will improve performance on fill
         * rate limited devices where you are drawing lots of overlapping opaque
         * sprites. It is off by default but if you do not change sprite depth
         * frequently it is recommended to turn it on. This does not apply to
         * transparent sprites which have their own sorting requirements. This command
         * is deprecated, sorting is now handled automatically.
         *
         * @param sort - Set to 1 to sort opaque sprites by depth. default=0
         * @return void
         */
        @Signature
        public native void SetSortDepth(int sort);

        /**
         * Sets whether the device should sleep when your app is idle. By default this
         * is turned off, but if activated it will use the device settings to determine
         * how long it should idle before sleeping.
         *
         * @param mode - 1 to enable sleep mode, 0 to turn it off (default)
         * @return void
         */
        @Signature
        public native void SetSleepMode(int mode);

        /**
         * Sets whether the sky box object is visible or not. By default it is not
         * visible. The sky box will always appear behind all other 3D objects and will
         * be drawn at the maximum visible view range, which is set with SetCameraRange.
         * The sky box has an optional sun that will be drawn to match the current
         * directional light direction, set with SetSunDirection. However it will not
         * use the directional light color, so you can have the directional light as one
         * color and the sky box sun as another color.
         *
         * @param active - 1 to show the skybox, 0 to hide it
         * @return void
         */
        @Signature
        public native void SetSkyBoxVisible(int active);

        /**
         * Sets whether the app will allow background music from other apps to continue
         * playing (mode=0) or silence other apps whilst this app is active (mode=1).
         * Note that in mode 0 the device considers your app audio to be unimportant so
         * will be silenced if the device ringer is set to silent. This only works on
         * iOS.
         *
         * @param mode - The sound mode to use (default=0)
         * @return void
         */
        @Signature
        public native void SetSoundDeviceMode(int mode);

        /**
         * Sets the current balance of the specified instance, with 0 being centered,
         * -1.0 being all on the left speaker, and 1.0 being all on the right speaker,
         * any values outside this range will be clamped. This works best with mono
         * sounds but can be applied to stereo sounds. The instance ID is the value
         * returned from PlaySound when you initiated the playing of the sound.
         *
         * @param iID     - The ID of the instance to modify
         * @param balance - The new balance of the instance
         * @return void
         */
        @Signature
        public native void SetSoundInstanceBalance(int iID, float balance);

        /**
         * Sets the size of the sun and its halo, if visible. The size values are not
         * relative to any world units and must be in the range 1.0 to 100.0. The
         * default values are 5.0 for the sun and 50.0 for the halo.
         *
         * @param sun  - The size of the sun
         * @param halo - The size of the halo around the sun
         * @return void
         */
        @Signature
        public native void SetSkyBoxSunSize(float sun, float halo);

        /**
         * Sets the color that will fill the majority of the sky. By default this is
         * 161,183,209. Colors should be in the range 0 to 255, although this is not
         * limited and values outside this range will be accepted, including negative
         * values.
         *
         * @param red   - The red component of the sky color
         * @param green - The green component of the sky color
         * @param blue  - The blue component of the sky color
         * @return void
         */
        @Signature
        public native void SetSkyBoxSkyColor(int red, int green, int blue);

        /**
         * If two sprites occupy the same depth then the order they are drawn is
         * undefined unless this function is set to 1, in which case sprites at the same
         * depth will be drawn in the order they were created. For maximum performance
         * it is recommended that every sprite has its own depth value with this command
         * set to 0. If the order they are drawn is not important, for example physics
         * sprites that won't normally overlap, then you can use sprites at the same
         * depth without setting this command to 1.
         *
         * @param sort - Set to 1 to sort sprites that have the same depth by the order
         *             they were created, 0 to turn it off.
         * @return void
         */
        @Signature
        public native void SetSortCreated(int sort);

        /**
         * Sets the properties for any sticker images that are added to future calls to
         * ShareSnapChatImage. The X and Y parameters should be in the range 0.0 to 1.0
         * for example in the X direction 1.0 is the far right of the image and 0.0 is
         * the far left of the image.
         *
         * @param x      - The X position of the sticker, default 0.5
         * @param y      - The Y position of the sticker, default 0.5
         * @param width  - The width of the sticker, default 250
         * @param height - The height of the sticker, default 250
         * @param angle  - The angle of the sticker, default 0
         * @return void
         */
        @Signature
        public native void SetSnapChatStickerSettings(float x, float y, int width, int height, float angle);

        /**
         * Sets the size and height of the horizon. By default the size is 4.0 and the
         * height is 0.0. This affects how high the horizon color extends before
         * becoming the sky color. The height value is in world coordinates and
         * everything at or below this height will be the horizon color. Above this
         * height the horizon is blended into the sky color until at a certain point
         * only the sky color remains. The horizon will always be at the specified
         * height in the world, even if the camera moves up and down. The size value is
         * not relative to any world units and needs to be set to your liking, then
         * effective range is from 0.1 to about 50.0, but can be set higher. If the view
         * range is small then the height value will appear to have greater effect as
         * the sky box is drawn closer to the camera than if the view range was larger.
         * For example a horizon height of 100 with a small view range will appear very
         * high, but when the view range is larger the camera is viewing the horizon
         * from much further away, so a height change of 100 units will have less
         * effect.
         *
         * @param size   - The size of the horizon above the horizon height
         * @param height - The height that the horizon starts
         * @return void
         */
        @Signature
        public native void SetSkyBoxHorizonSize(float size, float height);

        /**
         * Sets the color that will appear at the horizon. By default this is
         * 255,255,255. Colors should be in the range 0 to 255, although this is not
         * limited and values outside this range will be accepted, including negative
         * values.
         *
         * @param red   - The red component of the sky color
         * @param green - The green component of the sky color
         * @param blue  - The blue component of the sky color
         * @return void
         */
        @Signature
        public native void SetSkyBoxHorizonColor(int red, int green, int blue);

        /**
         * Sets whether the sky box will draw a sun at the location of the current
         * directional light. It's position can be set with SetSunDirection, but it will
         * not use the directional light color, you can set that separately with
         * SetSkyBoxSunColor. Note that setting the sun visible changes the sky box
         * drawing calculations to make them more complicated which may have an impact
         * on performance.
         *
         * @param visible - 1 to draw the sun, 0 to hide it
         * @return void
         */
        @Signature
        public native void SetSkyBoxSunVisible(int visible);

        /**
         * Sets the color of the sun, if visible. By default this is 255,230,179. Colors
         * should be in the range 0 to 255, although this is not limited and values
         * outside this range will be accepted, including negative values. Note that due
         * to the way the sun color is added to the sky color, sun colors darker than
         * the sky color may result in an unexpected sun color where one or more color
         * components is completely missing. If this happens then scaling up the sun
         * color, going above 255 if necessary, will remove it. The sun color has some
         * affect on the size of the sun in addition to SetSkyBoxSunSize, with brighter
         * colors making it bigger.
         *
         * @param red   - The red component of the sky color
         * @param green - The green component of the sky color
         * @param blue  - The blue component of the sky color
         * @return void
         */
        @Signature
        public native void SetSkyBoxSunColor(int red, int green, int blue);

        /**
         * Sets the position of the root of the skeleton, the bone positions will be
         * relative to this spot. This can be used to move the skeleton whilst it is
         * animating to make it look like it is walking.
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param x         - The X position of the skeleton
         * @param y         - The Y position of the skeleton
         * @return void
         */
        @Signature
        public native void SetSkeleton2DPosition(int iSkeleton, float x, float y);

        /**
         * Sets the horizontal and vertical flip mode of the skeleton, this will flip
         * all bones and sprites along the horizontal or vertical axis (or both).
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param flipH     - 1 to flip the skeleton in the horizontal axis, 0 for no
         *                  flip.
         * @param flipV     - 1 to flip the skeleton in the vertical axis, 0 for no
         *                  flip.
         * @return void
         */
        @Signature
        public native void SetSkeleton2DFlip(int iSkeleton, int flipH, int flipV);

        /**
         * Sets the depth of this skeleton in the range 0-10000 with 0 being top.
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param depth     - The depth value to use
         * @return void
         */
        @Signature
        public native void SetSkeleton2DDepth(int iSkeleton, int depth);

        /**
         * Set the original scale of a bone. Animations will override this value.
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param bone      - ID of the bone to modify
         * @param sx        - The new X scale value to use
         * @param sy        - The new Y scale value to use
         * @return void
         */
        @Signature
        public native void SetSkeleton2DBoneScale(int iSkeleton, int bone, float sx, float sy);

        /**
         * Set the original position of a bone relative to its parent also know as the
         * setup pose. All animation will be relative to this position, this can be
         * changed whilst an animation is playing.
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param bone      - The ID of the bone to modify
         * @param x         - The new X position to use
         * @param y         - The new Y position to use
         * @return void
         */
        @Signature
        public native void SetSkeleton2DBonePosition(int iSkeleton, int bone, float x, float y);

        /**
         * Sets whether the bone can animate or if it remains stationary. You can still
         * modify the bone position, angle, and scale manually.
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param bone      - ID of the bone to modify
         * @param mode      - 1 to let the bone animate, 0 to stop it
         * @return void
         */
        @Signature
        public native void SetSkeleton2DBoneMode(int iSkeleton, int bone, int mode);

        /**
         * Sets whether the specified skeleton is visible or not. AGK will automatically
         * hide the skeleton when it moves off screen to improve performance, so you
         * only need to do this if you want to hide it whilst it is on screen. When
         * hidden a skeleton will still animate.
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param mode      - 1 to make it visible, 0 to hide it
         * @return void
         */
        @Signature
        public native void SetSkeleton2DVisible(int iSkeleton, int mode);

        /**
         * Set the original angle of a bone relative to its parent. All animation will
         * be relative to this angle, this can be changed whilst an animation is
         * playing.
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param bone      - ID of the bone to modify
         * @param r         - The new angle to use
         * @return void
         */
        @Signature
        public native void SetSkeleton2DBoneAngle(int iSkeleton, int bone, float r);

        /**
         * Sets the angle of the root of the skeleton, the bone angles will be relative
         * to this angle.
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param r         - The angle to use in degrees
         * @return void
         */
        @Signature
        public native void SetSkeleton2DRotation(int iSkeleton, float r);

        /**
         * Sets the skeleton to a specific point in the animation based on time, with
         * optional tweening time. The tween time will smoothly interpolate the skeleton
         * from its current state to the chosen frame of the specified animation so that
         * there is no sharp transition.
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param anim      - The name of the animation to use
         * @param time      - The time offset to use to set the frame of the skeleton
         * @param tweentime - Number of seconds to transition from its current state to
         *                  the given frame
         * @return void
         */
        @Signature
        public native void SetSkeleton2DAnimationFrame(int iSkeleton, String anim, float time, float tweentime);

        /**
         * For iOS only. Tells AGK what App Group you are using to share data between
         * apps. For example group.com.mycompany.mygroup.myvariables, this is created on
         * the Apple developer portal and must be added to every App ID you want to
         * access these variables. You will need to regenerate the provisioning profile
         * for each app after adding an App Group to its App ID.
         *
         * @param group - The name to use to identify this variable
         * @return void
         */
        @Signature
        public native void SetSharedVariableAppGroup(String group);

        /**
         * Sets the smoothing mode for the shadow map. Mode 0 turns smoothing off and
         * results in the fastest shadows but produces hard edges. Mode 1 is slightly
         * slower but produces softer shadows by sampling the shadow map multiple times.
         * Mode 2 uses random multisampling to avoid banding produced by mode 1, but is
         * slower still.
         *
         * @param mode - 0 to use no smoothing, 1 to use multismapling, 2 to use random
         *             multisampling
         * @return void
         */
        @Signature
        public native void SetShadowSmoothing(int mode);

        /**
         * Sets the range from the camera that shadows will be drawn. Ideally this would
         * be set to the camera far range from SetCameraRange, but drawing shadows all
         * the way to the far plane may take some quality away from those shadows closer
         * to the camera. Therefore setting the shadow range lower than the camera far
         * range may improve shadow quality at the expense of distant objects not having
         * shadows. The actual shadow range will be the lower value of the the camera
         * far range and this shadow range, so you can safely set it larger than the
         * camera far range without any effect on quality. If you later adjust the
         * camera far range then the shadow range will not change accordingly, you must
         * set it separately. Use a value of -1 to ignore this value and always use the
         * camera far range for shadows. By default this is set to -1.
         *
         * @param range - The distance to stop drawing shadows, -1 to use the camera far
         *              range instead
         * @return void
         */
        @Signature
        public native void SetShadowRange(float range);

        /**
         * Sets the shadow map resolution in pixels. Good values are 512x512 or
         * 1024x1024, it does not need to be a power of two in size. The higher the
         * resolution the better quality the shadows will be, although performance will
         * be lower with higher resolution shadow maps.
         *
         * @param width  - The width in pixels to use for the shadow map
         * @param height - The height in pixels to use for the shadow map
         * @return void
         */
        @Signature
        public native void SetShadowMapSize(int width, int height);

        /**
         * Turns shadow mapping on or off, by default this is off. Shadows are only
         * generated by the the global directional light, which can be controlled with
         * the SetSunDirection command. Note that this is not guaranteed to be supported
         * on all devices, you can check for the current device by calling
         * GetShadowMappingSupported. There are currently three shadow modes that can be
         * used, mode 1 uses Uniform shadow mapping which has lower but consistent
         * quality. Mode 2 uses Light Space Perspective shadow mapping (LiPSM) which has
         * higher quality in most cases but if the camera is looking in the same
         * direction as the light then it is no better than Uniform shadow mapping.
         * Light Space Perspective also suffers from shadow shimmering as the camera
         * moves whereas Uniform is more stable. Both have about the same performance.
         * Mode 3 uses Cascade shadow mapping which uses multiple shadow maps to
         * maintain high quality near the camera whilst still allowing lower quality
         * shadows in the distance. This method has much lower performance than the
         * previous two methods but results in better quality shadows in all cases. Note
         * that when using modes 1 and 2, texture stage 7 on all objects receiving
         * shadow is reserved for the shadow map. When using shadow mode 3 (cascade
         * shadows) then texture stages 4, 5, 6, and 7 are reserved for the shadow maps.
         *
         * @param mode - 0 to turn it off, 1 to use Uniform shadows, 2 to use LiPSM
         *             shadows, 3 to use Cascade shadows
         * @return void
         */
        @Signature
        public native void SetShadowMappingMode(int mode);

        /**
         * Limits the directional light angle to steps of the given size rather than
         * being a continuous value. This can prevent shadow shimmering if the
         * directional light is slowly changing its angle, such as the sun moving across
         * the sky. By default this is set to 0 which disables the step size and keeps
         * the angle as a continuous value. Values in the range 0.1 to 2.0 seem to work
         * best. This only applies if the SetShadowMappingMode is set to Uniform.
         *
         * @param step - The light angle step size in degrees
         * @return void
         */
        @Signature
        public native void SetShadowLightStepSize(float step);

        /**
         * Sets a shader constant by name, the constant must be marked as "uniform" in
         * the shader source. This will affect all objects drawn using this shader. All
         * shader values have 1 to 4 components, this command accepts 4 values and
         * discards any that are not used by the named variable.
         *
         * @param shaderID - The ID of the shader to modify.
         * @param szName   - The name of the constant to change, as defined in the
         *                 shader source file.
         * @param value1   - The X or R component of the new value, this value will
         *                 always be used.
         * @param value2   - The Y or G component of the new value, if the constant only
         *                 uses 1 component this value is discarded.
         * @param value3   - The Z or B component of the new value, if the constant only
         *                 uses 2 components this value is discarded.
         * @param value4   - The W or A component of the new value, if the constant only
         *                 uses 3 components this value is discarded.
         * @return void
         */
        @Signature
        public native void SetShaderConstantByName(int shaderID, String szName, float value1, float value2,
                        float value3, float value4);

        /**
         * Sets the bias to shift shadows so that object surfaces don't shadow
         * themselves, default is 0.001. This can help prevent shadow artifacts on
         * surfaces that are in light but also casting a shadow behind themselves.
         *
         * @param bias - The distance to shift shadows
         * @return void
         */
        @Signature
        public native void SetShadowBias(float bias);

        /**
         * Sets a shader constant array index by name, the constant must be marked as
         * "uniform" in the shader source. Array indices start at 0, if the array index
         * is out of bounds then it will be ignored and no changes will be made. This
         * will affect all objects drawn using this shader. All shader values have 1 to
         * 4 components, this command accepts 4 values and discards any that are not
         * used by the named variable.
         *
         * @param shaderID   - The ID of the shader to modify.
         * @param szName     - The name of the constant to change, as defined in the
         *                   shader source file.
         * @param arrayIndex - The index of the element within the array to modify.
         * @param value1     - The X or R component of the new value, this value will
         *                   always be used.
         * @param value2     - The Y or G component of the new value, if the constant
         *                   only uses 1 component this value is discarded.
         * @param value3     - The Z or B component of the new value, if the constant
         *                   only uses 2 components this value is discarded.
         * @param value4     - The W or A component of the new value, if the constant
         *                   only uses 3 components this value is discarded.
         * @return void
         */
        @Signature
        public native void SetShaderConstantArrayByName(int shaderID, String szName, int arrayIndex, float value1,
                        float value2, float value3, float value4);

        /**
         * Sets the animation speed (Default 1.0), negative values are allowed to
         * reverse the animation.
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param speed     - The speed of the animation with 1.0 being normal speed
         * @return void
         */
        @Signature
        public native void SetSkeleton2DAnimationSpeed(int iSkeleton, float speed);

        /**
         * Sets the resolution of the backbuffer where possible. If your chosen
         * resolution is greater than the device can display than the device will use
         * its highest possible resolution, you can use GetDeviceWidth and
         * GetDeviceHeight to find out what was used. On mobile devices using a screen
         * resolution with a different aspect ratio than the device will result in
         * stretching. You can check the aspect ratio of the device with
         * GetMaxDeviceWidth and GetMaxDeviceHeight. It is not recommended that you
         * allow both portrait and landscape orientations when using this command as AGK
         * cannot prevent stretching without undoing your desired screen resolution so
         * it will not do so. If you want all orientations without stretching you will
         * need to monitor GetMaxDeviceWidth and GetMaxDeviceHeight for changes and set
         * an appropriate replacement resolution with SetScreenResolution to match the
         * new aspect ratio. Using a resolution of 0 in either direction will reset the
         * screen resolution to the maximum resolution supported on the device. Note
         * that on Windows and Mac the backbuffer size is changed by modifying the size
         * of the window, so it will overwrite any settings from SetWindowSize. This may
         * not be the case in the future and AGK may be able to have separate window
         * sizes and backbuffer sizes in a future version.
         *
         * @param width  - The desired width of the screen in pixels.
         * @param height - The desired height of the screen in pixels.
         * @return void
         */
        @Signature
        public native void SetScreenResolution(int width, int height);

        /**
         * The function sets the area of the screen that will be drawn to in subsequent
         * Sync() or Render() commands. The area is defined by two points representing
         * the top left and bottom right corners of a rectangle which will be the new
         * drawing area. By default this is set to your virtual resolution so anything
         * placed outside this resolution is not be visible. Using SetScissor(0,0,0,0)
         * is a special case that will turn off all clipping and make the full screen
         * useable for displaying things. This can be useful when making an app that
         * works across varying aspect ratios. For example using a virtual resolution of
         * 1024x768 on a device with a 1280x800 screen would fit the 1024x768 area as
         * closely as possible in the center of the screen, with black borders either
         * side. SetScissor(0,0,0,0) places the 1024x768 area in the same place, but
         * there are no black borders, so placing something at a negative X position
         * would still be visible for as long as the screen can still fit it in. Whereas
         * placing something at a negative position on a device with a 1024x768 screen
         * (which fits your virtual resolution perfectly), would make that item
         * disappear off the edge of the screen. You can use this with the commands
         * GetScreenBoundsLeft, GetScreenBoundsRight, GetScreenBoundsTop, and
         * GetScreenBoundsBottom to find the actual edge of the screen in your chosen
         * resolution. This allows you to place items at the edge of the screen on all
         * devices regardless of its aspect ratio.
         *
         * @param x  - The x component of the first coordinate.
         * @param y  - The y component of the first coordinate.
         * @param x2 - The x component of the second coordinate.
         * @param y2 - The y component of the second coordinate.
         * @return void
         */
        @Signature
        public native void SetScissor(float x, float y, float x2, float y2);

        /**
         * Redirects all future draw calls to an image instead of to the screen. The
         * specified image could then be applied to an object or sprite. Be careful not
         * to apply to an object or sprite at the same time as it is being drawn to as
         * this could result in an error. You can also choose to render the depth
         * information to an image that you can use later, or render without a depth
         * buffer if your scene does not need one. You can also use a depth image ID of
         * -1 to render a depth buffer without capturing it in an image. Note that some
         * devices (particularly Android) do not support rendering depth to an image, in
         * these cases the only valid values for the depth ID are 0 and -1. You can
         * check if the current device supports depth textures by using
         * IsSupportedDepthTexture. Render images can be any size, and do not need to be
         * a power of 2 in width or height. For a more detailed explanation, when you
         * render to an image it will draw to the image exactly what it would have drawn
         * to the screen. For example if your virtual resolution is 1024x768 and
         * requires borders then it will draw borders onto the render image. This means
         * if you were to look at the resulting render image in its native form, e.g.
         * 1024x1024, it will look like you've taken a 1024x768 window and stretched it
         * vertically into a square. The result is that if you take this square image
         * and stretch it back into 1024x768, by texturing a sprite or quad that happens
         * to be 1024x768 in size, then it will look normal again. This means you can
         * render a 1024x768 window to an image of any size, say 64x512, and stretch it
         * to 1024x768 and it should look correct aspect ratio wise, it will of course
         * be missing some detail. You can then get more advanced by changing the
         * virtual resolution after setting a render image and changing it back when
         * rendering to the screen, or using SetCameraAspect to change the 3D aspect
         * ratio if the render image is going to be used for something other than a 1:1
         * representation of the screen. When rendering to an image it is very important
         * that the image be cleared with ClearScreen() before drawing a new scene to
         * it. This is so the GPU knows it can discard the previous contents. If the
         * image is not cleared and things keep getting drawn to it then performance on
         * some GPUs will degrade over time.
         *
         * @param colorImage - The ID of the image to use as the color buffer, 0 to not
         *                   render color
         * @param depthImage - The ID of the image to use as the depth buffer, 0 to not
         *                   render depth, -1 to use a depth buffer without an image
         * @return void
         */
        @Signature
        public native void SetRenderToImage(int colorImage, int depthImage);

        /**
         * Sets the folder where files created by AGK will be stored. This has no effect
         * on iOS since it cannot write outside its app folder. You can set this to any
         * absolute path on the device, however some locations, such as the Program
         * Files folder on Windows, will require administrator privileges to write to
         * them. Some locations will be protected by the operating system,
         * SetRawWritePath will let you set the path to these locations but any attempt
         * to write to them will fail. You can use GetDocumentsPath to get the system
         * defined documents folder for the current user, or sdcard folder on Android,
         * which is guaranteed to allow write access. This command is now deprecated.
         * The preferred method of accessing files outside of the usual write folder is
         * to use the OpenRawFolder commands and "raw:" file paths.
         *
         * @param str - The path to use as the write folder
         * @return void
         */
        @Signature
        public native void SetRawWritePath(String str);

        /**
         * When using cascade shadow maps (SetShadowMappingMode 3), this command sets
         * the range that each cascade map will cover. In total there are 4 cascade
         * shadow maps, the fourth one always covers the entire shadowed area (cascade4
         * = 1.0), by default the third cascade covers half the shadowed area (cascade3
         * = 0.5), the second cascade covers a quarter of the shadowed area (cascade2 =
         * 0.25), and the first cascade covers one eighth of the shadowed area (cascade1
         * = 0.125). Since all the cascade shadow maps use the same resolution, the
         * smaller the area it covers the greater the shadow detail will be in that
         * area. The cascade shadow maps are ordered so that the smallest one is closest
         * to the camera, and the largest is the furthest away. In this way the shadows
         * close to the camera should have high detail whilst the ones furthest away,
         * which area less noticeable, will have lower detail. Note that whilst using a
         * smaller area for a particular cascade will increase the shadow quality, it
         * will reduce the area which that cascade covers, so shadow quality will drop
         * to the next level sooner as the distance from the camera increases. Cascade
         * levels must be in the range 0.0 to 1.0, and each level must be greater than
         * the previous level, i.e. cascade2 must be greater than cascade1, and so on.
         * If these rules are broken then this command will do nothing.
         *
         * @param cascade1 - The smallest cascade level, must be less than cascade2,
         *                 must be greater than 0.0
         * @param cascade2 - The second cascade level, must be less than cascade3
         * @param cascade3 - The third cascade level, must be less than 1.0
         * @return void
         */
        @Signature
        public native void SetShadowCascadeValues(float cascade1, float cascade2, float cascade3);

        /**
         * Attempts to hide or show any mouse pointer used on this platform. Not
         * guaranteed to work on all platforms.
         *
         * @param visible - 1 to make it visible, 0 to hide it.
         * @return void
         */
        @Signature
        public native void SetRawMouseVisible(int visible);

        /**
         * Attempts to position any mouse pointer used on this platform. Not guaranteed
         * to work on all platforms. Will only work whilst your app window has focus.
         *
         * @param x - The X component of the new mouse position.
         * @param y - The Y component of the new mouse position.
         * @return void
         */
        @Signature
        public native void SetRawMousePosition(float x, float y);

        /**
         * Sets the dead zone for all real joysticks so that any X or Y value below the
         * given threshold will return 0 instead. This value must be between 0 and 1, by
         * default it is set to 0.15.
         *
         * @param threshold - The value below which 0 will be returned.
         * @return void
         */
        @Signature
        public native void SetRawJoystickDeadZone(float threshold);

        /**
         * Some platforms have high resolution screens such as the iPad, this function
         * determines how those platforms display their content. You have the choice of
         * mode=1 which will use a full resolution frame buffer that will look better,
         * or mode=0 that will use a smaller resolution frame buffer (usually half
         * sized) which is then scaled to fit the screen, and will run faster. This does
         * not affect low resolution devices that will always use a low resolution frame
         * buffer.
         *
         * @param mode - 1 to use a high (native) resolution, 0 to use a low (scaled)
         *             resolution
         * @return void
         */
        @Signature
        public native void SetResolutionMode(int mode);

        /**
         * Sets the seed for the random number generator. Two AGK applications using the
         * same seed value will generate the same sequence of random numbers. By default
         * the seed is set to the current time on startup so that each run of the
         * application will generate a different sequence of numbers.
         *
         * @param seed - The seed value, between 1 and 2^32
         * @return void
         */
        @Signature
        public native void SetRandomSeed(int seed);

        /**
         * This command sets the render pipeline to output any future draw calls to the
         * screen. This is the default mode so you only need to call this if you have
         * previously redirected drawing to an image with SetRenderToImage.
         *
         * @return void
         */
        @Signature
        public native void SetRenderToScreen();

        /**
         * This command is used on Android to set the SenderID used by the Firebase
         * project. Currently keyName must be set to "SenderID" (case sensitive), and
         * the keyValue must be set to the SenderID value that can be found in your
         * Firebase project settings, in the Cloud Messaging tab.
         *
         * @param keyName  - The key to set
         * @param keyValue - The key value
         * @return void
         */
        @Signature
        public native void SetPushNotificationKeys(String keyName, String keyValue);

        /**
         * Sets the spacing between letters. A value of 0 puts no gap between the letter
         * bounding boxes, a positive value increases this gap, a negative value
         * overlaps the letters. This is a global command and will affect all printed
         * text in the next call to Sync. To control spacing on a per string basis use
         * the Text commands.
         *
         * @param fSpacing - The letter spacing to use.
         * @return void
         */
        @Signature
        public native void SetPrintSpacing(float fSpacing);

        /**
         * Sets the size that printed text will appear on the screen. This is a global
         * command and will affect all printed text in the next call to Sync. To control
         * size on a per string basis use the Text commands.
         *
         * @param fSize - The size in virtual resolution pixels for the text.
         * @return void
         */
        @Signature
        public native void SetPrintSize(float fSize);

        /**
         * Sets the font to use for all Print text, the font must have been previously
         * loaded with LoadFont. Use a font ID of 0 to use the AGK default font.
         *
         * @param fontID - The font ID to use for Print text
         * @return void
         */
        @Signature
        public native void SetPrintFont(int fontID);

        /**
         * Sets the seed for the random number generator. Two AGK applications using the
         * same seed value will generate the same sequence of random numbers. By default
         * the seed is set to the current time on startup so that each run of the
         * application will generate a different sequence of numbers.
         *
         * @param seed - The seed value, between 1 and 2^32
         * @return void
         */
        @Signature
        public native void SetRandomSeed2(int seed);

        /**
         * Sets the color of the printed text. This is a global command and will affect
         * all printed text in the next call to Sync. To control color on a per string
         * basis use the Text commands. This version sets the alpha to 255, fully
         * opaque.
         *
         * @param iRed   - The red component of the color.
         * @param iGreen - The green component of the color.
         * @param iBlue  - The blue component of the color.
         * @return void
         */
        @Signature
        public native void SetPrintColor(int iRed, int iGreen, int iBlue);

        /**
         * Sets the color of the printed text. This is a global command and will affect
         * all printed text in the next call to Sync. To control color on a per string
         * basis use the Text commands. This version sets the alpha to 255, fully
         * opaque.
         *
         * @param iRed   - The red component of the color.
         * @param iGreen - The green component of the color.
         * @param iBlue  - The blue component of the color.
         * @param iAlpha - The alpha component of the color.
         * @return void
         */
        @Signature
        public native void SetPrintColor(int iRed, int iGreen, int iBlue, int iAlpha);

        /**
         * Changes the point light to a new radius of affect. Objects greater than this
         * distance from the light will receive zero light from it.
         *
         * @param lightID - The ID of the light to modify.
         * @param radius  - The distance that the light can affect.
         * @return void
         */
        @Signature
        public native void SetPointLightRadius(int lightID, float radius);

        /**
         * Places the point light at a new position.
         *
         * @param lightID - The ID of the light to modify.
         * @param x       - The X component of the new position.
         * @param y       - The Y component of the new position.
         * @param z       - The Z component of the new position.
         * @return void
         */
        @Signature
        public native void SetPointLightPosition(int lightID, float x, float y, float z);

        /**
         * Sets the distance a touch event has to move before it gets classed as a drag
         * event. By default this is set at 6.
         *
         * @param distance - The distance the touch event has to move in virtual
         *                 coordinates
         * @return void
         */
        @Signature
        public native void SetRawTouchMoveSensitivity(int distance);

        /**
         * Allows you to set some custom data to be stored in this event that you can
         * retrieve later. Could be a value or pointer.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @param value  - The value to store with this event.
         * @return void
         */
        @Signature
        public native void SetRawTouchValue(int iIndex, int value);

        /**
         * Changes the point light to a new color. Values should be in the range 0-255
         * but are not limited to it. Values greater than 255 will over saturate things
         * and values less than 0 will take light away.
         *
         * @param lightID - The ID of the light to modify.
         * @param red     - The red component of the light color.
         * @param green   - The green component of the light color.
         * @param blue    - The blue component of the light color.
         * @return void
         */
        @Signature
        public native void SetPointLightColor(int lightID, int red, int green, int blue);

        /**
         * Toggles the existence of a physics wall at the top of the screen to prevent
         * physics objects leaving the screen in that direction. If you have physics
         * objects beyond the edge of the screen, e.g. in a platform game, you should
         * turn this off. If you change the view offset using SetViewOffset the walls
         * will not move with it, they are fixed to the world, so they will be disabled
         * automatically.
         *
         * @param mode - 0=off, 1=on
         * @return void
         */
        @Signature
        public native void SetPhysicsWallTop(int mode);

        /**
         * Toggles the existence of a physics wall on the right of the screen to prevent
         * physics objects leaving the screen in that direction. If you have physics
         * objects beyond the edge of the screen, e.g. in a platform game, you should
         * turn this off. If you change the view offset using SetViewOffset the walls
         * will not move with it, they are fixed to the world, so they will be disabled
         * automatically.
         *
         * @param mode - 0=off, 1=on
         * @return void
         */
        @Signature
        public native void SetPhysicsWallRight(int mode);

        /**
         * Sets the number of threads to use during physics. A value of 0 or 1 turns off
         * multi-threading, a value of minus 1 chooses a value matching the number of
         * processors in the device for best performance. Using a value higher than the
         * number of processors in the device is likely to hurt performance. Default is
         * minus 1.
         *
         * @param threads - The number of threads to use, minus 1 to automatically
         *                choose a number appropriate for the device
         * @return void
         */
        @Signature
        public native void SetPhysicsThreading(int threads);

        /**
         * Sets the ability of dynamic bodies to sleep when they are not moving, this
         * dramatically improves performance when dynamic bodies have settled into their
         * final positions. Turning it off is only useful for benchmarking when you want
         * to keep the CPU active processing all bodies all the time. Default is on.
         *
         * @param mode - 0 to disable sleeping, 1 to turn it on
         * @return void
         */
        @Signature
        public native void SetPhysicsSleeping(int mode);

        /**
         * Sets the scale used by the physics system compared with world coordinates. By
         * design the physics system is set to use 1 unit as equalling 1 meter, which in
         * the case of default world coordinates (100,100) would mean that the screen is
         * 100 meters by 100 meters in the physics simulation. However by design the
         * physics system is designed to work best with dynamic objects ranging from 0.1
         * meters to 10 meters in size, and with static objects up to 50 meters, so the
         * screen is scaled down when sent to the physics system, by default the scale
         * is 0.2, so in the physics world the screen is 20 meters by 20 meters. This is
         * purely to allow the physics system to work at its designed scale whilst
         * allowing world coordinates to be used as parameters with the AGK doing all
         * the necessary scaling behind the scenes. This function allows you to change
         * the scale factor if your virtual resolution is going to be different from
         * 100,100. This function must be called before any other physics functions, and
         * must not be called once the physics system is running.
         *
         * @param scale - The new scale value to use for all screen to physics values
         *              and vice versa.
         * @return void
         */
        @Signature
        public native void SetPhysicsScale(float scale);

        /**
         * Sets the maximum number of points that will be generated in future polygon
         * physics shapes, does not affect already generated shapes, may be called
         * multiple times. Only affects shapes generated by the AGK through
         * SetSpriteShape. Must be between 2 and 12. The default setting is 8.
         *
         * @param points - The maximum number of points allowed in new polygon shapes.
         * @return void
         */
        @Signature
        public native void SetPhysicsMaxPolygonPoints(int points);

        /**
         * Changes the range of the global force. Sprites greater than this distance
         * from the force position will not feel its effects. A range less than zero
         * equals an infinite range.
         *
         * @param iForceIndex - The ID of the force to modify.
         * @param range       - The new range of the force.
         * @return void
         */
        @Signature
        public native void SetPhysicsForceRange(int iForceIndex, float range);

        /**
         * Sets the gravity vector for all sprites using physics. The x and y values
         * will be scaled into physics space so will only represent meters per second
         * squared when scale = 1.0, in world space the values represent pixels per
         * second squared. For example in the default scale of 0.2, a SetPhysicsGravity
         * value of 0,50 would represent 10 meters per second squared. Gravity is a
         * constant acceleration applied to all physics objects equally, regardless of
         * mass. Whereas a force applies an acceleration proportional to the objects
         * mass. To counteract gravity with a force will require accounting for mass.
         *
         * @param x - The X component of the gravity vector.
         * @param y - The Y component of the gravity vector.
         * @return void
         */
        @Signature
        public native void SetPhysicsGravity(float x, float y);

        /**
         * Toggles the existence of a physics wall on the left of the screen to prevent
         * physics objects leaving the screen in that direction. If you have physics
         * objects beyond the edge of the screen, e.g. in a platform game, you should
         * turn this off. If you change the view offset using SetViewOffset the walls
         * will not move with it, they are fixed to the world, so they will be disabled
         * automatically.
         *
         * @param mode - 0=off, 1=on
         * @return void
         */
        @Signature
        public native void SetPhysicsWallLeft(int mode);

        /**
         * Changes the strength of the global force. For forces that fade this will be
         * the strength at 1 unit from the force position. The force is in Newtons, and
         * is similar in size to gravity except that it is affected by the mass of the
         * object. For example, for an object of mass of 1 kg and a force of 10 newtons
         * will affect the object in the same way as gravity set at 10 m/s^2. For a mass
         * of 2 kg it is harder to move, so a force of 10 Newtons would be half as
         * effective at moving the object as gravity at 10m/s^2.
         *
         * @param iForceIndex - The ID of the force to modify.
         * @param power       - The new strength of the force.
         * @return void
         */
        @Signature
        public native void SetPhysicsForcePower(int iForceIndex, float power);

        /**
         * Enables the drawing of internal physics shapes on screen. If you
         * SetViewOffset to something other than 0,0 make sure none of your physics
         * sprites are fixed to the screen using FixSpriteToScreen otherwise the debug
         * shapes will not line up. Debug outlines are drawn as world sprites. The debug
         * output will draw the shape of every physics sprite set using
         * SetSpritePhysicsOn and all non physics sprites that have a shape assigned for
         * non-physics collision commands. The shapes will be drawn in the following
         * colors: Cream=Dynamic physics object, Green=Static physics object, Dark
         * Blue=Kinematic physics object, Light Blue=Non-physics object. Grey=Sleeping
         * dynamic physics object. Additionally physics objects will be drawn as shaded
         * with an outline, non-physics objects will be an outline only.
         *
         * @return void
         */
        @Signature
        public native void SetPhysicsDebugOn();

        /**
         * Turns Continuous Collision Detection on and off. This prevents fast moving
         * objects from tunnelling through static bodies. To prevent fast moving objects
         * passing through each other use SetSpritePhysicsIsBullet When you have a large
         * number of dynamic bodies CCD can be the bottleneck in the physics engine,
         * especially when threading is turned on as this part is not currently
         * threaded. Default is off.
         *
         * @param mode - 0 to disable CCD, 1 to turn it on
         * @return void
         */
        @Signature
        public native void SetPhysicsCCD(int mode);

        /**
         * Sets the point light to vertex or pixel mode. Vertex mode is faster but pixel
         * mode has better quality. By default lights are created in vertex mode. A mesh
         * can be lit by up to 8 vertex lights and 4 pixel lights at a time, if you add
         * more lights than this then the closest lights will be used by the mesh.
         *
         * @param lightID - The ID of the light to modify.
         * @param mode    - 0 for vertex, 1 for pixel mode.
         * @return void
         */
        @Signature
        public native void SetPointLightMode(int lightID, int mode);

        /**
         * Sets whether the emitted particles are drawn. Set to 1 to show particles, 0
         * to hide them. Particles will still update whilst hidden, you can stop
         * particles updating with SetParticlesActive
         *
         * @param ID      - The ID of the emitter to modify.
         * @param visible - 1=show, 0=hide
         * @return void
         */
        @Signature
        public native void SetParticlesVisible(int ID, int visible);

        /**
         * Toggles the existence of a physics wall at the bottom of the screen to
         * prevent physics objects leaving the screen in that direction. If you have
         * physics objects beyond the edge of the screen, e.g. in a platform game, you
         * should turn this off. If you change the view offset using SetViewOffset the
         * walls will not move with it, they are fixed to the world, so they will be
         * disabled automatically.
         *
         * @param mode - 0=off, 1=on
         * @return void
         */
        @Signature
        public native void SetPhysicsWallBottom(int mode);

        /**
         * Sets the area around the emitter where new particles may appear. The values
         * are relative to the emitter position, for example a zone of 0,0,0,0 would
         * mean that all particles start on the emitter position point. A zone of -10 in
         * x and +10 x, with y being 0 (-10,0,10,0) would create a line centered on the
         * emitter position that particles would randomly appear along. A box zone where
         * both x and y are non-zero sizes would mean that particles could start at any
         * point inside the box.
         *
         * @param ID - The ID of the emitter to modify.
         * @param x1 - The x coordinate of the top left corner of the start zone.
         * @param y1 - The y coordinate of the top left corner of the start zone.
         * @param x2 - The x coordinate of the bottom right corner of the start zone.
         * @param y2 - The y coordinate of the bottom right corner of the start zone.
         * @return void
         */
        @Signature
        public native void SetParticlesStartZone(int ID, float x1, float y1, float x2, float y2);

        /**
         * Sets the size of all particles in world coordinates. Setting a large number
         * of particles to a large size will perform poorly on mobile devices that have
         * a low fill rate (number of pixels it can draw per second).
         *
         * @param ID   - The ID of the emitter to modify.
         * @param size - Size of the particles
         * @return void
         */
        @Signature
        public native void SetParticlesSize(int ID, float size);

        /**
         * Changes the position of the global force in world coordinates.
         *
         * @param iForceIndex - The ID of the force to modify.
         * @param x           - The x component of the new position.
         * @param y           - The y component of the new position.
         * @return void
         */
        @Signature
        public native void SetPhysicsForcePosition(int iForceIndex, float x, float y);

        /**
         * Disables the drawing of internal physics shapes on screen.
         *
         * @return void
         */
        @Signature
        public native void SetPhysicsDebugOff();

        /**
         * Sets the range of rotation in radians that a particle can have during its
         * life. When a particle is created it starts at angle 0 and chooses and random
         * rotation rate between angle1 and angle2. The particle will then rotate at
         * that chosen rate for its entire life. Use negative values for
         * counter-clockwise rotation and positive for clockwise rotation.
         *
         * @param ID     - The ID of the emitter to modify.
         * @param angle1 - The minimum angle of the range in degrees per second.
         * @param angle2 - The maximum angle of the range in degrees per second.
         * @return void
         */
        @Signature
        public native void SetParticlesRotationRange(int ID, float angle1, float angle2);

        /**
         * Sets the position of the particle emitter. This is the position that new
         * particles will emerge from and does not affect particles that are already
         * visible.
         *
         * @param ID - The ID of the emitter to modify.
         * @param x  - The new x coordinate for the emitter in world coordinates.
         * @param y  - The new y coordinate for the emitter in world coordinates.
         * @return void
         */
        @Signature
        public native void SetParticlesPosition(int ID, float x, float y);

        /**
         * Sets the maximum number of particles that will be emitted. If this value is
         * equal to -1 then the number is infinite. The emitter will keep a count of the
         * number of particles it emits and stop when the limit is reached. To check if
         * the emitter has reached its limit use GetParticlesMaxReached. To reset the
         * count and make it start emitting again use ResetParticleCount.
         *
         * @param ID  - The ID of the emitter to modify.
         * @param max - The maximum number of particles to emit
         * @return void
         */
        @Signature
        public native void SetParticlesMax(int ID, int max);

        /**
         * Sets the image to use for each particle. Since 1083 images can be loaded from
         * sub images contained on atlas textures.
         *
         * @param ID      - The ID of the emitter to modify.
         * @param imageID - The ID of an image to use for emitted particles.
         * @return void
         */
        @Signature
        public native void SetParticlesImage(int ID, int imageID);

        /**
         * Set the particle transparency to a particular setting, with a choice of no
         * transparency, alpha transparency, and additive blending. By default particles
         * are created with alpha transparency.
         *
         * @param ID   - The ID of the particle emitter to modify.
         * @param mode - The transparency mode for these particles, 0=off, 1=alpha
         *             transparency, 2=additive blending
         * @return void
         */
        @Signature
        public native void SetParticlesTransparency(int ID, int mode);

        /**
         * Sets particles to rotate to the direction they are moving. This overrides any
         * use of SetParticlesRotationRange to modify the rate at which particles
         * rotate. Instead particles will always rotate to face their direction of
         * travel.
         *
         * @param ID   - The ID of the emitter to modify.
         * @param mode - 1 to make particles rotate to the direction they are moving, 0
         *             to use normal rotation.
         * @return void
         */
        @Signature
        public native void SetParticlesFaceDirection(int ID, int mode);

        /**
         * Sets the initial direction of new particles when they emerge from the
         * emitter. This can be used along with the SetParticlesAngle command to set the
         * range of variation from this initial direction that new particles can choose.
         * This also sets the initial speed of the particles by taking the length of the
         * vector as units per second. For example if the initial direction is vx=10,
         * vy=-15, particles will begin by moving to the right at a rate of 10 units per
         * second and upwards at a rate of 15 units per second and will continue this
         * rate of motion for their entire life unless influenced by forces added with
         * AddParticlesForce.
         *
         * @param ID - The ID of the emitter to modify.
         * @param vx - The x direction that particles will move initially.
         * @param vy - The y direction that particles will move initially.
         * @return void
         */
        @Signature
        public native void SetParticlesDirection(int ID, float vx, float vy);

        /**
         * Sets a minimum and maximum multiplier that will affect particles being
         * emitted. This can be used to ensure that there will be some variation when
         * particles are emitted.
         *
         * @param ID - The ID of the emitter to modify.
         * @param v1 - The minimum velocity multiplier.
         * @param v2 - The maximum velocity multiplier.
         * @return void
         */
        @Signature
        public native void SetParticlesVelocityRange(int ID, float v1, float v2);

        /**
         * Sets the range of rotation in radians that a particle can have during its
         * life. When a particle is created it starts at angle 0 and chooses and random
         * rotation rate between angle1 and angle2. The particle will then rotate at
         * that chosen rate for its entire life. Use negative values for
         * counter-clockwise rotation and positive for clockwise rotation.
         *
         * @param ID     - The ID of the emitter to modify.
         * @param angle1 - The minimum angle of the range in radians per second.
         * @param angle2 - The maximum angle of the range in radians per second.
         * @return void
         */
        @Signature
        public native void SetParticlesRotationRangeRad(int ID, float angle1, float angle2);

        /**
         * Sets the depth of the particle emitter. This affects all particles, even
         * those that are already visible. All particles are drawn at the same depth as
         * the emitter so that the AGK can group them into a single draw call for faster
         * drawing. The depth should be between 0 and 10000, with 0 being the front of
         * the screen.
         *
         * @param ID    - The ID of the emitter to modify.
         * @param depth - The new depth value of the particles.
         * @return void
         */
        @Signature
        public native void SetParticlesDepth(int ID, int depth);

        /**
         * Sets the range of direction in radians that a particle can choose when it
         * first starts. This takes the base direction set with SetParticlesDirection
         * and adjusts it by a random amount between 0 and angle/2 radians. For example
         * an angle of 0 would mean that all new particles follow exactly the direction
         * specified earlier. An angle of 2*PI would mean that particles could appear
         * travelling in any direction, and an angle of PI/2 would mean that particles
         * would travel outward in a cone of PI/2 radians from their start position with
         * the cone centered on the given direction.
         *
         * @param ID    - The ID of the emitter to modify.
         * @param angle - The range of variation a particle can choose from the emitter
         *              direction.
         * @return void
         */
        @Signature
        public native void SetParticlesAngleRad(int ID, float angle);

        /**
         * Sets the interpolation mode for color changes. Colors can be set at certain
         * points in a particle's life using AddParticlesColorKeyFrame and the particle
         * will either blend between these colors or quickly change when it reaches the
         * next color change.
         *
         * @param ID   - The ID of the emitter to modify.
         * @param mode - 1=smooth interpolation, 0=no interpolation
         * @return void
         */
        @Signature
        public native void SetParticlesColorInterpolation(int ID, int mode);

        /**
         * Sets the range of direction in degrees that a particle can choose when it
         * first starts. This takes the base direction set with SetParticlesDirection
         * and adjusts it by a random amount between 0 and angle/2 degrees. For example
         * an angle of 0 would mean that all new particles follow exactly the direction
         * specified earlier. An angle of 360 would mean that particles could appear
         * travelling in any direction, and an angle of 90 would mean that particles
         * would travel outward in a cone of 90 degrees from their start position with
         * the cone centered on the given direction.
         *
         * @param ID    - The ID of the emitter to modify.
         * @param angle - The range of variation a particle can choose from the emitter
         *              direction.
         * @return void
         */
        @Signature
        public native void SetParticlesAngle(int ID, float angle);

        /**
         * Sets whether the emitted particles are updated every frame. Set to 1 to
         * update particles as normal, 0 to pause them. Particles will continue to be
         * visible when paused. To hide particles use SetParticlesVisible.
         *
         * @param ID     - The ID of the emitter to modify.
         * @param active - 1=normal, 0=pause
         * @return void
         */
        @Signature
        public native void SetParticlesActive(int ID, int active);

        /**
         * Sets which orientations the AGK will allow the app to rotate to. There are
         * two portrait and two landscape orientations, one for the right way up and the
         * other for upside down. On platforms that can't rotate, like Windows or Mac,
         * this command has no effect and the app will always be drawn right way up. A
         * value of 1 for each orientation will determine if the app will rotate when
         * the device is held in that orientation. A value of 0 will keep the app at its
         * last valid orientation. Note that if the device is currently in a disallowed
         * orientation then AGK will attempt to rotate the device into an allowed
         * orientation, however this is not guaranteed to happen immediately. So, for
         * example, if you need the device to be in landscape and you call this command
         * with only landscape allowed, you should then wait for GetDeviceWidth to
         * return greater than GetDeviceHeight which will signal that the device is now
         * in landscape.
         *
         * @param portrait   - The default device orientation.
         * @param portrait2  - The upside down portrait orientation.
         * @param landscape  - The landscape orientation when the device is rotated left
         *                   from its default position.
         * @param landscape2 - The landscape orientation when the device is rotated
         *                   right from its default position.
         * @return void
         */
        @Signature
        public native void SetOrientationAllowed(int portrait, int portrait2, int landscape, int landscape2);

        /**
         * Sets whether this object is visible or not. It will still participate in
         * collisions and other non-visual interactions.
         *
         * @param objID - The ID of the object to modify.
         * @param mode  - 1 to set this object as visible, 0 to hide it.
         * @return void
         */
        @Signature
        public native void SetObjectVisible(int objID, int mode);

        /**
         * Modifies all meshes in the object to use the specified UV offset, see
         * SetObjectMeshUVOffset for more information.
         *
         * @param objID        - The ID of the object to modify.
         * @param textureStage - The texture stage of the UVs to modify, in the range 0
         *                     to 7
         * @param offsetU      - The offset to use in the U direction, the default is 0
         * @param offsetV      - The offset to use in the V direction, the default is 0
         * @return void
         */
        @Signature
        public native void SetObjectUVOffset(int objID, int textureStage, float offsetU, float offsetV);

        /**
         * Sets the life of particles once they have been emitted in seconds. After
         * particles have been alive for the given number of seconds they will
         * disappear. This is one of the two values that affects the number of particles
         * generated, the other being SetParticlesFrequency. The maximum number of
         * particles that can be on screen at any one time is freq*life, with freq being
         * the number of particles emitted per second. This value is independent of
         * frame rate.
         *
         * @param ID   - The ID of the emitter to modify.
         * @param time - The time in seconds that a particle is visible.
         * @return void
         */
        @Signature
        public native void SetParticlesLife(int ID, float time);

        /**
         * Sets the objects collision shape to a static triangle mesh based on the size
         * of the object. The object becomes a static object a triangle mesh shape can
         * not be dynamic. You must first create a physics body for the object or this
         * command will fail.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void SetObjectShapeStaticPolygon(int objID);

        /**
         * Sets the collision shape to a sphere based on the size of the object. You
         * must first create a physics body for the object or this command will fail.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void SetObjectShapeSphere(int objID);

        /**
         * Sets the collision shape to a sphere based on the size of the object. You
         * must first create a physics body for the object or this command will fail.
         *
         * @param objID    - object ID
         * @param diameter - size of sphere
         * @return void
         */
        @Signature
        public native void SetObjectShapeSphere(int objID, float diameter);

        /**
         * Sets the frequency of new particle generation. The freq value states how many
         * particles should be produced per second, this is independent of frame rate.
         * This is one of the two values that affects the number of particles generated,
         * the other being SetParticlesLife. The maximum number of particles that can be
         * on screen at any one time is freq*life, with life being the number of seconds
         * a particle lives before it disappears. This value is independent of frame
         * rate.
         *
         * @param ID   - The ID of the emitter to modify.
         * @param freq - The rate of new particle production in particles per second.
         * @return void
         */
        @Signature
        public native void SetParticlesFrequency(int ID, float freq);

        /**
         * Sets the collision shape to a Cylinder based on the size of the object. You
         * must first create a physics body for the object or this command will fail.
         *
         * @param objID - object ID
         * @param axis  - 0 =X axis, 1 =Y axis, 2 = Z axis orientation
         * @return void
         */
        @Signature
        public native void SetObjectShapeCylinder(int objID, int axis);

        /**
         * Sets the collision shape to a Cylinder based on the size of the object. You
         * must first create a physics body for the object or this command will fail.
         *
         * @param objID    - object ID
         * @param axis     - 0 =X axis, 1 =Y axis, 2 = Z axis orientation
         * @param height   - height on the y
         * @param diameter - diameter on the x and z
         * @return void
         */
        @Signature
        public native void SetObjectShapeCylinder(int objID, int axis, float height, float diameter);

        /**
         * Sets the objects collision shape to a compound shape ready to add more
         * shapes. The object must be dynamic.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void SetObjectShapeCompound(int objID);

        /**
         * Sets the collision shape to a cone based on the size passed in. You must
         * first create a physics body for the object or this command will fail. Returns
         * shape ID.
         *
         * @param objID    - object ID
         * @param axis     - 0 =X axis, 1 =Y axis, 2 = Z axis orientation
         * @param height   - height on the y
         * @param diameter - diameter on the x and z
         * @return void
         */
        @Signature
        public native void SetObjectShapeCone(int objID, int axis, float height, float diameter);

        /**
         * Sets the collision shape to a cone based on the size passed in. You must
         * first create a physics body for the object or this command will fail. Returns
         * shape ID.
         *
         * @param objID - object ID
         * @param axis  - 0 =X axis, 1 =Y axis, 2 = Z axis orientation
         * @return void
         */
        @Signature
        public native void SetObjectShapeCone(int objID, int axis);

        /**
         * Sets the collision shape to a capsule based on the size passed in. You must
         * first create a physics body for the object or this command will fail.
         *
         * @param objID - object ID
         * @param axis  - 0 =X axis, 1 =Y axis, 2 = Z axis orientation
         * @param sizeX - dimension on the x axis
         * @param sizeY - dimension on the Y axis
         * @param sizeZ - dimension on the Z axis
         * @return void
         */
        @Signature
        public native void SetObjectShapeCapsule(int objID, int axis, float sizeX, float sizeY, float sizeZ);

        /**
         * Sets the collision shape to a capsule based on the size passed in. You must
         * first create a physics body for the object or this command will fail.
         *
         * @param objID - object ID
         * @param axis  - 0 =X axis, 1 =Y axis, 2 = Z axis orientation
         * @return void
         */
        @Signature
        public native void SetObjectShapeCapsule(int objID, int axis);

        /**
         * Sets the collision shape to a capsule based on the size passed in. You must
         * first create a physics body for the object or this command will fail.
         *
         * @param objID    - object ID
         * @param axis     - 0 =X axis, 1 =Y axis, 2 = Z axis orientation
         * @param vectorID - ID of the dimension vector.
         * @return void
         */
        @Signature
        public native void SetObjectShapeCapsule(int objID, int axis, int vectorID);

        /**
         * Sets the collision shape to a box based on the size passed in. You must first
         * create a physics body for the object or this command will fail.
         *
         * @param objID - object ID
         * @param sizeX - dimension on the x axis
         * @param sizeY - dimension on the Y axis
         * @param sizeZ - dimension on the Z axis
         * @return void
         */
        @Signature
        public native void SetObjectShapeBox(int objID, float sizeX, float sizeY, float sizeZ);

        /**
         * Sets the collision shape to a box based on the size passed in. You must first
         * create a physics body for the object or this command will fail.
         *
         * @param objID    - object ID
         * @param vectorID - Id of a dimension vector
         * @return void
         */
        @Signature
        public native void SetObjectShapeBox(int objID, int vectorID);

        /**
         * Sets the collision shape to a box based on the size passed in. You must first
         * create a physics body for the object or this command will fail.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void SetObjectShapeBox(int objID);

        /**
         * Stops an object setting the given constant name in its shaders and uses the
         * shader's default value from now on.
         *
         * @param objID  - The ID of the object to modify.
         * @param szName - The name of the constant to stop changing.
         * @return void
         */
        @Signature
        public native void SetObjectShaderConstantDefault(int objID, String szName);

        /**
         * Sets a shader constant for an object by name, the constant must be marked as
         * "uniform" in the shader source. The object will set the specified constant to
         * this value for any shader that it is applied to it. Array indices start at 0,
         * if the array index is out of bounds then it will be ignored and no changes
         * will be made. All shader values have 1 to 4 components, this command accepts
         * 4 values and discards any that are not used by the named variable.
         *
         * @param objID      - The ID of the object to modify.
         * @param szName     - The name of the constant to change, as defined in the
         *                   shader source file.
         * @param arrayIndex - The index of the element within the array to modify.
         * @param value1     - The X or R component of the new value, this value will
         *                   always be used.
         * @param value2     - The Y or G component of the new value, if the constant
         *                   only uses 1 component this value is discarded.
         * @param value3     - The Z or B component of the new value, if the constant
         *                   only uses 2 components this value is discarded.
         * @param value4     - The W or A component of the new value, if the constant
         *                   only uses 3 components this value is discarded.
         * @return void
         */
        @Signature
        public native void SetObjectShaderConstantArrayByName(int objID, String szName, int arrayIndex, float value1,
                        float value2, float value3, float value4);

        /**
         * Sets the shader used to draw the meshes in this object, each mesh can have
         * its own shader set with SetObjectMeshShader, this command sets all meshes in
         * this object to use the specified shader. The shader must have been loaded
         * with LoadShader. A shader is like a script sent to the GPU to tell it how to
         * combine the polygon and texture data to display it on screen. By default
         * meshes are assigned an internal shader that will handle lighting and
         * texturing. If you use a shader ID of 0 the meshes are assigned the internal
         * shader.
         *
         * @param objID    - The ID of the object to modify.
         * @param shaderID - The ID of the shader to use.
         * @return void
         */
        @Signature
        public native void SetObjectShader(int objID, int shaderID);

        /**
         * Modifies all meshes in the object to use the specified UV scale, see
         * SetObjectMeshUVScale for more information.
         *
         * @param objID        - The ID of the object to modify.
         * @param textureStage - The texture stage of the UVs to modify, in the range 0
         *                     to 7
         * @param scaleU       - The scale to use in the U direction, the default is 1
         * @param scaleV       - The scale to use in the V direction, the default is 1
         * @return void
         */
        @Signature
        public native void SetObjectUVScale(int objID, int textureStage, float scaleU, float scaleV);

        /**
         * Sets whether the object will be culled when it moves off screen. By default
         * AGK will attempt to detect when an object has moved off screen, and objects
         * that are no longer on screen will no longer be sent to the render pipeline.
         * If the vertex shader modifies the vertices from their normal positions then
         * this should be turned off as AGK can't know in advance where the object will
         * be drawn.
         *
         * @param objID - The ID of the object to modify.
         * @param mode  - 0 to turn off screen culling, 1 to turn it on (default).
         * @return void
         */
        @Signature
        public native void SetObjectScreenCulling(int objID, int mode);

        /**
         * Sets the transparency mode for this object, 0 is opaque, 1 is alpha blended,
         * 2 is additive blended, 3 is custom blending. Using a transparency value
         * greater than 0 will slow down rendering, it also doesn't write transparent
         * objects to the Z buffer so it might cause some depth ordering problems. There
         * is an alternative form of transparency called Alpha Masking that is useful if
         * you only need fully transparent or fully opaque pixels but no blending in
         * between. See SetObjectAlphaMask for more details. When using mode 3 (custom)
         * the blend values must be specified with SetObjectBlendModes otherwise the
         * object will not be transparent.
         *
         * @param objID - The ID of the object to modify.
         * @param mode  - The transparency mode to use for this object.
         * @return void
         */
        @Signature
        public native void SetObjectTransparency(int objID, int mode);

        /**
         * Modifies the object size in the X, Y, and Z directions. This modifies the
         * object's vertices which makes this a permanent change, and is slower than
         * SetObjectScale. This command does not read or affect the values set with
         * SetObjectScale so using SetObjectScale(ID,2,2,2) and then setting a permanent
         * scale of 3,3,3 would still draw the object 2 times bigger than normal, which
         * means 6 times bigger than when you started. This command does not affect any
         * child objects that may have been loaded with it, nor any objects attached to
         * it with FixObjectToObject. This command will work on bone animated objects as
         * long as the scale is uniform, i.e. the X, Y, and Z scale values are all the
         * same.
         *
         * @param objID - The ID of the object to modify.
         * @param x     - The amount to scale the object on the X axis.
         * @param y     - The amount to scale the object on the Y axis.
         * @param z     - The amount to scale the object on the Z axis.
         * @return void
         */
        @Signature
        public native void SetObjectScalePermanent(int objID, float x, float y, float z);

        /**
         * Sets the rotation of the specified object using euler angles in degrees.
         * Alternatively you can use SetObjectRotationQuat to use a quaternion. By
         * default objects are created with the angles 0,0,0 in the order YXZ. Euler
         * angles are compound angles where the object starts at 0,0,0 and is then
         * rotated using the given Y angle, then by the given X angle, then rolled by
         * the given Z angle. Each 3D rotation can be represented by 2 Euler angle
         * combinations, Y,X,Z and Y-180,X-180,Z-180 so either version may be returned
         * by the GetObjectAngle commands. Quaternions and Euler angles can both be used
         * at the same time. For example setting a quaternion rotation will generate
         * equivalent Euler values that can be retrieved with GetObjectAngleX,
         * GetObjectAngleX, and GetObjectAngleZ.
         *
         * @param objID - The ID of the object to modify.
         * @param angx  - The X component of the euler rotation.
         * @param angy  - The Y component of the euler rotation.
         * @param angz  - The Z component of the euler rotation.
         * @return void
         */
        @Signature
        public native void SetObjectRotation(int objID, float angx, float angy, float angz);

        /**
         * Sets the rotation of the specified object using a quaternion. Alternatively
         * you can use SetObjectRotation to use Euler angles. By default objects are
         * created with the quaternion 1,0,0,0 in the order w,x,y,z. A Quaternion is a 4
         * dimensional representation of a 3D rotation with the property w^2+x^2+y^2+z^2
         * = 1 which allows easy interpolation between two rotations by linearly
         * interpolating the two quaternions and normalising them. Each 3D rotation is
         * represented by exactly 2 quaternions, w,x,y,z and -w,-x,-y,-z so either
         * version may be returned by the GetObjectQuat commands. Quaternions and Euler
         * angles can both be used at the same time. For example setting a quaternion
         * rotation will generate equivalent Euler values that can be retrieved with
         * GetObjectAngleX, GetObjectAngleX, and GetObjectAngleZ.
         *
         * @param objID - The ID of the object to modify.
         * @param w     - The W component of the quaternion.
         * @param x     - The X component of the quaternion.
         * @param y     - The Y component of the quaternion.
         * @param z     - The Z component of the quaternion.
         * @return void
         */
        @Signature
        public native void SetObjectRotationQuat(int objID, float w, float x, float y, float z);

        /**
         * Modifies the object size in the X, Y, and Z directions. A scale value of
         * 1,1,1 returns the object to its original size, a scale value of 2 would make
         * the object twice as big, 0.5 would be half the size, and so on. This command
         * does not stack, so calling it twice with a value of 2 would not make it 4
         * times bigger, it would remain 2 times bigger. Note that using different
         * values for the X, Y, and Z directions like so 1,2,1 is called a non-uniform
         * scale, whilst 1.5,1.5,1.5 would be a uniform scale. Non-uniform scaling
         * requires that any shader used by this object use the agk_WorldNormal matrix
         * for any normal transformations to look correct. If this object was loaded
         * with LoadObjectWithChildren command and has child objects, or has objects
         * attached to it with FixObjectToObject, then they will also be scaled by this
         * amount in addition to their own scaling. Note that this will not work
         * correctly with bone animated objects, use SetObjectScalePermanent instead.
         *
         * @param objID - The ID of the object to modify.
         * @param x     - The amount to scale the object on the X axis.
         * @param y     - The amount to scale the object on the Y axis.
         * @param z     - The amount to scale the object on the Z axis.
         * @return void
         */
        @Signature
        public native void SetObjectScale(int objID, float x, float y, float z);

        /**
         * Sets an object to receive shadows from other objects. By default this is set
         * to 1. An object can be set to both cast and receive shadows.
         *
         * @param objID - The ID of the object to receive shadows
         * @param mode  - 1 to make this object receive shadows, 0 to stop it receiving
         *              shadows
         * @return void
         */
        @Signature
        public native void SetObjectReceiveShadow(int objID, int mode);

        /**
         * Sets the position of the specified object. By default objects are positioned
         * at 0,0,0
         *
         * @param objID - The ID of the object to modify.
         * @param x     - The X component of the position.
         * @param y     - The Y component of the position.
         * @param z     - The Z component of the position.
         * @return void
         */
        @Signature
        public native void SetObjectPosition(int objID, float x, float y, float z);

        /**
         * Scales the normal map UV coordinates by the specified amount. This does not
         * affect any other texture, but does stack on top of the object's UV offset and
         * scale. A scale value of 1.0 would use unmodified UVs, a scale value of 2.0
         * would double the UV value, and so on.
         *
         * @param objID  - The ID of the object to modify.
         * @param scaleU - The amount to scale the normal map in the U direction
         * @param scaleV - The amount to scale the normal map in the V direction
         * @return void
         */
        @Signature
        public native void SetObjectNormalMapScale(int objID, float scaleU, float scaleV);

        /**
         * Modifies the mesh UVs to scale them by the specified amount. This may push
         * the UV coordinates outside the range 0.0 to 1.0, in which case the image wrap
         * mode will be used to either clamp or repeat the texture. Use SetImageWrapU
         * and SetImageWrapV to set the wrap mode. A scale value of 1 will leave the UV
         * coordinates with their default values, whilst a scale value of 2.0 would
         * double the number of times the texture appears across the mesh (assuming the
         * wrap mode is set to repeat). Note that the image must be a power of 2 in size
         * to use the repeat mode.
         *
         * @param objID        - The ID of the object to modify.
         * @param meshIndex    - The index of the mesh to modify.
         * @param textureStage - The texture stage of the UVs to modify, in the range 0
         *                     to 7
         * @param scaleU       - The scale to use in the U direction, the default is 1
         * @param scaleV       - The scale to use in the V direction, the default is 1
         * @return void
         */
        @Signature
        public native void SetObjectMeshUVScale(int objID, int meshIndex, int textureStage, float scaleU, float scaleV);

        /**
         * Sets all meshes in this object to use the specified image as a normal map.
         * You can set a normal map for a single mesh by using SetObjectMeshNormalMap.
         * The normal map will be placed in texture stage 2, overwriting anything that
         * is already there and will have a shader generated that combines it with any
         * dynamic lighting, to correctly light the object. If you are setting your own
         * shader with SetObjectShader then your shader will have to make use of the
         * normal map itself as AGK will not modify your shader in this way. The normal
         * map will use the second set of UV coordinates, if available, otherwise it
         * will use the same UV coordinates as the base texture. If there is also an
         * image in texture stage 1 (such as a light map) then the normal map will
         * always use the base UVs.
         *
         * @param objID   - The ID of the object to modify.
         * @param imageID - The ID of the image to use as a normal map.
         * @return void
         */
        @Signature
        public native void SetObjectNormalMap(int objID, int imageID);

        /**
         * Sets the shader used to draw this mesh, the shader must have been loaded with
         * LoadShader. A shader is like a script sent to the GPU to tell it how to
         * combine the polygon and texture data to display it on screen. By default
         * meshes are assigned an internal shader that will handle lighting and
         * texturing. If you use a shader ID of 0 the mesh is assigned the internal
         * shader. Mesh indices are in the range 1 to GetObjectNumMeshes
         *
         * @param objID     - The ID of the object to modify.
         * @param meshIndex - The index of the mesh to modify, first mesh is at index 1.
         * @param shaderID  - The ID of the shader to use.
         * @return void
         */
        @Signature
        public native void SetObjectMeshShader(int objID, int meshIndex, int shaderID);

        /**
         * Sets the objects collision shape to a convex hull based on the size of the
         * object. You must first create a physics body for the object or this command
         * will fail.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void SetObjectShapeConvexHull(int objID);

        /**
         * Scales the normal map UV coordinates by the specified amount. This does not
         * affect any other texture, but does stack on top of the object's UV offset and
         * scale. A scale value of 1.0 would use unmodified UVs, a scale value of 2.0
         * would double the UV value, and so on.
         *
         * @param objID     - The ID of the object to modify.
         * @param meshIndex - The index of the mesh to modify, first mesh is at index 1.
         * @param scaleU    - The amount to scale the normal map in the U direction
         * @param scaleV    - The amount to scale the normal map in the V direction
         * @return void
         */
        @Signature
        public native void SetObjectMeshNormalMapScale(int objID, int meshIndex, float scaleU, float scaleV);

        /**
         * Sets an object mesh to use the specified image as a normal map. The normal
         * map will be placed in texture stage 2, overwriting anything that is already
         * there and will have a shader generated that combines it with any dynamic
         * lighting, to correctly light the object. If you are setting your own shader
         * with SetObjectShader then your shader will have to make use of the normal map
         * itself as AGK will not modify your shader in this way. Mesh indices are in
         * the range 1 to GetObjectNumMeshes
         *
         * @param objID     - The ID of the object to modify.
         * @param meshIndex - The index of the mesh to modify, first mesh is at index 1.
         * @param imageID   - The ID of the image to use as a normal map.
         * @return void
         */
        @Signature
        public native void SetObjectMeshNormalMap(int objID, int meshIndex, int imageID);

        /**
         * Sets an object mesh to use the specified image as a lightmap. The lightmap
         * will be placed in texture stage 1, overwriting anything that is already there
         * and will have a shader generated that combines it with texture stage 0, and
         * any dynamic lighting, to correctly light the object. If you are setting your
         * own shader with SetObjectShader then your shader will have to make use of the
         * lightmap itself as AGK will not modify your shader in this way. Mesh indices
         * are in the range 1 to GetObjectNumMeshes
         *
         * @param objID     - The ID of the object to modify.
         * @param meshIndex - The index of the mesh to modify, first mesh is at index 1.
         * @param imageID   - The ID of the image to use as a light map.
         * @return void
         */
        @Signature
        public native void SetObjectMeshLightMap(int objID, int meshIndex, int imageID);

        /**
         * Sets an object mesh to use this image when rendering. A mesh can have up to 8
         * images assigned to it in the texture stages 0 to 7. If you are unsure of
         * which texture stage to use, place the image in stage 0. Texture stages can be
         * used to assign multiple images to a mesh, for example you might put the base
         * (diffuse) texture in stage 0, a normal map in stage 1, and a light map in
         * stage 2. The shader used to draw this object can then combine the various
         * textures into a pixel value to show on the screen. Using an image value of 0
         * for a particular texture stage removes any assigned image from that stage.
         * Mesh indices are in the range 1 to GetObjectNumMeshes
         *
         * @param objID        - The ID of the object to modify.
         * @param meshIndex    - The index of the mesh to modify, first mesh is at index
         *                     1.
         * @param imageID      - The ID of the image to assign to this object.
         * @param textureStage - The texture stage to use for this image.
         * @return void
         */
        @Signature
        public native void SetObjectMeshImage(int objID, int meshIndex, int imageID, int textureStage);

        /**
         * Changes an object's mesh based on the memblock provided. The memblock need
         * not have the same number of attributes or vertices as the original mesh, but
         * it will improve performance if it does. The first 4 bytes of the memblock
         * represent the number of vertices in the mesh. The second 4 bytes represent
         * the number of indices in the mesh, this may be 0 in which case every three
         * vertices represents a polygon, and no vertices can be shared. If the number
         * of indices is greater than 0 then every three indices represent a polygon and
         * vertices may be shared between polygons. Indices start at 0 so index 0
         * references the first vertex in the list. The third 4 bytes represents the
         * number of attributes per vertex, e.g. position, normals, and UV data are all
         * potential attributes, so a vertex containing all three would have 3
         * attributes. A vertex must have a position attribute, everything else is
         * optional. The fourth 4 bytes represent the size of a single vertex in bytes,
         * this can be calculated from the attribute data but is given for convenience.
         * The fifth 4 bytes is offset for the beginning of the vertex data, so you can
         * reach it easily. The sixth 4 bytes is offset for the beginning of the index
         * data, will be 0 if there are no indices. After those 6 values, starting at
         * offset 24, is the vertex attribute data. The vertex attribute data describes
         * how the vertex data is laid out, for example if it has normals, UV data, etc.
         * For each attribute there is a 1 byte data type, 1 byte component count, 1
         * byte normalize flag, 1 byte string length, and X bytes of string data for the
         * attribute name. The data type will be 0 for floats (used for almost
         * everything, e.g. position, normals, etc) or 1 for unsigned bytes (used for
         * vertex colors). The component count is the number of values per attribute,
         * e.g. position has 3 components, x,y,z, UV data has 2 components, and vertex
         * colors have 4 components. Note that any unsigned byte data type must have 4
         * components even if some are unused. The normalize flag is only used for
         * unsigned byte data types and will convert values in the range 0-255 into
         * 0.0-1.0 for use in a shader. Usually the normalize flag will be 1 for color
         * attributes and 0 for everything else. The string length byte must always be a
         * multiple of 4 for alignment reasons, the string itself might have slightly
         * less characters but always round up to the nearest multiple of 4 for the
         * string length value. e.g. a string of length 5 should have a string length
         * value of 8. Note that a string of 4 characters has a null terminator on the
         * end which makes it length 5, so even though it has a multiple of 4 characters
         * already it must use a length value of 8 due to the null terminator. The
         * attribute name string will be used by the shader to recognise what the vertex
         * data is, the attribute names recognised by AGK are "position", "normal",
         * "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
         * "boneindices", however you may add attributes with any name you like as long
         * as you write a matching shader that has the same names. If you are not using
         * your own shader and instead rely on AGK to draw the object then you must
         * stick to the above attribute names. Following the attribute data is the raw
         * vertex data, which usually starts with the "position" attribute. It will be a
         * 4 byte float for the X position, a 4 byte float for the Y position, and a 4
         * byte float for the Z position. This continues for each attribute specified in
         * the attribute data. Note that color data will always be 4 bytes in total, 1
         * unsigned byte for each color channel. You can access individual vertices by
         * using the vertex size provided above and the vertex index like so
         * offset=vertexDataOffset+(vertexIndex*vertexSize). Lastly is the index data,
         * if present. Each index is a 4 byte integer which references a vertex in the
         * vertex data. Every three indices represents a polygon. If you plan on making
         * regular changes to the mesh you should keep the memblock around after using
         * SetObjectMeshFromMemblock instead of regenerating from the object it every
         * time you want to make a change. Then call SetObjectMeshFromMemblock again
         * when you want to push your new changes onto the object.
         *
         * @param objID     - The ID of the object to modify
         * @param meshIndex - The index of the mesh to modify
         * @param memID     - The index of the memblock to use to modify the mesh
         * @return void
         */
        @Signature
        public native void SetObjectMeshFromMemblock(int objID, int meshIndex, int memID);

        /**
         * Sets collision detection on or off for a single mesh in a object.
         *
         * @param objID     - The ID of the object to modify.
         * @param meshIndex - The index of the mesh to change collison mode, first mesh
         *                  is at index 1.
         * @param mode      - 0 to turn collision off, 1 to turn it on.
         * @return void
         */
        @Signature
        public native void SetObjectMeshCollisionMode(int objID, int meshIndex, int mode);

        /**
         * Rotates the object to look at a particular point in space with an optional
         * roll value. "looking at" is defined as aligning the object's local Z axis to
         * point its positive side at the given point. This can be achieved using only
         * the Y and X angles in Euler notation, so you can specify an optional Z angle
         * in degrees to roll the object left of right whilst always looking at the same
         * spot.
         *
         * @param objID - The ID of the object to modify.
         * @param x     - The X component of the position to look at.
         * @param y     - The Y component of the position to look at.
         * @param z     - The Z component of the position to look at.
         * @param roll  - The Z angle to roll the object when looking at the given
         *              position, negative is clockwise.
         * @return void
         */
        @Signature
        public native void SetObjectLookAt(int objID, float x, float y, float z, float roll);

        /**
         * Sets a shader constant for an object by name, the constant must be marked as
         * "uniform" in the shader source. The object will set the specified constant to
         * this value for any shader that it is applied to it. All shader values have 1
         * to 4 components, this command accepts 4 values and discards any that are not
         * used by the named variable.
         *
         * @param objID  - The ID of the object to modify.
         * @param szName - The name of the constant to change, as defined in the shader
         *               source file.
         * @param value1 - The X or R component of the new value, this value will always
         *               be used.
         * @param value2 - The Y or G component of the new value, if the constant only
         *               uses 1 component this value is discarded.
         * @param value3 - The Z or B component of the new value, if the constant only
         *               uses 2 components this value is discarded.
         * @param value4 - The W or A component of the new value, if the constant only
         *               uses 3 components this value is discarded.
         * @return void
         */
        @Signature
        public native void SetObjectShaderConstantByName(int objID, String szName, float value1, float value2,
                        float value3, float value4);

        /**
         * Turns lighting on or off when drawing this object.
         *
         * @param objID - The ID of the object to modify.
         * @param mode  - 0 to turn lighting off, 1 to turn it on.
         * @return void
         */
        @Signature
        public native void SetObjectLightMode(int objID, int mode);

        /**
         * Sets all meshes in this object to use the specified image as a lightmap. You
         * can set a light map for a single mesh by using SetObjectMeshLightMap. The
         * lightmap will be placed in texture stage 1, overwriting anything that is
         * already there and will have a shader generated that combines it with texture
         * stage 0, and any dynamic lighting, to correctly light the object. If you are
         * setting your own shader with SetObjectShader then your shader will have to
         * make use of the lightmap itself as AGK will not modify your shader in this
         * way. The lightmap will use the second set of UV coordinates, if available,
         * otherwise it will use the same UV coordinates as the base texture.
         *
         * @param objID   - The ID of the object to modify.
         * @param imageID - The ID of the image to use as a light map.
         * @return void
         */
        @Signature
        public native void SetObjectLightMap(int objID, int imageID);

        /**
         * Sets the depth write mode when drawing this object to the screen. If it
         * passes the depth test the object writes its depth value to the depth buffer
         * to stop anything further behind from passing their depth tests. By default
         * only objects that are closer (less than) the current depth value will
         * overwrite the current contents of the screen. You can turn off this writing
         * to the depth buffer for this object, this can be useful for transparent
         * objects that shouldn't block drawing behind themselves. By default all opaque
         * objects have depth write turned on and all transparent objects have depth
         * write turned off.
         *
         * @param objID - The ID of the object to modify.
         * @param mode  - 0 to turn depth write off for this object, 1 to turn it on.
         * @return void
         */
        @Signature
        public native void SetObjectDepthWrite(int objID, int mode);

        /**
         * Sets whether this objects mesh is visible or not.
         *
         * @param objID     - The ID of the object to modify.
         * @param meshIndex - The index of the mesh to check, first mesh is at index 1.
         * @param mode      - 1 to set this objects mesh as visible, 0 to hide it.
         * @return void
         */
        @Signature
        public native void SetObjectMeshVisible(int objID, int meshIndex, int mode);

        /**
         * Sets the depth read mode when drawing this object to the screen. The object
         * must pass the the depth test in order to be visible. The available options
         * are 0=never pass, 1=less than, 2=equal, 3=less than or equal, 4=greater than,
         * 5=not equal, 6=greater than or equal, 7=always pass. By default all objects
         * use the mode 1 (less than) which means they must be closer than any objects
         * already drawn to be visible.
         *
         * @param objID - The ID of the object to modify.
         * @param mode  - The depth mode to use for this object.
         * @return void
         */
        @Signature
        public native void SetObjectDepthReadMode(int objID, int mode);

        /**
         * Modifies the mesh UVs to shift them by the specified offset. This may push
         * the UV coordinates outside the range 0.0 to 1.0, in which case the image wrap
         * mode will be used to either clamp or repeat the texture. Use SetImageWrapU
         * and SetImageWrapV to set the wrap mode. Note that the image must be a power
         * of 2 in size to use the repeat mode.
         *
         * @param objID        - The ID of the object to modify.
         * @param meshIndex    - The index of the mesh to modify.
         * @param textureStage - The texture stage of the UVs to modify, in the range 0
         *                     to 7
         * @param offsetU      - The offset to use in the U direction, the default is 0
         * @param offsetV      - The offset to use in the V direction, the default is 0
         * @return void
         */
        @Signature
        public native void SetObjectMeshUVOffset(int objID, int meshIndex, int textureStage, float offsetU,
                        float offsetV);

        /**
         * Sets the depth bias when drawing this object to the screen. If two objects
         * are very close together, one in front of the other, they can cause Z fighting
         * where they appear to flicker between one object and the other being displayed
         * in front of each other. For example a decal on the surface of another object.
         * Z bias is designed to prevent this flickering by forcing (biasing) one object
         * to always be in front of, or behind, the other. The bias value should be
         * positive to bring this object towards the camera, and negative to push it
         * backwards. This does not actually affect the position of the object, only its
         * perceived position when the rendering system tests to see if the object
         * should be drawn or not. If the object passes this biased depth test then it
         * is drawn at its original position. The bias value is in multiples of the
         * smallest z buffer value, so a bias value of 1 is the recommended value.
         * Values smaller than this are not likely to have any effect, values bigger
         * than this can be tried if a value of 1 does not work, try 1.5, 2.0, etc.
         *
         * @param objID - The ID of the object to modify.
         * @param bias  - The bias amount, 0 to turn depth biasing off for this object.
         * @return void
         */
        @Signature
        public native void SetObjectDepthBias(int objID, float bias);

        /**
         * Sets whether this object should draw its back faces when rendering. Use mode
         * 0=both front and back drawn, 1=only front faces, 2=only back faces. By
         * default only front faces are drawn (mode 1).
         *
         * @param objID - The ID of the object to modify.
         * @param mode  - The cull mode to use for this object.
         * @return void
         */
        @Signature
        public native void SetObjectCullMode(int objID, int mode);

        /**
         * Sets the emissive color to use when drawing this object. Values should be in
         * the range 0-255 but are not limited to it. Values greater than 255 will over
         * saturate the object and values less than 0 will take light away. The emissive
         * color simulates light being generated by the object so it will gain this
         * color even if it is not being lit by anything. This does not not affect any
         * surrounding objects.
         *
         * @param objID - The ID of the object to modify.
         * @param red   - The red component of the color.
         * @param green - The green component of the color.
         * @param blue  - The blue component of the color.
         * @return void
         */
        @Signature
        public native void SetObjectColorEmissive(int objID, int red, int green, int blue);

        /**
         * Sets the diffuse color to use when drawing this object. Values should be in
         * the range 0-255 but are not limited to it. Values greater than 255 will over
         * saturate the object and values less than 0 will take light away.
         *
         * @param objID - The ID of the object to modify.
         * @param red   - The red component of the color.
         * @param green - The green component of the color.
         * @param blue  - The blue component of the color.
         * @param alpha - The alpha component of the color.
         * @return void
         */
        @Signature
        public native void SetObjectColor(int objID, int red, int green, int blue, int alpha);

        /**
         * Sets collision detection on or off for this object.
         *
         * @param objID - The ID of the object to modify.
         * @param mode  - 0 to turn collision off, 1 to turn it on.
         * @return void
         */
        @Signature
        public native void SetObjectCollisionMode(int objID, int mode);

        /**
         * Sets an object to cast shadows on other objects. By default this is set to 0.
         * An object can be set to both cast and receive shadows.
         *
         * @param objID - The ID of the object to cast shadows
         * @param mode  - 1 to make this object cast shadows, 0 to stop it casting
         *              shadows
         * @return void
         */
        @Signature
        public native void SetObjectCastShadow(int objID, int mode);

        /**
         * Sets the rotation of the specified bone using euler angles in degrees.
         * Alternatively you can use SetObjectBoneRotationQuat to use a quaternion.
         *
         * @param objID     - The ID of the object that contains the bone.
         * @param boneIndex - The index of the bone to modify
         * @param angx      - The X component of the rotation.
         * @param angy      - The Y component of the rotation.
         * @param angz      - The Z component of the rotation.
         * @return void
         */
        @Signature
        public native void SetObjectBoneRotation(int objID, int boneIndex, float angx, float angy, float angz);

        /**
         * Sets the position of the specified bone relative to its parent.
         *
         * @param objID     - The ID of the object that contains the bone.
         * @param boneIndex - The index of the bone to modify
         * @param x         - The X component of the position.
         * @param y         - The Y component of the position.
         * @param z         - The Z component of the position.
         * @return void
         */
        @Signature
        public native void SetObjectBonePosition(int objID, int boneIndex, float x, float y, float z);

        /**
         * Turns fog on or off when drawing this object. By default all objects receive
         * fog when it is turned on with SetFogMode
         *
         * @param objID - The ID of the object to modify.
         * @param mode  - 0 to turn fog off, 1 to turn it on.
         * @return void
         */
        @Signature
        public native void SetObjectFogMode(int objID, int mode);

        /**
         * Sets all meshes in this object to use this image when rendering. You can set
         * textures separately for each mesh by using SetObjectMeshImage. Each mesh can
         * have up to 8 images assigned to it in the texture stages 0 to 7. If you are
         * unsure of which texture stage to use, place the image in stage 0. Texture
         * stages can be used to assign multiple images to a mesh, for example you might
         * put the base (diffuse) texture in stage 0, a normal map in stage 1, and a
         * light map in stage 2. The shader used to draw this object can then combine
         * the various textures into a pixel value to show on the screen. Using an image
         * value of 0 for a particular texture stage removes any assigned image from
         * that stage.
         *
         * @param objID    - The ID of the object to modify.
         * @param imageID  - The ID of the image to assign to this object.
         * @param texStage - The texture stage to use for this image.
         * @return void
         */
        @Signature
        public native void SetObjectImage(int objID, int imageID, int texStage);

        /**
         * Rotates the bone to look at a particular point in world space with an
         * optional roll value. "looking at" is defined as aligning the bone's local Z
         * axis to point its positive side at the given point. This can be achieved
         * using only the Y and X angles in Euler notation, so you can specify an
         * optional Z angle in degrees to roll the bone left of right whilst always
         * looking at the same spot.
         *
         * @param objID     - The ID of the object that contains the bone.
         * @param boneIndex - The index of the bone to modify.
         * @param x         - The X component of the position to look at.
         * @param y         - The Y component of the position to look at.
         * @param z         - The Z component of the position to look at.
         * @param roll      - The Z angle to roll the bone when looking at the given
         *                  position, negative is clockwise.
         * @return void
         */
        @Signature
        public native void SetObjectBoneLookAt(int objID, int boneIndex, float x, float y, float z, float roll);

        /**
         * Sets whether the specified bone is controlled by animation or controlled
         * manually. When controlled by animation then none of the SetObjectBonePosition
         * or similar commands will have any effect. When controlled manually the bone
         * will maintain its current position unless modified by you.
         *
         * @param objID     - The ID of the object that contains the bone.
         * @param boneIndex - The index of the bone to modify.
         * @param animate   - 1 to allow animation to affect this bone, 0 to allow
         *                  manual control.
         * @return void
         */
        @Signature
        public native void SetObjectBoneCanAnimate(int objID, int boneIndex, int animate);

        /**
         * Sets the animation speed for the given object as a multiple of the default
         * time, i.e. 1.0 would use the times from the animation keyframes, 2.0 would
         * play them twice as fast, 0.5 twice as slow, and so on. You can also use
         * negative values to play the animation in reverse, or 0 to pause it.
         *
         * @param objID - The ID of the object to modify.
         * @param speed - The new animation speed to use for this object, default 1.0
         * @return void
         */
        @Signature
        public native void SetObjectAnimationSpeed(int objID, float speed);

        /**
         * When SetObjectTransparency is set to 3 then the source and destination blend
         * values can be specified manually using this command. The blend modes
         * available are as follows: 0 = 0 1 = 1 2 = Source Pixel Alpha 3 = 1 - Source
         * Pixel Alpha 4 = Destination Pixel Alpha 5 = 1 - Destination Pixel Alpha 6 =
         * Source Pixel Color (valid for destination mode only) 7 = 1 - Source Pixel
         * Color (valid for destination mode only) 8 = Destination Pixel Color (valid
         * for source mode only) 9 = 1 - Destination Pixel Color (valid for source mode
         * only) 10 = Alpha Saturate (valid for source mode only) The source pixel will
         * be multiplied by the source mode, and the destination pixel will be
         * multiplied by the destination mode. The two will then be added together to
         * make the final pixel color. The source pixel is the pixel belonging to the
         * object being drawn, whilst the destination pixel is the color of the pixel
         * already on screen, which the current object is being drawn over.
         *
         * @param objID - The ID of the object to modify.
         * @param src   - The blend mode to use for the source of the blend.
         * @param dst   - The blend mode to use for the destination of the blend.
         * @return void
         */
        @Signature
        public native void SetObjectBlendModes(int objID, int src, int dst);

        /**
         * Sets the range of depth values that this object is mapped to. By default this
         * is 0 to 1 where 0 is the near plane and 1 is the far plane. For example
         * setting a depth range of 1,1 will make every pixel in this object have a
         * depth value of 1 when comparing and writing to the depth buffer. Values will
         * be clamped to the range 0 to 1, objects outside the near or far planes will
         * still be clipped. Reverse mappings are allowed by setting near greater than
         * far.
         *
         * @param objID - The ID of the object to modify.
         * @param zNear - The start of the depth range for this object
         * @param zFar  - The end of the depth range for this object
         * @return void
         */
        @Signature
        public native void SetObjectDepthRange(int objID, float zNear, float zFar);

        /**
         * Sets the object bone positions to match a given time in the animation. Only
         * objects loaded with LoadObjectWithChildren will have animations assigned to
         * them. Animation names are defined by the modelling program when the
         * animations were created, you can discover what the names are by using
         * GetObjectAnimationName. If the given time falls between keyframes then the
         * bone positions will be interpolated between them. The tweentime parameter can
         * be used to interpolate between the current bone positions and the given time
         * of the animation so that there is no sudden jump in bone positions. Note that
         * as soon as this command is called the bones will be controlled by animation
         * and cannot be moved with SetObjectBonePosition or similar commands. You can
         * regain manual control of individual bones by using SetObjectBoneCanAnimate on
         * it. You can regain control of the entire bone structure by using
         * ResetObjectAnimation.
         *
         * @param objID     - The ID of the object to modify.
         * @param animName  - The name of the animation to play, defined by the
         *                  modelling program
         * @param time      - The point in the animation to read the bone positions, in
         *                  seconds
         * @param tweentime - The time in seconds to transition from the objects current
         *                  state to the given frame
         * @return void
         */
        @Signature
        public native void SetObjectAnimationFrame(int objID, String animName, float time, float tweentime);

        /**
         * Sets alpha masking on or off for this object. This is similar to transparency
         * but only produces fully transparent or fully opaque pixels, there are no
         * blended or semi-transparent pixels. If a pixel has an alpha value less than
         * 128 it will be ignored, if it is greater than or equal to 128 then it will be
         * drawn. This has less problems with depth ordering than when using
         * SetObjectTransparency but may be slightly slower in some cases. You should
         * not use both transparency and alpha masking on the same object at the same
         * time, only use one or the other.
         *
         * @param objID - The ID of the object to modify.
         * @param mode  - 1=use alpha masking, 0=turn off alpha masking.
         * @return void
         */
        @Signature
        public native void SetObjectAlphaMask(int objID, int mode);

        /**
         * Sets the alpha value to use when drawing this object. This is the same alpha
         * value that can be set in SetObjectColor. Values should be in the range 0-255
         * but are not limited to it.
         *
         * @param objID - The ID of the object to modify.
         * @param alpha - The alpha component of the color.
         * @return void
         */
        @Signature
        public native void SetObjectAlpha(int objID, int alpha);

        /**
         * Sets the 3d physics sleeping thresholds for the object.
         *
         * @param objID   - object ID
         * @param angular - angular velocity
         * @param linear  - linear velocity
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsSleepingThreshold(int objID, float angular, float linear);

        /**
         * Sets the restitution friction for the object. You can set the Restitution for
         * dynamic and static objects.
         *
         * @param objID    - object ID
         * @param friction - The amount of friction applied to the object.
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsRestitution(int objID, float friction);

        /**
         * This will set the max linear velocity for the dynamic object. This will
         * prevent objects from going too fast to be seen on screen.
         *
         * @param objID             - object ID
         * @param maxLinearVelocity - max speed an object can reach.
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsMaxLinearVelocity(int objID, float maxLinearVelocity);

        /**
         * Sets the mass of the object
         *
         * @param objID - object ID
         * @param mass  - mass of the object
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsMass(int objID, float mass);

        /**
         * Sets the objects collision group and mask. By default all physics objects are
         * in one group and are not masked. If you use collision groups and masks you
         * must use them for all physics objects in the world.
         *
         * @param objID - object ID
         * @param group - collision group that this Physics object belongs too.
         * @param mask  - collision groups you want masked from collision.
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsGroupAndMask(int objID, int group, int mask);

        /**
         * Sets the linear velocity vector for the object. The direction vector is
         * automatically normalized.
         *
         * @param objID        - object ID
         * @param vectorID     - ID of the direction vector
         * @param initialSpeed - the initial speed.
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsLinearVelocity(int objID, int vectorID, float initialSpeed);

        /**
         * Sets the linear velocity vector for the object. The direction vector is
         * automatically normalized.
         *
         * @param objID        - object ID
         * @param dirX         - the X component of the direction vector
         * @param dirY         - the Y component of the direction vector
         * @param dirZ         - the Z component of the direction vector
         * @param initialSpeed - the initial speed.
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsLinearVelocity(int objID, float dirX, float dirY, float dirZ,
                        float initialSpeed);

        /**
         * This will set the friction for dynamic and static objects
         *
         * @param objID    - object ID
         * @param friction - friction value as a float
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsFriction(int objID, float friction);

        /**
         * Sets the linear and angular damping for the object
         *
         * @param objID       - object ID
         * @param linearDamp  - The amount of linear damping applied to the object.
         * @param angularDamp - The amount of angular damping applied to the object.
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsDamping(int objID, float linearDamp, float angularDamp);

        /**
         * Sets the deactivation time for the physics object. This is the amount of time
         * the physics object waits when it comes to rest before it becomes deactivated.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsDeactivationTime(int objID, float time);

        /**
         * Sets the rotation of the specified bone relative to its parent as a
         * quaternion.
         *
         * @param objID     - The ID of the object that contains the bone.
         * @param boneIndex - The index of the bone to modify.
         * @param w         - The W component of the rotation.
         * @param x         - The X component of the rotation.
         * @param y         - The Y component of the rotation.
         * @param z         - The Z component of the rotation.
         * @return void
         */
        @Signature
        public native void SetObjectBoneRotationQuat(int objID, int boneIndex, float w, float x, float y, float z);

        /**
         * All dynamic objects are automatically put to sleep at rest. This will stop
         * the dynamic object from being automatically put to sleep.
         *
         * @param objID    - object ID
         * @param canSleep - 1 = true , 0 = false
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsCanSleep(int objID, int canSleep);

        /**
         * This will set the type of anisotropic friction.
         *
         * @param objID - object ID
         * @param type  - DISABLED = 0, FRICTION = 1, ROLLING_FRICTION = 2
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsAnisotropicFriction(int objID, int type);

        /**
         * Stops anymore clients from connecting to this network, only applicable if you
         * are hosting the network. Also stops the broadcasting of the network to the
         * LAN so it will no longer appear to those apps listening to broadcasts.
         *
         * @param iNetID - The ID of the network to modify.
         * @return void
         */
        @Signature
        public native void SetNetworkNoMoreClients(int iNetID);

        /**
         * Sets a local integer variable for this client by name. Other clients can then
         * read this variable by using the same name when requesting its value. The mode
         * parameter specifies how this variable should behave, with a value of 1
         * meaning that this variable will reset to 0 when read. For example if you
         * wanted to send a click notification you could set a value of 1 to signify a
         * click with a mode value of 1. When each client reads the variable, each will
         * see the value 1, but if they try to read it again they will get the value 0.
         * Each client only resets its own copy of the variable. A mode value of 0 means
         * it is a normal variable that will not change when read. If the variable with
         * that name does not exist it is created. Once a variable is created in normal
         * or resetting mode it cannot be changed and the mode parameter is ignored.
         *
         * @param iNetID - The ID of the network to check.
         * @param name   - The name of this variable.
         * @param i      - The value to set this variable to.
         * @param mode   - The type of this variable, 0=normal, 1=resetting
         * @return void
         */
        @Signature
        public native void SetNetworkLocalInteger(int iNetID, String name, int i, int mode);

        /**
         * Sets a local integer variable for this client by name. Other clients can then
         * read this variable by using the same name when requesting its value. The mode
         * parameter specifies how this variable should behave, with a value of 1
         * meaning that this variable will reset to 0 when read. For example if you
         * wanted to send a click notification you could set a value of 1 to signify a
         * click with a mode value of 1. When each client reads the variable, each will
         * see the value 1, but if they try to read it again they will get the value 0.
         * Each client only resets its own copy of the variable. A mode value of 0 means
         * it is a normal variable that will not change when read. If the variable with
         * that name does not exist it is created. Once a variable is created in normal
         * or resetting mode it cannot be changed and the mode parameter is ignored.
         *
         * @param iNetID - The ID of the network to check.
         * @param name   - The name of this variable.
         * @param i      - The value to set this variable to.
         * @return void
         */
        @Signature
        public native void SetNetworkLocalInteger(int iNetID, String name, int i);

        /**
         * Sets a local float variable for this client by name. Other clients can then
         * read this variable by using the same name when requesting its value. A float
         * variable may not have the same name as an integer variable. If the variable
         * with that name does not exist it is created.
         *
         * @param iNetID - The ID of the network to check.
         * @param name   - The name of this variable.
         * @param f      - The value to set this variable to.
         * @return void
         */
        @Signature
        public native void SetNetworkLocalFloat(int iNetID, String name, float f);

        /**
         * Sets a local float variable for this client by name. Other clients can then
         * read this variable by using the same name when requesting its value. A float
         * variable may not have the same name as an integer variable. If the variable
         * with that name does not exist it is created.
         *
         * @param iNetID - The ID of the network to check.
         * @param name   - The name of this variable.
         * @param f      - The value to set this variable to.
         * @param mode   - The type of this variable, 0=normal, 1=resetting
         * @return void
         */
        @Signature
        public native void SetNetworkLocalFloat(int iNetID, String name, float f, int mode);

        /**
         * Sets how often the network sends updates and checks for variable updates from
         * other clients in milliseconds. The lower this value the more often this
         * client will send and receive updates meaning shared variables are more likely
         * to be up to date, but this will increase network traffic. In the case of
         * connections across the internet this is particularly important as a large
         * number of variables being updated frequently means that there may not be
         * enough bandwidth. The default is 15 milliseconds which translates to roughly
         * 67 updates every second to match closely a game frame rate of 60 fps. If you
         * are updating a large number of variables over an internet connection it is
         * recommended you increase this value towards 50 milliseconds resulting in 20
         * updates per second or further.
         *
         * @param iNetID  - The ID of the network to disconnect from.
         * @param latency - The latency to use in milliseconds
         * @return void
         */
        @Signature
        public native void SetNetworkLatency(int iNetID, int latency);

        /**
         * Assigns a local value to one of 5 data slots in the client that can be used
         * to keep track of items that belong to this client. For example if you create
         * a sprite to represent the client in your game you could assign the sprite ID
         * to one of these data slots so that when you go through the client list you
         * can detect which sprite you used for each client. This also allows you to
         * clean up the sprite if the client is found to have disconnected. This value
         * is entirely local and does not get transferred across the network.
         *
         * @param iNetID - The ID of the network to store the value.
         * @param client - The ID of the client on the network to store the value.
         * @param index  - The index (0 to 4) of the data slot to set.
         * @param value  - The integer value to set.
         * @return void
         */
        @Signature
        public native void SetNetworkClientUserData(int iNetID, int client, int index, int value);

        /**
         * Restarts listening for new client connections, only applicable if you are
         * hosting the network. Also restarts the broadcasting of the network to the LAN
         * so it will appear to those apps listening to broadcasts. This only needs to
         * be called if you have previously called SetNetworkNoMoreClients and now want
         * to allow connections again.
         *
         * @param iNetID - The ID of the network to modify.
         * @return void
         */
        @Signature
        public native void SetNetworkAllowClients(int iNetID);

        /**
         * Sets the volume on a per file basis. By default files are played at volume
         * 100. The volume level should be between 0 and 100.
         *
         * @param musicID - The ID of the music file to modify.
         * @param vol     - The volume to use for this file.
         * @return void
         */
        @Signature
        public native void SetMusicVolumeOGG(int musicID, int vol);

        /**
         * Sets the master volume for all OGG music files. This is multiplied by the
         * file volume, so if the system volume is set to 100 but the file volume is set
         * to 0 then the file will still be at volume 0.
         *
         * @param vol - The master volume to use, between 0 and 100
         * @return void
         */
        @Signature
        public native void SetMusicSystemVolumeOGG(int vol);

        /**
         * Sets the master volume of the music player, in the range 0 to 100.
         *
         * @param iVol - The new volume value to use.
         * @return void
         */
        @Signature
        public native void SetMusicSystemVolume(int iVol);

        /**
         * Sets the start and end times of the music loop. When PlayMusicOGG is used
         * with the loop parameter it will by default stop at the end of the file and
         * return to the beginning of the file. This command will change it to the
         * looping begins and ends at specific times in the music file. Using a start
         * time of -1 will return to the beginning of the file, using and end time of -1
         * will stop at the end of the file, these match the default behaviour. If the
         * start time is greater than the current play time then the music file will
         * continue playing until it reaches the end time, it will then return to the
         * chosen start time.
         *
         * @param musicID   - The ID of the music file to change
         * @param startTime - The time in seconds to return to at the beginning of a
         *                  loop
         * @param endTime   - The time in seconds to end the loop and return to the
         *                  start
         * @return void
         */
        @Signature
        public native void SetMusicLoopTimesOGG(int musicID, float startTime, float endTime);

        /**
         * Changes the number of times the music file will loop, can be set whilst it is
         * playing. Use a value of 0 to play to the end of the file, or the current loop
         * end time, and then stop. A loop value of 1 will loop forever, a value greater
         * than 1 will loop for that number of times. This command resets the
         * GetMusicLoopCountOGG command and it starts counting again from 0.
         *
         * @param musicID - The ID of the music file to change
         * @param loop    - The number of times to loop, 0 to stop looping.
         * @return void
         */
        @Signature
        public native void SetMusicLoopCountOGG(int musicID, int loop);

        /**
         * Sets the volume on a per file basis, this volume level is combined with the
         * music system volume to create the final volume. By default files are played
         * at volume 100. The volume level should be between 0 and 100.
         *
         * @param ID  - The music number to set.
         * @param vol - The volume to use for this file.
         * @return void
         */
        @Signature
        public native void SetMusicFileVolume(int ID, int vol);

        /**
         * Provides a quick way to modify the UV values of a vertex inside a mesh
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and change the UV values. Vertices start at index
         * 0.
         *
         * @param memID       - The ID of the memblock to modify
         * @param vertexIndex - The index of the vertex to modify
         * @param u           - The new U value for this vertex
         * @param v           - The new V value for this vertex
         * @return void
         */
        @Signature
        public native void SetMeshMemblockVertexUV(int memID, int vertexIndex, float u, float v);

        /**
         * Provides a quick way to modify the position of a vertex inside a mesh
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and change the position values. Vertices start at
         * index 0.
         *
         * @param memID       - The ID of the memblock to modify
         * @param vertexIndex - The index of the vertex to modify
         * @param x           - The new X position for this vertex
         * @param y           - The new Y position for this vertex
         * @param z           - The new Z position for this vertex
         * @return void
         */
        @Signature
        public native void SetMeshMemblockVertexPosition(int memID, int vertexIndex, float x, float y, float z);

        /**
         * This will set the rolling friction for static and dynamic objects.
         *
         * @param objID    - object ID
         * @param friction - rolling friction value as a float
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsRollingFriction(int objID, float friction);

        /**
         * Provides a quick way to modify the normal of a vertex inside a mesh memblock.
         * It uses the attribute data from the beginning of the memblock to work out the
         * vertex offset and change the normal values. Vertices start at index 0.
         *
         * @param memID       - The ID of the memblock to modify
         * @param vertexIndex - The index of the vertex to modify
         * @param x           - The X component of the new normal for this vertex
         * @param y           - The Y component of the new normal for this vertex
         * @param z           - The Z component of the new normal for this vertex
         * @return void
         */
        @Signature
        public native void SetMeshMemblockVertexNormal(int memID, int vertexIndex, float x, float y, float z);

        /**
         * Provides a quick way to modify the color values of a vertex inside a mesh
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and change the color values. Vertices start at
         * index 0. Color values must be between 0 and 255.
         *
         * @param memID       - The ID of the memblock to modify
         * @param vertexIndex - The index of the vertex to modify
         * @param red         - The new red value for this vertex
         * @param green       - The new green value for this vertex
         * @param blue        - The new blue value for this vertex
         * @param alpha       - The new alpha value for this vertex
         * @return void
         */
        @Signature
        public native void SetMeshMemblockVertexColor(int memID, int vertexIndex, int red, int green, int blue,
                        int alpha);

        /**
         * Writes a string to a memblock as raw bytes. The first null terminator found
         * will end the string and a single null terminator will be written to the
         * memblock data. To read the string out of the memblock again you will need to
         * know its length, so it is recommended that you also write a string length
         * value before the string data to help read the string back later. The offset
         * plus the length of the string, plus 1 for the null terminator, must be less
         * than the memblock size.
         *
         * @param memID  - The ID of the memblock to modify.
         * @param offset - The offset from the start of the memblock to write to,
         *               between 0 and size.
         * @param value  - The string to write.
         * @return void
         */
        @Signature
        public native void SetMemblockString(int memID, int offset, String value);

        /**
         * Writes a short (2 byte) value at the given offset. The offset must be less
         * than the size of the memblock. The first value is at offset 0. For best
         * performance the offset should be a multiple of 2 because writing short values
         * that are not aligned to 2 byte boundaries incurs a hardware performance
         * penalty. Short values are stored in little endian format so writing a short
         * of 23 at offset 0 and then reading it back in bytes would return the byte at
         * offset 0 as 23 and the byte at offset 1 as 0. The given value will be
         * truncated to the range -32768 and 32767.
         *
         * @param memID  - The ID of the memblock to modify.
         * @param offset - The offset from the start of the memblock to write to,
         *               between 0 and size.
         * @param value  - The value to write.
         * @return void
         */
        @Signature
        public native void SetMemblockShort(int memID, int offset, int value);

        /**
         * Writes an int (4 byte) value at the given offset. The offset must be less
         * than the size of the memblock. The first value is at offset 0. For best
         * performance the offset should be a multiple of 4 because writing integer
         * values that are not aligned to 4 byte boundaries incurs a hardware
         * performance penalty. Int values are stored in little endian format so writing
         * an int of 23 at offset 0 and then reading it back in bytes would return the
         * byte at offset 0 as 23, the byte at offset 1 as 0, the byte at offset 2 as 0,
         * and the byte at offset 3 as 0.
         *
         * @param memID  - The ID of the memblock to modify.
         * @param offset - The offset from the start of the memblock to write to,
         *               between 0 and size.
         * @param value  - The value to write.
         * @return void
         */
        @Signature
        public native void SetMemblockInt(int memID, int offset, int value);

        /**
         * Write a float (4 byte) value at the given offset. The offset must be less
         * than the size of the memblock. The first value is at offset 0. For best
         * performance the offset should be a multiple of 4 because writing float values
         * that are not aligned to 4 byte boundaries incurs a hardware performance
         * penalty. Float values are stored in IEEE 754 format so writing an float and
         * then reading it back in bytes would return various components of the float
         * format.
         *
         * @param memID  - The ID of the memblock to modify.
         * @param offset - The offset from the start of the memblock to write to,
         *               between 0 and size.
         * @param value  - The value to write.
         * @return void
         */
        @Signature
        public native void SetMemblockFloat(int memID, int offset, float value);

        /**
         * Writes a single byte value at the given offset. The offset must be less than
         * the size of the memblock. The first value is at offset 0. The given value
         * will be truncated to the range -128 and 127.
         *
         * @param memID  - The ID of the memblock to modify.
         * @param offset - The offset from the start of the memblock to write to,
         *               between 0 and size.
         * @param value  - The value to write.
         * @return void
         */
        @Signature
        public native void SetMemblockByteSigned(int memID, int offset, int value);

        /**
         * Writes a single byte value at the given offset. The offset must be less than
         * the size of the memblock. The first value is at offset 0. The given value
         * will be truncated to the range 0 and 255.
         *
         * @param memID  - The ID of the memblock to modify.
         * @param offset - The offset from the start of the memblock to write to,
         *               between 0 and size.
         * @param value  - The value to write.
         * @return void
         */
        @Signature
        public native void SetMemblockByte(int memID, int offset, int value);

        /**
         * Creates a local notification that will appear at some point in the future.
         * Notifications are referenced by ID and can be overwritten by creating a new
         * notification with the same ID as the notification you want to overwrite. If a
         * notification triggers whilst the app is open then the notification will not
         * appear and it will silently disappear from the list of scheduled
         * notifications. If the app is not open then a notification will display to the
         * user and tapping on it will open up your app. If you set the deeplink
         * parameter then that URL will be sent to the app when the notification is
         * tapped. The URL can be retrieved by using the GetURLSchemeText command. The
         * datetime parameter should be specified in unix time, which is measured in
         * seconds since 1st Jan 1970, you can use the command GetUnixTime to return the
         * current date and time then modify it as needed. If the date and time is in
         * the past then the notification will be ignored, it will not overwrite any
         * existing notification. The ID must be in the range 1 to 100 inclusive.
         *
         * @param iID       - The ID to use to reference this notification in future
         * @param datetime  - The date and time to show this notification in unix time
         * @param szMessage - The message to display in the notification
         * @return void
         */
        @Signature
        public native void SetLocalNotification(int iID, int datetime, String szMessage);

        /**
         * Creates a local notification that will appear at some point in the future.
         * Notifications are referenced by ID and can be overwritten by creating a new
         * notification with the same ID as the notification you want to overwrite. If a
         * notification triggers whilst the app is open then the notification will not
         * appear and it will silently disappear from the list of scheduled
         * notifications. If the app is not open then a notification will display to the
         * user and tapping on it will open up your app. If you set the deeplink
         * parameter then that URL will be sent to the app when the notification is
         * tapped. The URL can be retrieved by using the GetURLSchemeText command. The
         * datetime parameter should be specified in unix time, which is measured in
         * seconds since 1st Jan 1970, you can use the command GetUnixTime to return the
         * current date and time then modify it as needed. If the date and time is in
         * the past then the notification will be ignored, it will not overwrite any
         * existing notification. The ID must be in the range 1 to 100 inclusive.
         *
         * @param iID        - The ID to use to reference this notification in future
         * @param datetime   - The date and time to show this notification in unix time
         * @param szMessage  - The message to display in the notification
         * @param szDeepLink - The URL to send to the app if the notification is tapped
         * @return void
         */
        @Signature
        public native void SetLocalNotification(int iID, int datetime, String szMessage, String szDeepLink);

        /**
         * The AGK joystick is an emulated input method that uses whatever device inputs
         * are available to produce a joystick style input in the range -1 to 1. This
         * command positions a virtual joystick on screen only if it is necessary to
         * emulate this input. For example if a real joystick or keyboard are available
         * then this command has no noticeable effect. It is recommended that you always
         * call this command anyway if you intend to use GetJoystickX or GetJoystickY
         * just incase a virtual joystick is needed. Any virtual joystick will be
         * centered on the given X and Y position.
         *
         * @param x    - The X coordinate of the new position in screen coordinates.
         * @param y    - The Y coordinate of the new position in screen coordinates.
         * @param size - The diameter of the joystick in screen coordinates.
         * @return void
         */
        @Signature
        public native void SetJoystickScreenPosition(float x, float y, float size);

        /**
         * Sets the dead zone for the universal joysticks so that any X or Y value below
         * the given threshold will return 0 instead. This value must be between 0 and
         * 1, by default it is set to 0.15.
         *
         * @param threshold - The value below which 0 will be returned.
         * @return void
         */
        @Signature
        public native void SetJoystickDeadZone(float threshold);

        /**
         * Sets the target point in world coordinates that the mouse joint will attempt
         * to move the attached body towards. Only works on Mouse joints.
         *
         * @param iJointIndex - The ID of the joint to modify.
         * @param x           - The x coordinate of the new target.
         * @param y           - The y coordinate of the new target.
         * @return void
         */
        @Signature
        public native void SetJointMouseTarget(int iJointIndex, float x, float y);

        /**
         * Sets the angular velocity of the object. The angle vector is automatically
         * normalized.
         *
         * @param objID        - object ID
         * @param angX         - the X component of the angle vector
         * @param angY         - the Y component of the angle vector
         * @param angZ         - the Z component of the angle vector
         * @param initialSpeed - the initial speed.
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsAngularVelocity(int objID, float angX, float angY, float angZ,
                        float initialSpeed);

        /**
         * Sets the angular velocity of the object. The angle vector is automatically
         * normalized.
         *
         * @param objID        - object ID
         * @param vectorID     - ID of direction Vector.
         * @param initialSpeed - the initial speed.
         * @return void
         */
        @Signature
        public native void SetObject3DPhysicsAngularVelocity(int objID, int vectorID, float initialSpeed);

        /**
         * Turns on a motor for the joint so that it moves continuously until prevented
         * by a collision. Works on Line/Wheel joints, Prismatic joints, and Revolute
         * joints. Motors work by applying a force to achieve a set speed, if they meet
         * resistance they increase the force until either the motor is moving at the
         * desired speed or the maximum force specified is reached, at which point the
         * motor will stop, continuing to apply the maximum force. In the case of linear
         * joints the motor applies in one direction and either pushes the attached
         * sprites together or apart.
         *
         * @param iJointIndex - The ID of the joint to modify.
         * @param speed       - The desired speed of the motor.
         * @param maxForce    - The max force it can use to achieve the speed.
         * @return void
         */
        @Signature
        public native void SetJointMotorOn(int iJointIndex, float speed, float maxForce);

        /**
         * Sets the maximum force that can be used by the mouse joint to move an object.
         * By default this is set to 0
         *
         * @param iJointIndex - The ID of the joint to modify.
         * @param maxForce    - The maximum force to allow.
         * @return void
         */
        @Signature
        public native void SetJointMouseMaxForce(int iJointIndex, float maxForce);

        /**
         * Turns off limits for joints that support them. Works on Prismatic joints and
         * Revolute joints.
         *
         * @param iJointIndex - The ID of the joint to modify.
         * @return void
         */
        @Signature
        public native void SetJointLimitOff(int iJointIndex);

        /**
         * Sets the size of the device you have designed all your artwork for, this
         * allows AGK to downsize the images to save memory on lower resolution devices.
         * Note that commands such as SetSpriteAnimation that might assume image sizes
         * must account for images that have been reduced. For example loading a 512x512
         * image and using SetSpriteAnimation(spr,128,128,16) should instead use
         * SetSpriteAnimation(spr,GetImageWidth(img)/4,GetImageHeight(img)/4,16) in case
         * the image is no longer 512 in size. This command has been deprecated and you
         * should use LoadImageResized to adjust image sizes depending on the device
         * resolution, you can check the device resolution with GetDeviceWidth and
         * GetDeviceHeight.
         *
         * @param width  - The intended width
         * @param height - The intended height
         * @return void
         */
        @Signature
        public native void SetIntendedDeviceSize(int width, int height);

        /**
         * Damping can be used to make the joint soft, like a spring. The frequency is
         * specified in hertz and should typically be less than half of the physics step
         * rate. For example if the fps is 60 then the frequency should be less than 30.
         * The damping ratio should be between 0 and 1, but can be larger. This can only
         * be used on distance joints, weld joints, line/wheel joints, and mouse joints.
         * By default distance and weld joints have a damping ratio and frequency of 0
         * making the joint rigid. By default mouse joints have a frequency of 5 and a
         * damping ratio of 0.7. By default line/wheel joints have a frequency of 2 and
         * a damping ratio of 0.7.
         *
         * @param iJointIndex  - The ID of the joint to modify.
         * @param dampingRatio - The damping ratio to use, typically between 0 and 1
         * @param frequency    - The frequency of the oscillations, should be less than
         *                     half the frame rate
         * @return void
         */
        @Signature
        public native void SetJointDamping(int iJointIndex, float dampingRatio, float frequency);

        /**
         * Removes any on screen controls that may have been placed on screen by the OS,
         * for example the home and back buttons, allowing your app to use the entire
         * screen. Your app may be resized after calling this command so if you have
         * used GetDeviceWidth or GetDeviceHeight you should wait a few frames then call
         * them again to get the new values. The values may not change immediately after
         * calling this command as it takes some time for the navigation bar to change.
         * Sometimes the OS will turn off immersive mode without warning, for example if
         * the volume buttons are pressed. When this happens your app will return to its
         * non-immersive mode size to prevent any part of the app being hidden by the
         * nav bar, which could make some parts of the app inaccessible to touch events.
         * You can detect this change by checking GetDeviceWidth and GetDeviceHeight at
         * regular intervals, and use SetImmersiveMode again to request a return to
         * immersive mode. Currently this only applies to Android devices running 4.4
         * (API 19) or higher. On other platforms this command does nothing.
         *
         * @param mode - 1 to turn on immersive mode, 0 to turn it off
         * @return void
         */
        @Signature
        public native void SetImmersiveMode(int mode);

        /**
         * Sets your Inneractive account details to be used by CreateAdvert. Not all
         * platforms support all ad providers so setting as many account details as
         * possible will allow AGK to select a suitable ad for this platform.
         * Inneractive is currently supported by iOS, Android, Windows, and Mac.
         *
         * @param szCode - Your account code provided by Inneractive.
         * @return void
         */
        @Signature
        public native void SetInneractiveDetails(String szCode);

        /**
         * Sets the UV wrap mode of the image when the V coordinate goes outside the
         * range 0-1. The default is mode 0 which clamps the pixel value to the last
         * valid pixel, mode 1 repeats the texture starting from the opposite side. To
         * use UV values outside 0-1 successfully on all platforms the image in question
         * must be a power of 2 in width and height, and not be part of an atlas
         * texture. This applies to both clamp and repeat.
         *
         * @param iImageIndex - The ID of the image to change.
         * @param mode        - The wrap mode to use, 0=clamp, 1=repeat
         * @return void
         */
        @Signature
        public native void SetImageWrapV(int iImageIndex, int mode);

        /**
         * Sets the UV wrap mode of the image when the U coordinate goes outside the
         * range 0-1. The default is mode 0 which clamps the pixel value to the last
         * valid pixel, mode 1 repeats the texture starting from the opposite side. To
         * use UV values outside 0-1 successfully on all platforms the image in question
         * must be a power of 2 in width and height, and not be part of an atlas
         * texture. This applies to both clamp and repeat.
         *
         * @param iImageIndex - The ID of the image to change.
         * @param mode        - The wrap mode to use, 0=clamp, 1=repeat
         * @return void
         */
        @Signature
        public native void SetImageWrapU(int iImageIndex, int mode);

        /**
         * Sets the sub image data for an atlas image, which is the layout of where each
         * sub image is located within the atlas image. Normally this is loaded
         * automatically from the subimages.txt file when the image is loaded, but if
         * this is not possible then this command can be used to set that data. The file
         * must be a valid subimages.txt file in the same format as that specified in
         * LoadSubImage Unlike the normal load image command the file does not need to
         * be named subimages.txt, it can have any name and path
         *
         * @param iImageIndex   - The ID of the image to change
         * @param sSubImageFile - The path to the sub images file
         * @return void
         */
        @Signature
        public native void SetImageSubImages(int iImageIndex, String sSubImageFile);

        /**
         * Turns a particular color completely transparent in the chosen image. This is
         * a slow command and should not be called every frame.
         *
         * @param iImage - The ID of the image to change.
         * @param r      - The red component of the color to set as transparent
         * @param g      - The red component of the color to set as transparent
         * @param b      - The red component of the color to set as transparent
         * @return void
         */
        @Signature
        public native void SetImageTransparentColor(int iImage, int r, int g, int b);

        /**
         * Copies a color channel from one image to another. You can specify the source
         * and destination channels using the values 1,2,3,4 to represent red, green,
         * blue, and alpha respectively. This is a slow command and should not be called
         * every frame. The x,y offset values allow you to offset the source image on te
         * destination image so a small source image can be used to mask any part of a
         * large image. Any part of the large image outside the size of the small image
         * will be left unchanged. negative offset values are supported to shift the
         * source image off the top left of the destination image. If you add some
         * transparent pixels to an image that currently has none, and you use the image
         * on a sprite, then be sure to use SetSpriteTransparency to make the sprite
         * transparent.
         *
         * @param iDstImage - The ID of the image to change.
         * @param iSrcImage - The ID of the image to use as a source.
         * @param dst       - The ID of the color channel to use as the destination, 1-4
         *                  for RGBA,
         * @param src       - The ID of the color channel to use as the source, 1-4 for
         *                  RGBA,
         * @param x         - The x offset for the source image on the destination
         *                  image,
         * @param y         - The y offset for the source image on the destination
         *                  image.
         * @return void
         */
        @Signature
        public native void SetImageMask(int iDstImage, int iSrcImage, int dst, int src, int x, int y);

        /**
         * Sets the filter for textures when the texture is smaller than the screen
         * space it is displayed in. You can use a mode of 0 to use the nearest pixel,
         * which will appear blocky, or 1 to use a linear filter which will look blurry.
         * When the image matches the screen space exactly then both filters will look
         * the same when there is a slight difference, nearest tends to be sharper, but
         * may flicker as it changes pixel choice.
         *
         * @param iImageIndex - The ID of the image to change.
         * @param mode        - The filter mode to use, 0=nearest, 1=linear
         * @return void
         */
        @Signature
        public native void SetImageMinFilter(int iImageIndex, int mode);

        /**
         * Sets the filter for textures when the texture is larger than the screen space
         * it is displayed in. You can use a mode of 0 to use the nearest pixel, which
         * will appear blocky, or 1 to use a linear filter which will look blurry. When
         * the image matches the screen space exactly then both filters will look the
         * same when there is a slight difference, nearest tends to be sharper, but may
         * flicker as it changes pixel choice.
         *
         * @param iImageIndex - The ID of the image to change.
         * @param mode        - The filter mode to use, 0=nearest, 1=linear
         * @return void
         */
        @Signature
        public native void SetImageMagFilter(int iImageIndex, int mode);

        /**
         * Sets whether the device should verify the SSL certificate when making a
         * secure connection. If the server you are connecting to is using a self signed
         * certificate you will need to set this to 0 or the connection will fail. In
         * all other cases you must leave this at 1 to ensure a secure connection to the
         * server. Turning off verification will turn off protection against man in the
         * middle attacks on SSL connections.
         *
         * @param iHTTP - The ID of the connection to set.
         * @param mode  - 1 to verify, 0 to not verify.
         * @return void
         */
        @Signature
        public native void SetHTTPVerifyCertificate(int iHTTP, int mode);

        /**
         * Sets the time in milliseconds that AGK will wait for a connection to be made
         * before giving up.
         *
         * @param iHTTP        - The ID of the connection to set.
         * @param milliseconds - The time in milliseconds to wait.
         * @return void
         */
        @Signature
        public native void SetHTTPTimeout(int iHTTP, int milliseconds);

        /**
         * Sets the position of all 3D objects relative to 2D objects. For example using
         * a global 3D depth of 100 would mean that all sprites at a depth less than or
         * equal to 100 would appear above any 3D objects whilst sprites at a depth
         * greater than 100 would appear below any 3D objects.
         *
         * @param depth - The sprite depth to render 3D.
         * @return void
         */
        @Signature
        public native void SetGlobal3DDepth(int depth);

        /**
         * 
         * @param str
         * @return
         */
        @Signature
        public native int SetFolder(String str);

        /**
         * Turns off a motor previously applied to a joint that supports it. Works on
         * Line joints, Prismatic joints, and Revolute joints.
         *
         * @param iJointIndex - The ID of the joint to modify.
         * @return void
         */
        @Signature
        public native void SetJointMotorOff(int iJointIndex);

        /**
         * Works on Prismatic joints and Revolute joints. Sets the limit that this joint
         * can reach before stopping, for revolute joints this is based on angles, for
         * the others it is on length. By default a joint does not have limits.
         *
         * @param iJointIndex - The ID of the joint to modify.
         * @param lowerLimit  - The smallest extent that the joint can reach.
         * @param upperLimit  - The greatest extent that the joint can reach.
         * @return void
         */
        @Signature
        public native void SetJointLimitOn(int iJointIndex, float lowerLimit, float upperLimit);

        /**
         * Sets the 3D fog sun color. This is used in place of the normal fog color when
         * the camera is facing the sun, as defined by the command SetSunDirection. This
         * can be used to simulate light scattering effects to make the air seem hazy.
         * The fog sun color should be close to the sun color for best effect, but this
         * need not be the case. Note that calling this command changes the fog
         * calculation to a more complicated version that will reduce performance on
         * mobile devices. To return to the faster method of calculating fog, make the
         * fog sun color equal to the normal fog color.
         *
         * @param red   - The red component of the color.
         * @param green - The green component of the color.
         * @param blue  - The blue component of the color.
         * @return void
         */
        @Signature
        public native void SetFogSunColor(int red, int green, int blue);

        /**
         * Sets the domain of the host you want to connect to, for example to access
         * www.thegamecreators.com/index.php you would use a host value of
         * www.thegamecreators.com, do not include the http: that usually goes before
         * it. Note that trying to use a specific port with www.thegamecreators.com:8080
         * may be ignored on some platforms and port 80 will be used in these cases.
         * When exporting to HTML5 note that web browsers limit which servers you can
         * connect to. By default you are limited to files hosted by the same server as
         * your app. However if the server sends an Access-Control-Allow-Origin header
         * in its response that allows your app's server, then the browser will let you
         * connect to it.
         *
         * @param iHTTP   - The ID of the connection to set.
         * @param szHost  - The domain to connect to.
         * @param iSecure - Set to 1 to use an HTTPS secure connection, 0 to use a
         *                standard HTTP connection.
         * @return int
         */
        @Signature
        public native int SetHTTPHost(int iHTTP, String szHost, int iSecure);

        /**
         * Sets the domain of the host you want to connect to, for example to access
         * www.thegamecreators.com/index.php you would use a host value of
         * www.thegamecreators.com, do not include the http: that usually goes before
         * it. Note that trying to use a specific port with www.thegamecreators.com:8080
         * may be ignored on some platforms and port 80 will be used in these cases.
         * When exporting to HTML5 note that web browsers limit which servers you can
         * connect to. By default you are limited to files hosted by the same server as
         * your app. However if the server sends an Access-Control-Allow-Origin header
         * in its response that allows your app's server, then the browser will let you
         * connect to it.
         *
         * @param iHTTP   - The ID of the connection to set.
         * @param szHost  - The domain to connect to.
         * @param iSecure - Set to 1 to use an HTTPS secure connection, 0 to use a
         *                standard HTTP connection.
         * @param szUser  - The username to send to the server.
         * @param szPass  - The password to send to the server.
         * @return int
         */
        @Signature
        public native int SetHTTPHost(int iHTTP, String szHost, int iSecure, String szUser, String szPass);

        /**
         * Sets the 3D fog color. Objects will gradually fade to this color as they get
         * further from the camera. Color values should be in the range 0 to 255, but
         * they are not limited to this and the system will accept out of range values,
         * including negative.
         *
         * @param red   - The red component of the color.
         * @param green - The green component of the color.
         * @param blue  - The blue component of the color.
         * @return void
         */
        @Signature
        public native void SetFogColor(int red, int green, int blue);

        /**
         * Sets 3D fog on or off, this can be used to create an atmospheric haze or fade
         * objects to the background color to simulate reduced visibility. Fog will be
         * automatically applied to all 3D objects if they are using the default shader.
         * If you have applied your own shader with SetObjectShader then declare the
         * function mediump vec3 ApplyFog( mediump vec3 color, highp vec3 pointPos ); in
         * the pixel shader which AGK will fill in for you at run time. pointPos is the
         * pixel position in world coordinates, which you will need to pass in from the
         * vertex shader.
         *
         * @param mode - 1 to turn fog on, 0 to turn it off.
         * @return void
         */
        @Signature
        public native void SetFogMode(int mode);

        /**
         * Sets the current read position in the file
         *
         * @param iFileID - The ID of the file to check.
         * @param pos     - The new position to continue reading from
         * @return void
         */
        @Signature
        public native void SetFilePos(int iFileID, int pos);

        /**
         * Sets the range of the 3D fog. No fog will occur within the minimum distance,
         * after which the fog will begin to take affect. The maximum distance is not a
         * limit and is only a rough guide for how far you want to be able to see in
         * your scene. The fog increases exponentially to mimic reality, meaning it
         * increases quickly at first then tails off and gradually reaches full
         * intensity around the maximum distance.
         *
         * @param minDist - The minimum distance for the fog, no fog will affect pixels
         *                within this distance from the camera.
         * @param maxDist - The maximum distance for the fog, the fog will reach full
         *                intensity around this distance.
         * @return void
         */
        @Signature
        public native void SetFogRange(float minDist, float maxDist);

        /**
         * Sets the version number to use in the other expansion file commands.
         * Currently only applicable to Android. The version number of the expansion
         * file is determined by the version number of the APK that was uploaded with
         * it. For example the APK may be updated to a new version number but the
         * expansion file could still be the original version number.
         *
         * @param version - The version number to use when checking for and downloading
         *                an expansion file.
         * @return void
         */
        @Signature
        public native void SetExpansionFileVersion(int version);

        /**
         * Sets the error mode for the AGK from ignore, report, or stop from AGK
         * commands, e.g. sprite ID doesn't exist in a command that accepts a sprite ID.
         * Ignoring will make the AGK attempt to carry on, ignoring the entire command
         * if necessary. Reporting will make the AGK report the error to an appropriate
         * debug console and carry on. Stop will force the AGK to report the error as
         * before and then stop by throwing an exception, which must be caught or the
         * app will terminate. In the case of tier 1 the exception is caught by the
         * interpreter and, if debugging, displayed in the IDE.
         *
         * @param mode - 0=ignore, 1=report, 2=stop
         * @return void
         */
        @Signature
        public native void SetErrorMode(int mode);

        /**
         * Sets the public key to use in the other expansion file commands. Currently
         * only applicable to Android. The public key can be found in the Google Play
         * Developer Console and is different for each app. Click on the app and then
         * click on the Services and APIs section, it is the long string that starts
         * MIIB.
         *
         * @param key - The public key to use when checking for and downloading an
         *            expansion file.
         * @return void
         */
        @Signature
        public native void SetExpansionFileKey(String key);

        /**
         * When SetEditBoxMultiLine is set to 0 this command sets whether the single
         * line of text will scroll to the right or wrap to a new line when it over
         * flows the edit box width. The use will still not be allowed to enter new line
         * characters themselves.
         *
         * @param index - The ID of the edit box to modify.
         * @param mode  - 0 to scroll to the right (default), 1 to wrap to a new line.
         * @return void
         */
        @Signature
        public native void SetEditBoxWrapMode(int index, int mode);

        /**
         * Toggles the visible status of this edit box, when visible is set to 1 the
         * edit box can be clicked on, gain focus and be changed, when set to 0 the edit
         * box is not shown, cannot be changed, nor gain focus.
         *
         * @param index   - The ID of the edit box to modify.
         * @param visible - The new state of the edit box, 1 for visible, 0 for
         *                invisible.
         * @return void
         */
        @Signature
        public native void SetEditBoxVisible(int index, int visible);

        /**
         * Sets the height in world coordinates of the text in this edit box. By default
         * it is set to the edit box's height minus 2.
         *
         * @param index - The ID of the edit box to modify.
         * @param size  - The new size of font to use.
         * @return void
         */
        @Signature
        public native void SetEditBoxTextSize(int index, float size);

        /**
         * Sets whether the edit box will use an alternate text input method if the edit
         * box would be hidden by a virtual keyboard. This only applies to mobile
         * platforms like iOS and Android and the alternate input method is usually a
         * smaller edit box placed just above the keyboard. The edit box will still
         * update in real time as if it is being typed into directly, but since it is
         * covered by the keyboard the user will not see it. By default this is turned
         * on. If you wish you can turn it off and move the edit box into view when
         * GetEditBoxHasFocus returns 1, be sure to move it back again when
         * GetEditBoxHasFocus returns 0.
         *
         * @param index - The ID of the edit box to modify.
         * @param mode  - 1 to use alternate input (default), 0 to use the normal input.
         * @return void
         */
        @Signature
        public native void SetEditBoxUseAlternateInput(int index, int mode);

        /**
         * Sets the color of the text being input.
         *
         * @param index - The ID of the edit box to modify.
         * @param red   - The red component of the color (0 to 255).
         * @param green - The green component of the color (0 to 255).
         * @param blue  - The blue component of the color (0 to 255).
         * @return void
         */
        @Signature
        public native void SetEditBoxTextColor(int index, int red, int green, int blue);

        /**
         * Sets the text which is currently being displayed in the edit box.
         *
         * @param index - The ID of the edit box to modify.
         * @param str   - The new text to display.
         * @return void
         */
        @Signature
        public native void SetEditBoxText(int index, String str);

        /**
         * Clips the edit box to the specified world coordinates when drawn.
         *
         * @param index - The ID of the edit box to modify.
         * @param x     - The x coordinate of the top left corner of the box to use as a
         *              clip boundary.
         * @param y     - The y coordinate of the top left corner of the box to use as a
         *              clip boundary.
         * @param x2    - The x coordinate of the bottom right corner of the box to use
         *              as a clip boundary.
         * @param y2    - The y coordinate of the bottom right corner of the box to use
         *              as a clip boundary.
         * @return void
         */
        @Signature
        public native void SetEditBoxScissor(int index, float x, float y, float x2, float y2);

        /**
         * Sets whether the edit box display stars instead of the text input. Using
         * GetEditBoxText will still return the actual characters entered by the user.
         *
         * @param index - The ID of the edit box to modify.
         * @param mode  - 1 to display stars, 0 to display the normal input.
         * @return void
         */
        @Signature
        public native void SetEditBoxPasswordMode(int index, int mode);

        /**
         * Sets whether the edit box will wrap text to a new line when it reaches the
         * edge of the edit box. The default is for multiline to be 0 so text is one
         * continuous line in the box.
         *
         * @param index     - The ID of the edit box to modify.
         * @param multiline - 1 to enable multiline, 0 to disable.
         * @return void
         */
        @Signature
        public native void SetEditBoxMultiLine(int index, int multiline);

        /**
         * Sets the maximum number of lines that can be entered into this multiline edit
         * box. Use 0 for unlimited.
         *
         * @param index - The ID of the edit box to modify.
         * @param max   - The maximum number of lines.
         * @return void
         */
        @Signature
        public native void SetEditBoxMaxLines(int index, int max);

        /**
         * Sets whether loaded images having mipmaps generated and used. Should be
         * called before any images are loaded. May be changed before another image is
         * loaded to make some use mipmaps and others not.
         *
         * @param generate - Set to 1 to generate mipmaps (default is 0)
         * @return void
         */
        @Signature
        public native void SetGenerateMipmaps(int generate);

        /**
         * Sets the maximum number of characters that can be entered in this edit box.
         * Use 0 for unlimited.
         *
         * @param index - The ID of the edit box to modify.
         * @param max   - The maximum number of characters.
         * @return void
         */
        @Signature
        public native void SetEditBoxMaxChars(int index, int max);

        /**
         * Sets the type of keyboard that will appear on mobile devices when editing
         * this edit box. Where possible a keyboard of that type will be displayed, for
         * example a keyboard with numbers only.
         *
         * @param index     - The ID of the edit box to modify.
         * @param inputType - 0 for normal text, 1 for numbers only.
         * @return void
         */
        @Signature
        public native void SetEditBoxInputType(int index, int inputType);

        /**
         * Sets the font image to use for this edit box, must have been previously
         * loaded with LoadImage(). Use 0 to return the edit box to its default font.
         *
         * @param index - The ID of the edit box to modify.
         * @param image - The ID of the image to use, 0 for default font.
         * @return void
         */
        @Signature
        public native void SetEditBoxFontImage(int index, int image);

        /**
         * Sets the position in world coordinates of the edit box using it's top left
         * corner. This sets the position of the actual text entry box, its border will
         * extend to the left and above this point.
         *
         * @param index - The ID of the edit box to modify.
         * @param x     - The X value of the position.
         * @param y     - The Y value of the position.
         * @return void
         */
        @Signature
        public native void SetEditBoxPosition(int index, float x, float y);

        /**
         * Sets the extended font image to use for this edit box, must have been
         * previously loaded with LoadImage(). Use 0 to remove the extended font image.
         * If you do not set this image the edit box will not accept extended characters
         * such as £ é á etc.
         *
         * @param index - The ID of the edit box to modify.
         * @param image - The ID of the image to use, 0 to use no image.
         * @return void
         */
        @Signature
        public native void SetEditBoxExtendedFontImage(int index, int image);

        /**
         * Toggles the focus status of this edit box, when focus is set to 1 the cursor
         * starts flashing and any key presses will add text to the edit box. When set
         * to 0 the cursor disappears and text will not be added.
         *
         * @param index - The ID of the edit box to modify.
         * @param focus - The new state of the edit box, 1 for active, 0 for inactive.
         * @return void
         */
        @Signature
        public native void SetEditBoxFocus(int index, int focus);

        /**
         * Sets the depth of the edit box so it may appear behind or in front of other
         * sprites and text objects.
         *
         * @param index - The ID of the edit box to modify.
         * @param depth - The depth in the range 0 (front) to 10000 (back).
         * @return void
         */
        @Signature
        public native void SetEditBoxDepth(int index, int depth);

        /**
         * Sets the cursor to the specified position in the text, i.e. position 0 is
         * left of the first character, position 1 is left of the second character, and
         * so on. If the position value is out of range it will be clamped to the
         * nearest character. The current cursor position is guaranteed to be in view of
         * the user, so this can be used to left or right justify text by setting the
         * cursor to the far left or right of the text.
         *
         * @param index - The ID of the edit box to modify.
         * @param pos   - The new position of the cursor
         * @return void
         */
        @Signature
        public native void SetEditBoxCursorPosition(int index, int pos);

        /**
         * Sets the color of the flashing cursor in this edit box.
         *
         * @param index - The ID of the edit box to modify.
         * @param red   - The red component of the color (0 to 255).
         * @param green - The green component of the color (0 to 255).
         * @param blue  - The blue component of the color (0 to 255).
         * @return void
         */
        @Signature
        public native void SetEditBoxCursorColor(int index, int red, int green, int blue);

        /**
         * Sets the size of the edit box in world coordinates. This sets the size of the
         * actual text entry box, its border will extend beyond these values.
         *
         * @param index  - The ID of the edit box to modify.
         * @param width  - The width of the new size.
         * @param height - The height of the new size.
         * @return void
         */
        @Signature
        public native void SetEditBoxSize(int index, float width, float height);

        /**
         * Sets the time in seconds between the cursor being visible and invisible in
         * the text entry box.
         *
         * @param index - The ID of the edit box to modify.
         * @param time  - The time in seconds.
         * @return void
         */
        @Signature
        public native void SetEditBoxCursorBlinkTime(int index, float time);

        /**
         * Sets the size of the border in world coordinates that will surround the text
         * entry box. For example a value of 2 would add a 2 pixel border around the
         * entry box.
         *
         * @param index - The ID of the edit box to modify.
         * @param size  - The size of the border.
         * @return void
         */
        @Signature
        public native void SetEditBoxBorderSize(int index, float size);

        /**
         * Sets an image to use for the border, this can be used together with the
         * border color. Use 0 to remove the border image.
         *
         * @param index - The ID of the edit box to modify.
         * @param image - The ID of the image to use.
         * @return void
         */
        @Signature
        public native void SetEditBoxBorderImage(int index, int image);

        /**
         * Sets an image to use for the background, this can be used together with the
         * background color. Use 0 to remove the background image.
         *
         * @param index - The ID of the edit box to modify.
         * @param image - The ID of the image to use.
         * @return void
         */
        @Signature
        public native void SetEditBoxBackgroundImage(int index, int image);

        /**
         * Sets the color of the main text entry box.
         *
         * @param index - The ID of the edit box to modify.
         * @param red   - The red component of the color (0 to 255).
         * @param green - The green component of the color (0 to 255).
         * @param blue  - The blue component of the color (0 to 255).
         * @param alpha - The alpha component of the color (0 to 255). 255 is fully
         *              opaque.
         * @return void
         */
        @Signature
        public native void SetEditBoxBackgroundColor(int index, int red, int green, int blue, int alpha);

        /**
         * This command is used in conjunction with the default percentage based
         * positioning system in AGK. If using this approach you will need to specify a
         * display aspect, so that AGK knows how to correctly display entities on
         * screen. If your artwork was originally designed for a resolution of 1024 x
         * 768, this would result in an aspect ratio of 4:3, which is also the same as
         * saying 1024 / 768 = 1.33, therefore you would call SetDisplayAspect and pass
         * in a 1.33 as your aspect ratio. On platforms where the resolution was
         * different AGK will take care of things internally so that your application
         * still maintains this aspect ratio and looks correct. The alternative approach
         * is to call SetVirtualResolution to control the coordinate system and place
         * sprites using screen coordinates instead of using percentages, in which case
         * you should not call this command. If sprites already exist when this is
         * called they will become distorted. If the aspect ratio given does not fit
         * exactly on the current device, black borders will be drawn around the
         * rendering area to center it on screen. Use an aspect ratio of 0 to use the
         * current coordinate system as the aspect ratio. Use an aspect ratio of -1 to
         * use the device aspect ratio (fills the whole screen without black borders,
         * but will cause stretching and look different on every device) An alternative
         * method of filling the screen which avoids this problem is to use SetScissor
         * with the values 0,0,0,0.
         *
         * @param aspect - the aspect ratio to use from now on, in the form of
         *               width/height.
         * @return void
         */
        @Signature
        public native void SetDisplayAspect(float aspect);

        /**
         * Sets the font to use for this edit box, must have been previously loaded with
         * LoadFont. Use 0 to return the edit box to its default font.
         *
         * @param index  - The ID of the edit box to modify.
         * @param fontID - The ID of the font to use, 0 for default font.
         * @return void
         */
        @Signature
        public native void SetEditBoxFont(int index, int fontID);

        /**
         * Using an image ID greater than zero will stream the device camera to the
         * chosen image. The image must not currently exist, it will be created by this
         * command. Use an imageID of 0 to stop streaming, this will also delete the
         * image. The cameraID parameter is used when the device has multiple cameras,
         * for example front and back facing cameras. Typically 0 refers the back facing
         * camera. Use GetNumDeviceCameras to see how many cameras this device has and
         * GetDeviceCameraType to check whether it is front or back facing. This
         * parameter is ignored if the imageID is 0. You can only have one device camera
         * active at once, so to switch from back to front facing cameras you must first
         * call this command with imageID set to 0 to stop the capture, then start it
         * again with the new cameraID. Returns 1 if it was successful, 0 if there was a
         * problem or the current platform doesn't support this command. This is
         * currently supported on iOS, Android 4.0.3 and above, and Windows.
         *
         * @param cameraID - The ID of the device camera you want to use, could be back
         *                 or front facing camera
         * @param imageID  - The imageID you want to use for this image, must not exist
         * @return int
         */
        @Signature
        public native int SetDeviceCameraToImage(int cameraID, int imageID);

        /**
         * Sets the default texture wrapping for images where the UV coordinates go
         * beyond the range 0 to 1 in the V direction.
         *
         * @param mode - The wrapping mode to use 0=clamp, 1=repeat
         * @return void
         */
        @Signature
        public native void SetDefaultWrapV(int mode);

        /**
         * Sets the width in world coordinates of the text input cursor, by default this
         * is set to 1.5 Note that functions that change the text size or edit box size
         * may overwrite this value.
         *
         * @param index - The ID of the edit box to modify.
         * @param width - The new width of the cursor.
         * @return void
         */
        @Signature
        public native void SetEditBoxCursorWidth(int index, float width);

        /**
         * Sets the default texture wrapping for images where the UV coordinates go
         * beyond the range 0 to 1 in the U direction.
         *
         * @param mode - The wrapping mode to use 0=clamp, 1=repeat
         * @return void
         */
        @Signature
        public native void SetDefaultWrapU(int mode);

        /**
         * Sets the default minification filter for textures when the texture is smaller
         * than the screen space it is displayed in. You can use a mode of 0 to use the
         * nearest pixel, which will appear blocky, or 1 to use a linear filter which
         * will look blurry. When the image matches the screen space exactly then both
         * filters will look the same when there is a slight difference, nearest tends
         * to be sharper, but may flicker as it changes pixel choice. You can set this
         * value per image using SetImageMinFilter.
         *
         * @param filter - The filter mode to use 0=nearest, 1=linear
         * @return void
         */
        @Signature
        public native void SetDefaultMinFilter(int filter);

        /**
         * Sets the default magnification filter for textures when the texture is larger
         * than the screen space it is displayed in. You can use a mode of 0 to use the
         * nearest pixel, which will appear blocky, or 1 to use a linear filter which
         * will look blurry. When the image matches the screen space exactly then both
         * filters will look the same when there is a slight difference, nearest tends
         * to be sharper, but may flicker as it changes pixel choice. You can set this
         * value per image using SetImageMagFilter.
         *
         * @param filter - The filter mode to use 0=nearest, 1=linear
         * @return void
         */
        @Signature
        public native void SetDefaultMagFilter(int filter);

        /**
         * Sets the time in seconds between the cursor appearing and disappearing in the
         * fullscreen edit box
         *
         * @param seconds - The time in seconds.
         * @return void
         */
        @Signature
        public native void SetCursorBlinkTime(float seconds);

        /**
         * Sets a cloud data variable to the specified value. If multiple devices write
         * a value at the same time then the cloud provider chooses one and sends it to
         * all devices. The variable name must be less than 64 bytes, a single UTF8
         * character may be multiple bytes but typically 1 character equals 1 byte. It
         * is recommended that variable names incorporate the app name, for example
         * "myapp.myvariablename", since when broadcasting your apps they will all share
         * a single data store in the AGK PLayer app. Varaible data is stored locally so
         * GetCloudDataVariable will immediately return the new value, however syncing
         * with the cloud is done in the background and may take several minutes. If the
         * device has no internet connection then the data will be synced at the next
         * available opportunity. On iOS you are limited to 1024 variables with 1MB
         * total storage. On Android any data you store counts against the user's Google
         * Drive storage limit, the user can clear your app data to free up space, but
         * they cannot read the data you store. You should not store sensitive
         * information like passwords in plain text using these commands.
         *
         * @param varName  - The name of the variable to change, must be less than 64
         *                 bytes
         * @param varValue - The value to set the variable
         * @return void
         */
        @Signature
        public native void SetCloudDataVariable(String varName, String varValue);

        /**
         * Sets the color of any border present. You can also use an image by using
         * SetEditBoxBorderImage().
         *
         * @param index - The ID of the edit box to modify.
         * @param red   - The red component of the color (0 to 255).
         * @param green - The green component of the color (0 to 255).
         * @param blue  - The blue component of the color (0 to 255).
         * @param alpha - The alpha component of the color (0 to 255). 255 is fully
         *              opaque.
         * @return void
         */
        @Signature
        public native void SetEditBoxBorderColor(int index, int red, int green, int blue, int alpha);

        /**
         * Sets your Chartboost account details to be used by interstitial (fullscreen)
         * ads and reward video ads. After calling this command an attempt will be made
         * to cache an interstitial so you can display it immediately later. You can
         * check the progress of this by using GetFullscreenAdvertLoadedChartboost. Note
         * that this command will not automatically cache a reward video ad, you must do
         * that manually with CacheRewardAdChartboost. Chartboost ads are currently
         * supported by Android and iOS.
         *
         * @param szKey1 - App ID
         * @param szKey2 - App Signature
         * @return void
         */
        @Signature
        public native void SetChartboostDetails(String szKey1, String szKey2);

        /**
         * Toggles the active status of this edit box, when active is set to 1 the edit
         * box can be clicked on, gain focus and be changed, when set to 0 the edit box
         * cannot be changed nor gain focus.
         *
         * @param index  - The ID of the edit box to modify.
         * @param active - The new state of the edit box, 1 for active, 0 for inactive.
         * @return void
         */
        @Signature
        public native void SetEditBoxActive(int index, int active);

        /**
         * Sets the rotation of the specified camera using euler angles in degrees.
         * Alternatively you can use SetCameraRotationQuat to use a quaternion. By
         * default cameras are created with the angles 0,0,0 in the order YXZ. Euler
         * angles are compound angles where the camera starts at 0,0,0 and is then
         * rotated using the given Y angle, then by the given X angle, then rolled by
         * the given Z angle. Each 3D rotation can be represented by 2 Euler angle
         * combinations, Y,X,Z and Y-180,X-180,Z-180 so either version may be returned
         * by the GetCameraAngle commands. Quaternions and Euler angles can both be used
         * at the same time. For example setting an Euler angle rotation will generate a
         * quaternion representation that can be retrieved with GetCameraQuatX, etc.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param angx     - The X component of the euler rotation.
         * @param angy     - The Y component of the euler rotation.
         * @param angz     - The Z component of the euler rotation.
         * @return void
         */
        @Signature
        public native void SetCameraRotation(int cameraID, float angx, float angy, float angz);

        /**
         * Sets the near and far planes of the camera. Due to rendering limitations not
         * everything in front of the camera can be rendered so they must be limited to
         * a visible range. Anything outside this range is clipped by the rendering
         * system and is invisible. The near plane is the closest that an object can be
         * to the camera and still be rendered, it must be greater than 0. Note that
         * using very small values for the near plane will affect the accuracy of the
         * depth buffer when rendering objects far away which might cause flickering on
         * far away objects. This is because the depth buffer is not linear, instead it
         * is skewed towards the near plane and the closer to 0 the near plane becomes
         * the less of the depth buffer is available for far objects. The far plane is
         * the maximum distance an object can be from the camera and still be rendered,
         * it's maximum value is infinity but again the further you try to render an
         * object from the near plane the less accurate depth buffering becomes. If an
         * object crosses the near or far plane so that part of it is on one side and
         * part is on the other the object will be cut by the plane and only the part
         * within the view range will be visible. The default range is near=1, far=1000.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param fNear    - The nearest that an object will be rendered.
         * @param fFar     - The furthest that an object will be rendered.
         * @return void
         */
        @Signature
        public native void SetCameraRange(int cameraID, float fNear, float fFar);

        /**
         * Sets the clear color to use when clearing the back buffer.
         *
         * @param red   - The red component of the clear color
         * @param green - The green component of the clear color
         * @param blue  - The blue component of the clear color
         * @return void
         */
        @Signature
        public native void SetClearColor(int red, int green, int blue);

        /**
         * Sets the position of the specified camera. By default cameras are positioned
         * at 0,0,0 The main camera is ID 1.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param x        - The X component of the position.
         * @param y        - The Y component of the position.
         * @param z        - The Z component of the position.
         * @return void
         */
        @Signature
        public native void SetCameraPosition(int cameraID, float x, float y, float z);

        /**
         * Sets the rotation of the specified camera using a quaternion. Alternatively
         * you can use SetCameraRotation to use Euler angles. By default cameras are
         * created with the quaternion 1,0,0,0 in the order w,x,y,z. A Quaternion is a 4
         * dimensional representation of a 3D rotation with the property w^2+x^2+y^2+z^2
         * = 1 which allows easy interpolation between two rotations by linearly
         * interpolating the two quaternions and normalising them. Each 3D rotation is
         * represented by exactly 2 quaternions, w,x,y,z and -w,-x,-y,-z so either
         * version may be returned by the GetCameraQuat commands. Quaternions and Euler
         * angles can both be used at the same time. For example setting a quaternion
         * rotation will generate Euler representation that can be retrieved with
         * GetCameraAngleX, etc.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param w        - The W component of the quaternion.
         * @param x        - The X component of the quaternion.
         * @param y        - The Y component of the quaternion.
         * @param z        - The Z component of the quaternion.
         * @return void
         */
        @Signature
        public native void SetCameraRotationQuat(int cameraID, float w, float x, float y, float z);

        /**
         * This command is deprecated and has been replaced with SetFolder.
         *
         * @param szPath - The directory to use as the new current directory.
         * @return int
         */
        @Signature
        public native int SetCurrentDir(String szPath);

        /**
         * Rotates the camera to look at a particular point in space with an optional
         * roll value. "looking at" is defined as aligning the camera's local Z axis to
         * point its positive side at the given point. This can be achieved using only
         * the Y and X angles in Euler notation, so you can specify an optional Z angle
         * in degrees to roll the camera left of right whilst always looking at the same
         * spot.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param x        - The X component of the position to look at.
         * @param y        - The Y component of the position to look at.
         * @param z        - The Z component of the position to look at.
         * @param roll     - The Z angle to roll the camera when looking at the given
         *                 position, negative is clockwise.
         * @return void
         */
        @Signature
        public native void SetCameraLookAt(int cameraID, float x, float y, float z, float roll);

        /**
         * Sets the device clipboard to the specified text, this overwrites anything
         * that was previously in the device clipboard. The clipboard is the same as
         * that used by the copy/paste functionality of the device.
         *
         * @param szText - The text to copy
         * @return void
         */
        @Signature
        public native void SetClipboardText(String szText);

        /**
         * Sets the parameters for an off center projection matrix. The near and far
         * values are set separately with SetCameraRange. To use an off center
         * projection matrix you must activate it with SetCameraOffCenter.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param left     - The left component of the projection matrix.
         * @param right    - The right component of the projection matrix.
         * @param top      - The top component of the projection matrix.
         * @param bottom   - The bottom component of the projection matrix.
         * @return void
         */
        @Signature
        public native void SetCameraBounds(int cameraID, float left, float right, float top, float bottom);

        /**
         * This function positions a virtual button at the given position only if it is
         * necessary for this device, for example if a real joystick or keyboard are
         * present then this command will have no noticeable effect. It is recommended
         * you call this command anyway, just in case a virtual button is needed. The
         * AGK buttons are an emulated input method that uses whatever device inputs are
         * available to produce 5 buttons. If a real joystick is found then the first 5
         * buttons from that will be used for the AGK button commands. Otherwise the AGK
         * looks for a full-size keyboard and if found will use the following keys in
         * the following order Space, E, R, Q, Control, to represent buttons 1 to 5
         * respectively. If neither a joystick nor keyboard is found then a virtual
         * button is created that will appear on screen and can be pressed with either
         * touch screen inputs or a mouse. Every platform is guaranteed to have a method
         * of activating the AGK buttons. If a virtual button is created it will be
         * centered on the given X,Y position.
         *
         * @param index - The ID of the button to position, must be in the range 1 to 5
         *              inclusive.
         * @param x     - The X coordinate of the button position in screen coordinates.
         * @param y     - The Y coordinate of the button position in screen coordinates.
         * @param size  - The diameter of the button position in screen coordinates.
         * @return void
         */
        @Signature
        public native void SetButtonScreenPosition(int index, float x, float y, float size);

        /**
         * Sets the camera to use an off center projection matrix. You must set the
         * projection matrix values by using SetCameraBounds and SetCameraRange.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param mode     - 1 to use an off center projection matrix, 0 to use a normal
         *                 matrix, default is 0.
         * @return void
         */
        @Signature
        public native void SetCameraOffCenter(int cameraID, int mode);

        /**
         * Sets the color or any borders used when the display does not fit the aspect
         * ratio exactly. If this color is different from the clear color than an
         * additional clear operation is performed and may affect performance if fill
         * rate is an issue.
         *
         * @param red   - The red component of the border color
         * @param green - The green component of the border color
         * @param blue  - The blue component of the border color
         * @return void
         */
        @Signature
        public native void SetBorderColor(int red, int green, int blue);

        /**
         * Sets a new color for the global ambient light. Values should be in the range
         * 0-255 but are not limited to it. Values greater than 255 will over saturate
         * things and values less than 0 will take light away. The default ambient color
         * is 76,76,76.
         *
         * @param red   - The red component of the new color.
         * @param green - The green component of the new color.
         * @param blue  - The blue component of the new color.
         * @return void
         */
        @Signature
        public native void SetAmbientColor(int red, int green, int blue);

        /**
         * Sets the camera horizontal field of view (FOV). This determines the angle
         * between the left and right of the camera view, the default being 70 and
         * provides a realistic 3D projection. Using smaller values would look like the
         * camera is zooming in on the scene without actually moving. This is sometimes
         * used for dramatic effect in movies where the FOV zooms one way whilst the
         * camera moves the other way. Using an FOV value of 0 is a special case that
         * will generate an orthographic matrix instead of a projection matrix, this
         * will make everything stay the same size no matter how near or far it is to
         * the camera. The orthographic matrix will have a width of 40 world units with
         * a height determined by the camera aspect ratio.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param fov      - The field of view in degrees.
         * @return void
         */
        @Signature
        public native void SetCameraFOV(int cameraID, float fov);

        /**
         * Sets your Amazon Ads account details to be used by interstitial (fullscreen)
         * ads. After calling this command an attempt will be made to cache an
         * interstitial so you can display it immediately later. You can check the
         * progress of this by using GetFullscreenAdvertLoadedAmazon. Amazon ads are
         * currently supported by iOS and Android.
         *
         * @param szKey - Ad unit ID as provided by Amazon.
         * @return void
         */
        @Signature
        public native void SetAmazonAdDetails(String szKey);

        /**
         * Sets whether the Amazon Ads will be test ads or paying ads. This should be
         * called before SetAmazonAdDetails to ensure all ads are test ads. By default
         * paying ads will be shown.
         *
         * @param mode - 0=show paying ads, 1=show test ads
         * @return void
         */
        @Signature
        public native void SetAmazonAdTesting(int mode);

        /**
         * If the camera FOV is set to 0 then this will determine the width of the
         * orthographic view, the default is 40. The height value will be calculated
         * from it based on the camera aspect ratio. When using an orthographic
         * projection everything remains the same size no matter how near or far it is
         * to the camera, so when using the default width value, a cube of size 80 units
         * would always fill the camera view when the camera is looking at it, since the
         * 40 is measured from the center of the screen to the edge. This command will
         * overwrite any values set with SetCameraBounds.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param width    - The width of the view in world coordinates.
         * @return void
         */
        @Signature
        public native void SetCameraOrthoWidth(int cameraID, float width);

        /**
         * Positions the advert created with CreateAdvert somewhere on screen and
         * attempts to scale it to a certain width. Since the advert will have its own
         * aspect ratio the height will be calculated from the width. This is not
         * guaranteed to work on all advert providers, currently only Inneractive can
         * scale and move ads to an absolute position.
         *
         * @param x     - The x position of the top left corner of the ad
         * @param y     - The y position of the top left corner of the ad
         * @param width - The desired width of the ad, it will be scaled to this width
         * @return void
         */
        @Signature
        public native void SetAdvertPosition(float x, float y, float width);

        /**
         * Positions the advert created with CreateAdvert somewhere on screen and
         * attempts to scale it to a certain width. Since the advert will have its own
         * aspect ratio the height will be calculated from the width. This provides
         * rough positioning by letting you choose between left, centered, or right
         * justify for the horizontal and vertical positions. This is not guaranteed to
         * work on all advert providers, currently only Inneractive can scale ads to a
         * specific width.
         *
         * @param horz  - The horizontal position of the ad, 0=left, 1=center, 2=right
         * @param vert  - The vertical postion of the ad, 0=top, 1=center, 2=bottom
         * @param width - The desired width of the ad, it will be scaled to this width
         * @return void
         */
        @Signature
        public native void SetAdvertLocation(int horz, int vert, float width);

        /**
         * Positions the advert created with CreateAdvert somewhere on screen and
         * attempts to scale it to a certain width. Since the advert will have its own
         * aspect ratio the height will be calculated from the width. This provides
         * rough positioning by letting you choose between left, centered, or right
         * justify for the horizontal and vertical positions. This is not guaranteed to
         * work on all advert providers, currently only Inneractive can scale ads to a
         * specific width.
         *
         * @param horz    - The horizontal position of the ad, 0=left, 1=center, 2=right
         * @param vert    - The vertical postion of the ad, 0=top, 1=center, 2=bottom
         * @param offsetx - when horz is equal to 0 or 2 this value offsets the ad from
         *                the specified edge
         * @param offsety - when vert is equal to 0 or 2 this value offsets the ad from
         *                the specified edge
         * @param width   - The desired width of the ad, it will be scaled to this width
         * @return void
         */
        @Signature
        public native void SetAdvertLocationEx(int horz, int vert, float offsetx, float offsety, float width);

        /**
         * Sets the camera aspect ratio when rendering 3D. The default is
         * GetDeviceWidth()/GetDeviceHeight() and provides a realistic 3D projection. If
         * the device backbuffer size changes, for example if the device changes
         * orientation, or the window size is changed, or SetScreenResolution is called,
         * then this value will reset to its default.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param aspect   - The new aspect ratio to use.
         * @return void
         */
        @Signature
        public native void SetCameraAspect(int cameraID, float aspect);

        /**
         * Sets whether the device should use anti-aliasing when rendering to the back
         * buffer. Currently this only applies to Windows, Mac, and Linux, and only 4x
         * multi-sampling is available. This does not apply to any objects drawn to an
         * image with SetRenderToImage, only the back buffer is anti-aliased.
         *
         * @param mode - 0=off, 1=4xMSAA
         * @return void
         */
        @Signature
        public native void SetAntialiasMode(int mode);

        /**
         * Sets your AdMob account details to be used by banner ads and interstitial
         * (fullscreen) ads. Note that this only supports one or the other, you can
         * either set a banner ad unit ID, or an interstitial ad unit ID, but not both
         * at the same time. After calling this command an attempt will be made to cache
         * an interstitial so you can display it immediately later. You can check the
         * progress of this by using GetFullscreenAdvertLoadedAdMob. AdMob ads are
         * currently supported by iOS and Android.
         *
         * @param szID - Ad unit ID as provided by AdMob.
         * @return void
         */
        @Signature
        public native void SetAdMobDetails(String szID);

        /**
         * Set the visibility of any advert.
         *
         * @param iVisible - 1 will display the advert and 0 will hide it.
         * @return void
         */
        @Signature
        public native void SetAdvertVisible(int iVisible);

        /**
         * Set the target velocity for a twist joint. Must be called in the loop. Enable
         * joint first with Set3DPhysicsTwistJointMotorIsEnabled()
         *
         * @param jointID        - Id of joint
         * @param rotationVec3ID - The Id of a Vector which has the rotation target for
         *                       a twist joint motor.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsTwistJointMotorRotationTarget(int jointID, int rotationVec3ID);

        /**
         * Sets the content rating for AdMob ads if your app is targeted at children.
         * This must be called before SetAdMobDetails
         *
         * @param rating - 0 = normal ads, 1 = child safe ads
         * @return void
         */
        @Signature
        public native void SetAdMobChildRating(int rating);

        /**
         * Sets whether the AdMob ads will be test ads or paying ads. This should be
         * called before SetAdMobDetails to ensure all ads are test ads. By default
         * paying ads will be shown. Note that if you display paying ads when testing
         * you must not click on them or your AdMob account may be suspended.
         *
         * @param mode - 0 = show paying ads, 1 = show test ads
         * @return void
         */
        @Signature
        public native void SetAdMobTesting(int mode);

        /**
         * Enables a twist joint motor.
         *
         * @param jointID   - joint ID
         * @param isEnabled - 1 = true , 0 = false
         * @return void
         */
        @Signature
        public native void Set3DPhysicsTwistJointMotorIsEnabled(int jointID, int isEnabled);

        /**
         * Sets the max motor Impulse value for a Twist joint. Enable joint first with
         * Set3DPhysicsTwistJointMotorIsEnabled()
         *
         * @param jointID    - Id of joint
         * @param maxImpulse - The maximum impulse to be applied to the joint motor.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsTwistJointMaxMotorImpulse(int jointID, float maxImpulse);

        /**
         * Sets the rotation of the static Plane
         *
         * @param planeID - static plane ID
         * @param angX    - The world X angle of rotation.
         * @param angY    - The world Y angle of rotation.
         * @param angZ    - The world Z angle of rotation.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsStaticPlaneRotation(int planeID, float angX, float angY, float angZ);

        /**
         * Sets the position of the static plane
         *
         * @param planeID - static plane ID
         * @param posX    - The world X position.
         * @param posY    - The world Y position.
         * @param posZ    - The world Z position.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsStaticPlanePosition(int planeID, float posX, float posY, float posZ);

        /**
         * Sets the target linear Motor Velocity for the physics slider joint.
         *
         * @param jointID             - Id of joint
         * @param linearMotorVelocity - The linear velocity to be applied to the joint
         *                            motor.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsSliderJointTargetLinearMotorVelocity(int jointID, float linearMotorVelocity);

        /**
         * Sets the ragdoll static by changing the mass of all the ragdoll bones to
         * zero.
         *
         * @param objID    - object ID
         * @param isStatic - 1 = true, 0 = false
         * @return void
         */
        @Signature
        public native void Set3DphysicsRagdollStatic(int objID, int isStatic);

        /**
         * Sets the joints motor to the maximum linear force.
         *
         * @param jointID        - Id of joint
         * @param maxLinearForce - The maximum linear force to be applied to the joint
         *                       motor.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsSliderJointMaxLinearMotorForce(int jointID, float maxLinearForce);

        /**
         * Set the slider joints powered linear motor to enabled.
         *
         * @param jointID   - Id of joint
         * @param isEnabled - 1 = true, 0 = false
         * @return void
         */
        @Signature
        public native void Set3DPhysicsSliderJointPoweredLinearMotorIsEnabled(int jointID, int isEnabled);

        /**
         * Sets the deactivation time for the ragdoll being created. The default values
         * should be good for most situations. Only call if you wish to change these
         * values. Must be called before Finalize3DPhysicsRagDoll()
         *
         * @param time - Default value is 0.8
         * @return void
         */
        @Signature
        public native void Set3DPhysicsRagdollDeactivationTime(float time);

        /**
         * Sets your AdMob account details to be used by reward video ads. After calling
         * this command an attempt will be made to cache a reward video so you can
         * display it immediately later. You can check the progress of this by using
         * GetRewardAdLoadedAdMob. AdMob reward videos are currently supported by iOS
         * and Android.
         *
         * @param szID - Ad unit ID as provided by AdMob (not the App ID).
         * @return void
         */
        @Signature
        public native void SetAdMobRewardAdDetails(String szID);

        /**
         * Keeps physics ragdoll active. Does not allow the automatic deactivation when
         * ragdoll comes to rest.
         *
         * @param objID      - object ID
         * @param isDisabled - 1 = true, 0 = false
         * @return void
         */
        @Signature
        public native void Set3DPhysicsRagdollDeactivation(int objID, int isDisabled);

        /**
         * Sets the damping for the ragdoll being created. The default values should be
         * good for most situations. Only call if you wish to change these values. Must
         * be called before Finalize3DPhysicsRagDoll()
         *
         * @param linear  - Default value is 0.08
         * @param angular - Default value is 0.95
         * @return void
         */
        @Signature
        public native void Set3DPhysicsRagdollDamping(float linear, float angular);

        /**
         * Sets the Linear limits for a slider joint. To unlock the joint set the lower
         * limit greater than upper limit.
         *
         * @param jointID    - Id of joint
         * @param lowerLimit - The lower limit
         * @param upperLimit - The upper limit
         * @return void
         */
        @Signature
        public native void Set3DPhysicsJointSliderLinearLimits(int jointID, float lowerLimit, float upperLimit);

        /**
         * Sets the Angular limits for a slider joint. To unlock the joint set the lower
         * limit greater than upper limit.
         *
         * @param jointID    - Id of joint
         * @param lowerLimit - The Lower limit in degrees
         * @param upperLimit - The upper limit in degrees
         * @return void
         */
        @Signature
        public native void Set3DPhysicsJointSliderAngularLimits(int jointID, float lowerLimit, float upperLimit);

        /**
         * Sets the angular limits for a hinge joint in degrees. To unlock the joint set
         * the lower limit greater than upper limit.
         *
         * @param jointID - Id of joint
         * @param minAng  - The minimum angle in degrees.
         * @param maxAng  - The maximum angle in degrees.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsJointHingeLimits(int jointID, float minAng, float maxAng);

        /**
         * Sets the breaking threshold for the joint.
         *
         * @param jointID        - Id of joint
         * @param breakThreshold - breaking threshold value
         * @return void
         */
        @Signature
        public native void Set3DPhysicsJointBreakingThreshold(int jointID, float breakThreshold);

        /**
         * Shows the ragdoll bone objects and hides the object.
         *
         * @param objID     - object ID
         * @param isVisible - 1 = true, 0 = false
         * @return void
         */
        @Signature
        public native void Set3DPhysicsRagdollBonesVisible(int objID, int isVisible);

        /**
         * Enables a hinge joint motor.
         *
         * @param jointID   - Id of joint
         * @param isEnabled - 1 = true , 0 = false
         * @return void
         */
        @Signature
        public native void Set3DPhysicsHingeJointMotorIsEnabled(int jointID, int isEnabled);

        /**
         * Sets the breaking threshold for the joint.
         *
         * @param jointID   - Id of joint
         * @param isEnabled - 0 will disable joint
         * @return void
         */
        @Signature
        public native void Set3DPhysicsJointEnabled(int jointID, int isEnabled);

        /**
         * Sets the sleeping thresholds for the ragdoll being created. The default
         * values should be good for most situations. Only call if you wish to change
         * these values. Must be called before Finalize3DPhysicsRagDoll()
         *
         * @param linear  - Default value is 1.8
         * @param angular - Default value is 2.8
         * @return void
         */
        @Signature
        public native void Set3DPhysicsRagdollSleepingThresholds(float linear, float angular);

        /**
         * Set the target velocity for a hinge joint. Must be called in the loop. Enable
         * joint first with Set3DPhysicsHingeJointMotorIsEnabled()
         *
         * @param jointID        - Id of joint
         * @param targetVelocity - The target velocity to be used.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsHingeJointMotorVelocity(int jointID, float targetVelocity);

        /**
         * Sets the angular limits for a cone twist joint in degrees. To unlock a
         * particular value set it to 360
         *
         * @param jointID    - Id of joint
         * @param swingSpan1 - angle in degrees
         * @param swingSpan2 - angle in degrees
         * @param twistSpan  - angle in degrees
         * @return void
         */
        @Signature
        public native void Set3DPhysicsJointConeTwistLimits(int jointID, float swingSpan1, float swingSpan2,
                        float twistSpan);

        /**
         * Repositions the Controller to the new coordinates passed in. Do not position
         * the controller inside another physics object.
         *
         * @param objID - object ID
         * @param posX  - The new X coordinate
         * @param posY  - The new Y coordinate
         * @param posZ  - The new Z coordinate
         * @return void
         */
        @Signature
        public native void Set3DPhysicsCharacterControllerPosition(int objID, float posX, float posY, float posZ);

        /**
         * set the max slope in angle degrees that a controller can climb.
         *
         * @param objID           - object ID
         * @param maxSlopeDegress - Default value is 45.0 degrees.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsCharacterControllerMaxSlope(int objID, float maxSlopeDegress);

        /**
         * Set the speed at which the controller moves up when jump is called.
         *
         * @param objID     - object ID
         * @param jumpSpeed - Default is 10.0
         * @return void
         */
        @Signature
        public native void Set3DPhysicsCharacterControllerJumpSpeed(int objID, float jumpSpeed);

        /**
         * Sets the gravity of the physics world, gravity is in meters per second.
         * Gravity is set to ( 0.0, -10.0, 0.0 ) by default. You only need to call this
         * command if you need to change from the default setting.
         *
         * @param x - The value of gravity on the X axis in meters per second.
         * @param y - The value of gravity on the Y axis in meters per second.
         * @param z - The value of gravity on the Z axis in meters per second.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsGravity(float x, float y, float z);

        /**
         * Sets the gravity of the physics world, gravity is in meters per second.
         * Gravity is set to ( 0.0, -10.0, 0.0 ) by default. You only need to call this
         * command if you need to change from the default setting.
         *
         * @param vectorID - The ID of the vector to use
         * @return void
         */
        @Signature
        public native void Set3DPhysicsGravity(int vectorID);

        /**
         * Sets the gravity for the character controller. This gravity is not the same
         * as the physics world gravity. and only affects the individual character
         * controller.
         *
         * @param objID   - object ID
         * @param gravity - Default value is (9.8 * 3)
         * @return void
         */
        @Signature
        public native void Set3DPhysicsCharacterControllerGravity(int objID, float gravity);

        /**
         * Sets the height that the controller can step up and over.
         *
         * @param objID      - object ID
         * @param stepHeight - Step height in world values.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsCharacterControllerStepHeight(int objID, float stepHeight);

        /**
         * Set the particle transparency to a particular setting, with a choice of no
         * transparency, alpha transparency, and additive blending. By default particles
         * are created with alpha transparency.
         *
         * @param ID   - The ID of the particle emitter to modify.
         * @param mode - The transparency mode for these particles, 0=off, 1=alpha
         *             transparency, 2=additive blending
         * @return void
         */
        @Signature
        public native void Set3DParticlesTransparency(int ID, int mode);

        /**
         * Sets the speed at which the controller will fall.
         *
         * @param objID     - object ID
         * @param fallSpeed - Default value is 55.0 which is the terminal velocity of a
         *                  sky diver in meters per second.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsCharacterControllerFallSpeed(int objID, float fallSpeed);

        /**
         * Sets a minimum and maximum multiplier that will affect particles being
         * emitted. This can be used to ensure that there will be some variation in
         * velocity when particles are emitted.
         *
         * @param ID - The ID of the emitter to modify.
         * @param v1 - The minimum velocity multiplier.
         * @param v2 - The maximum velocity multiplier.
         * @return void
         */
        @Signature
        public native void Set3DParticlesVelocityRange(int ID, float v1, float v2);

        /**
         * Sets the size of all particles in world coordinates. Setting a large number
         * of particles to a large size will perform poorly on mobile devices that have
         * a low fill rate (number of pixels it can draw per second).
         *
         * @param ID   - The ID of the emitter to modify.
         * @param size - Size of the particles
         * @return void
         */
        @Signature
        public native void Set3DParticlesSize(int ID, float size);

        /**
         * Sets the position of the 3D particle emitter. This is the position that new
         * particles will emerge from and does not affect particles that are already
         * visible.
         *
         * @param ID - The ID of the emitter to modify.
         * @param x  - The new x coordinate for the emitter in world coordinates.
         * @param y  - The new y coordinate for the emitter in world coordinates.
         * @param z  - The new z coordinate for the emitter in world coordinates.
         * @return void
         */
        @Signature
        public native void Set3DParticlesPosition(int ID, float x, float y, float z);

        /**
         * Sets the area around the emitter where new particles may appear. The values
         * are relative to the emitter position, for example a zone of 0,0,0,0 would
         * mean that all particles start on the emitter position point. A zone of -10 in
         * x and +10 x, with y and z being 0 (-10,0,0,10,0,0) would create a line
         * centered on the emitter position that particles would randomly appear along.
         * A box zone where x, y, and z are non-zero would mean that particles could
         * start at any point inside the box.
         *
         * @param ID - The ID of the emitter to modify.
         * @param x1 - The x coordinate of the top left corner of the start zone.
         * @param y1 - The y coordinate of the top left corner of the start zone.
         * @param z1 - The z coordinate of the top left corner of the start zone.
         * @param x2 - The x coordinate of the bottom right corner of the start zone.
         * @param y2 - The y coordinate of the bottom right corner of the start zone.
         * @param z2 - The z coordinate of the bottom right corner of the start zone.
         * @return void
         */
        @Signature
        public native void Set3DParticlesStartZone(int ID, float x1, float y1, float z1, float x2, float y2, float z2);

        /**
         * Sets the maximum number of particles that will be emitted. If this value is
         * equal to -1 then the number is infinite. The emitter will keep a count of the
         * total number of particles it emits and stop when the limit is reached. To
         * check if the emitter has reached its limit use Get3DParticlesMaxReached. To
         * reset the count and make it start emitting again use Reset3DParticleCount.
         *
         * @param ID  - The ID of the emitter to modify.
         * @param max - The maximum number of particles to emit
         * @return void
         */
        @Signature
        public native void Set3DParticlesMax(int ID, int max);

        /**
         * Sets the image to use for each particle.
         *
         * @param ID      - The ID of the emitter to modify.
         * @param imageID - The ID of an image to use for emitted particles.
         * @return void
         */
        @Signature
        public native void Set3DParticlesImage(int ID, int imageID);

        /**
         * Sets the frequency of new particle generation. The freq value states how many
         * particles should be produced per second, this is independent of frame rate.
         * This is one of the two values that affects the number of particles generated,
         * the other being SetParticlesLife. The maximum number of particles that can be
         * on screen at any one time is freq*life, with life being the number of seconds
         * a particle lives before it disappears.
         *
         * @param ID   - The ID of the emitter to modify.
         * @param freq - The rate of new particle production in particles per second.
         * @return void
         */
        @Signature
        public native void Set3DParticlesFrequency(int ID, float freq);

        /**
         * Sets the maximum motor Impulse value for a hinge joint. Enable joint first
         * with Set3DPhysicsHingeJointMotorIsEnabled()
         *
         * @param jointID    - Id of joint
         * @param maxImpulse - The Maximum impulse value to be applied to the joint
         *                   motor.
         * @return void
         */
        @Signature
        public native void Set3DPhysicsHingeJointMaxMotorImpulse(int jointID, float maxImpulse);

        /**
         * Sets the initial direction of new particles when they emerge from the
         * emitter. This can be used along with the Set3DParticlesDirectionRange command
         * to set the range of variation from this initial direction that new particles
         * can choose. This also sets the initial speed of the particles by taking the
         * length of the vector as units per second. For example if the initial
         * direction is vx=10, vy=-15, vz=0 particles will begin by moving in the X
         * direction at a rate of 10 units per second and in the Y direction at a rate
         * of 15 units per second and will continue this rate of motion for their entire
         * life unless influenced by forces added with Add3DParticlesForce.
         *
         * @param ID   - The ID of the emitter to modify.
         * @param vx   - The x direction that particles will move initially.
         * @param vy   - The y direction that particles will move initially.
         * @param vz   - The z direction that particles will move initially.
         * @param roll - The angle to turn the emitter as it is facing in the given
         *             direction
         * @return void
         */
        @Signature
        public native void Set3DParticlesDirection(int ID, float vx, float vy, float vz, float roll);

        /**
         * Sets the interpolation mode for color changes. Colors can be set at certain
         * points in a particle's life using Add3DParticlesColorKeyFrame and the
         * particle will either blend between these colors (smooth interpolation) or
         * quickly change when it reaches the next color change (no interpolation).
         *
         * @param ID   - The ID of the emitter to modify.
         * @param mode - 1=smooth interpolation, 0=no interpolation
         * @return void
         */
        @Signature
        public native void Set3DParticlesColorInterpolation(int ID, int mode);

        /**
         * Sends a network message created with CreateNetworkMessage to the specified
         * remote IP and port. You must specify a UDP listener to use as the source IP
         * and port. This function will delete the specified message ID.
         *
         * @param listenerID - The ID of the listener to use as the source ip and port
         * @param messageID  - The ID of the network message to send
         * @param toIP       - The IP address to send the message to
         * @param toPort     - The port to send the message to
         * @return void
         */
        @Signature
        public native void SendUDPNetworkMessage(int listenerID, int messageID, String toIP, int toPort);

        /**
         * Sets the life of particles in seconds once they have been emitted. After
         * particles have been alive for the given number of seconds they will
         * disappear. This is one of the two values that affects the number of particles
         * generated, the other being Set3DParticlesFrequency. The maximum number of
         * particles that can be on screen at any one time is freq*life, with freq being
         * the number of particles emitted per second. This value is independent of
         * frame rate.
         *
         * @param ID   - The ID of the emitter to modify.
         * @param time - The time in seconds that a particle is visible.
         * @return void
         */
        @Signature
        public native void Set3DParticlesLife(int ID, float time);

        /**
         * Sets whether the emitted particles are updated every frame. Set to 1 to
         * update particles as normal, 0 to pause them. Particles will continue to be
         * visible when paused. To hide particles use Set3DParticlesVisible.
         *
         * @param ID     - The ID of the emitter to modify.
         * @param active - 1=normal, 0=pause
         * @return void
         */
        @Signature
        public native void Set3DParticlesActive(int ID, int active);

        /**
         * Sets the range of direction in degrees that a particle can choose when it
         * first starts. This takes the base direction set with Set3DParticlesDirection
         * and adjusts it by a random amount between 0 and angle1/2 degrees in one
         * direction and angle2/2 degrees in the perpendicular direction. For example an
         * angle1 of 0 and an angle2 of 0 would mean that all new particles follow
         * exactly the direction specified earlier. An angle1 of 360 and an angle2 of 0
         * would mean that particles could appear travelling in any direction in a flat
         * circle, whilst an angle1 of 360 and an angle2 of 180 would mean that
         * particles would travel in any direction in a sphere. The angles form a
         * pyramid aligned with the particle emitter direction specified earlier. Angle1
         * must be between 0 and 360, angle2 must be between 0 and 180.
         *
         * @param ID     - The ID of the emitter to modify.
         * @param angle1 - The range of variation a particle can choose from the emitter
         *               direction.
         * @param angle2 - The perpendicular range of variation a particle can choose
         *               from the emitter direction.
         * @return void
         */
        @Signature
        public native void Set3DParticlesDirectionRange(int ID, float angle1, float angle2);

        /**
         * Sets whether the emitted particles are drawn. Set to 1 to show particles, 0
         * to hide them. Particles will still update whilst hidden, you can stop
         * particles updating with Set3DParticlesActive
         *
         * @param ID      - The ID of the emitter to modify.
         * @param visible - 1=show, 0=hide
         * @return void
         */
        @Signature
        public native void Set3DParticlesVisible(int ID, int visible);

        /**
         * Will send a 4 byte float to the remote connection. Note that data is not sent
         * immediately, you must call FlushSocket to send it. Returns 1 if the float was
         * successfully written to the buffer, 0 if the socket disconnected.
         *
         * @param socketID - The ID of the socket to write
         * @param value    - The value to send
         * @return int
         */
        @Signature
        public native int SendSocketFloat(int socketID, float value);

        /**
         * Will send a string to the remote connection. Note that data is not sent
         * immediately, you must call FlushSocket to send it. If you are sending the
         * string to a non-AGK app then the string is constructed of a 4 byte length
         * value followed by X bytes of string data where X is the length value. The
         * string is not null terminated. Returns 1 if the string was successfully
         * written to the buffer, 0 if the socket disconnected.
         *
         * @param socketID - The ID of the socket to write
         * @param value    - The value to send
         * @return int
         */
        @Signature
        public native int SendSocketString(int socketID, String value);

        /**
         * Will send a 4 byte integer to the remote connection. Note that data is not
         * sent immediately, you must call FlushSocket to send it. Returns 1 if the
         * integer was successfully written to the buffer, 0 if the socket disconnected.
         *
         * @param socketID - The ID of the socket to write
         * @param value    - The value to send
         * @return int
         */
        @Signature
        public native int SendSocketInteger(int socketID, int value);

        /**
         * Will send a single byte in the range -128 to 127 to the remote connection.
         * Note that data is not sent immediately, you must call FlushSocket to send it.
         * Returns 1 if the byte was successfully written to the buffer, 0 if the socket
         * disconnected.
         *
         * @param socketID - The ID of the socket to write
         * @param value    - The value to send
         * @return int
         */
        @Signature
        public native int SendSocketByte(int socketID, int value);

        /**
         * Send a request to the server specified in SetHTTPHost(), for example if
         * requesting http: www.thegamecreators.com/index.php szServerFile should be
         * "index.php". This command waits for the server to respond and returns the
         * server reply. If using tier 2 you must delete this reply when finished with
         * it. Does not work when exported to HTML5
         *
         * @param iHTTP        - The ID of the connection to use.
         * @param szServerFile - The file to request from the server, include everything
         *                     after the domain part of the URL.
         * @return String
         */
        @Signature
        public native String SendHTTPRequest(int iHTTP, String szServerFile);

        /**
         * Send a request to the server specified in SetHTTPHost(), for example if
         * requesting http: www.thegamecreators.com/index.php szServerFile should be
         * "index.php". This command waits for the server to respond and returns the
         * server reply. If using tier 2 you must delete this reply when finished with
         * it. Does not work when exported to HTML5
         *
         * @param iHTTP        - The ID of the connection to use.
         * @param szServerFile - The file to request from the server, include everything
         *                     after the domain part of the URL.
         * @param szPostData   - The raw post data to send to the server, note that &
         *                     and = are special characters that separate variables.
         * @return String
         */
        @Signature
        public native String SendHTTPRequest(int iHTTP, String szServerFile, String szPostData);

        /**
         * Sends a created network message to a given client on a given network. Use a
         * client ID of 0 to send to all connected clients (except the sender),
         * otherwise if the client ID does not exist an error will be generated. This
         * function will delete the message ID given.
         *
         * @param iNetID   - The ID of the network to send the message over.
         * @param toClient - The ID of the client to send the message to, 0 to send to
         *                 all.
         * @param iMsgID   - The ID of the message to send.
         * @return void
         */
        @Signature
        public native void SendNetworkMessage(int iNetID, int toClient, int iMsgID);

        /**
         * Seeks to a given time value, if the file is currently playing then it will
         * immediately continue playing from there. If the file is not currently playing
         * then it will take effect after the next call to PlayMusicOGG. The mode
         * parameter lets you choose whether to seek based on an absolute or relative
         * time value. Absolute will seek to that position in the file, whilst relative
         * will seek relative to the current position.
         *
         * @param musicID - The ID of the music file to seek
         * @param seconds - The time in seconds to seek to
         * @param mode    - 0 for absolute seeking, 1 for relative seeking
         * @return void
         */
        @Signature
        public native void SeekMusicOGG(int musicID, float seconds, int mode);

        /**
         * Send a file to the server specified in SetHTTPHost, for example if requesting
         * http: www.thegamecreators.com/index.php szServerFile should be "index.php".
         * Also allows you to send POST data to the server which can include variables
         * or file data, e.g. "myvar=5&var2=test". This command returns immediately and
         * waits for the server to reply in the background. You can check the status of
         * the reply with GetHTTPResponseReady and when it is ready retrieve the
         * response with GetHTTPResponse. You can check the progress of the upload with
         * GetHTTPFileProgress. Does not work when exported to HTML5
         *
         * @param iHTTP        - The ID of the connection to use.
         * @param szServerFile - The file to request from the server, include everything
         *                     after the domain part of the URL.
         * @param szPostData   - The raw post data to send to the server, note that &
         *                     and = are special characters that separate variables.
         * @param szLocalFile  - The filename of the file you want to send to the
         *                     server.
         * @return int
         */
        @Signature
        public native int SendHTTPFile(int iHTTP, String szServerFile, String szPostData, String szLocalFile);

        /**
         * Converts a screen X coordinate into a world X coordinate based on the current
         * view offset and zoom. When the SetViewOffset is 0,0 and the SetViewZoom is
         * 1.0 world and screen coordinates are the same. For example when the view is
         * offset by 20 pixels to the right, input at 0,0 on the screen will appear 20,0
         * in the world.
         *
         * @param x - The screen X coordinate to convert.
         * @return float
         */
        @Signature
        public native float ScreenToWorldX(float x);

        /**
         * Send a request to the server specified in SetHTTPHost, for example if
         * requesting http: www.thegamecreators.com/index.php szServerFile should be
         * "index.php". This command returns immediately and waits for the server to
         * reply in the background. You can check the status of the reply with
         * GetHTTPResponseReady and when it is ready retrieve the response with
         * GetHTTPResponse.
         *
         * @param iHTTP        - The ID of the connection to use.
         * @param szServerFile - The file to request from the server, include everything
         *                     after the domain part of the URL.
         * @return int
         */
        @Signature
        public native int SendHTTPRequestASync(int iHTTP, String szServerFile);

        /**
         * Send a request to the server specified in SetHTTPHost, for example if
         * requesting http: www.thegamecreators.com/index.php szServerFile should be
         * "index.php". This command returns immediately and waits for the server to
         * reply in the background. You can check the status of the reply with
         * GetHTTPResponseReady and when it is ready retrieve the response with
         * GetHTTPResponse.
         *
         * @param iHTTP        - The ID of the connection to use.
         * @param szServerFile - The file to request from the server, include everything
         *                     after the domain part of the URL.
         * @param szPostData   - The raw post data to send to the server, note that &
         *                     and = are special characters that separate variables.
         * @return int
         */
        @Signature
        public native int SendHTTPRequestASync(int iHTTP, String szServerFile, String szPostData);

        /**
         * Send data to the smart watch in the background, if watch app is not currently
         * open the message will be queued and received by the watch app when it is next
         * opened. The message must be in the form of a JSON string, for example
         * "{"label":"my message"}". You can also use a type with the .toJSON() function
         * to create a JSON string. The watch app will receive it as an NSDictionary
         * with the labels as keys. Currently only works on iOS.
         *
         * @param szJson - A JSON string containing the message to send to the watch
         *               app.
         * @return void
         */
        @Signature
        public native void SendSmartWatchData(String szJson);

        /**
         * Seeks the currently playing music to the speicifed number of seconds, either
         * relative to the current position or an absolute position. For example if the
         * music track is 60 seconds long and is currently at a position of 10 seconds
         * (it has played 10 seconds of music), seeking to an absolute value of 3
         * seconds will take it back to 3 seconds after the start of the music track.
         * Using a relative value of 3 will add 3 seconds to the current position,
         * taking it to 13.
         *
         * @param seconds - The number of seconds to seek to.
         * @param mode    - 0 to use an absolute position, 1 to use a relative position
         * @return void
         */
        @Signature
        public native void SeekMusic(float seconds, int mode);

        /**
         * Saves a variable so it can be accessed from other apps. This only works on
         * iOS, Android 10 and below, and HTML5 platforms. Apps can only share a
         * variable if they meet certain requirements based on the platform. On iOS the
         * apps must be created by the same Apple developer account, and have the same
         * App Group added to their App IDs on the Apple developer portal. You will need
         * to regenerate the provisioning profile after doing this. On iOS you must tell
         * AGK what the App Group is by using SetSharedVariableAppGroup. On Android 10
         * and below the apps must have the WRITE_EXTERNAL_STORAGE permission and have
         * the same package name up to the last dot. For example
         * com.mycompany.mygroup.myapp1 and com.mycompany.mygroup.myapp2 would be able
         * to share variables. On Android shared variables are written to a user
         * accessible location, so be aware that users may be able to read and/or edit
         * the variables that you save. On Android 11 or higher this command will not
         * work as apps are restricted from writing to shared locations. On HTML the
         * apps must be hosted on the same domain, the values are stored as cookies.
         * Variables are identified by name, so using SaveSharedVariable("username",
         * "Alice") will set the variable called "username" to the value "Alice". This
         * can then be read by other apps by using LoadSharedVariable( "username", "" )
         * If two apps save different values to the same variable name then the value
         * will be overwritten and only the most recent value will be accessible.
         * Variable values will persist even if the app is deleted and re-installed. You
         * should not use this command to store any sensitive information such as
         * passwords in plain text. On iOS the length of the variable name plus the
         * length of your App ID up to the last dot (e.g. com.mycompany.mygroup) must be
         * less than 58.
         *
         * @param varName  - The name to use to identify this variable
         * @param varValue - The value to save in this variable
         * @return void
         */
        @Signature
        public native void SaveSharedVariable(String varName, String varValue);

        /**
         * Saves the objects collision shape to a .bcs (Bullet Collision Shape) file.
         * Returns true if succeeded.
         *
         * @param objID    - object ID
         * @param fileName - the name of the file as a string.
         * @return int
         */
        @Signature
        public native int SaveObjectShape(int objID, String fileName);

        /**
         * Not yet functional.
         *
         * @param objID      - The ID of the object to save.
         * @param szFilename - The file name to use for the new file.
         * @return void
         */
        @Signature
        public native void SaveObject(int objID, String szFilename);

        /**
         * Returns an average frames per second based on the rendering time of the last
         * few frames. To get the exact time spent on the last frame you can call
         * GetFrameTime.
         *
         * @return float
         */
        @Signature
        public native float ScreenFPS();

        /**
         * Saves the image at the given ID to the file name specified. The file will be
         * placed in the app's write folder at the location currently specified by
         * SetFolder. Alternatively you can specify a path beginning with a forward
         * slash to choose a location from the root of the write folder, ignoring any
         * SetFolder folder. It is recommended that you use the extension ".png" at the
         * end of the filename to save in PNG format. Some platforms may support
         * additional extensions such as ".jpg" but this is not guaranteed to work on
         * all platforms.
         *
         * @param iImageIndex - The ID of the image to change.
         * @param filename    - The filename of the saved image
         * @return void
         */
        @Signature
        public native void SaveImage(int iImageIndex, String filename);

        /**
         * Runs an external executable that is independent of this app. It will return
         * an ID that you can use to check if the app is still running or in extreme
         * cases to terminate the app. If this fails it will return 0. Currently only
         * works on Windows, Mac, Linux, and Raspberry Pi.
         *
         * @param szFilename   - The filename of the new app, this is accessed just like
         *                     any other file in AGK
         * @param szParameters - Optional command line parameters to pass to the app, or
         *                     an empty string
         * @return int
         */
        @Signature
        public native int RunApp(String szFilename, String szParameters);

        /**
         * Saves a sound file to the application write folder.
         *
         * @param iID       - The ID of the sound to save.
         * @param sFilename - The filename to use for the sound file, recommended it end
         *                  in .wav.
         * @return void
         */
        @Signature
        public native void SaveSound(int iID, String sFilename);

        /**
         * Rounds a float to the nearest integer (positive or negative).
         *
         * @param a - The value to round.
         * @return int
         */
        @Signature
        public native int Round(float a);

        /**
         * Rolls the specified object around its local Z axis, i.e. if the object were
         * an airplane this command would make it do a barrel roll no matter which
         * direction it was facing.
         *
         * @param objID  - The ID of the object to modify.
         * @param amount - The angle to rotate on the local Z axis in degrees, positive
         *               rolls anti-clockwise, negative rolls clockwise.
         * @return void
         */
        @Signature
        public native void RotateObjectLocalZ(int objID, float amount);

        /**
         * Rotates the specified object around its local X axis, i.e. if the object were
         * an airplane this command would make it pitch up and down no matter which
         * direction it was facing.
         *
         * @param objID  - The ID of the object to modify.
         * @param amount - The angle to rotate on the local X axis in degrees, positive
         *               looks down, negative looks up.
         * @return void
         */
        @Signature
        public native void RotateObjectLocalX(int objID, float amount);

        /**
         * Rotates the specified object around global Z axis. Imagine the camera looking
         * down the Z axis at an object with a random rotation. This command will roll
         * the object left and right relative to the camera regardless of which way the
         * object is facing.
         *
         * @param objID  - The ID of the object to modify.
         * @param amount - The angle to rotate on the global Z axis in degrees, positive
         *               rolls anti-clockwise, negative rolls clockwise.
         * @return void
         */
        @Signature
        public native void RotateObjectGlobalZ(int objID, float amount);

        /**
         * Rotates the specified object around global Y axis. Imagine the camera looking
         * down the Z axis at an object with a random rotation. This command will turn
         * the object left and right relative to the camera regardless of which way the
         * object is facing.
         *
         * @param objID  - The ID of the object to modify.
         * @param amount - The angle to rotate on the global Y axis in degrees, positive
         *               turns right, negative turns left.
         * @return void
         */
        @Signature
        public native void RotateObjectGlobalY(int objID, float amount);

        /**
         * Rotates the specified bone around its local Y axis, i.e. if the bone were an
         * airplane this command would make it turn left and right no matter which
         * direction it was facing.
         *
         * @param objID     - The ID of the object that contains the bone.
         * @param boneIndex - The index of the bone to modify.
         * @param amount    - The angle to rotate on the local Y axis in degrees,
         *                  positive turns right, negative turns left.
         * @return void
         */
        @Signature
        public native void RotateObjectBoneLocalY(int objID, int boneIndex, float amount);

        /**
         * Rotates the specified bone around its local X axis, i.e. if the bone were an
         * airplane this command would make it pitch up and down no matter which
         * direction it was facing.
         *
         * @param objID     - The ID of the object that contains the bone.
         * @param boneIndex - The index of the bone to modify.
         * @param amount    - The angle to rotate on the local X axis in degrees,
         *                  positive looks down, negative looks up.
         * @return void
         */
        @Signature
        public native void RotateObjectBoneLocalX(int objID, int boneIndex, float amount);

        /**
         * Rotates the specified object around its local Y axis, i.e. if the object were
         * an airplane this command would make it turn left and right no matter which
         * direction it was facing.
         *
         * @param objID  - The ID of the object to modify.
         * @param amount - The angle to rotate on the local Y axis in degrees, positive
         *               turns right, negative turns left.
         * @return void
         */
        @Signature
        public native void RotateObjectLocalY(int objID, float amount);

        /**
         * Rotates the specified camera around its local Y axis, i.e. if the camera were
         * an airplane this command would make it turn left and right no matter which
         * direction it was facing.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param amount   - The angle to rotate on the local Y axis in degrees,
         *                 positive turns right, negative turns left.
         * @return void
         */
        @Signature
        public native void RotateCameraLocalY(int cameraID, float amount);

        /**
         * Rotates the specified camera around its local X axis, i.e. if the camera were
         * an airplane this command would make it pitch up and down no matter which
         * direction it was facing.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param amount   - The angle to rotate on the local X axis in degrees,
         *                 positive looks down, negative looks up.
         * @return void
         */
        @Signature
        public native void RotateCameraLocalX(int cameraID, float amount);

        /**
         * Converts a screen Y coordinate into a world Y coordinate based on the current
         * view offset and zoom. When the SetViewOffset is 0,0 and the SetViewZoom is
         * 1.0 world and screen coordinates are the same. For example when the view is
         * offset by 20 pixels down, input at 0,0 on the screen will appear 0,20 in the
         * world.
         *
         * @param y - The screen Y coordinate to convert.
         * @return float
         */
        @Signature
        public native float ScreenToWorldY(float y);

        /**
         * Rotates the specified camera around global Z axis. Imagine looking at the
         * camera as if it were an object positioned at 0,0,0 looking in a random
         * direction. This command would roll it around the fixed Z axis, the one which
         * is used to define the positions of everything in the world.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param amount   - The angle to rotate on the global Z axis in degrees,
         *                 negative is clockwise.
         * @return void
         */
        @Signature
        public native void RotateCameraGlobalZ(int cameraID, float amount);

        /**
         * Rotates the specified camera around global Y axis. Imagine looking at the
         * camera as if it were an object positioned at 0,0,0 looking in a random
         * direction. This command would turn it around the fixed Y axis, the one which
         * is used to define the positions of everything in the world.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param amount   - The angle to rotate on the global Y axis in degrees,
         *                 positive turns right, negative turns left.
         * @return void
         */
        @Signature
        public native void RotateCameraGlobalY(int cameraID, float amount);

        /**
         * Rotates the specified camera around global X axis. Imagine looking at the
         * camera as if it were an object positioned at 0,0,0 looking in a random
         * direction. This command would roll it around the fixed X axis, the one which
         * is used to define the positions of everything in the world.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param amount   - The angle to rotate on the global X axis in degrees,
         *                 positive pitches down, negative pitches up.
         * @return void
         */
        @Signature
        public native void RotateCameraGlobalX(int cameraID, float amount);

        /**
         * Crops the given string retaining the right most number of characters up to
         * the specified count value.
         *
         * @param strin - The string to be cropped
         * @param count - The number of characters to retain
         * @return String
         */
        @Signature
        public native String Right(String strin, int count);

        /**
         * Rotates the specified object around global X axis. Imagine the camera looking
         * down the Z axis at an object with a random rotation. This command will pitch
         * the object up and down relative to the camera regardless of which way the
         * object is facing.
         *
         * @param objID  - The ID of the object to modify.
         * @param amount - The angle to rotate on the global X axis in degrees, positive
         *               pitches down, negative pitches up.
         * @return void
         */
        @Signature
        public native void RotateObjectGlobalX(int objID, float amount);

        /**
         * Rolls the specified bone around its local Z axis, i.e. if the bone were an
         * airplane this command would make it do a barrel roll no matter which
         * direction it was facing.
         *
         * @param objID     - The ID of the object that contains the bone.
         * @param boneIndex - The index of the bone to modify.
         * @param amount    - The angle to rotate on the local Z axis in degrees,
         *                  positive rolls anti-clockwise, negative rolls clockwise.
         * @return void
         */
        @Signature
        public native void RotateObjectBoneLocalZ(int objID, int boneIndex, float amount);

        /**
         * Rotates the specified camera around its local Z axis, i.e. if the camera were
         * an airplane this command would make it roll left and right no matter which
         * direction it was facing.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param amount   - The angle to rotate on the local Z axis in degrees,
         *                 negative is clockwise.
         * @return void
         */
        @Signature
        public native void RotateCameraLocalZ(int cameraID, float amount);

        /**
         * Resumes the given tween from the point it was paused with PauseTweenSprite.
         * If the tween is already resumed or doesn't exist then this does nothing.
         *
         * @param tweenID  - ID of the tween to resume
         * @param spriteID - ID of the sprite to resume
         * @return void
         */
        @Signature
        public native void ResumeTweenSprite(int tweenID, int spriteID);

        /**
         * Resumes the given tween from the point it was paused with PauseTweenText. If
         * the tween is already resumed or doesn't exist then this does nothing.
         *
         * @param tweenID - ID of the tween to resume
         * @param textID  - ID of the text to resume
         * @return void
         */
        @Signature
        public native void ResumeTweenText(int tweenID, int textID);

        /**
         * Resumes the given tween from the point it was paused with PauseTweenObject.
         * If the tween is already resumed or doesn't exist then this does nothing.
         *
         * @param tweenID  - ID of the tween to resume
         * @param objectID - ID of the object to resume
         * @return void
         */
        @Signature
        public native void ResumeTweenObject(int tweenID, int objectID);

        /**
         * Resumes the given tween from the point it was paused with PauseTweenCustom.
         * If the tween is already resumed or doesn't exist then this does nothing.
         *
         * @param tweenID - ID of the tween to resume
         * @return void
         */
        @Signature
        public native void ResumeTweenCustom(int tweenID);

        /**
         * Resumes the given tween from the point it was paused with PauseTweenCamera.
         * If the tween is already resumed or doesn't exist then this does nothing.
         *
         * @param tweenID  - ID of the tween to resume
         * @param cameraID - ID of the camera to resume
         * @return void
         */
        @Signature
        public native void ResumeTweenCamera(int tweenID, int cameraID);

        /**
         * Resumes the given tween from the point it was paused with PauseTweenChar. If
         * the tween is already resumed or doesn't exist then this does nothing.
         *
         * @param tweenID - ID of the tween to resume
         * @param textID  - ID of the text to resume
         * @param charID  - Index of the character to resume
         * @return void
         */
        @Signature
        public native void ResumeTweenChar(int tweenID, int textID, int charID);

        /**
         * Continues the animation of the sprite using the values used to set it up.
         * Continues from the current frame rather than starting again at the first
         * frame.
         *
         * @param iSpriteIndex - The ID of the sprite to resume animating.
         * @return void
         */
        @Signature
        public native void ResumeSprite(int iSpriteIndex);

        /**
         * Rotates the controller.
         *
         * @param objID - object ID
         * @param angle - amount in degrees
         * @return void
         */
        @Signature
        public native void Rotate3DPhysicsCharacterController(int objID, float angle);

        /**
         * Resumes the music file if it was paused.
         *
         * @param musicID - The ID of the music file to pause
         * @return void
         */
        @Signature
        public native void ResumeMusicOGG(int musicID);

        /**
         * Resumes the paused music where it left off.
         *
         * 
         * @return void
         */
        @Signature
        public native void ResumeMusic();

        /**
         * This command reinstates the normal functionality of UV coordinates after a
         * call to SetSpriteUV.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @return void
         */
        @Signature
        public native void ResetSpriteUV(int iSpriteIndex);

        /**
         * Sets the Chartboost rewarded value to 0. You can use this after detecting the
         * reward event and acting on so that you don't reward the user more than once.
         *
         * @return void
         */
        @Signature
        public native void ResetRewardChartboost();

        /**
         * Sets the AdMob rewarded value to 0. You can use this after detecting the
         * reward event and acting on so that you don't reward the user more than once.
         *
         * @return void
         */
        @Signature
        public native void ResetRewardAdMob();

        /**
         * Resets the emitted particle count when the emitter has been set with a
         * maximum number of particles using SetParticlesMax. You can check when the
         * emitter has reached its maximum count using GetParticlesMaxReached. If the
         * maximum is set at -1 then this command has no effect.
         *
         * @param ID - The ID of the emitter to modify.
         * @return void
         */
        @Signature
        public native void ResetParticleCount(int ID);

        /**
         * Resets the time returned from Timer to 0. This allows the full accuracy to be
         * regained after your app has been running for some time. This also resets the
         * values returned by GetSeconds and GetMilliseconds to 0.
         *
         * @return void
         */
        @Signature
        public native void ResetTimer();

        /**
         * Resets the emitted particle count when the emitter has been set with a
         * maximum number of particles using Set3DParticlesMax. You can check when the
         * emitter has reached its maximum count using Get3DParticlesMaxReached. If the
         * maximum is set at -1 then this command has no effect.
         *
         * @param ID - The ID of the emitter to modify.
         * @return void
         */
        @Signature
        public native void Reset3DParticleCount(int ID);

        /**
         * Only for Android, all other platforms will do nothing. Generates a system
         * dialog asking the user for the specified device permission, used by certain
         * Android commands. The permissions are as follows "WriteExternal" - used by
         * the SaveSharedVariable commands and any "raw:" paths that access the sdcard.
         * "Location" - used by the GPS commands "Camera" - used by the
         * SetDeviceCameraToImage command and for the AR camera feed "RecordAudio" -
         * used by the StartScreenRecording command You can check the result of the
         * request by calling CheckPermission. After the first request Android will give
         * the user the option to stop displaying the request dialog. In this case this
         * command will no longer generate a request dialog and instead do nothing. The
         * user will have to go into the device app settings to reverse this decision.
         * Any permission not listed here does not require you to prompt the user for
         * permission, it will be auto granted on install if your app requires it. All
         * permissions that your app uses, even those that require prompting, must be
         * specified in the APK export dialog by ticking the appropriate check boxes.
         *
         * @param szPermission - The permission to request
         * @return void
         */
        @Signature
        public native void RequestPermission(String szPermission);

        /**
         * This deletes the physics world and all the shapes, rigid bodies, joints,
         * joint motors, ragdolls and character controllers. Then recreates an empty
         * physics world with default scale and gravity. You will then need to recreate
         * all the shapes, rigid bodies, joints, joint motors, ragdolls and character
         * controllers that you require.
         *
         * @return void
         */
        @Signature
        public native void Reset3DPhysicsWorld();

        /**
         * Restores the app from a minimized state to a normal window.
         *
         * @return void
         */
        @Signature
        public native void RestoreApp();

        /**
         * Call this command to request a new advert. Usually adverts will be provided
         * automatically. You may only want to do this when switching to new screens
         * within your application
         *
         * @return void
         */
        @Signature
        public native void RequestAdvertRefresh();

        /**
         * Returns a string with all instances of "find" replaced with "replace". You
         * can use the qty parameter to limit the number of replacements made, or use -1
         * for no limit. The original string is unmodified and a new string is returned
         * with the replacements in it. Note that if you are calling this command from
         * tier 2 then the returned string must be deleted when you are done with it.
         *
         * @param str     - The string to modify
         * @param find    - The string to find
         * @param replace - The string to replace it with
         * @param qty     - The maximum number of replacements to make, use minus 1 for
         *                no limit
         * @return String
         */
        @Signature
        public native String ReplaceString(String str, String find, String replace, int qty);

        /**
         * Stops any playing animation and resets the object bones to their bind
         * positions.
         *
         * @param objID - The ID of the object to modify.
         * @return void
         */
        @Signature
        public native void ResetObjectAnimation(int objID);

        /**
         * Called automatically. This is an advanced command to take control of the
         * render pipeline. Normally Render calls Render2DBack, RenderShadowMap,
         * Render3D, Render2DFront to draw everything in the world. This command only
         * draws the 3D objects.
         *
         * 
         * @return void
         */
        @Signature
        public native void Render3D();

        /**
         * Called automatically. This is an advanced command to take control of the
         * render pipeline. Normally Render calls Render2DBack, RenderShadowMap,
         * Render3D, Render2DFront to draw everything in the world. This command only
         * calculates the shadow map.
         *
         * 
         * @return void
         */
        @Signature
        public native void RenderShadowMap();

        /**
         * Resizes an image to new width and height. If the image is an atlas image then
         * its subimages.txt values will also be resized so that LoadSubImage will still
         * work. Note that if you have previously used LoadSubImage on this image then
         * resizing it will make those sub images display incorrectly. This command will
         * not work on sub images themselves.
         *
         * @param imageID - The ID of the image to resize
         * @param width   - The new width of the image
         * @param height  - The new height of the image
         * @return void
         */
        @Signature
        public native void ResizeImage(int imageID, int width, int height);

        /**
         * Called automatically. This is an advanced command to take control of the
         * render pipeline. Normally Render calls Render2DBack, ClearDepthBuffer,
         * Render3D, ClearDepthBuffer, Render2DFront to draw everything in the world.
         * This command only draws the 2D sprites and text that are behind the 3D.
         *
         * 
         * @return void
         */
        @Signature
        public native void Render2DBack();

        /**
         * Removes a header that you have previously added, if you have not used
         * AddHTTPHeader to add a header with the given name then this command does
         * nothing. If the header name is a standard header that is normally included
         * then this command does not remove it, use AddHTTPHeader with an empty string
         * instead to overwrite it. If the header name is a standard header that you
         * have overwritten then this command returns it to its normal value. Note that
         * this command does not work in the HTML5 version.
         *
         * @param iHTTP      - The ID of the connection to change.
         * @param headerName - The name of the header to remove
         * @return void
         */
        @Signature
        public native void RemoveHTTPHeader(int iHTTP, String headerName);

        /**
         * Not yet functional.
         *
         * @param szFilename - The file to save the sound to.
         * @return void
         */
        @Signature
        public native void RecordSound(String szFilename);

        /**
         * Displays a popup dialog asking the user for consent to show personalised ads.
         * The user's response will automatically be used to modify the AdMob settings
         * so that ads are displayed in accordance with the user's preferences. The
         * consent status will also be saved on the AdMob server so that a future call
         * to LoadConsentStatusAdMob can retrieve the value. You can call this command
         * at any time during your app so that the user can change their preference, the
         * user must be able to do this somewhere within your app. This consent does not
         * apply to Chartboost or Amazon, it only asks for consent to show personalised
         * ads from AdMob. You will need your own method of requesting consent for
         * Chartboost and Amazon.
         *
         * @return void
         */
        @Signature
        public native void RequestConsentAdMob();

        /**
         * Called automatically. This is an advanced command to take control of the
         * render pipeline. Normally Render calls Render2DBack, ClearDepthBuffer,
         * Render3D, ClearDepthBuffer, Render2DFront to draw everything in the world.
         * This command only draws the 2D sprites and text that are in front the 3D.
         *
         * 
         * @return void
         */
        @Signature
        public native void Render2DFront();

        /**
         * Draws all 2D and 3D created using an ID number to the current frame buffer.
         * It does not swap the backbuffer to the screen. It does not draw sprites or
         * objects you have created using pointers, you will either have to draw them
         * individually or assign them to a sprite manager to batch draw them. In this
         * case Render should still be called as it also draws the print text. Called
         * automatically by Sync, you may either use Sync or Update(), Render(), Swap()
         * to manually sync. If you wish to have more control you can break this down
         * further and replace Render with Render2DBack, ClearDepthBuffer, Render3D,
         * ClearDepthBuffer, Render2DFront
         *
         * @return void
         */
        @Signature
        public native void Render();

        /**
         * Reads a null terminated string from the given file, which must have been
         * opened for reading. Note that this can only read strings in binary form such
         * as those written using WriteString, if you are trying to read strings
         * separated by new lines then use ReadLine instead. If you use this command in
         * tier 2 you must delete the returned string with agk::DeleteString when you
         * are finished with it.
         *
         * @param iFileID - The ID of the file to read.
         * @return String
         */
        @Signature
        public native String ReadString(int iFileID);

        /**
         * Reads a new line terminated string from the given file, which must have been
         * opened for reading. If you use this command in tier 2 you must delete the
         * returned string with agk::DeleteString when you are finished with it.
         *
         * @param iFileID - The ID of the file to read.
         * @return String
         */
        @Signature
        public native String ReadLine(int iFileID);

        /**
         * Reads a 4 byte float from the given file, which must have been opened for
         * reading.
         *
         * @param iFileID - The ID of the file to read.
         * @return float
         */
        @Signature
        public native float ReadFloat(int iFileID);

        /**
         * Receives a queued message from the watch app. This will be in the form of a
         * JSON string. If you are calling this command from Tier 2 you must delete the
         * returned string when you are done with it by calling agk::DeleteString.
         * Currently only works on iOS.
         *
         * @return String
         */
        @Signature
        public native String ReceiveSmartWatchData();

        /**
         * iOS 10.3 has a special feature that will allow the user to review your app
         * from within the app itself, this command will tell iOS to start this process.
         * Note that iOS is not guaranteed to display anything when you call this
         * command, and it should not be called in response to a button press or other
         * user interaction. You should call it when there is a lull in the app such as
         * the end of a level. If you want to start the review process in response to a
         * user action, such as a button press, then you should use the OpenBrowser
         * command to open the AppStore.
         *
         * @return void
         */
        @Signature
        public native void RequestAppReview();

        /**
         * Reads a string from the given file, which must have been opened for reading.
         * Note that this can only read strings in binary form such as those written
         * using WriteString2, if you are trying to read strings separated by new lines
         * then use ReadLine instead. If you use this command in tier 2 you must delete
         * the returned string with agk::DeleteString when you are finished with it.
         * This uses a different method from ReadString that is slightly faster but this
         * command can only read strings written with WriteString2
         *
         * @param iFileID - The ID of the file to read.
         * @return String
         */
        @Signature
        public native String ReadString2(int iFileID);

        /**
         * Reads a 1 byte unsigned integer (0-255) from the given file, which must have
         * been opened for reading.
         *
         * @param iFileID - The ID of the file to read.
         * @return int
         */
        @Signature
        public native int ReadByte(int iFileID);

        /**
         * Cast a ray and checks against the object.
         *
         * @param objID        - Id of object to check against.
         * @param rayID        - ID of the ray
         * @param fromVec3ID   - ID of the starting point vector. Create a vector with
         *                     the CreateVector3() command.
         * @param toVec3ID     - ID of the destination vector
         * @param allOrClosest - 1 = all contacts, 0 = closest contact
         * @return int
         */
        @Signature
        public native int RayCast3DPhysicsObject(int objID, int rayID, int fromVec3ID, int toVec3ID, int allOrClosest);

        /**
         * Cast a ray
         *
         * @param rayID        - ID of the ray
         * @param fromVec3ID   - ID of the starting point vector. Create a vector with
         *                     the CreateVector3() command.
         * @param toVec3ID     - ID of the destination vector
         * @param allOrClosest - 1 = all contacts, 0 = closest contact
         * @return void
         */
        @Signature
        public native void RayCast3DPhysics(int rayID, int fromVec3ID, int toVec3ID, int allOrClosest);

        /**
         * Return a 1 if the ray exists. Returns a 0 if it does not.
         *
         * @param rayID - ID of the ray
         * @return int
         */
        @Signature
        public native int Ray3DPhysicsExist(int rayID);

        /**
         * Will randomly negate the value given and return it. Has a 50-50 chance of
         * negating the value. The initial value can be negative, in which case it will
         * randomly become positive.
         *
         * @param value - The value to change.
         * @return int
         */
        @Signature
        public native int RandomSign(int value);

        /**
         * Generates a random number based on the current seed value. The random number
         * generator is built into AGK so a particular seed value will produce the same
         * sequence of numbers on every platform. Produces a random number between 0 and
         * 65535
         *
         * 
         * @return int
         */
        @Signature
        public native int Random();

        /**
         * Generates a random number based on the current seed value. The random number
         * generator is built into AGK so a particular seed value will produce the same
         * sequence of numbers on every platform. Produces a random number between 0 and
         * 65535
         *
         * @param from - The lowest value to return
         * @param to   - The highest value to return
         * @return int
         */
        @Signature
        public native int Random(int from, int to);

        /**
         * Returns 1 if setup was successful, 0 if it failed or the device does not
         * support push notifications.
         *
         * @return int
         */
        @Signature
        public native int PushNotificationSetup();

        /**
         * Prints the given value or string to the screen but does not add a new line
         * character to the end. The next Print or PrintC command will follow on
         * directly from this one.
         *
         * @param szString - The string to print.
         * @return void
         */
        @Signature
        public native void PrintC(String szString);

        /**
         * Prints the given value or string to the screen but does not add a new line
         * character to the end. The next Print or PrintC command will follow on
         * directly from this one.
         *
         * @param i - The integer to print.
         * @return void
         */
        // НЕ РАБОТАЕТ @Signature
        public native void PrintC(int i);

        /**
         * Prints the given value or string to the screen but does not add a new line
         * character to the end. The next Print or PrintC command will follow on
         * directly from this one.
         *
         * @param f - The float to print.
         * @return void
         */
        // НЕ РАБОТАЕТ @Signature
        public native void PrintC(float f);

        /**
         * Prints the given value or string to the screen and adds a new line character
         * so that the next print command will be one line down.
         *
         * @param i - The integer to print.
         * @return void
         */
        // НЕ РАБОТАЕТ @Signature
        public native void Print(int i);

        /**
         * Prints the given value or string to the screen and adds a new line character
         * so that the next print command will be one line down.
         *
         * @param f - The float to print.
         * @return void
         */
        // НЕ РАБОТАЕТ @Signature
        public native void Print(float f);

        /**
         * Prints the given value or string to the screen and adds a new line character
         * so that the next print command will be one line down.
         *
         * @param szString - The string to print.
         * @return void
         */
        @Signature
        public native void Print(String szString);

        /**
         * Reads a 4 byte integer from the given file, which must have been opened for
         * reading.
         *
         * @param iFileID - The ID of the file to read.
         * @return int
         */
        @Signature
        public native int ReadInteger(int iFileID);

        /**
         * Plays the specified Youtube video in a separate window above your app. For
         * Android you must enable the Youtube Data API v3 in the Google Cloud Console
         * for your app, and create an API key for it in the credentials section. You
         * can create a key specifically for use with the Youtube API, or you can use an
         * unrestricted key that can be used by multiple APIs. The videoID is the string
         * that follows the ?v= part of a Youtube URL, e.g. "eLIgxYHCgWA". You can also
         * specify a start time to start playing the video from part way through instead
         * of starting from the beginning. The time is specified in seconds and accepts
         * decimal values to represent fractions of a second. On Windows, Mac, and Linux
         * this command will open the default browser to play the Youtube video. The
         * developer key field is only required on Android.
         *
         * @param developerKey - The API key credential created in the Google Cloud
         *                     Console for the Youtube Data API v3.
         * @param videoID      - The ID of the video, e.g. eLIgxYHCgWA
         * @param startTime    - The seek time in seconds from which to start playing
         *                     the video
         * @return void
         */
        @Signature
        public native void PlayYoutubeVideo(String developerKey, String videoID, float startTime);

        /**
         * Prints an image to a connected printer. This command is not guaranteed to
         * work on all platforms. The size parameter determines how large the image is
         * on the page, a value of 100 makes it use as much of the page as possible, 50
         * makes it use half this amount, 25 a quarter and so on.
         *
         * @param image - the ID of the image to print
         * @param size  - the amount of space to use on the page, between 0 and 100.
         * @return void
         */
        @Signature
        public native void PrintImage(int image, float size);

        /**
         * Displays a dialog box asking the user to rate the app on the App Store.
         * Currently this command is only supported on iOS.
         *
         * @param szID    - This is the ID of your app. You can obtain this from iTunes
         *                Connect.
         * @param szTitle - The string to use as the title of the dialog box, normally
         *                this is "Rate AppName"
         * @return void
         */
        @Signature
        public native void RateApp(String szID, String szTitle);

        /**
         * Displays a dialog box asking the user to rate the app on the App Store.
         * Currently this command is only supported on iOS.
         *
         * @param szID      - This is the ID of your app. You can obtain this from
         *                  iTunes Connect.
         * @param szTitle   - The string to use as the title of the dialog box, normally
         *                  this is "Rate AppName"
         * @param szMessage - The string to use as the message of the dialog box
         * @return void
         */
        @Signature
        public native void RateApp(String szID, String szTitle, String szMessage);

        /**
         * Displays a dialog box asking the user to rate the app on the App Store.
         * Currently this command is only supported on iOS.
         *
         * @param szID - This is the ID of your app. You can obtain this from iTunes
         *             Connect.
         * @return void
         */
        @Signature
        public native void RateApp(String szID);

        /**
         * Generates a random number based on the current seed value. The random number
         * generator is built into AGK so a particular seed value will produce the same
         * sequence of numbers on every platform. Produces a random number between
         * -2,147,483,648 and 2,147,483,647. This generator is slower than Random but
         * produces better quality randomness over a larger range of values.
         *
         * 
         * @return int
         */
        @Signature
        public native int Random2();

        /**
         * Generates a random number based on the current seed value. The random number
         * generator is built into AGK so a particular seed value will produce the same
         * sequence of numbers on every platform. Produces a random number between
         * -2,147,483,648 and 2,147,483,647. This generator is slower than Random but
         * produces better quality randomness over a larger range of values.
         *
         * @param from - The lowest value to return
         * @param to   - The highest value to return
         * @return int
         */
        @Signature
        public native int Random2(int from, int to);

        /**
         * Plays the video or resumes it from pausing. Plays the video to an image
         * instead of to the screen, the image must not already exist. The image will be
         * deleted when you call DeleteVideo, you must not delete it manually. You can
         * either use this command or PlayVideo, but not both. If you pause the video
         * you must resume it using the same command you used to start it, with the same
         * parameters. Currently this is only supported on iOS 7.0 or above, Android
         * 4.0.3 or above, and Windows.
         *
         * @param imageID - An ID to use to reference the new image, must not already
         *                exist
         * @return void
         */
        @Signature
        public native void PlayVideoToImage(int imageID);

        /**
         * Applies the given tween ID to a given object ID with an optional delay and
         * starts playing it. A tween can be played on multiple objects at the same
         * time, simply call this command again with a different object ID. The object
         * will not be modified until the delay time has passed, at which point the
         * tween will start at the begin values and move towards the end values over the
         * tween duration. If a tween end value is modified whilst the tween is playing
         * on a object the object will adjust its interpolation accordingly. Modifying
         * the duration whilst playing is undefined and not compatible with chains.
         *
         * @param tweenID  - ID of the tween to use
         * @param objectID - ID of the object to modify
         * @param delay    - Number of seconds before the tween should start playing
         * @return void
         */
        @Signature
        public native void PlayTweenObject(int tweenID, int objectID, float delay);

        /**
         * Plays the given custom tween ID with an optional delay and starts playing it.
         * Unlike other tweens this is not applied to any specific item or object and
         * cannot have multiple copies running at the same time, you will have to create
         * a separate custom tween for each copy you want to run simultaneously. The
         * tween values will not be modified until the delay time has passed, at which
         * point the tween will start at the begin values and move towards the end
         * values over the tween duration. If a tween end value is modified whilst the
         * tween is playing the tween will adjust its interpolation accordingly.
         * Modifying the duration whilst playing is undefined and not compatible with
         * chains.
         *
         * @param tweenID - ID of the tween to use
         * @param delay   - Number of seconds before the tween should start playing
         * @return void
         */
        @Signature
        public native void PlayTweenCustom(int tweenID, float delay);

        /**
         * Returns a raised to the power of b.
         *
         * @param a - The base.
         * @param b - The power.
         * @return float
         */
        @Signature
        public native float Pow(float a, float b);

        /**
         * Applies the given tween ID to a given character in a text object with an
         * optional delay and starts playing it. A tween can be played on multiple
         * characters across multiple text objects at the same time, simply call this
         * command again with a different text or character ID. The character will not
         * be modified until the delay time has passed, at which point the tween will
         * start at the begin values and move towards the end values over the tween
         * duration. If a tween end value is modified whilst the tween is playing on a
         * character the character will adjust its interpolation accordingly. Modifying
         * the duration whilst playing is undefined and not compatible with chains.
         *
         * @param tweenID - ID of the tween to use
         * @param textID  - ID of the text object to modify
         * @param charID  - The index of the character, indices start at 0, if out of
         *                range it will be ignored
         * @param delay   - Number of seconds before the tween should start playing
         * @return void
         */
        @Signature
        public native void PlayTweenChar(int tweenID, int textID, int charID, float delay);

        /**
         * Starts playing the given chain from the beginning or resumes it if it was
         * paused.
         *
         * @param chainID - ID of the chain to modify
         * @return void
         */
        @Signature
        public native void PlayTweenChain(int chainID);

        /**
         * Applies the given tween ID to a given camera ID with an optional delay and
         * starts playing it. A tween can be played on multiple cameras at the same
         * time, simply call this command again with a different camera ID. The camera
         * will not be modified until the delay time has passed, at which point the
         * tween will start at the begin values and move towards the end values over the
         * tween duration. If a tween end value is modified whilst the tween is playing
         * on a camera the camera will adjust its interpolation accordingly. Modifying
         * the duration whilst playing is undefined and not compatible with chains.
         *
         * @param tweenID  - ID of the tween to use
         * @param cameraID - ID of the camera to modify
         * @param delay    - Number of seconds before the tween should start playing
         * @return void
         */
        @Signature
        public native void PlayTweenCamera(int tweenID, int cameraID, float delay);

        /**
         * Play the sound previously loaded into the specified sound number. This
         * command can be called multiple times for the same sound ID and it will start
         * multiple copies of that sound playing as instances. The command will return
         * an instance ID that can be used to interact with this instance whilst it is
         * still playing. When an instance stops playing then it is automatically
         * deleted and can no longer be referenced. By default the sound is not looped.
         *
         * @param iID  - The sound number to play.
         * @param iVol - The volume at which the sound should be played (optional,
         *             default 100).
         * @return int
         */
        @Signature
        public native int PlaySound(int iID, int iVol);

        /**
         * Play the sound previously loaded into the specified sound number. This
         * command can be called multiple times for the same sound ID and it will start
         * multiple copies of that sound playing as instances. The command will return
         * an instance ID that can be used to interact with this instance whilst it is
         * still playing. When an instance stops playing then it is automatically
         * deleted and can no longer be referenced. By default the sound is not looped.
         *
         * @param iID   - The sound number to play.
         * @param iVol  - The volume at which the sound should be played (optional,
         *              default 100).
         * @param iLoop - The number of times to loop the instance, or 1 for forever.
         * @return int
         */
        @Signature
        public native int PlaySound(int iID, int iVol, int iLoop);

        /**
         * Play the sound previously loaded into the specified sound number. This
         * command can be called multiple times for the same sound ID and it will start
         * multiple copies of that sound playing as instances. The command will return
         * an instance ID that can be used to interact with this instance whilst it is
         * still playing. When an instance stops playing then it is automatically
         * deleted and can no longer be referenced. By default the sound is not looped.
         *
         * @param iID       - The sound number to play.
         * @param iVol      - The volume at which the sound should be played (optional,
         *                  default 100).
         * @param iLoop     - The number of times to loop the instance, or 1 for
         *                  forever.
         * @param iPriority - Reserved for future use, must be 0 (optional, default 0).
         * @return int
         */
        @Signature
        public native int PlaySound(int iID, int iVol, int iLoop, int iPriority);

        /**
         * Play the sound previously loaded into the specified sound number. This
         * command can be called multiple times for the same sound ID and it will start
         * multiple copies of that sound playing as instances. The command will return
         * an instance ID that can be used to interact with this instance whilst it is
         * still playing. When an instance stops playing then it is automatically
         * deleted and can no longer be referenced. By default the sound is not looped.
         *
         * @param iID - The sound number to play.
         * @return int
         */
        @Signature
        public native int PlaySound(int iID);

        /**
         * Plays the given animation by name if it exists with an optional start time
         * (Default 0), optional looping, and optional tween time (Default 0). The tween
         * time will smoothly interpolate the skeleton from its current state to the
         * first frame of the specified animation before it starts animating so that
         * there is no sharp transition. A loop value of 1 will loop forever, a loop
         * value greater than 1 will loop for that many times and then stop, and a loop
         * value of 0 will play the animation once and then stop
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param anim      - The name of the animation to play
         * @param starttime - An optional offset into the animation to skip some frames
         * @param loop      - 1 to loop the animation until stopped, 0 to play it once,
         *                  greater than 1 to loop that many times
         * @param tweentime - Number of seconds to transition from its current state
         *                  before animating
         * @return void
         */
        @Signature
        public native void PlaySkeleton2DAnimation(int iSkeleton, String anim, float starttime, int loop,
                        float tweentime);

        /**
         * Plays an given animation on its parent object. Only objects loaded with
         * LoadObjectWithChildren will have animations assigned to them. Animation names
         * are defined by the modelling program when the animations were created, you
         * can discover what the names are by using GetObjectAnimationName. The
         * animation can be started and ended at any point in the animation using the
         * start and end parameters, these are given in seconds, and if looping is
         * turned on then the object will return to the given start time at the start of
         * each loop. If you want the looping to be seamless then the bone positions at
         * the start and end time must be exactly the same, as there will be no
         * interpolation between them when it loops. The tweentime parameter can be used
         * to interpolate between the current bone positions and the start time of the
         * animation so that there is no sudden jump in bone positions. This tweening
         * only happens once, it does not happen every loop, and does not contribute to
         * the animation time. Essentially the animation is paused until tweening has
         * finished. Note that as soon as this command is called the bones will be
         * controlled by animation and cannot be moved with SetObjectBonePosition or
         * similar commands. You can regain manual control of individual bones by using
         * SetObjectBoneCanAnimate on it. You can regain control of the entire bone
         * structure by using ResetObjectAnimation.
         *
         * @param objID     - The ID of the object to modify.
         * @param animName  - The name of the animation to play, defined by the
         *                  modelling program
         * @param starttime - The point in the animation at which the object should
         *                  start playing, in seconds
         * @param endtime   - The point in the animation at which the object should stop
         *                  playing, minus 1 to continue to the end
         * @param loop      - 1 to loop the animation forever, 0 to play once, any other
         *                  positive integer to loop that many times
         * @param tweentime - The time in seconds to transition from the objects current
         *                  state to the first frame of animation
         * @return void
         */
        @Signature
        public native void PlayObjectAnimation(int objID, String animName, float starttime, float endtime, int loop,
                        float tweentime);

        /**
         * Plays the music file. Multiple OGG music files can be playing at the same
         * time.
         *
         * @param musicID - The ID of the music file to play
         * @param iLoop   - The number of times to loop, or 1 to loop forever
         * @return void
         */
        @Signature
        public native void PlayMusicOGG(int musicID, int iLoop);

        /**
         * Plays the music file. Multiple OGG music files can be playing at the same
         * time.
         *
         * @param musicID - The ID of the music file to play
         * @return void
         */
        @Signature
        public native void PlayMusicOGG(int musicID);

        /**
         * Plays the given music file only and loops it if desired. This is a change
         * from previous versions where AGK would continue playing the next music track
         * after this one. Now you must use the additional parameters of PlayMusic to
         * play tracks one after the other. Only one music file may be playing at any
         * one time.
         *
         * @param iID   - The music file to start with.
         * @param bLoop - 1 to loop forever, 0 to stop after the last ID.
         * @return void
         */
        @Signature
        public native void PlayMusic(int iID, int bLoop);

        /**
         * Plays the given music file only and loops it if desired. This is a change
         * from previous versions where AGK would continue playing the next music track
         * after this one. Now you must use the additional parameters of PlayMusic to
         * play tracks one after the other. Only one music file may be playing at any
         * one time.
         *
         * @param iID - The music file to start with.
         * @return void
         */
        @Signature
        public native void PlayMusic(int iID);

        /**
         * Plays the given music file only and loops it if desired. This is a change
         * from previous versions where AGK would continue playing the next music track
         * after this one. Now you must use the additional parameters of PlayMusic to
         * play tracks one after the other. Only one music file may be playing at any
         * one time.
         *
         * @return void
         */
        @Signature
        public native void PlayMusic();

        /**
         * Plays the given music file only and loops it if desired. This is a change
         * from previous versions where AGK would continue playing the next music track
         * after this one. Now you must use the additional parameters of PlayMusic to
         * play tracks one after the other. Only one music file may be playing at any
         * one time.
         *
         * @param iID      - The music file to start with.
         * @param bLoop    - 1 to loop forever, 0 to stop after the last ID.
         * @param iStartID - The ID to return to when looping from the end to the
         *                 beginning of the file list.
         * @param iEndID   - The ID after which it should loop back to the beginning.
         * @return void
         */
        @Signature
        public native void PlayMusic(int iID, int bLoop, int iStartID, int iEndID);

        /**
         * Plays the video on screen or resumes it from pausing. You can either use this
         * command or PlayVideoToImage, but not both. If you pause the video you must
         * resume it using the same command you used to start it.
         *
         * @return void
         */
        @Signature
        public native void PlayVideo();

        /**
         * Applies the given tween ID to a given sprite ID with an optional delay and
         * starts playing it. A tween can be played on multiple sprites at the same
         * time, simply call this command again with a different sprite ID. The sprite
         * will not be modified until the delay time has passed, at which point the
         * tween will start at the begin values and move towards the end values over the
         * tween duration. If a tween end value is modified whilst the tween is playing
         * on a sprite the sprite will adjust its interpolation accordingly. Modifying
         * the duration whilst playing is undefined and not compatible with chains.
         *
         * @param tweenID  - ID of the tween to use
         * @param spriteID - ID of the sprite to modify
         * @param delay    - Number of seconds before the tween should start playing
         * @return void
         */
        @Signature
        public native void PlayTweenSprite(int tweenID, int spriteID, float delay);

        /**
         * Applies the given tween ID to a given text ID with an optional delay and
         * starts playing it. A tween can be played on multiple text objects at the same
         * time, simply call this command again with a different text ID. The text will
         * not be modified until the delay time has passed, at which point the tween
         * will start at the begin values and move towards the end values over the tween
         * duration. If a tween end value is modified whilst the tween is playing on a
         * text object the text will adjust its interpolation accordingly. Modifying the
         * duration whilst playing is undefined and not compatible with chains.
         *
         * @param tweenID - ID of the tween to use
         * @param textID  - ID of the text object to modify
         * @param delay   - Number of seconds before the tween should start playing
         * @return void
         */
        @Signature
        public native void PlayTweenText(int tweenID, int textID, float delay);

        /**
         * Casts a ray through all physics objects including sprites that have physics
         * turned on and stores the closest item hit. Results of a ray cast can be
         * retrieved using the other ray cast functions such as GetRayCastNormalX. If
         * the ray starts inside a shape that shape will not be counted in the results.
         * This function filters the sprites that are checked so only sprites of a
         * certain group are checked, a group value of 0 means all groups will be
         * checked. Returns 1 if there was a collision, 0 if not.
         *
         * @param group - The group ID to check for intersection with the ray, can be
         *              negative.
         * @param x     - The X coordinate of the start point in world coordinates.
         * @param y     - The Y coordinate of the start point in world coordinates.
         * @param x2    - The X coordinate of the end point in world coordinates.
         * @param y2    - The Y coordinate of the end point in world coordinates.
         * @return int
         */
        @Signature
        public native int PhysicsRayCastGroup(int group, float x, float y, float x2, float y2);

        /**
         * Pauses the video and keeps it on screen.
         *
         * @return void
         */
        @Signature
        public native void PauseVideo();

        /**
         * Casts a ray through all physics objects including sprites that have physics
         * turned on and stores the closest item hit. Results of a ray cast can be
         * retrieved using the other ray cast functions such as GetRayCastNormalX. If
         * the ray starts inside a shape that shape will not be counted in the results.
         * Returns 1 if there was a collision, 0 if not.
         *
         * @param x  - The X coordinate of the start point in world coordinates.
         * @param y  - The Y coordinate of the start point in world coordinates.
         * @param x2 - The X coordinate of the end point in world coordinates.
         * @param y2 - The Y coordinate of the end point in world coordinates.
         * @return int
         */
        @Signature
        public native int PhysicsRayCast(float x, float y, float x2, float y2);

        /**
         * Casts a ray through all physics objects including sprites that have physics
         * turned on and stores the closest item hit. Results of a ray cast can be
         * retrieved using the other ray cast functions such as GetRayCastNormalX. If
         * the ray starts inside a shape that shape will not be counted in the results.
         * This function filters the sprites that are checked so only sprites of certain
         * categories are checked. The category parameter is a bitwise field that uses
         * the lower 16 bits to represent each of the possible 16 categories used when
         * setting up a sprite. The default value of all 1s means all categories will be
         * included, whereas a value of all 0s means no categories will be included. You
         * can set individual bits to set which ones should be checked. Returns 1 if
         * there was a collision, 0 if not.
         *
         * @param category - The categories to check for intersection with the ray,
         *                 bitwise field using the lower most 16 bits.
         * @param x        - The X coordinate of the start point in world coordinates.
         * @param y        - The Y coordinate of the start point in world coordinates.
         * @param x2       - The X coordinate of the end point in world coordinates.
         * @param y2       - The Y coordinate of the end point in world coordinates.
         * @return int
         */
        @Signature
        public native int PhysicsRayCastCategory(int category, float x, float y, float x2, float y2);

        /**
         * Pauses the given tween at its current point. It will not update again until
         * ResumeTweenText is called. If the tween has already stopped or doesn't exist
         * then this does nothing.
         *
         * @param tweenID - ID of the tween to pause
         * @param textID  - ID of the text to pause
         * @return void
         */
        @Signature
        public native void PauseTweenText(int tweenID, int textID);

        /**
         * Pauses the given tween at its current point. It will not update again until
         * ResumeTweenObject is called. If the tween has already stopped or doesn't
         * exist then this does nothing.
         *
         * @param tweenID  - ID of the tween to pause
         * @param objectID - ID of the object to pause
         * @return void
         */
        @Signature
        public native void PauseTweenObject(int tweenID, int objectID);

        /**
         * Pauses the given tween at its current point. It will not update again until
         * ResumeTweenChar is called. If the tween has already stopped or doesn't exist
         * then this does nothing.
         *
         * @param tweenID - ID of the tween to pause
         * @param textID  - ID of the text to pause
         * @param charID  - Index of the character to pause
         * @return void
         */
        @Signature
        public native void PauseTweenChar(int tweenID, int textID, int charID);

        /**
         * Pauses the given chain that has started playing, it can be resumed with
         * PlayTweenChain
         *
         * @param chainID - ID of the chain to modify
         * @return void
         */
        @Signature
        public native void PauseTweenChain(int chainID);

        /**
         * Pauses the given tween at its current point. It will not update again until
         * ResumeTweenCamera is called. If the tween has already stopped or doesn't
         * exist then this does nothing.
         *
         * @param tweenID  - ID of the tween to pause
         * @param cameraID - ID of the camera to pause
         * @return void
         */
        @Signature
        public native void PauseTweenCamera(int tweenID, int cameraID);

        /**
         * Pauses the music file. GetMusicPlayingOGG will continue to return 1.
         *
         * @param musicID - The ID of the music file to pause
         * @return void
         */
        @Signature
        public native void PauseMusicOGG(int musicID);

        /**
         * Pauses the currently playing music, whichever ID that may be.
         *
         * 
         * @return void
         */
        @Signature
        public native void PauseMusic();

        /**
         * Forces Chartboost to use the given consent value when showing ads, by default
         * AGK shows non-personalised ads from Chartboost. This command can be used if
         * you have you own method of aquiring user consent to show personalised ads.
         * Note that the GDPR requires you by law to have the consent from EU users
         * before showing them personalised ads.
         *
         * @param consent - The consent value to use, 1=non-personalised, 2=personalised
         * @return void
         */
        @Signature
        public native void OverrideConsentChartboost(int consent);

        /**
         * Forces AdMob to use the given consent value when showing ads, this is not
         * saved to the AdMob server and overrides the normal consent process. This is
         * used if you have you own method of aquiring user consent to show personalised
         * ads. Note that the GDPR requires you by law to have the consent from EU users
         * before showing them personalised ads.
         *
         * @param consent - The consent value to use, 1=non-personalised, 2=personalised
         * @return void
         */
        @Signature
        public native void OverrideConsentAdMob(int consent);

        /**
         * Begins the animation of a sprite based on the given values. Animation speed
         * is based on animation frames per second and is not affected by the drawing
         * frame rate.
         *
         * @param iSpriteIndex - The ID of the sprite to animate.
         * @return void
         */
        @Signature
        public native void PlaySprite(int iSpriteIndex);

        /**
         * Begins the animation of a sprite based on the given values. Animation speed
         * is based on animation frames per second and is not affected by the drawing
         * frame rate.
         *
         * @param iSpriteIndex - The ID of the sprite to animate.
         * @param fFps         - Frames per second. The number of frames the sprite
         *                     should attempt to cycle through every second (optional,
         *                     default 10).
         * @return void
         */
        @Signature
        public native void PlaySprite(int iSpriteIndex, float fFps);

        /**
         * Begins the animation of a sprite based on the given values. Animation speed
         * is based on animation frames per second and is not affected by the drawing
         * frame rate.
         *
         * @param iSpriteIndex - The ID of the sprite to animate.
         * @param fFps         - Frames per second. The number of frames the sprite
         *                     should attempt to cycle through every second (optional,
         *                     default 10).
         * @param iLoop        - The looping mode of the sprite, 0 equals do not loop, 1
         *                     equals loop forever (optional, default 1).
         * @return void
         */
        @Signature
        public native void PlaySprite(int iSpriteIndex, float fFps, int iLoop);

        /**
         * Begins the animation of a sprite based on the given values. Animation speed
         * is based on animation frames per second and is not affected by the drawing
         * frame rate.
         *
         * @param iSpriteIndex - The ID of the sprite to animate.
         * @param fFps         - Frames per second. The number of frames the sprite
         *                     should attempt to cycle through every second (optional,
         *                     default 10).
         * @param iLoop        - The looping mode of the sprite, 0 equals do not loop, 1
         *                     equals loop forever (optional, default 1).
         * @param iFromFrame   - The frame to begin at, frames start at 1 (optional,
         *                     default minus 1).
         * @param iToFrame     - The frame to end at, frames end at GetSpriteFrameCount
         *                     (optional, default minus 1).
         * @return void
         */
        @Signature
        public native void PlaySprite(int iSpriteIndex, float fFps, int iLoop, int iFromFrame, int iToFrame);

        /**
         * Opens a folder any where on the file system and reads the list of files and
         * folders it contains. This is done immediately so any changes that occur to
         * the folder after this command will not be noticed, you would need to call
         * this command again to get the updated contents. The file path must be
         * absolute for the current device, i.e. it must begin with a drive letter and
         * colon on Windows, and a forward slash on all other platforms. The path must
         * exist and be accessible to the current app or this command will generate an
         * error. The path may begin with the text "raw:" or not, both forms are
         * accepted. This command will return an ID that you can use to access the file
         * list that was found, it will remain accessible until you close it with
         * CloseRawFolder. Multiple folders can be open at the same time, they will each
         * be given a different ID.
         *
         * @param szPath - The path to the folder to open
         * @return int
         */
        @Signature
        public native int OpenRawFolder(String szPath);

        /**
         * Opens the default browser of the current platform and points it to the page
         * given.
         *
         * @param url - THe url to open
         * @return void
         */
        @Signature
        public native void OpenBrowser(String url);

        /**
         * Pauses the given tween at its current point. It will not update again until
         * ResumeTweenSprite is called. If the tween has already stopped or doesn't
         * exist then this does nothing.
         *
         * @param tweenID  - ID of the tween to pause
         * @param spriteID - ID of the sprite to pause
         * @return void
         */
        @Signature
        public native void PauseTweenSprite(int tweenID, int spriteID);

        /**
         * Pauses the given tween at its current point. It will not update again until
         * ResumeTweenCustom is called. If the tween has already stopped or doesn't
         * exist then this does nothing.
         *
         * @param tweenID - ID of the tween to pause
         * @return void
         */
        @Signature
        public native void PauseTweenCustom(int tweenID);

        /**
         * Immediately moves all existing particles by the given offset. For example an
         * offset of x=3,y=5,z=0 would move all particles to the right by 3 units and
         * down 5 units. This does not affect the particle emitter but can be used in
         * conjunction with Set3DParticlesPosition to move both the emitter and the
         * particles that already exist.
         *
         * @param ID - The ID of the emitter to modify.
         * @param x  - The distance to move the particles in the X direction.
         * @param y  - The distance to move the particles in the Y direction.
         * @param z  - The distance to move the particles in the Z direction.
         * @return void
         */
        @Signature
        public native void Offset3DParticles(int ID, float x, float y, float z);

        /**
         * This command does the same as ObjectSphereCast but over multiple iterations
         * to produce a slide point for use in sliding collisions. It produces a slide
         * point that is checked again to make sure this new point does not collide with
         * any objects. This produces another point, which must be checked and so on.
         * ObjectSphereSlide uses a maximum of three iterations to finalize a point that
         * will keep the sphere outside all objects checked. The command
         * GetObjectRayCastNumHits can be used to get the number of iterations used by
         * this command. Details of the collision point, normal, and slide point for
         * each iteration are also available using collision indices 1 to 3 i.e.
         * GetObjectRayCastX(1) (2) or (3). The final collision point, normal and slide
         * point are in index 0, i.e. GetObjectRayCastSlideX(0).
         *
         * @param objID  - The ID of the object to check, 0 for all objects.
         * @param oldx   - The X component of the start position.
         * @param oldy   - The Y component of the start position.
         * @param oldz   - The Z component of the start position.
         * @param newx   - The X component of the end position.
         * @param newy   - The Y component of the end position.
         * @param newz   - The Z component of the end position.
         * @param radius - The radius of the sphere to cast.
         * @return int
         */
        @Signature
        public native int ObjectSphereSlide(int objID, float oldx, float oldy, float oldz, float newx, float newy,
                        float newz, float radius);

        /**
         * Will check if the ray starting at oldx, oldy, oldz and ending at newx, newy,
         * newz, and of width radius, collides with the specified object (objID=0 for
         * all). Does not collide with backfaces, will return the number of the object
         * hit first, or 0 for no collision. Sphere casting commands add a width
         * dimension to normal ray casting which can be used to check if a player has
         * hit anything during movement and to position them at the collision point to
         * provide 'sticky' collision, where the player stops if they hit anything. The
         * alternative is sliding collision. see ObjectSphereSlide
         *
         * @param objID  - The ID of the object to check, 0 for all objects.
         * @param oldx   - The X component of the start position.
         * @param oldy   - The Y component of the start position.
         * @param oldz   - The Z component of the start position.
         * @param newx   - The X component of the end position.
         * @param newy   - The Y component of the end position.
         * @param newz   - The Z component of the end position.
         * @param radius - The radius of the sphere to cast.
         * @return int
         */
        @Signature
        public native int ObjectSphereCast(int objID, float oldx, float oldy, float oldz, float newx, float newy,
                        float newz, float radius);

        /**
         * Casts a ray through 1 or all objects to check for intersection with the
         * object. Rays are define with a start position and an end position and does
         * not collide with backfaces, will return the number of the object hit first,
         * or 0 for no collision. Ray casting commands are useful for calculating the
         * collisions of bullets with levels and objects, or for representing the line
         * of sight of an enemy to detect if they can see the player.
         *
         * @param objID - The ID of the object to check, 0 for all objects.
         * @param oldx  - The X component of the start position.
         * @param oldy  - The Y component of the start position.
         * @param oldz  - The Z component of the start position.
         * @param newx  - The X component of the end position.
         * @param newy  - The Y component of the end position.
         * @param newz  - The Z component of the end position.
         * @return int
         */
        @Signature
        public native int ObjectRayCast(int objID, float oldx, float oldy, float oldz, float newx, float newy,
                        float newz);

        /**
         * Moves the specified object along its local Y axis, i.e. if the object were a
         * character this command would make them jump no matter which direction they
         * were facing.
         *
         * @param objID  - The ID of the object to modify.
         * @param amount - The distance to move in the local Y direction, can be
         *               negative.
         * @return void
         */
        @Signature
        public native void MoveObjectLocalY(int objID, float amount);

        /**
         * Moves the specified object along its local X axis, i.e. if the object were a
         * character this command would make them strafe no matter which direction they
         * were facing.
         *
         * @param objID  - The ID of the object to modify.
         * @param amount - The distance to move in the local X direction, can be
         *               negative.
         * @return void
         */
        @Signature
        public native void MoveObjectLocalX(int objID, float amount);

        /**
         * Opens a file stored on the local filesystem for writing into the specified
         * ID. All platforms are restricted to a single folder for writing so file paths
         * must be relative, not absolute. This write folder is not the same folder as
         * the application itself, so images, sounds, and the application itself cannot
         * be overwritten. Files written to this folder can be read using OpenToRead. If
         * the file does not exist it will be created, if the file does exist it will be
         * overwritten if append is 0. or appended to if append is 1. If a directory is
         * given in the filename and does not exist it will be created. To write a file
         * outside the normal write folder you can use "raw:" followed by an absolute
         * path for the current platform, for example "raw:C:\MyFolder\MyFile.txt" on
         * Windows or "raw:/sdcard/Documents/MyFile.txt" on Android. If any folders in
         * your chosen path do not exist they will be created. On Raspberry Pi you can
         * use this command to open a GPIO pin for writing by using the filename "gpio:"
         * followed by the GPIO pin number, for example OpenToWrite(1, "gpio:4"), this
         * is case sensitive. You can then use WriteByte to write 0 or 1 to the pin and
         * CloseFile to close the pin.
         *
         * @param ID     - The ID to use to reference this file later.
         * @param szFile - The filename to open for writing.
         * @return void
         */
        // НЕ РАБОТАЕТ@Signature
        public native void OpenToWrite(int ID, String szFile);

        /**
         * Opens a file stored on the local filesystem for writing into the specified
         * ID. All platforms are restricted to a single folder for writing so file paths
         * must be relative, not absolute. This write folder is not the same folder as
         * the application itself, so images, sounds, and the application itself cannot
         * be overwritten. Files written to this folder can be read using OpenToRead. If
         * the file does not exist it will be created, if the file does exist it will be
         * overwritten if append is 0. or appended to if append is 1. If a directory is
         * given in the filename and does not exist it will be created. To write a file
         * outside the normal write folder you can use "raw:" followed by an absolute
         * path for the current platform, for example "raw:C:\MyFolder\MyFile.txt" on
         * Windows or "raw:/sdcard/Documents/MyFile.txt" on Android. If any folders in
         * your chosen path do not exist they will be created. On Raspberry Pi you can
         * use this command to open a GPIO pin for writing by using the filename "gpio:"
         * followed by the GPIO pin number, for example OpenToWrite(1, "gpio:4"), this
         * is case sensitive. You can then use WriteByte to write 0 or 1 to the pin and
         * CloseFile to close the pin.
         *
         * @param szFile - The filename to open for writing.
         * @param append - Set to 1 to append to the file, 0 to overwrite all data
         *               (optional, default 0).
         * @return int
         */
        @Signature
        public native int OpenToWrite(String szFile, int append);

        /**
         * Opens a file stored on the local filesystem for writing into the specified
         * ID. All platforms are restricted to a single folder for writing so file paths
         * must be relative, not absolute. This write folder is not the same folder as
         * the application itself, so images, sounds, and the application itself cannot
         * be overwritten. Files written to this folder can be read using OpenToRead. If
         * the file does not exist it will be created, if the file does exist it will be
         * overwritten if append is 0. or appended to if append is 1. If a directory is
         * given in the filename and does not exist it will be created. To write a file
         * outside the normal write folder you can use "raw:" followed by an absolute
         * path for the current platform, for example "raw:C:\MyFolder\MyFile.txt" on
         * Windows or "raw:/sdcard/Documents/MyFile.txt" on Android. If any folders in
         * your chosen path do not exist they will be created. On Raspberry Pi you can
         * use this command to open a GPIO pin for writing by using the filename "gpio:"
         * followed by the GPIO pin number, for example OpenToWrite(1, "gpio:4"), this
         * is case sensitive. You can then use WriteByte to write 0 or 1 to the pin and
         * CloseFile to close the pin.
         *
         * @param szFile - The filename to open for writing.
         * @return int
         */
        @Signature
        public native int OpenToWrite(String szFile);

        /**
         * Opens a file stored on the local filesystem for writing into the specified
         * ID. All platforms are restricted to a single folder for writing so file paths
         * must be relative, not absolute. This write folder is not the same folder as
         * the application itself, so images, sounds, and the application itself cannot
         * be overwritten. Files written to this folder can be read using OpenToRead. If
         * the file does not exist it will be created, if the file does exist it will be
         * overwritten if append is 0. or appended to if append is 1. If a directory is
         * given in the filename and does not exist it will be created. To write a file
         * outside the normal write folder you can use "raw:" followed by an absolute
         * path for the current platform, for example "raw:C:\MyFolder\MyFile.txt" on
         * Windows or "raw:/sdcard/Documents/MyFile.txt" on Android. If any folders in
         * your chosen path do not exist they will be created. On Raspberry Pi you can
         * use this command to open a GPIO pin for writing by using the filename "gpio:"
         * followed by the GPIO pin number, for example OpenToWrite(1, "gpio:4"), this
         * is case sensitive. You can then use WriteByte to write 0 or 1 to the pin and
         * CloseFile to close the pin.
         *
         * @param ID     - The ID to use to reference this file later.
         * @param szFile - The filename to open for writing.
         * @param append - Set to 1 to append to the file, 0 to overwrite all data
         *               (optional, default 0).
         * @return void
         */
        @Signature
        public native void OpenToWrite(int ID, String szFile, int append);

        /**
         * Moves the specified camera along its local Y axis, i.e. if the camera were a
         * character this command would make them jump no matter which direction they
         * were facing.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param amount   - The distance to move in the local Y direction, can be
         *                 negative.
         * @return void
         */
        @Signature
        public native void MoveCameraLocalY(int cameraID, float amount);

        /**
         * Moves the specified object along its local Z axis, i.e. if the object were a
         * character this command would make them move forwards no matter which
         * direction they were facing.
         *
         * @param objID  - The ID of the object to modify.
         * @param amount - The distance to move in the local Z direction, can be
         *               negative.
         * @return void
         */
        @Signature
        public native void MoveObjectLocalZ(int objID, float amount);

        /**
         * Moves the specified camera along its local X axis, i.e. if the camera were a
         * character this command would make them strafe no matter which direction they
         * were facing.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param amount   - The distance to move in the local X direction, can be
         *                 negative.
         * @return void
         */
        @Signature
        public native void MoveCameraLocalX(int cameraID, float amount);

        /**
         * Moves the Controller.
         *
         * @param objID    - object ID
         * @param x        - The amount to move in the x direction, this will be
         *                 normalised with the z direction
         * @param z        - The amount to move in the z direction, this will be
         *                 normalised with the x direction
         * @param velocity - travel speed
         * @return void
         */
        @Signature
        public native void Move3DPhysicsCharacterController(int objID, float x, float z, float velocity);

        /**
         * Moves the Controller.
         *
         * @param objID     - object ID
         * @param direction - 0 = stop, 1 = forward, 2 = backward, 3 = strafe left, 4 =
         *                  strafe right
         * @param velocity  - travel speed
         * @return void
         */
        @Signature
        public native void Move3DPhysicsCharacterController(int objID, int direction, float velocity);

        /**
         * Opens a file stored on the local filesystem for reading into the specified
         * ID. All platforms are restricted to a single folder for reading and writing
         * so file paths must be relative, not absolute. This command will check the
         * special write folder first, and if it cannot locate the file it will check
         * the media folder, so you may load images, sounds, and other bundled media
         * files using this command. To read a file outside the normal read or write
         * folders you can use "raw:" followed by an absolute path for the current
         * platform, for example "raw:C:\MyFolder\MyFile.txt" on Windows or
         * "raw:/sdcard/Documents/MyFile.txt" on Android. On Raspberry Pi you can use
         * this command to open a GPIO pin for reading by using the filename "gpio:"
         * followed by the GPIO pin number, for example OpenToRead(1, "gpio:4"), this is
         * case sensitive. You can then use ReadByte to read from the pin and CloseFile
         * to close the pin.
         *
         * @param ID     - The ID to use for referencing this file later.
         * @param szFile - The filename to open for reading.
         * @return void
         */
        @Signature
        public native void OpenToRead(int ID, String szFile);

        /**
         * Opens a file stored on the local filesystem for reading into the specified
         * ID. All platforms are restricted to a single folder for reading and writing
         * so file paths must be relative, not absolute. This command will check the
         * special write folder first, and if it cannot locate the file it will check
         * the media folder, so you may load images, sounds, and other bundled media
         * files using this command. To read a file outside the normal read or write
         * folders you can use "raw:" followed by an absolute path for the current
         * platform, for example "raw:C:\MyFolder\MyFile.txt" on Windows or
         * "raw:/sdcard/Documents/MyFile.txt" on Android. On Raspberry Pi you can use
         * this command to open a GPIO pin for reading by using the filename "gpio:"
         * followed by the GPIO pin number, for example OpenToRead(1, "gpio:4"), this is
         * case sensitive. You can then use ReadByte to read from the pin and CloseFile
         * to close the pin.
         *
         * @param szFile - The filename to open for reading.
         * @return int
         */
        @Signature
        public native int OpenToRead(String szFile);

        /**
         * Returns the remainder of the integer division a/b.
         *
         * @param a - The numerator.
         * @param b - The denominator.
         * @return int
         */
        @Signature
        public native int Mod(int a, int b);

        /**
         * Sends the app to the background. On desktop platforms like Windows the app
         * will continue to run when minimized. On Android the app will pause. On iOS it
         * will do nothing as a user must minimize the app by pressing the home button.
         * On desktop platforms the window can be restored with RestoreApp.
         *
         * @return void
         */
        @Signature
        public native void MinimizeApp();

        /**
         * Extracts a sub string from the given string located at the position provided.
         *
         * @param strin    - The string to be extracted from
         * @param position - The position to start within the string, the first
         *                 character is position 1.
         * @param length   - The number of characters to extract from the string, use
         *                 minus 1 to continue to the end of the string
         * @return String
         */
        @Signature
        public native String Mid(String strin, int position, int length);

        /**
         * Moves the specified camera along its local Z axis, i.e. if the camera were a
         * character this command would make them move forwards no matter which
         * direction they were facing.
         *
         * @param cameraID - The ID of the camera to modify, the main camera is ID 1.
         * @param amount   - The distance to move in the local Z direction, can be
         *                 negative.
         * @return void
         */
        @Signature
        public native void MoveCameraLocalZ(int cameraID, float amount);

        /**
         * Displays a message box containing the given text. Your app is not guaranteed
         * to pause whilst the message is displayed.
         *
         * @param msg - The message to display
         * @return void
         */
        @Signature
        public native void Message(String msg);

        /**
         * Maximizes the window so that it is the largest possible size in the current
         * visible space without going full screen. Does nothing on mobile devices.
         *
         * @return void
         */
        @Signature
        public native void MaximizeWindow();

        /**
         * Creates a folder at the current path. By default this is determined by the
         * command SetFolder. You can also use a filename beginning with "raw:" to
         * create a folder anywhere on the file system, for example
         * MakeFolder("raw:C:\Temp\MyFolder")
         *
         * @param szName - The name of the folder create.
         * @return int
         */
        @Signature
        public native int MakeFolder(String szName);

        /**
         * Immediately moves all existing particles by the given offset. For example an
         * offset of x=3,y=5 would move all particles to the right by 3 units and down 5
         * units. This does not affect the particle emitter but can be used in
         * conjunction with SetParticlesPosition to move both the emitter and the
         * particles that already exist.
         *
         * @param ID - The ID of the emitter to modify.
         * @param x  - The distance to move the particles in the X direction.
         * @param y  - The distance to move the particles in the Y direction.
         * @return void
         */
        @Signature
        public native void OffsetParticles(int ID, float x, float y);

        /**
         * Creates a compound color value from color components that can then be used
         * with 2D drawing commands.
         *
         * @param red   - The red component of the color.
         * @param green - The green component of the color.
         * @param blue  - The blue component of the color.
         * @return int
         */
        @Signature
        public native int MakeColor(int red, int green, int blue);

        /**
         * Converts the string to lower case characters.
         *
         * @param strin - The string to convert
         * @return String
         */
        @Signature
        public native String Lower(String strin);

        /**
         * Displays the specified text to the appropriate device log or output window.
         *
         * @param szMessage - the text message to send to the log/output area
         * @return void
         */
        @Signature
        public native void Log(String szMessage);

        /**
         * Returns the natural logarithm of the given value.
         *
         * @param a - The input value
         * @return float
         */
        // НЕ РАБОТАЕТ@Signature
        public native float Log(float a);

        /**
         * This command loads a video file ready to be played. Only one video file can
         * be loaded at a time so loading a video deletes any existing video. On iOS,
         * Android, and Mac it is recommended that you use .mp4 files with the H264
         * (MPEG-4 AVC) codec for video. For audio it must be encoded in MP3 or AAC. On
         * Windows it depends on the codecs installed and although in some cases it will
         * play mp4 files it is recommended that you use wmv on Windows for maximum
         * support. Returns 1 if successful, 0 if there was an error, -1 if this
         * platform does not support videos.
         *
         * @param szFilename - The video file to load.
         * @return int
         */
        @Signature
        public native int LoadVideo(String szFilename);

        /**
         * Loads a shader used for modifying sprites, as such it only contains a pixel
         * shader, the vertex shader is automatically generated to make sure it appears
         * in the right place. This type of shader should only be applied to sprites but
         * nothing bad will happen if you choose to apply it to objects, it will just
         * produce unusual rendering results for that object. Currently shaders default
         * to GLSL version 1.10, the line "#version 110" will be automatically added as
         * the first line of the shader unless you specify a "#version " line of your
         * own. Note that doing this may mean your shader does not work on all devices
         * and platforms. The global "precision" value will be added and should not be
         * included in the shader source. Returns an ID that can be used to reference
         * this shader in other commands. IDs are shared across all shader types so
         * loading a sprite shader into ID 1 will not work if a 3D shader exists with ID
         * 1.
         *
         * @param szPixelFile - The file name of the pixel shader file, normally ending
         *                    .ps
         * @return int
         */
        @Signature
        public native int LoadSpriteShader(String szPixelFile);

        /**
         * Loads a shader used for modifying sprites, as such it only contains a pixel
         * shader, the vertex shader is automatically generated to make sure it appears
         * in the right place. This type of shader should only be applied to sprites but
         * nothing bad will happen if you choose to apply it to objects, it will just
         * produce unusual rendering results for that object. Currently shaders default
         * to GLSL version 1.10, the line "#version 110" will be automatically added as
         * the first line of the shader unless you specify a "#version " line of your
         * own. Note that doing this may mean your shader does not work on all devices
         * and platforms. The global "precision" value will be added and should not be
         * included in the shader source. Returns an ID that can be used to reference
         * this shader in other commands. IDs are shared across all shader types so
         * loading a sprite shader into ID 1 will not work if a 3D shader exists with ID
         * 1.
         *
         * @param shaderID    - An ID used to reference this shader in other commands.
         * @param szPixelFile - The file name of the pixel shader file, normally ending
         *                    .ps
         * @return void
         */
        @Signature
        public native void LoadSpriteShader(int shaderID, String szPixelFile);

        /**
         * Creates a sprite in a blank sprite ID with an explicit image to use when
         * rendering, it returns the sprite ID used. By default sprites are created with
         * a depth of 10, are sized using the given image as a guide, and positioned at
         * 0,0 using their top left corner. If the assigned image has alpha pixels the
         * sprite is create with a transparency mode of 1, otherwise it uses a
         * transparency mode of 0 (opaque) This command takes an image file name and
         * loads it specifically for this sprite, this image will be deleted when the
         * sprite is deleted. If lots of sprites are going to use the same image you
         * should load the image separately and pass its ID to the CreateSprite command
         * to save memory.
         *
         * @param imagefile - The file name of the image to use when drawing this sprite
         * @return int
         */
        @Signature
        public native int LoadSprite(String imagefile);

        /**
         * Creates a sprite in a blank sprite ID with an explicit image to use when
         * rendering, it returns the sprite ID used. By default sprites are created with
         * a depth of 10, are sized using the given image as a guide, and positioned at
         * 0,0 using their top left corner. If the assigned image has alpha pixels the
         * sprite is create with a transparency mode of 1, otherwise it uses a
         * transparency mode of 0 (opaque) This command takes an image file name and
         * loads it specifically for this sprite, this image will be deleted when the
         * sprite is deleted. If lots of sprites are going to use the same image you
         * should load the image separately and pass its ID to the CreateSprite command
         * to save memory.
         *
         * @param iSpriteIndex - The sprite ID to use to reference this sprite later
         *                     (separate from image IDs, so there can be both a sprite 1
         *                     and an image 1)
         * @param imagefile    - The file name of the image to use when drawing this
         *                     sprite
         * @return void
         */
        @Signature
        public native void LoadSprite(int iSpriteIndex, String imagefile);

        /**
         * Loads a sound file from the application media folder. File paths must be
         * relative, not absolute, you cannot load sound files from elsewhere on the
         * disk. This command takes a compressed OGG file and decompresses it during
         * loading, allowing you to save file size, but memory usage will be the same as
         * if you used a WAV file. If you want to use OGG whilst also saving memory then
         * use the new LoadMusicOGG commands.
         *
         * @param iID       - The sound number to store the sound.
         * @param sFilename - The filename of the sound file to load, must be a OGG
         *                  file.
         * @return void
         */
        @Signature
        public native void LoadSoundOGG(int iID, String sFilename);

        /**
         * Loads a sound file from the application media folder. File paths must be
         * relative, not absolute, you cannot load sound files from elsewhere on the
         * disk. This command takes a compressed OGG file and decompresses it during
         * loading, allowing you to save file size, but memory usage will be the same as
         * if you used a WAV file. If you want to use OGG whilst also saving memory then
         * use the new LoadMusicOGG commands.
         *
         * @param sFilename - The filename of the sound file to load, must be a OGG
         *                  file.
         * @return int
         */
        @Signature
        public native int LoadSoundOGG(String sFilename);

        /**
         * Loads a sound file from the application media folder and returns the sound
         * number. File paths must be relative, not absolute, you cannot load sound
         * files from elsewhere on the disk. Please note that compressed WAV files are
         * not supported. You must use uncompressed WAV files to ensure compatibility on
         * all platforms.
         *
         * @param sFilename - The filename of the sound file to load, must be a WAV
         *                  file.
         * @return int
         */
        @Signature
        public native int LoadSound(String sFilename);

        /**
         * Loads a sound file from the application media folder and returns the sound
         * number. File paths must be relative, not absolute, you cannot load sound
         * files from elsewhere on the disk. Please note that compressed WAV files are
         * not supported. You must use uncompressed WAV files to ensure compatibility on
         * all platforms.
         *
         * @param iID       - The sound number to store the sound.
         * @param sFilename - The filename of the sound file to load, must be a WAV
         *                  file.
         * @return void
         */
        @Signature
        public native void LoadSound(int iID, String sFilename);

        /**
         * Loads a Spriter animation exported in the JSON format. Please see the guide
         * section for details on what is supported. Returns an ID to use to reference
         * this skeleton. The atlas image parameter is not yet supported and must be 0,
         * the images will be loaded from the paths specified in the Spriter JSON file.
         * You can use the scale value to change the size of the sprites and bones to
         * match your chosen resolution. A value of 1 will not change the sizes, a value
         * of 2 will make everything twice as big, a value of 0.5 will half the size,
         * and so on.
         *
         * @param filename   - Name of the file to load, should be the .json export from
         *                   Spine
         * @param scale      - The amount to scale the object sizes
         * @param atlasImage - reserved, must be 0
         * @return int
         */
        @Signature
        public native int LoadSkeleton2DFromSpriterFile(String filename, float scale, int atlasImage);

        /**
         * Loads a Spriter animation exported in the JSON format. Please see the guide
         * section for details on what is supported. Returns an ID to use to reference
         * this skeleton. The atlas image parameter is not yet supported and must be 0,
         * the images will be loaded from the paths specified in the Spriter JSON file.
         * You can use the scale value to change the size of the sprites and bones to
         * match your chosen resolution. A value of 1 will not change the sizes, a value
         * of 2 will make everything twice as big, a value of 0.5 will half the size,
         * and so on.
         *
         * @param iSkeleton  - ID to use for this skeleton
         * @param filename   - Name of the file to load, should be the .json export from
         *                   Spine
         * @param scale      - The amount to scale the object sizes
         * @param atlasImage - reserved, must be 0
         * @return void
         */
        @Signature
        public native void LoadSkeleton2DFromSpriterFile(int iSkeleton, String filename, float scale, int atlasImage);

        /**
         * Loads a Spine animation exported in the JSON format. Please see the guide
         * section for details on what is supported. Returns an ID to use to reference
         * this skeleton. You must first load the atlas image exported by Spine into an
         * AGK image with the normal LoadImage command and pass it into this function.
         * You can choose to load animations as well, or just the sprites and bones and
         * move or modify them manually. You can use the scale value to change the size
         * of the sprites and bones to match your chosen resolution. A value of 1 will
         * not change the sizes, a value of 2 will make everything twice as big, a value
         * of 0.5 will half the size, and so on.
         *
         * @param filename   - Name of the file to load, should be the .json export from
         *                   Spine
         * @param scale      - The amount to scale the object sizes
         * @param atlasImage - ID of the atlas image containing all the images
         * @param loadAnim   - 1 to load animation, 0 to only load sprites and bones
         * @return int
         */
        @Signature
        public native int LoadSkeleton2DFromSpineFile(String filename, float scale, int atlasImage, int loadAnim);

        /**
         * Loads a Spine animation exported in the JSON format. Please see the guide
         * section for details on what is supported. Returns an ID to use to reference
         * this skeleton. You must first load the atlas image exported by Spine into an
         * AGK image with the normal LoadImage command and pass it into this function.
         * You can choose to load animations as well, or just the sprites and bones and
         * move or modify them manually. You can use the scale value to change the size
         * of the sprites and bones to match your chosen resolution. A value of 1 will
         * not change the sizes, a value of 2 will make everything twice as big, a value
         * of 0.5 will half the size, and so on.
         *
         * @param iSkeleton  - ID to use for this skeleton
         * @param filename   - Name of the file to load, should be the .json export from
         *                   Spine
         * @param scale      - The amount to scale the object sizes
         * @param atlasImage - ID of the atlas image containing all the images
         * @param loadAnim   - 1 to load animation, 0 to only load sprites and bones
         * @return void
         */
        @Signature
        public native void LoadSkeleton2DFromSpineFile(int iSkeleton, String filename, float scale, int atlasImage,
                        int loadAnim);

        /**
         * Loads a shader used for drawing objects. The vertex shader transforms the
         * polygons into screen space and the pixel shader determines the final color of
         * each pixel the object covers. Currently shaders default to GLSL version 1.10,
         * the line "#version 110" will be automatically added as the first line of the
         * shader unless you specify a "#version " line of your own. Note that doing
         * this may mean your shader does not work on all devices and platforms. The
         * global "precision" value will be added and should not be included in the
         * shader source.
         *
         * @param shaderID       - An ID used to reference this shader in other
         *                       commands.
         * @param szVertexSource - The file name of the vertex shader file, normally
         *                       ending .vs
         * @param szPixelSource  - The file name of the pixel shader file, normally
         *                       ending .ps
         * @return void
         */
        @Signature
        public native void LoadShaderFromString(int shaderID, String szVertexSource, String szPixelSource);

        /**
         * Loads a shader used for drawing objects. The vertex shader transforms the
         * polygons into screen space and the pixel shader determines the final color of
         * each pixel the object covers. Currently shaders default to GLSL version 1.10,
         * the line "#version 110" will be automatically added as the first line of the
         * shader unless you specify a "#version " line of your own. Note that doing
         * this may mean your shader does not work on all devices and platforms. The
         * global "precision" value will be added and should not be included in the
         * shader source.
         *
         * @param szVertexSource - The file name of the vertex shader file, normally
         *                       ending .vs
         * @param szPixelSource  - The file name of the pixel shader file, normally
         *                       ending .ps
         * @return int
         */
        @Signature
        public native int LoadShaderFromString(String szVertexSource, String szPixelSource);

        /**
         * Loads a shader used for drawing objects. The vertex shader transforms the
         * polygons into screen space and the pixel shader determines the final color of
         * each pixel the object covers. Currently shaders default to GLSL version 1.10,
         * the line "#version 110" will be automatically added as the first line of the
         * shader unless you specify a "#version " line of your own. Note that doing
         * this may mean your shader does not work on all devices and platforms. The
         * global "precision" value will be added and should not be included in the
         * shader source.
         *
         * @param shaderID     - An ID used to reference this shader in other commands.
         * @param szVertexFile - The file name of the vertex shader file, normally
         *                     ending .vs
         * @param szPixelFile  - The file name of the pixel shader file, normally ending
         *                     .ps
         * @return void
         */
        @Signature
        public native void LoadShader(int shaderID, String szVertexFile, String szPixelFile);

        /**
         * Loads a shader used for drawing objects. The vertex shader transforms the
         * polygons into screen space and the pixel shader determines the final color of
         * each pixel the object covers. Currently shaders default to GLSL version 1.10,
         * the line "#version 110" will be automatically added as the first line of the
         * shader unless you specify a "#version " line of your own. Note that doing
         * this may mean your shader does not work on all devices and platforms. The
         * global "precision" value will be added and should not be included in the
         * shader source.
         *
         * @param szVertexFile - The file name of the vertex shader file, normally
         *                     ending .vs
         * @param szPixelFile  - The file name of the pixel shader file, normally ending
         *                     .ps
         * @return int
         */
        @Signature
        public native int LoadShader(String szVertexFile, String szPixelFile);

        /**
         * Loads an object from a file, currently supported formats are .X .FBX .dae
         * (collada) .3ds .md3 .smd .md5 .lwo .ac .b3d .dae .3d .lws .ms3d .blend .obj
         * and .ago. If the model file contains a bone hierarchy or animation data then
         * this will also be loaded and associated with the object. Note that objects
         * with more than 50 bones may fail to render on some old devices. AGK has a
         * limit of 200 bones. If the model file contains a scene graph containing
         * multiple objects then these will also be loaded and stored in separate
         * objects which can be discovered with GetObjectNumChildren. If you just want
         * to load a single object without any bones, animation, or children then use
         * LoadObject instead. Returns an ID you can use to reference this object in
         * other commands.
         *
         * @param szFilename - The name of the object file to load.
         * @return int
         */
        @Signature
        public native int LoadObjectWithChildren(String szFilename);

        /**
         * Loads an object from a file, currently supported formats are .X .FBX .dae
         * (collada) .3ds .md3 .smd .md5 .lwo .ac .b3d .dae .3d .lws .ms3d .blend .obj
         * and .ago. If the model file contains a bone hierarchy or animation data then
         * this will also be loaded and associated with the object. Note that objects
         * with more than 50 bones may fail to render on some old devices. AGK has a
         * limit of 200 bones. If the model file contains a scene graph containing
         * multiple objects then these will also be loaded and stored in separate
         * objects which can be discovered with GetObjectNumChildren. If you just want
         * to load a single object without any bones, animation, or children then use
         * LoadObject instead. Returns an ID you can use to reference this object in
         * other commands.
         *
         * @param objID      - The ID to use for the new object.
         * @param szFilename - The name of the object file to load.
         * @return void
         */
        @Signature
        public native void LoadObjectWithChildren(int objID, String szFilename);

        /**
         * loads a collision shape from a .bcs (Bullet Collision Shape) file and sets it
         * to the object. Returns true if succeeded.
         *
         * @param objID    - object ID
         * @param fileName - file name
         * @return int
         */
        @Signature
        public native int LoadObjectShape(int objID, String fileName);

        /**
         * Loads an object from a file, currently supported formats are .X .3ds .md3
         * .smd .md5 .lwo. .ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj and .ago. This
         * command will not load any animation or bone data and will consolidate the
         * vertices into a single object with as few meshes as possible. To load
         * animation and bone data use LoadObjectWithChildren instead.
         *
         * @param objID      - The ID to use for the new object.
         * @param szFilename - The name of the object file to load.
         * @return void
         */
        // НЕ работает @Signature
        public native void LoadObject(int objID, String szFilename);

        /**
         * Loads an object from a file, currently supported formats are .X .3ds .md3
         * .smd .md5 .lwo. .ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj and .ago. This
         * command will not load any animation or bone data and will consolidate the
         * vertices into a single object with as few meshes as possible. To load
         * animation and bone data use LoadObjectWithChildren instead.
         *
         * @param szFilename - The name of the object file to load.
         * @param height     - Scale the loaded object to this height.
         * @return int
         */
        @Signature
        public native int LoadObject(String szFilename, float height);

        /**
         * Loads an object from a file, currently supported formats are .X .3ds .md3
         * .smd .md5 .lwo. .ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj and .ago. This
         * command will not load any animation or bone data and will consolidate the
         * vertices into a single object with as few meshes as possible. To load
         * animation and bone data use LoadObjectWithChildren instead.
         *
         * @param objID      - The ID to use for the new object.
         * @param szFilename - The name of the object file to load.
         * @param height     - Scale the loaded object to this height.
         * @return void
         */
        @Signature

        public native void LoadObject(int objID, String szFilename, float height);

        /**
         * Loads an object from a file, currently supported formats are .X .3ds .md3
         * .smd .md5 .lwo. .ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj and .ago. This
         * command will not load any animation or bone data and will consolidate the
         * vertices into a single object with as few meshes as possible. To load
         * animation and bone data use LoadObjectWithChildren instead.
         *
         * @param szFilename - The name of the object file to load.
         * @return int
         */
        @Signature
        public native int LoadObject(String szFilename);

        /**
         * Loads a music file compressed with OGG Vorbis. This is supported on all
         * platforms as is the new preferred way of playing music, replacing the
         * LoadMusic command. Multiple OGG music files can be played at the same time.
         * OGG music file IDs are separate from normal music file IDs and are not
         * limited to a specific range of numbers.
         *
         * @param musicID - The ID to use to refer to this music file.
         * @param sFile   - The filename of the music file to load.
         * @return void
         */
        @Signature
        public native void LoadMusicOGG(int musicID, String sFile);

        /**
         * Loads a music file compressed with OGG Vorbis. This is supported on all
         * platforms as is the new preferred way of playing music, replacing the
         * LoadMusic command. Multiple OGG music files can be played at the same time.
         * OGG music file IDs are separate from normal music file IDs and are not
         * limited to a specific range of numbers.
         *
         * @param sFile - The filename of the music file to load.
         * @return int
         */
        @Signature
        public native int LoadMusicOGG(String sFile);

        /**
         * Loads an image, resizing it in the process. This allows you to have one high
         * quality image and then resize it based on the device resolution at runtime,
         * instead of having multiple levels of quality. Reducing the image size is
         * preferred to increasing the image size as increasing the image size doesn't
         * improve the quality, but both are supported. A value of 1.0 does not change
         * the image size, a value less than 1 will make the image smaller, a value
         * greater than 1 will make the image bigger. Scaling values must be greater
         * than 0, but can be any fraction, i.e. a scale of 0.6742 would be valid. A
         * scale of 0.5 would halve the image size, 2.0 would double to image size, and
         * so on. The image can be resized differently in the X and Y directions,
         * although this will cause stretching. If you load an atlas texture using this
         * command then the subimages.txt file will also have its values resized so that
         * LoadSubImage will still work correctly. The cache parameter is no longer used
         * as the image scaling is now done by the GPU so has almost no impact on
         * performance
         *
         * @param szFilename - The name of the file to load
         * @param scaleX     - The amount to scale in the X direction, 1.0 is the
         *                   original size
         * @param scaleY     - The amount to scale in the Y direction, 1.0 is the
         *                   original size
         * @param cache      - No longer used, must be 0
         * @return int
         */
        @Signature
        public native int LoadImageResized(String szFilename, float scaleX, float scaleY, int cache);

        /**
         * Loads an image, resizing it in the process. This allows you to have one high
         * quality image and then resize it based on the device resolution at runtime,
         * instead of having multiple levels of quality. Reducing the image size is
         * preferred to increasing the image size as increasing the image size doesn't
         * improve the quality, but both are supported. A value of 1.0 does not change
         * the image size, a value less than 1 will make the image smaller, a value
         * greater than 1 will make the image bigger. Scaling values must be greater
         * than 0, but can be any fraction, i.e. a scale of 0.6742 would be valid. A
         * scale of 0.5 would halve the image size, 2.0 would double to image size, and
         * so on. The image can be resized differently in the X and Y directions,
         * although this will cause stretching. If you load an atlas texture using this
         * command then the subimages.txt file will also have its values resized so that
         * LoadSubImage will still work correctly. The cache parameter is no longer used
         * as the image scaling is now done by the GPU so has almost no impact on
         * performance
         *
         * @param iImageID   - The ID to use to reference this image in future
         * @param szFilename - The name of the file to load
         * @param scaleX     - The amount to scale in the X direction, 1.0 is the
         *                   original size
         * @param scaleY     - The amount to scale in the Y direction, 1.0 is the
         *                   original size
         * @param cache      - No longer used, must be 0
         * @return void
         */
        @Signature
        public native void LoadImageResized(int iImageID, String szFilename, float scaleX, float scaleY, int cache);

        /**
         * Loads a shader used for modifying render targets, as such it only contains a
         * pixel shader, the vertex shader is automatically generated to make sure it
         * applies to the full screen. This type of shader should only be applied to
         * objects created with CreateObjectQuad but nothing bad will happen if you
         * choose to apply it to other objects, it will just produce unusual rendering
         * results for that object. Currently shaders default to GLSL version 1.10, the
         * line "#version 110" will be automatically added as the first line of the
         * shader unless you specify a "#version " line of your own. Note that doing
         * this may mean your shader does not work on all devices and platforms. The
         * global "precision" value will be added and should not be included in the
         * shader source. Returns an ID that can be used to reference this shader in
         * other commands. IDs are shared across all shader types so loading a full
         * screen shader into ID 1 will not work if a normal shader exists with ID 1.
         *
         * @param szPixelFile - The file name of the pixel shader file, normally ending
         *                    .ps
         * @return int
         */
        @Signature
        public native int LoadFullScreenShader(String szPixelFile);

        /**
         * Loads a shader used for modifying render targets, as such it only contains a
         * pixel shader, the vertex shader is automatically generated to make sure it
         * applies to the full screen. This type of shader should only be applied to
         * objects created with CreateObjectQuad but nothing bad will happen if you
         * choose to apply it to other objects, it will just produce unusual rendering
         * results for that object. Currently shaders default to GLSL version 1.10, the
         * line "#version 110" will be automatically added as the first line of the
         * shader unless you specify a "#version " line of your own. Note that doing
         * this may mean your shader does not work on all devices and platforms. The
         * global "precision" value will be added and should not be included in the
         * shader source. Returns an ID that can be used to reference this shader in
         * other commands. IDs are shared across all shader types so loading a full
         * screen shader into ID 1 will not work if a normal shader exists with ID 1.
         *
         * @param shaderID    - An ID used to reference this shader in other commands.
         * @param szPixelFile - The file name of the pixel shader file, normally ending
         *                    .ps
         * @return void
         */
        @Signature
        public native void LoadFullScreenShader(int shaderID, String szPixelFile);

        /**
         * Loads a font file into AGK, typically in the TrueType format, but anything
         * supported by FreeType should work. The szFontFile parameter can either be a
         * font file located in your media folder or the name of a system font, this
         * command will check your media folder first before checking for system fonts.
         * If loading a system font then the file extension is optional, for example
         * "Arial.ttf" and "Arial" would both load the system font "Arial" if it exists.
         * When loading a system font the filename must not have any folder paths in the
         * filename, i.e. no forward or backward slashes. To improve performance you
         * should only load a font once. For example if you wanted to use the "Arial"
         * font in multiple places then you should load it into an ID then use that ID
         * for all uses, rather than loading multiple copies of the Arial font file into
         * separate IDs.
         *
         * @param iFontID    - The ID to use to reference this font in future
         * @param szFontFile - The filename of the font to load
         * @return void
         */
        @Signature
        public native void LoadFont(int iFontID, String szFontFile);

        /**
         * Loads a font file into AGK, typically in the TrueType format, but anything
         * supported by FreeType should work. The szFontFile parameter can either be a
         * font file located in your media folder or the name of a system font, this
         * command will check your media folder first before checking for system fonts.
         * If loading a system font then the file extension is optional, for example
         * "Arial.ttf" and "Arial" would both load the system font "Arial" if it exists.
         * When loading a system font the filename must not have any folder paths in the
         * filename, i.e. no forward or backward slashes. To improve performance you
         * should only load a font once. For example if you wanted to use the "Arial"
         * font in multiple places then you should load it into an ID then use that ID
         * for all uses, rather than loading multiple copies of the Arial font file into
         * separate IDs.
         *
         * @param szFontFile - The filename of the font to load
         * @return int
         */
        @Signature
        public native int LoadFont(String szFontFile);

        /**
         * Loads the current user consent status from the AdMob server, this must be
         * done before calling RequestConsentAdMob. You should wait for
         * GetConsentStatusAdMob to return a non-negative value before using the other
         * AdMob consent commands.
         *
         * @param szPubID       - The publisher ID for you AdMob account
         * @param privacyPolicy - A URL to your privacy policy, this will be shown to
         *                      the user as a link on the consent dialog
         * @return void
         */
        @Signature
        public native void LoadConsentStatusAdMob(String szPubID, String privacyPolicy);

        /**
         * Loads an image from a file into a specified image ID, can also be used to
         * load an atlas texture that will be used by sub images. If loading an atlas
         * texture a subimages.txt file must exist detailing all the images contained on
         * it. Image width and height must be between 1 and 2048 pixels, some devices
         * may support larger sizes but this is not guaranteed. Images do not need to be
         * a power of 2 in size (2,4,8,16,32,etc). If you have lots of small images you
         * could combine them into an atlas texture to improve performance.
         *
         * @param ID             - The ID to use to reference this image later.
         * @param sImageFilename - The filename of the image to load.
         * @param bBlackToAlpha  - Set to 1 to override the image's alpha channel to be
         *                       transparent where there are black pixels and opaque
         *                       otherwise (default 0)
         * @return void
         */
        @Signature
        public native void LoadImage(int ID, String sImageFilename, int bBlackToAlpha);

        /**
         * Loads an image from a file into a specified image ID, can also be used to
         * load an atlas texture that will be used by sub images. If loading an atlas
         * texture a subimages.txt file must exist detailing all the images contained on
         * it. Image width and height must be between 1 and 2048 pixels, some devices
         * may support larger sizes but this is not guaranteed. Images do not need to be
         * a power of 2 in size (2,4,8,16,32,etc). If you have lots of small images you
         * could combine them into an atlas texture to improve performance.
         *
         * @param sImageFilename - The filename of the image to load.
         * @param bBlackToAlpha  - Set to 1 to override the image's alpha channel to be
         *                       transparent where there are black pixels and opaque
         *                       otherwise (default 0)
         * @return int
         */
        @Signature
        public native int LoadImage(String sImageFilename, int bBlackToAlpha);

        /**
         * Loads an image from a file into a specified image ID, can also be used to
         * load an atlas texture that will be used by sub images. If loading an atlas
         * texture a subimages.txt file must exist detailing all the images contained on
         * it. Image width and height must be between 1 and 2048 pixels, some devices
         * may support larger sizes but this is not guaranteed. Images do not need to be
         * a power of 2 in size (2,4,8,16,32,etc). If you have lots of small images you
         * could combine them into an atlas texture to improve performance.
         *
         * @param sImageFilename - The filename of the image to load.
         * @return int
         */
        @Signature
        public native int LoadImage(String sImageFilename);

        /**
         * Loads an image from a file into a specified image ID, can also be used to
         * load an atlas texture that will be used by sub images. If loading an atlas
         * texture a subimages.txt file must exist detailing all the images contained on
         * it. Image width and height must be between 1 and 2048 pixels, some devices
         * may support larger sizes but this is not guaranteed. Images do not need to be
         * a power of 2 in size (2,4,8,16,32,etc). If you have lots of small images you
         * could combine them into an atlas texture to improve performance.
         *
         * @param ID             - The ID to use to reference this image later.
         * @param sImageFilename - The filename of the image to load.
         * @return void
         */
        // НЕ РАБОТАЕТ@Signature
        public native void LoadImage(int ID, String sImageFilename);

        /**
         * Loads a sub image from an atlas texture for use as a standalone image into a
         * specified image ID. The subimages.txt file should start with the same name as
         * the image file, for example an atlas image MyImage.png would have a subimages
         * file named "MyImage subimages.txt". The subimages file contains a series of
         * rows each describing an image that exists within the atlas image. Each line
         * must have the format Name:X:Y:Width:Height with the delimiter : used between
         * the fields. The Name field is the name you want to used to reference the sub
         * image when loading, this should match the sImageFilename parameter of this
         * LoadSubImage command. The X:Y fields are the X and Y pixel coordinates that
         * represent the top left corner of the subimage, and the Width:Height fields
         * are the size in pixels of the sub image. These values are then used to
         * extract your named image from the atlas and load it into its own image ID to
         * be used as if it were a normal image. The atlas image must remain loaded for
         * the entire time you are using the loaded sub image. Note that when loading a
         * sub image AGK will modify the UV coordinates slightly so that the image does
         * not steal pixels from neighboring images during filtering, by default it
         * shifts the UV inwards by 0.5 pixels. You can override this by setting
         * SetSpriteUVBorder to 0 for sprites where you need pixel perfect results, but
         * you will have to watch out for pixel bleeding around the edges, and may need
         * to give your sub images a 1 pixel border of an appropriate color that it can
         * safely steal from when filtering.
         *
         * @param iParentIndex   - The image ID that holds the atlas texture, loaded
         *                       previously.
         * @param sImageFilename - The filename of the sub image as stored in
         *                       subimages.txt. Do not use a path before the filename.
         * @return int
         */
        @Signature
        public native int LoadSubImage(int iParentIndex, String sImageFilename);

        /**
         * Loads a sub image from an atlas texture for use as a standalone image into a
         * specified image ID. The subimages.txt file should start with the same name as
         * the image file, for example an atlas image MyImage.png would have a subimages
         * file named "MyImage subimages.txt". The subimages file contains a series of
         * rows each describing an image that exists within the atlas image. Each line
         * must have the format Name:X:Y:Width:Height with the delimiter : used between
         * the fields. The Name field is the name you want to used to reference the sub
         * image when loading, this should match the sImageFilename parameter of this
         * LoadSubImage command. The X:Y fields are the X and Y pixel coordinates that
         * represent the top left corner of the subimage, and the Width:Height fields
         * are the size in pixels of the sub image. These values are then used to
         * extract your named image from the atlas and load it into its own image ID to
         * be used as if it were a normal image. The atlas image must remain loaded for
         * the entire time you are using the loaded sub image. Note that when loading a
         * sub image AGK will modify the UV coordinates slightly so that the image does
         * not steal pixels from neighboring images during filtering, by default it
         * shifts the UV inwards by 0.5 pixels. You can override this by setting
         * SetSpriteUVBorder to 0 for sprites where you need pixel perfect results, but
         * you will have to watch out for pixel bleeding around the edges, and may need
         * to give your sub images a 1 pixel border of an appropriate color that it can
         * safely steal from when filtering.
         *
         * @param iImageIndex    - The image ID to use to reference this image later.
         * @param iParentIndex   - The image ID that holds the atlas texture, loaded
         *                       previously.
         * @param sImageFilename - The filename of the sub image as stored in
         *                       subimages.txt. Do not use a path before the filename.
         * @return void
         */
        @Signature
        public native void LoadSubImage(int iImageIndex, int iParentIndex, String sImageFilename);

        /**
         * Returns the number of characters in the given string. Note that for strings
         * encoded in UTF-8 this may not be equal to the number of bytes in the string,
         * as each character can use up to 4 bytes. To determine the length in bytes use
         * the ByteLen command.
         *
         * @param strin - The string to measure the length of
         * @return int
         */
        @Signature
        public native int Len(String strin);

        /**
         * Crops the given string retaining the left most number of characters up to the
         * specified count value.
         *
         * @param strin - The string to be cropped
         * @param count - The number of characters to retain
         * @return String
         */
        @Signature
        public native String Left(String strin, int count);

        /**
         * Kicks a client from the network. This does not happen immediately and the
         * client may remain for a few frames before it is finally kicked. The client
         * will disconnect in the normal way, you must check
         * GetNetworkClientDisconnected to detect when the client has been kicked, and
         * then call DeleteNetworkClient to finally get rid of it.
         *
         * @param iNetID - The ID of the network.
         * @param client - the ID of the client to kick.
         * @return void
         */
        @Signature
        public native void KickNetworkClient(int iNetID, int client);

        /**
         * Loads a variable that was saved by this app, or another app. This only works
         * on iOS, Android 10 and below, and HTML5 platforms. Apps can only share a
         * variable if they meet certain requirements based on the platform. On iOS the
         * apps must have the same Bundle Seed ID (also called App ID Prefix) and have
         * the same explicit App ID up to the last dot. For example
         * com.mycompany.mygroup.myapp1 and com.mycompany.mygroup.myapp2 would be able
         * to share variables. On Android 10 and below the apps must have the
         * WRITE_EXTERNAL_STORAGE permission and have the same package name up to the
         * last dot. For example com.mycompany.mygroup.myapp1 and
         * com.mycompany.mygroup.myapp2 would be able to share variables. On Android
         * shared variables are written to a user accessible location, so be aware that
         * users may be able to read and/or edit the variables that you save. On Android
         * 11 or higher this command will not work as apps are restricted from writing
         * to shared locations. On HTML the apps must be hosted on the same domain, the
         * values are stored as cookies. Variables are identified by name, so using
         * SaveSharedVariable("username", "Alice") will set the variable called
         * "username" to the value "Alice". This can then be read by other apps by using
         * LoadSharedVariable( "username", "" ). If a variable with the given name
         * doesn't exist then the specified default value is returned instead
         *
         * @param varName      - The name of the variable to retrieve
         * @param defaultValue - The value to return if the variable doesn't exist
         * @return String
         */
        @Signature
        public native String LoadSharedVariable(String varName, String defaultValue);

        /**
         * Joins two paths together and simplifies them, for example joining a path with
         * ../ will remove the last folder from the path. A forward slash will be added
         * between them if necessary, if the first path ends in a forward slash and the
         * second path starts with a forward slash then one will be removed to make a
         * valid path. Any back slashes will be converted to forward slashes. The first
         * path can be relative or absolute, the second path must be relative. This will
         * not be checked.
         *
         * @param szPath  - The first part of the path
         * @param szPath2 - The second part of the path
         * @return String
         */
        @Signature
        public native String JoinPaths(String szPath, String szPath2);

        /**
         * Joins an AGK network hosted by another app. The network is specified by name,
         * or by IP address and port number. For named networks the app will look for
         * any AGK networks broadcast with that name and connect to it if found.
         * Alternatively using an IP address and port number will attempt a direct
         * connection to the host. In the case of internet connections an IP and port is
         * the only way to connect as broadcasts will not leave the local area network.
         * IP addresses can be IPv4 or IPv6 depending on what IP addresses the host is
         * using (it could have one or more of each). You may detect all the networks
         * available for connecting to by setting up a broadcast listener and listening
         * for the broadcasts yourself, you could then display a list of discovered
         * networks to the user to let them decide which one to connect to. This
         * function does not connect immediately, it returns a network ID and continues
         * to attempt to connect in the background. You can detect when a connection is
         * made by checking the GetNetworkNumClients is greater than 1, indicating that
         * at least the local client and server client have been detected. If
         * IsNetworkActive returns 0 at any time then the connection to the server
         * failed and the network should be closed, you may attempt to reconnect by
         * opening a new network. Once connected the app becomes a client of the
         * network, along with the host and any other clients that have connected to it.
         * All clients are treated equally and have a list of local variables that they
         * can read from and write to, all clients can also read any variables on other
         * clients on a read only basis. You must identify your client with a client
         * name that will be visible to other clients, the client name does not need to
         * be unique. Returns a network ID to use when interacting with this network.
         * Does not work when exported to HTML5
         *
         * @param szIP     - The IP address of the host to connect to, can be IPv4 or
         *                 IPv6
         * @param port     - The port to connect to.
         * @param szMyName - The name to use in identifying this client.
         * @return int
         */
        @Signature
        public native int JoinNetwork(String szIP, int port, String szMyName);

        /**
         * Joins an AGK network hosted by another app. The network is specified by name,
         * or by IP address and port number. For named networks the app will look for
         * any AGK networks broadcast with that name and connect to it if found.
         * Alternatively using an IP address and port number will attempt a direct
         * connection to the host. In the case of internet connections an IP and port is
         * the only way to connect as broadcasts will not leave the local area network.
         * IP addresses can be IPv4 or IPv6 depending on what IP addresses the host is
         * using (it could have one or more of each). You may detect all the networks
         * available for connecting to by setting up a broadcast listener and listening
         * for the broadcasts yourself, you could then display a list of discovered
         * networks to the user to let them decide which one to connect to. This
         * function does not connect immediately, it returns a network ID and continues
         * to attempt to connect in the background. You can detect when a connection is
         * made by checking the GetNetworkNumClients is greater than 1, indicating that
         * at least the local client and server client have been detected. If
         * IsNetworkActive returns 0 at any time then the connection to the server
         * failed and the network should be closed, you may attempt to reconnect by
         * opening a new network. Once connected the app becomes a client of the
         * network, along with the host and any other clients that have connected to it.
         * All clients are treated equally and have a list of local variables that they
         * can read from and write to, all clients can also read any variables on other
         * clients on a read only basis. You must identify your client with a client
         * name that will be visible to other clients, the client name does not need to
         * be unique. Returns a network ID to use when interacting with this network.
         * Does not work when exported to HTML5
         *
         * @param szNetworkName - The name of the network to connect to.
         * @param szMyName      - The name to use in identifying this client.
         * @return int
         */
        @Signature
        public native int JoinNetwork(String szNetworkName, String szMyName);

        /**
         * Loads a music file from the application media folder into a specified ID.
         * File paths must be relative, not absolute, you cannot load music files from
         * elsewhere on the disk. It returns the ID of the music file for referencing it
         * later. The recommended format for cross platform compatibility is MP3. Please
         * note that the Meego platform does not currently support MP3, it will instead
         * attempt to load an OGG Vorbis file. For example, if you attempt to load
         * "music.mp3", on Meego this will be intepreted as "music.ogg". The ID must be
         * in the range 1 to 50.
         *
         * @param iID   - The music number to store the music.
         * @param sFile - The filename of the music file to load.
         * @return void
         */
        @Signature
        public native void LoadMusic(int iID, String sFile);

        /**
         * Loads a music file from the application media folder into a specified ID.
         * File paths must be relative, not absolute, you cannot load music files from
         * elsewhere on the disk. It returns the ID of the music file for referencing it
         * later. The recommended format for cross platform compatibility is MP3. Please
         * note that the Meego platform does not currently support MP3, it will instead
         * attempt to load an OGG Vorbis file. For example, if you attempt to load
         * "music.mp3", on Meego this will be intepreted as "music.ogg". The ID must be
         * in the range 1 to 50.
         *
         * @param sFile - The filename of the music file to load.
         * @return int
         */
        @Signature
        public native int LoadMusic(String sFile);

        /**
         * This command returns 1 if the current device supports using depth images with
         * SetRenderToImage. If this returns 0 then the only valid depth image IDs to
         * SetRenderToImage are 0 for no depth, or -1 for a normal depth buffer.
         *
         * @return int
         */
        @Signature
        public native int IsSupportedDepthTexture();

        /**
         * Returns 1 if Speak has been called and the text has not yet finished. If
         * multiple items of text have been queued up then this command will continue to
         * return 1 until all of them have been spoken, or StopSpeaking is called.
         * Currently only works on iOS and Android.
         *
         * @return int
         */
        @Signature
        public native int IsSpeaking();

        /**
         * Not yet functional.
         *
         * @return int
         */
        @Signature
        public native int IsSoundRecording();

        /**
         * Checks that the network is active, in the case of joining a network this will
         * return 0 if the connection failed or for some reason the connection to the
         * server broke. For a hoster this function will return 0 if it failed to listen
         * on the specified port for clients, otherwise it will forever return 1 as it
         * will not stop managing any connected clients, even if everyone disconnects.
         *
         * @param iNetID - The ID of the network to check.
         * @return int
         */
        @Signature
        public native int IsNetworkActive(int iNetID);

        /**
         * Returns 1 if the screen recording is currently active, 0 if it has stopped.
         * On Android it could have stopped because the app was sent to the background,
         * or another activity such as an In App Purchase was activated.
         *
         * @return int
         */
        @Signature
        public native int IsScreenRecording();

        /**
         * This function has been deprecated, use SetDeviceCameraToImage instead.
         * Returns 1 if AGK is currently displaying a camera feed and waiting for the
         * user to capture an image. When this returns 0 the user has either cancelled
         * or captured an image, check GetCapturedImage to see what the result was.
         *
         * @return int
         */
        @Signature
        public native int IsCapturingImage();

        /**
         * Returns 1 if the given path is absolute, 0 if it is relative. This varies by
         * platform, so a path beginning "C:/" is consider absolute on Windows but not
         * on Linux, whilst a path beginning with a forward slash is considered absolute
         * on Linux but not on Windows. The path may begin with the prefix "raw:" or
         * not, both are accepted.
         *
         * @param szPath - The path to check
         * @return int
         */
        @Signature
        public native int IsAbsolutePath(String szPath);

        /**
         * Returns a 1 if the Ragdoll is static.
         *
         * @param objID - object ID
         * @return int
         */
        @Signature
        public native int Is3dPhysicsRagdollStatic(int objID);

        /**
         * Copies an object into a new ID, the new object shares vertex data with the
         * original object. The original object must exist for the instanced object to
         * draw properly. Instancing an object that is already an instance will do
         * nothing. Instancing an object and then deleting the original will probably
         * crash. Setting a shader on an instance object is allowed as long as the
         * vertex attributes used by the shader match exactly in name and order as those
         * used on the shader of the original object. Setting different images on the
         * instance and original object is supported.
         *
         * @param objID - The ID of the object to copy.
         * @return int
         */
        @Signature
        public native int InstanceObject(int objID);

        /**
         * Copies an object into a new ID, the new object shares vertex data with the
         * original object. The original object must exist for the instanced object to
         * draw properly. Instancing an object that is already an instance will do
         * nothing. Instancing an object and then deleting the original will probably
         * crash. Setting a shader on an instance object is allowed as long as the
         * vertex attributes used by the shader match exactly in name and order as those
         * used on the shader of the original object. Setting different images on the
         * instance and original object is supported.
         *
         * @param newobjID - The ID of the new object.
         * @param objID    - The ID of the object to copy.
         * @return void
         */
        @Signature
        public native void InstanceObject(int newobjID, int objID);

        /**
         * Sets any necessary internal data when setting up IAP for this platform.
         * Currently this only applies to Google Play and Ouya where you need to provide
         * your public key in base64. This must be called before InAppPurchaseSetup. To
         * find the public key for Google Play apps, open your application's details in
         * the Google PlayDeveloper Console, and click Services & APIs. The public key
         * will be in the box titled "Your license key for this application".
         *
         * @param szData1 - Public Key
         * @param szData2 - Developer UUID (Ouya only)
         * @return void
         */
        @Signature
        public native void InAppPurchaseSetKeys(String szData1, String szData2);

        /**
         * Restores any managed purchases made on this platform. For example if a user
         * purchased at item then reinstalled the app the app would return 0 for
         * GetInAppPurchaseAvailable unless it was purchased again. Even though this
         * wouldn't charge the user again for managed items, Apple require you to have a
         * button that calls this function instead of making the user go through the
         * purchase process again. After calling this command you can call
         * GetInAppPurchaseAvailable. Currently this command is only supported on iOS.
         * This command is unnecessary on Android and Amazon as it automatically
         * restores in InAppPurchaseSetup
         *
         * @return void
         */
        @Signature
        public native void InAppPurchaseRestore();

        /**
         * After setting the in app purchase title and adding product IDs call
         * InAppPurchaseSetup to finalise the process. After this point you can attempt
         * to purchase unlockable content. Currently this command is only supported on
         * iOS and Android.
         *
         * @return void
         */
        @Signature
        public native void InAppPurchaseSetup();

        /**
         * Sets the name of your application so that it can be displayed on any dialogs
         * that get displayed when using the in app purchase commands. Currently this
         * command is only supported on iOS and Android.
         *
         * @param szTitle - Name of your application
         * @return void
         */
        @Signature
        public native void InAppPurchaseSetTitle(String szTitle);

        /**
         * Call this when you want to start the process of activating / unlocking extra
         * content. Currently this command is only supported on iOS and Android.
         *
         * @param iID - this ID corresponds to the product IDs that have been added e.g.
         *            your first product
         * @return void
         */
        @Signature
        public native void InAppPurchaseActivate(int iID);

        /**
         * Creates an AGK network with this app as the controller, this app is added as
         * the first client to the network. AGK networks are identified by name and are
         * automatically broadcast to anyone listening on the local area network,
         * meaning that other AGK apps on the LAN can pick up all broadcast networks,
         * display their names to their users and allow them to choose one to join. AGK
         * apps outside the LAN need the IP address and port of the hoster to join the
         * network, this port will need forwarding to the host through any intervening
         * firewall. The port value must be between 1025 and 65535, and will fail if
         * another application is already listening on that port. You must also specify
         * a client name to use to identify your client, all client names must be
         * unique. This name will be visible to all other clients. Clients will be added
         * to the network automatically and can be counted using GetNetworkNumClients.
         * You can call IsNetworkActive immediately after this command to check that the
         * network was setup successfully, once setup the network will not become
         * inactive for a hoster. Once connected the app becomes a client of the
         * network, any other clients that connect to it join the network. All clients
         * are treated equally and have a list of local variables that they can read
         * from and write to, all clients can also read any variables on other clients
         * on a read only basis. Some ports are used by AGK for internal networking and
         * should not be used by your application. Ports 5689-5692 are used to manage
         * apps broadcast from the IDE. Ports 45631 and 45632 are used for named network
         * connections. On IPv4 networks the network broadcast goes to all devices on
         * the local subnet, on IPv6 networks the broadcast goes to the AGK multicast
         * address "FF02::41:474B". If the device has both IPv4 and IPv6 IP addresses
         * then HostNetwork will accept connections from both IPv4 and IPv6 networks. If
         * you specify 0 for the port then it will disable IPv4 connections, if you set
         * portv6 to 0 then it will disable IPv6 connections. At least one must be
         * greater than 0 or an error will be generated. If you do not specify portv6 at
         * all then it will be set to 0. It should be safe to use the same port for both
         * IPv4 and IPv6, but this hasn't been widely tested. Returns an ID you can use
         * to interact with this network. Does not work when exported to HTML5
         *
         * @param szNetworkName - The name to use in identifying this network.
         * @param szMyName      - The name to use in identifying this client.
         * @param port          - The port that other clients should use to connect to
         *                      this network when using IPv4, 0 to disable IPv4
         *                      connections.
         * @param portv6        - The port that other clients should use to connect to
         *                      this network when using IPv6, 0 to disable IPv6
         *                      connections.
         * @return int
         */
        @Signature
        public native int HostNetwork(String szNetworkName, String szMyName, int port, int portv6);

        /**
         * Creates an AGK network with this app as the controller, this app is added as
         * the first client to the network. AGK networks are identified by name and are
         * automatically broadcast to anyone listening on the local area network,
         * meaning that other AGK apps on the LAN can pick up all broadcast networks,
         * display their names to their users and allow them to choose one to join. AGK
         * apps outside the LAN need the IP address and port of the hoster to join the
         * network, this port will need forwarding to the host through any intervening
         * firewall. The port value must be between 1025 and 65535, and will fail if
         * another application is already listening on that port. You must also specify
         * a client name to use to identify your client, all client names must be
         * unique. This name will be visible to all other clients. Clients will be added
         * to the network automatically and can be counted using GetNetworkNumClients.
         * You can call IsNetworkActive immediately after this command to check that the
         * network was setup successfully, once setup the network will not become
         * inactive for a hoster. Once connected the app becomes a client of the
         * network, any other clients that connect to it join the network. All clients
         * are treated equally and have a list of local variables that they can read
         * from and write to, all clients can also read any variables on other clients
         * on a read only basis. Some ports are used by AGK for internal networking and
         * should not be used by your application. Ports 5689-5692 are used to manage
         * apps broadcast from the IDE. Ports 45631 and 45632 are used for named network
         * connections. On IPv4 networks the network broadcast goes to all devices on
         * the local subnet, on IPv6 networks the broadcast goes to the AGK multicast
         * address "FF02::41:474B". If the device has both IPv4 and IPv6 IP addresses
         * then HostNetwork will accept connections from both IPv4 and IPv6 networks. If
         * you specify 0 for the port then it will disable IPv4 connections, if you set
         * portv6 to 0 then it will disable IPv6 connections. At least one must be
         * greater than 0 or an error will be generated. If you do not specify portv6 at
         * all then it will be set to 0. It should be safe to use the same port for both
         * IPv4 and IPv6, but this hasn't been widely tested. Returns an ID you can use
         * to interact with this network. Does not work when exported to HTML5
         *
         * @param szNetworkName - The name to use in identifying this network.
         * @param szMyName      - The name to use in identifying this client.
         * @param port          - The port that other clients should use to connect to
         *                      this network when using IPv4, 0 to disable IPv4
         *                      connections.
         * @return int
         */
        @Signature
        public native int HostNetwork(String szNetworkName, String szMyName, int port);

        /**
         * Moves the controller up to the jump height.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void Jump3DPhysicsCharacterController(int objID);

        /**
         * Converts a Hex string to a Base64 string. A hex string is a string containing
         * only the characters 0-9 and A-F. If you are calling this command from tier 2
         * this string must be deleted when you are done with it.
         *
         * @param input - The string to convert
         * @return String
         */
        @Signature
        public native String HexToBase64(String input);

        /**
         * Converts an integer value into a string containing its hexadecimal
         * representation. For example Hex(31) would return a string containing "1F". If
         * you are calling this command from tier 2 this string must be deleted when you
         * are done with it.
         *
         * @param i - Integer value to convert into a hexadecimal string
         * @return String
         */
        @Signature
        public native String Hex(int i);

        /**
         * Encodes a string so that it can be sent to a server via HTTP without
         * interfering with the HTTP request. For example if you wanted to send a POST
         * variable that contained the characters & or = these would look like
         * additional variables inside the string you want to send. Using HTTPEncode on
         * this string would turn these characters into POST safe values which are then
         * automatically converted back to their original characters once they reach
         * something like a PHP script. This uses standard URL encoding for
         * non-alphanumeric characters leaving alphanumeric characters alone.
         *
         * @param str - The string to encode
         * @return String
         */
        @Signature
        public native String HTTPEncode(String str);

        /**
         * Decodes a URL encoded string. It can decode all alphanumeric characters and
         * most non-alphanumeric characters.
         *
         * @param str - The string to decode
         * @return String
         */
        @Signature
        public native String HTTPDecode(String str);

        /**
         * Returns the year of a given unix time value. Unix time is represented as the
         * number of seconds since the 1st Jan 1970, it may also be negative. If not
         * using 64 bit values then the unix time value is limited to 1901 to 2038 for
         * the year.
         *
         * @param unixtime - A unix time value.
         * @return int
         */
        @Signature
        public native int GetYearFromUnix(int unixtime);

        /**
         * Returns the directory that new files will be written to on the current
         * platform that the app is running on.
         *
         * @return String
         */
        @Signature
        public native String GetWritePath();

        /**
         * Returns a value between 0 and 100 to represent the progress of the zip
         * extraction started with ExtractZipASync.
         *
         * @return float
         */
        @Signature
        public native float GetZipExtractProgress();

        /**
         * Returns 0 if a zip extraction started with ExtractZipASync is in progress, or
         * 1 if it has finished. It does not give an indication of if the extraction was
         * successful, only that it has finished.
         *
         * @return int
         */
        @Signature
        public native int GetZipExtractComplete();

        /**
         * Returns 1 if AGK is currently displaying a choose image screen and waiting
         * for the user to pick an image. When this returns 0 the user has either
         * cancelled or chosen an image, check GetChosenImage to see what the result
         * was.
         *
         * @return int
         */
        @Signature
        public native int IsChoosingImage();

        /**
         * Returns the drive letter of the specified drive, between 0 and
         * CountWindowsDrives minus one. Values outside this range will return an empty
         * string. The returned string will include the drive letter and a colon,
         * nothing else. This only applies to Windows, other platforms will return an
         * empty string. If you are calling this command from Tier 2 then you must
         * delete the returned string with agk::DeleteString() when you are done with
         * it.
         *
         * @param index - The index of the drive to return
         * @return String
         */
        @Signature
        public native String GetWindowsDrive(int index);

        /**
         * Converts a point on the sprite to world coordinates. For example if a 10x10
         * sprite was rotated by 45 degrees around its center point (at 5x5) then to
         * find the position in the world of the sprite's top left corner you would call
         * this command with the values -5,-5, since the values are relative to the
         * sprite's center point (defined by SetSpriteOffset). The command is not
         * limited by the size of the sprite, so in the above example values of 20 or
         * -15 would both be valid.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @param x            - The X component of the point on the sprite.
         * @param y            - The Y component of the point on the sprite.
         * @return float
         */
        @Signature
        public native float GetWorldXFromSprite(int iSpriteIndex, float x, float y);

        /**
         * Use this command to add any product IDs into the list e.g.
         * com.yourcompany.yourproduct.iap. The first product ID you add becomes 0, the
         * second is 1 etc. You must also specify the type of product this is,
         * consumable (1) or non-consumable(0). Consumable products are like coins that
         * can be bought again and again, they are called Unmanaged items by Google
         * Play. Non-consumable products are one off purchases like unlocking the full
         * version of an app, they are called managed items by Google Play. Currently
         * this command is only supported on iOS, Google Play, and Amazon. This must be
         * called before InAppPurchaseSetup, after that no further products can be
         * added.
         *
         * @param szID - The product ID as specified in iTunes Connect or the Google
         *             Play developer console
         * @param type - The type of product this is, consumable (1) or non
         *             consumable(0)
         * @return void
         */
        @Signature
        public native void InAppPurchaseAddProductID(String szID, int type);

        /**
         * Returns the width of the current device's window. This value may differ from
         * the GetDeviceWidth if the window size does not match the pixel size of the
         * backbuffer that is being used to draw the window. For example on a Mac with a
         * retina display the window size will be half of the pixel size.
         *
         * @return int
         */
        @Signature
        public native int GetWindowWidth();

        /**
         * Returns the height of the current device's window. This value may differ from
         * the GetDeviceHeight if the window size does not match the pixel size of the
         * backbuffer that is being used to draw the window. For example on a Mac with a
         * retina display the window size will be half of the pixel size.
         *
         * @return int
         */
        @Signature
        public native int GetWindowHeight();

        /**
         * Returns the coordinate for the far right side of the screen. In the default
         * percentage based coordinate system this is 100. If you have set up a virtual
         * resolution using SetVirtualResolution then the width specified here will be
         * returned.
         *
         * @return int
         */
        @Signature
        public native int GetVirtualWidth();

        /**
         * Returns the Y value of the virtual joystick at the given index. This will be
         * in the range -1.0 to 1.0 with 0 being centered. When the user is not
         * interacting with the virtual joystick this will return 0.
         *
         * @param index - The ID of the virtual joystick to check.
         * @return float
         */
        @Signature
        public native float GetVirtualJoystickY(int index);

        /**
         * Converts a point on the sprite to world coordinates. For example if a 10x10
         * sprite was rotated by 45 degrees around its center point (at 5x5) then to
         * find the position in the world of the sprite's top left corner you would call
         * this command with the values -5,-5, since the values are relative to the
         * sprite's center point (defined by SetSpriteOffset). The command is not
         * limited by the size of the sprite, so in the above example values of 20 or
         * -15 would both be valid.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @param x            - The X component of the point on the sprite.
         * @param y            - The Y component of the point on the sprite.
         * @return float
         */
        @Signature
        public native float GetWorldYFromSprite(int iSpriteIndex, float x, float y);

        /**
         * Returns the coordinate for the bottom of the screen. In the default
         * percentage based coordinate system this is 100. If you have set up a virtual
         * resolution using SetVirtualResolution then the height specified here will be
         * returned.
         *
         * @return int
         */
        @Signature
        public native int GetVirtualHeight();

        /**
         * Returns 1 if a virtual joystick exists at the given index. Must be in the
         * range 1 to 4.
         *
         * @param index - The ID of the virtual joystick to check.
         * @return int
         */
        @Signature
        public native int GetVirtualJoystickExists(int index);

        /**
         * Returns 1 if a virtual button is currently down, 0 if it is up. Use
         * GetVirtualButtonPressed or GetVirtualButtonReleased to check for the instance
         * a button is pressed or released.
         *
         * @param index - The ID of the virtual button to check.
         * @return int
         */
        @Signature
        public native int GetVirtualButtonState(int index);

        /**
         * Returns 1 if a virtual button was released this frame, after the initial
         * release this function will return to 0. Use GetVirtualButtonState to check if
         * a virtual button is up or down.
         *
         * @param index - The ID of the virtual button to check.
         * @return int
         */
        @Signature
        public native int GetVirtualButtonReleased(int index);

        /**
         * Returns 1 if a virtual button exists at the given index. 0 otherwise.
         *
         * @param index - The ID of the virtual button to check.
         * @return int
         */
        @Signature
        public native int GetVirtualButtonExists(int index);

        /**
         * Gets the current scroll zoom level, set using SetViewZoom.
         *
         * @return float
         */
        @Signature
        public native float GetViewZoom();

        /**
         * Gets the current view offset in the Y direction, set using SetViewOffset.
         *
         * @return float
         */
        @Signature
        public native float GetViewOffsetY();

        /**
         * Gets the current view offset in the X direction, set using SetViewOffset.
         *
         * @return float
         */
        @Signature
        public native float GetViewOffsetX();

        /**
         * Returns the width in pixels of the currently loaded video, if this returns 0
         * then call it in a loop with Sync() to wait for the video to finish loading
         * the meta data. If it returns less than 0 then this platform does not support
         * this command or an error occurred. example: width = GetVideoWidth() if (
         * width = 0 ) repeat Sync() width = GetVideoWidth() until width != 0 endif
         *
         * @return float
         */
        @Signature
        public native float GetVideoWidth();

        /**
         * Returns the number of seconds played so far.
         *
         * @return float
         */
        @Signature
        public native float GetVideoPosition();

        /**
         * Returns the X value of the virtual joystick at the given index. This will be
         * in the range -1.0 to 1.0 with 0 being centered. When the user is not
         * interacting with the virtual joystick this will return 0.
         *
         * @param index - The ID of the virtual joystick to check.
         * @return float
         */
        @Signature
        public native float GetVirtualJoystickX(int index);

        /**
         * Returns 1 if the video is currently playing, 0 if it has finished or been
         * stopped with StopVideo() or PauseVideo().
         *
         * @return int
         */
        @Signature
        public native int GetVideoPlaying();

        /**
         * Returns the height in pixels of the currently loaded video, if this returns 0
         * then call it in a loop with Sync() to wait for the video to finish loading
         * the meta data. If it returns less than 0 then this platform does not support
         * this command or an error occurred. example: height = GetVideoHeight() if (
         * height = 0 ) repeat Sync() height = GetVideoHeight() until height != 0 endif
         *
         * @return float
         */
        @Signature
        public native float GetVideoHeight();

        /**
         * Returns the number of seconds the video lasts from start to finish. If this
         * returns 0 then call it in a loop with Sync() to wait for the video to finish
         * loading the meta data. If it returns less than 0 then this platform does not
         * support this command or an error occurred. example: duration =
         * GetVideoDuration() if ( duration = 0 ) repeat Sync() duration =
         * GetVideoDuration() until duration != 0 endif
         *
         * @return float
         */
        @Signature
        public native float GetVideoDuration();

        /**
         * Returns the number of vertices processed by the GPU last frame.
         *
         * @return int
         */
        @Signature
        public native int GetVerticesProcessed();

        /**
         * Gets the y from the vector.
         *
         * @param vectorID - id of the vector
         * @return float
         */
        @Signature
        public native float GetVector3Y(int vectorID);

        /**
         * Gets the z from the vector.
         *
         * @param vectorID - id of the vector
         * @return float
         */
        @Signature
        public native float GetVector3Z(int vectorID);

        /**
         * Multiplies the components of the given vector by the given multiplier
         *
         * @param resultVec  - ID of the vector to multiply.
         * @param multiplier - float value to multiply by.
         * @return void
         */
        @Signature
        public native void GetVector3Multiply(int resultVec, float multiplier);

        /**
         * Returns the length of the vector
         *
         * @param vectorID - ID of the vector
         * @return float
         */
        @Signature
        public native float GetVector3Length(int vectorID);

        /**
         * Fills the result vector with the cross product of 2 vectors passed in.
         *
         * @param resultVec - ID of Vector for results
         * @param vectorU   - ID of the first vector
         * @param vectorV   - ID of the second vector
         * @return void
         */
        @Signature
        public native void GetVector3Cross(int resultVec, int vectorU, int vectorV);

        /**
         * Gets the x from the vector.
         *
         * @param vectorID - id of the vector
         * @return float
         */
        @Signature
        public native float GetVector3X(int vectorID);

        /**
         * Fills the resultVec vector with the sum of the resultVec vector and the
         * addVec vector.
         *
         * @param resultVec - ID of the vector to add and hold results.
         * @param addVec    - ID of vector to add.
         * @return void
         */
        @Signature
        public native void GetVector3Add(int resultVec, int addVec);

        /**
         * Returns the number of seconds and fractions of seconds spent updating
         * everything in the world except physics. This includes sprite animation,
         * emulating input, and handling sounds.
         *
         * @return float
         */
        @Signature
        public native float GetUpdateTime();

        /**
         * Returns the distance between the 2 vectors.
         *
         * @param vectorU - ID of the first vector
         * @param vectorV - ID of the second vector
         * @return float
         */
        @Signature
        public native float GetVector3Distance(int vectorU, int vectorV);

        /**
         * Converts a given date and time into its unix time equivalent, unix time is
         * the number of seconds since 1st Jan 1970. If not using 64 bit values then the
         * unix time value is limited to 1901 to 2038 for the year.
         *
         * @param year    - The year portion of the date.
         * @param month   - The month portion of the date, in the range 1 to 12.
         * @param days    - The day portion of the date, in the range 1 to 31.
         * @param hours   - The hours portion of the date, in the range 0 to 23.
         * @param minutes - The minutes portion of the date, in the range 0 to 59.
         * @param seconds - The seconds portion of the date, in the range 0 to 59.
         * @return int
         */
        @Signature
        public native int GetUnixFromDate(int year, int month, int days, int hours, int minutes, int seconds);

        /**
         * Returns the number of images currently loaded into the app but are not
         * assigned to a sprite or text object. This is useful for debugging to check
         * you have deleted all unused images when switching from a menu to a level, or
         * from one level to another.
         *
         * @return int
         */
        @Signature
        public native int GetUnassignedImages();

        /**
         * Returns the filename of the specified unassigned image.
         *
         * @param index - The index of the unassigned image, between 1 and the value
         *              returned by GetUnassignedImages
         * @return String
         */
        @Signature
        public native String GetUnassignedImageFileName(int index);

        /**
         * On Android and iOS this returns the full URL that was used to open this app
         * if a URL scheme was used. For example if you have set the URL scheme "myapp"
         * for this app and the user clicks on a link such as "myapp: sometext", then
         * the OS will open your app and GetURLSchemeText will return "myapp: sometext"
         * until the app is next opened. If a URL was not used to open the app, or the
         * platform doesn't support URL schemes, then an empty string will be returned.
         * When choosing a URL scheme you must make sure it is unique to your app, as
         * iOS will not allow two apps to have the same scheme.
         *
         * @return String
         */
        @Signature
        public native String GetURLSchemeText();

        /**
         * Checks a UDP listener for any broadcasts. Returns 0 if nothing has been
         * received. Returns a message ID if something has been received, you can access
         * the contents of this message using network message commands. The message must
         * be deleted when you have finished reading from it.
         *
         * @param listenerID - The ID of the listener to check for messages
         * @return int
         */
        @Signature
        public native int GetUDPNetworkMessage(int listenerID);

        /**
         * Returns the current date and time in unix time format, which is measured as
         * seconds from 1st Jan 1970. It can be negative for dates before 1970.
         *
         * @return int
         */
        @Signature
        public native int GetUnixTime();

        /**
         * Returns 1 if a tween with the given ID exists and it is a text tween,
         * otherwise 0.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenTextExists(int tweenID);

        /**
         * Returns 1 if a virtual button was pressed this frame, after the initial press
         * this function will return to 0. Use GetVirtualButtonState to check if a
         * virtual button is up or down.
         *
         * @param index - The ID of the virtual button to check.
         * @return int
         */
        @Signature
        public native int GetVirtualButtonPressed(int index);

        /**
         * Returns the dot product of 2 vectors
         *
         * @param vectorU - ID of the first vector
         * @param vectorV - ID of the second vector
         * @return float
         */
        @Signature
        public native float GetVector3Dot(int vectorU, int vectorV);

        /**
         * Returns 1 if a tween exists at the given ID and it is an object tween,
         * otherwise 0.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenObjectExists(int tweenID);

        /**
         * Returns 1 if a tween of any type exists at the given ID, 0 otherwise.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenExists(int tweenID);

        /**
         * Returns 1 if the given tween ID is currently playing on the given object,
         * otherwise 0. This will still return 1 if the tween is currently paused.
         *
         * @param tweenID  - ID of the tween to check
         * @param objectID - ID of the object to check
         * @return int
         */
        @Signature
        public native int GetTweenObjectPlaying(int tweenID, int objectID);

        /**
         * Returns 1 if the given tween ID is currently playing on the given text
         * object, otherwise 0. This will still return 1 if the tween is currently
         * paused.
         *
         * @param tweenID - ID of the tween to check
         * @param textID  - ID of the text to check
         * @return int
         */
        @Signature
        public native int GetTweenTextPlaying(int tweenID, int textID);

        /**
         * Returns the current value of the fourth integer of the custom tween.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenCustomInteger4(int tweenID);

        /**
         * Returns the current value of the third integer of the custom tween.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenCustomInteger3(int tweenID);

        /**
         * Returns 1 if the given tween ID is currently playing on the given sprite,
         * otherwise 0. This will still return 1 if the tween is currently paused.
         *
         * @param tweenID  - ID of the tween to check
         * @param spriteID - ID of the sprite to check
         * @return int
         */
        @Signature
        public native int GetTweenSpritePlaying(int tweenID, int spriteID);

        /**
         * Returns 1 if a tween with the given ID exists and it is a sprite tween,
         * otherwise 0.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenSpriteExists(int tweenID);

        /**
         * Returns the current value of the first integer of the custom tween.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenCustomInteger1(int tweenID);

        /**
         * Returns the current value of the fourth float of the custom tween.
         *
         * @param tweenID - ID of the tween to check
         * @return float
         */
        @Signature
        public native float GetTweenCustomFloat4(int tweenID);

        /**
         * Returns the current value of the first float of the custom tween.
         *
         * @param tweenID - ID of the tween to check
         * @return float
         */
        @Signature
        public native float GetTweenCustomFloat1(int tweenID);

        /**
         * Returns the current value of the second float of the custom tween.
         *
         * @param tweenID - ID of the tween to check
         * @return float
         */
        @Signature
        public native float GetTweenCustomFloat2(int tweenID);

        /**
         * Returns 1 if a tween with the given ID exists and it is a custom tween,
         * otherwise 0.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenCustomExists(int tweenID);

        /**
         * Returns 1 if the given custom tween ID is currently playing, otherwise 0.
         * This will still return 1 if the tween is currently paused.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenCustomPlaying(int tweenID);

        /**
         * Returns 1 if a tween with the given ID exists and it is a char tween,
         * otherwise 0.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenCharExists(int tweenID);

        /**
         * Returns the total length of the tween chain in seconds.
         *
         * @param chainID - ID of the chain to check
         * @return float
         */
        @Signature
        public native float GetTweenChainEndTime(int chainID);

        /**
         * Returns the current value of the second integer of the custom tween.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenCustomInteger2(int tweenID);

        /**
         * Returns the current value of the third float of the custom tween.
         *
         * @param tweenID - ID of the tween to check
         * @return float
         */
        @Signature
        public native float GetTweenCustomFloat3(int tweenID);

        /**
         * Returns 1 if a tween exists at the given ID and it is a camera tween,
         * otherwise 0.
         *
         * @param tweenID - ID of the tween to check
         * @return int
         */
        @Signature
        public native int GetTweenCameraExists(int tweenID);

        /**
         * Returns the current Y position of a text object in world coordinates, the
         * text is positioned using its top left corner.
         *
         * @param iTextIndex - The ID of the text object to return.
         * @return float
         */
        @Signature
        public native float GetTextY(int iTextIndex);

        /**
         * Returns the current X position of a text object in world coordinates, the
         * text is positioned using its top left corner.
         *
         * @param iTextIndex - The ID of the text object to return.
         * @return float
         */
        @Signature
        public native float GetTextX(int iTextIndex);

        /**
         * Returns 0 if the current text has been set as invisible using SetTextVisible,
         * 1 if it is set as visible (default). This does not check if the text is
         * currently positioned withing the visible viewport.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @return int
         */
        @Signature
        public native int GetTextVisible(int iTextIndex);

        /**
         * Returns 1 if the given tween ID is currently playing on the given character
         * and text object, otherwise 0. This will still return 1 if the tween is
         * currently paused.
         *
         * @param tweenID - ID of the tween to check
         * @param textID  - ID of the text to check
         * @param charID  - Index of the character to check, indices start at 0, if out
         *                of range it is ignored
         * @return int
         */
        @Signature
        public native int GetTweenCharPlaying(int tweenID, int textID, int charID);

        /**
         * Returns the current width of the text object in world units. If the text
         * object is displaying text over multiple lines it will return the width of the
         * longest line. This does not take into account the individual offsets of
         * characters, if you have used SetTextCharX or similar to move a character. The
         * returned value is the width used by the default drawing position of the text
         * characters.
         *
         * @param iTextIndex - The ID of the text object to return.
         * @return float
         */
        @Signature
        public native float GetTextTotalWidth(int iTextIndex);

        /**
         * Returns the current height of the text object in world units. This does not
         * take into account the individual offsets of characters, if you have used
         * SetTextCharY or similar to move a character. The returned value is the height
         * used by the default drawing position of the text characters. Note that if the
         * string of the text is empty then this value will return 0.
         *
         * @param iTextIndex - The ID of the text object to return.
         * @return float
         */
        @Signature
        public native float GetTextTotalHeight(int iTextIndex);

        /**
         * Returns 1 when the text to speech engine is ready to start converting text to
         * speech. Calling other text to speech commands when it is not ready will be
         * ignored. Currently only works on iOS and Android.
         *
         * @return int
         */
        @Signature
        public native int GetTextToSpeechReady();

        /**
         * Returns the current string being displayed by the text object. In tier 2 the
         * returned string must be deleted when you are done with it.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @return String
         */
        @Signature
        public native String GetTextString(int iTextIndex);

        /**
         * Returns the current spacing of the text object set with SetTextSpacing.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @return float
         */
        @Signature
        public native float GetTextSpacing(int iTextIndex);

        /**
         * Returns the current size of the text object set with SetTextSize.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @return float
         */
        @Signature
        public native float GetTextSize(int iTextIndex);

        /**
         * Returns the current line spacing of the text object set with
         * SetTextLineSpacing.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @return float
         */
        @Signature
        public native float GetTextLineSpacing(int iTextIndex);

        /**
         * Returns the current length of the string the text object is displaying.
         *
         * @param iTextIndex - The ID of the text object to return.
         * @return int
         */
        @Signature
        public native int GetTextLength(int iTextIndex);

        /**
         * Returns 0 if the user is currently inputting text, 1 if not.
         *
         * @return int
         */
        @Signature
        public native int GetTextInputState();

        /**
         * Returns 1 for the frame that the user completed inputting text (successfully
         * or not). After completion this command will return to 0. At this point you
         * can check if the user cancelled the input by using GetTextInputCancelled.
         *
         * @return int
         */
        @Signature
        public native int GetTextInputCompleted();

        /**
         * Returns 1 if the given point in world coordinates is inside the bounding box
         * of the text. If you are testing a mouse or touch coordinate, remember to
         * convert it to world coordinates using ScreenToWorldX and ScreenToWorldY. This
         * does not take into account individual character positions, for example if you
         * have positioned a character using SetTextCharX or similar. Only the bounding
         * box created by drawing the characters in their default positions is checked.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @param x          - The x coordinate of the point to check in world
         *                   coordinates.
         * @param y          - The y coordinate of the point to check in world
         *                   coordinates.
         * @return int
         */
        @Signature
        public native int GetTextHitTest(int iTextIndex, float x, float y);

        /**
         * Returns 1 if the chain is currently working through its list of tweens. If
         * the last tween has finished or the chain has yet to be started it will return
         * 0.
         *
         * @param chainID - ID of the chain to check
         * @return int
         */
        @Signature
        public native int GetTweenChainPlaying(int chainID);

        /**
         * Returns 1 if the text exists, 0 if not.
         *
         * @param iTextIndex - The ID of the text to check
         * @return int
         */
        @Signature
        public native int GetTextExists(int iTextIndex);

        /**
         * Get the red component of the text color. The value will be in the range
         * 0-255.
         *
         * @param iTextIndex - The ID of the text to check.
         * @return int
         */
        @Signature
        public native int GetTextColorRed(int iTextIndex);

        /**
         * Returns 1 if the given tween ID is currently playing on the given camera,
         * otherwise 0. This will still return 1 if the tween is currently paused.
         *
         * @param tweenID  - ID of the tween to check
         * @param cameraID - ID of the camera to check
         * @return int
         */
        @Signature
        public native int GetTweenCameraPlaying(int tweenID, int cameraID);

        /**
         * Returns the current depth of the text object, with 0 being the front of the
         * screen and 10000 being the back.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @return int
         */
        @Signature
        public native int GetTextDepth(int iTextIndex);

        /**
         * Returns 1 if the user cancelled the text input, 0 if not. This commands value
         * is not defined until GetTextInputCompleted returns 1.
         *
         * @return int
         */
        @Signature
        public native int GetTextInputCancelled();

        /**
         * Get the blue component of the text color. The value will be in the range
         * 0-255.
         *
         * @param iTextIndex - The ID of the text to check.
         * @return int
         */
        @Signature
        public native int GetTextColorBlue(int iTextIndex);

        /**
         * Get the green component of the text color. The value will be in the range
         * 0-255.
         *
         * @param iTextIndex - The ID of the text to check.
         * @return int
         */
        @Signature
        public native int GetTextColorGreen(int iTextIndex);

        /**
         * Get the alpha component of the text color. The value will be in the range
         * 0-255.
         *
         * @param iTextIndex - The ID of the text to check.
         * @return int
         */
        @Signature
        public native int GetTextColorAlpha(int iTextIndex);

        /**
         * Returns the red component of the given character color. The value will be in
         * the range 0-255.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @param iCharIndex - The index of the character to check, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @return int
         */
        @Signature
        public native int GetTextCharColorRed(int iTextIndex, int iCharIndex);

        /**
         * Returns the green component of the given character color. The value will be
         * in the range 0-255.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @param iCharIndex - The index of the character to check, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @return int
         */
        @Signature
        public native int GetTextCharColorGreen(int iTextIndex, int iCharIndex);

        /**
         * Returns the alpha component of the given character color. The value will be
         * in the range 0-255.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @param iCharIndex - The index of the character to check, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @return int
         */
        @Signature
        public native int GetTextCharColorAlpha(int iTextIndex, int iCharIndex);

        /**
         * Returns the current angle in radians of the specified character.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @param iCharIndex - The index of the character to check, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @return float
         */
        @Signature
        public native float GetTextCharAngleRad(int iTextIndex, int iCharIndex);

        /**
         * Returns the current angle in degrees of the specified character.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @param iCharIndex - The index of the character to check, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @return float
         */
        @Signature
        public native float GetTextCharAngle(int iTextIndex, int iCharIndex);

        /**
         * Returns the string that the user input. It will contain characters encoded
         * with UTF-8, some devices may also allow newline characters to be returned.
         * This commands value is not defined until GetTextInputCompleted returns 1.
         *
         * @return String
         */
        @Signature
        public native String GetTextInput();

        /**
         * Returns the current alignment of the text object set with SetTextAlignment.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @return int
         */
        @Signature
        public native int GetTextAlignment(int iTextIndex);

        /**
         * Returns the blue component of the given character color. The value will be in
         * the range 0-255.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @param iCharIndex - The index of the character to check, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @return int
         */
        @Signature
        public native int GetTextCharColorBlue(int iTextIndex, int iCharIndex);

        /**
         * Returns a specific token from a string separated by the given delimiter, for
         * example a string containing "first:second:third" has three tokens delimited
         * by ":". Similar to GetStringToken except that this command accepts only a
         * single character as the delimiter and recognises empty fields. For example
         * "first:second::fourth" has four tokens with the third being an empty string.
         * In tier 2 the returned string must be deleted when you are done with it. You
         * can use CountStringTokens2 to count the number of tokens in the string.
         *
         * @param str       - The string to check.
         * @param delimiter - The character that delimits the string.
         * @param token     - the index of the token to return, starting at 1 for the
         *                  first token.
         * @return String
         */
        @Signature
        public native String GetStringToken2(String str, String delimiter, int token);

        /**
         * Returns the current Y position of the specified character relative to the
         * text object.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @param iCharIndex - The index of the character to check, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @return float
         */
        @Signature
        public native float GetTextCharY(int iTextIndex, int iCharIndex);

        /**
         * Returns the current X position of the specified character relative to the
         * text object.
         *
         * @param iTextIndex - The ID of the text object to check.
         * @param iCharIndex - The index of the character to check, indexes start at 0,
         *                   if the index is out of range it will be ignored.
         * @return float
         */
        @Signature
        public native float GetTextCharX(int iTextIndex, int iCharIndex);

        /**
         * Returns the total number of MB of data storage at the specified path, used
         * and unused. For example using a path that points to a location on the sdcard
         * on Android will return the size of the sdcard, whereas using a path that
         * points to the AGK write folder will return the number of MB in the internal
         * storage. In some cases these may be the same. This command returns -1 if the
         * storage size could not be determined. Currently only implemented on iOS and
         * Android, other platforms will return -1.
         *
         * @param path - The path to check
         * @return int
         */
        @Signature
        public native int GetStorageTotal(String path);

        /**
         * Returns the number of MB available to the app for data storage at the
         * specified path. For example using a path that points to a location on the
         * sdcard on Android will return how many MBs can be stored there, whereas using
         * a path that points to the AGK write folder will return the number of MB the
         * app can store in its internal storage. In some cases these may be the same.
         * This command returns -1 if the space available could not be determined.
         * Currently only implemented on iOS and Android, other platforms will return
         * -1.
         *
         * @param path - The path to check
         * @return int
         */
        @Signature
        public native int GetStorageRemaining(String path);

        /**
         * Converts a point in world coordinates to a point on the sprite. This is the
         * opposite of GetWorldYFromSprite and will return values relative to the
         * sprite's center point defined with SetSpriteOffset. By default this is the
         * center of the sprite. The command is not limited by the size of the sprite,
         * it may return values larger than the sprite bounds.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @param x            - The X component of the point to convert into sprite
         *                     coordinates.
         * @param y            - The Y component of the point to convert into sprite
         *                     coordinates.
         * @return float
         */
        @Signature
        public native float GetSpriteYFromWorld(int iSpriteIndex, float x, float y);

        /**
         * Converts a pixel point on the sprite's image to the point on the sprite's
         * surface that represents where that pixel is. For example if a 200x100 pixel
         * image was assigned to a sprite of size 10x10, then calling this command with
         * a pixel value of 50 (center of the image) would return 5 (center of the
         * sprite). The sprite must have an image assigned for this to work or it will
         * always return 0. The command is not limited by the size of the image or
         * sprite, so in the above example a pixel value of 300 or -10 would both be
         * valid.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @param y            - The y coordinate of the pixel to check.
         * @return float
         */
        @Signature
        public native float GetSpriteYFromPixel(int iSpriteIndex, int y);

        /**
         * Returns the current Y coordinate of the sprite's current offset point in the
         * world.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve
         * @return float
         */
        @Signature
        public native float GetSpriteYByOffset(int iSpriteIndex);

        /**
         * Returns the current Y coordinate of the sprite's top left corner as a
         * floating point value.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve
         * @return float
         */
        @Signature
        public native float GetSpriteY(int iSpriteIndex);

        /**
         * Converts a point in world coordinates to a point on the sprite. This is the
         * opposite of GetWorldXFromSprite and will return values relative to the
         * sprite's center point defined with SetSpriteOffset. By default this is the
         * center of the sprite. The command is not limited by the size of the sprite,
         * it may return values larger than the sprite bounds.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @param x            - The X component of the point to convert into sprite
         *                     coordinates.
         * @param y            - The Y component of the point to convert into sprite
         *                     coordinates.
         * @return float
         */
        @Signature
        public native float GetSpriteXFromWorld(int iSpriteIndex, float x, float y);

        /**
         * Converts a pixel point on the sprite's image to the point on the sprite's
         * surface that represents where that pixel is. For example if a 200x100 pixel
         * image was assigned to a sprite of size 10x10, then calling this command with
         * a pixel value of 100 (center of the image) would return 5 (center of the
         * sprite). The sprite must have an image assigned for this to work or it will
         * always return 0. The command is not limited by the size of the image or
         * sprite, so in the above example a pixel value of 300 or -10 would both be
         * valid.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @param x            - The x coordinate of the pixel to check.
         * @return float
         */
        @Signature
        public native float GetSpriteXFromPixel(int iSpriteIndex, int x);

        /**
         * Returns the current X coordinate of the sprite's current offset point in the
         * world.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve
         * @return float
         */
        @Signature
        public native float GetSpriteXByOffset(int iSpriteIndex);

        /**
         * Returns the current X coordinate of the sprite's top left corner as a
         * floating point value.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve
         * @return float
         */
        @Signature
        public native float GetSpriteX(int iSpriteIndex);

        /**
         * Returns the current width of the sprite as a floating point value.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve
         * @return float
         */
        @Signature
        public native float GetSpriteWidth(int iSpriteIndex);

        /**
         * Returns 0 if the sprite has been set as invisible using SetSpriteVisible,
         * otherwise returns 1.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteVisible(int iSpriteIndex);

        /**
         * Returns 1 if the system contains a font with the given name, 0 otherwise. If
         * 1 is returned then passing the same filename to LoadFont will succeed. On iOS
         * this will always return 0 as the system font files are not accessible,
         * however AGK comes with a built in font you can use by using font ID 0 with
         * text objects.
         *
         * @param szFontFile - The name of the font to check
         * @return int
         */
        @Signature
        public native int GetSystemFontExists(String szFontFile);

        /**
         * Returns the current transparency mode of the sprite, 0=no transparency,
         * 1=alpha channel transparency, 2=additive blending.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteTransparency(int iSpriteIndex);

        /**
         * Returns the Y value of given vertex in the specified shape. This only applies
         * to polygon and chain shapes. Shape IDs start at 1 for the first shape up to
         * and including the value returned by GetSpriteNumShapes. Vertex IDs start at 1
         * for the first vertex up to and including the value returned by
         * GetSpriteShapeNumVertices
         *
         * @param iSpriteIndex - The ID of the sprite to check
         * @param shapeID      - The ID of the shape to check
         * @param vertex       - the ID of the vertex to check, vertices start at ID 1.
         * @return float
         */
        @Signature
        public native float GetSpriteShapeVertexY(int iSpriteIndex, int shapeID, int vertex);

        /**
         * Returns the X value of given vertex in the specified shape. This only applies
         * to polygon and chain shapes. Shape IDs start at 1 for the first shape up to
         * and including the value returned by GetSpriteNumShapes. Vertex IDs start at 1
         * for the first vertex up to and including the value returned by
         * GetSpriteShapeNumVertices
         *
         * @param iSpriteIndex - The ID of the sprite to check
         * @param shapeID      - The ID of the shape to check
         * @param vertex       - the ID of the vertex to check, vertices start at ID 1.
         * @return float
         */
        @Signature
        public native float GetSpriteShapeVertexX(int iSpriteIndex, int shapeID, int vertex);

        /**
         * Returns the number of vertices in the specified shape. This only applies to
         * polygon and chain shapes. Shape IDs start at 1 for the first shape up to and
         * including the value returned by GetSpriteNumShapes.
         *
         * @param iSpriteIndex - The ID of the sprite to check
         * @param shapeID      - The ID of the shape to check
         * @return int
         */
        @Signature
        public native int GetSpriteShapeNumVertices(int iSpriteIndex, int shapeID);

        /**
         * Returns the current scaling of the sprite in the Y direction as set with
         * SetSpriteScale or SetSpriteScaleByOffset
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve
         * @return float
         */
        @Signature
        public native float GetSpriteScaleY(int iSpriteIndex);

        /**
         * Returns the number of varying values that can be used in shaders on the
         * current device. Varyings are the variables that pass data between the vertex
         * and pixel shaders. This value is guaranteed to be at least 32, but most
         * devices support more. A single vec4 varying holds 4 varying values, so 32
         * varyings values means you can have a maximum of 8 vec4 varyings. Note that a
         * vec3 varying may take up 4 value spaces if it cannot be packed with any other
         * varying. Varyings will automatically be packed together if they can fill a
         * vec4 without being split, for example a vec3 and a float can be packed
         * together, as can two vec2 varyings. However two vec3 varyings cannot be
         * packed together without being split up so they will each use up 4 values with
         * the extra space being wasted.
         *
         * @return int
         */
        @Signature
        public native int GetSupportedShaderVaryings();

        /**
         * Returns the current scaling of the sprite in the X direction as set with
         * SetSpriteScale or SetSpriteScaleByOffset
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve
         * @return float
         */
        @Signature
        public native float GetSpriteScaleX(int iSpriteIndex);

        /**
         * Returns 1 if the sprite is currently playing an animation, 0 if not.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpritePlaying(int iSpriteIndex);

        /**
         * Converts a point on the sprite's image to the pixel on the sprite's image
         * that is underneath that point. For example if a 200x100 pixel image was
         * assigned to a sprite of size 10x10, then calling this command with a pixel
         * value of 5 (center of the sprite) would return 50 (center of the image). The
         * sprite must have an image assigned for this to work or it will always return
         * 0. The command is not limited by the size of the image or sprite, so in the
         * above example a pixel value of 20 or -1 would both be valid.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @param y            - The y coordinate of the sprite point to check.
         * @return int
         */
        @Signature
        public native int GetSpritePixelFromY(int iSpriteIndex, float y);

        /**
         * Returns a specific token from a string separated by the given delimiters, for
         * example a string containing "first:second:third" has three tokens delimited
         * by ":" and "first:second;third" has three tokens separated by the delimiters
         * ":;". You can have multiple delimiters between each token, for example
         * "first:;second:third" is valid, and has three tokens. In tier 2 the returned
         * string must be deleted when you are done with it. You can use
         * CountStringTokens to count the number of tokens in the string. This command
         * is useful for separating words in a sentence, which can be delimited by both
         * white space and punctuation.
         *
         * @param str        - The string to check.
         * @param delimiters - The set of characters that delimit the string.
         * @param token      - the index of the token to return, starting at 1 for the
         *                   first token.
         * @return String
         */
        @Signature
        public native String GetStringToken(String str, String delimiters, int token);

        /**
         * Converts a point on the sprite's image to the pixel on the sprite's image
         * that is underneath that point. For example if a 200x100 pixel image was
         * assigned to a sprite of size 10x10, then calling this command with a pixel
         * value of 5 (center of the sprite) would return 100 (center of the image). The
         * sprite must have an image assigned for this to work or it will always return
         * 0. The command is not limited by the size of the image or sprite, so in the
         * above example a pixel value of 20 or -1 would both be valid.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @param x            - The x coordinate of the sprite point to check.
         * @return int
         */
        @Signature
        public native int GetSpritePixelFromX(int iSpriteIndex, float x);

        /**
         * Returns the linear velocity of the sprite in the Y direction. This is the
         * number of units per second that the sprite is currently moving in your chosen
         * resolution.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return float
         */
        @Signature
        public native float GetSpritePhysicsVelocityY(int iSpriteIndex);

        /**
         * Returns the linear velocity of the sprite in the X direction. This is the
         * number of units per second that the sprite is currently moving in your chosen
         * resolution.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return float
         */
        @Signature
        public native float GetSpritePhysicsVelocityX(int iSpriteIndex);

        /**
         * Returns the Y value of current Center Of Mass for the given sprite's physics
         * body. All shapes currently added to this sprite contribute to this value. If
         * you have set the center of mass manually then it will return that value.
         * Physics must be turned on for this sprite for the command to work, otherwise
         * it will return 0.
         *
         * @param iSpriteIndex - The ID of the sprite to check
         * @return float
         */
        @Signature
        public native float GetSpritePhysicsCOMY(int iSpriteIndex);

        /**
         * Returns the mass of the sprite in kilograms currently being used. This was
         * either generated automatically when its shape was created or a shape was
         * added, or was set manually.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return float
         */
        @Signature
        public native float GetSpritePhysicsMass(int iSpriteIndex);

        /**
         * Returns the X value of current Center Of Mass for the given sprite's physics
         * body. All shapes currently added to this sprite contribute to this value. If
         * you have set the center of mass manually then it will return that value.
         * Physics must be turned on for this sprite for the command to work, otherwise
         * it will return 0.
         *
         * @param iSpriteIndex - The ID of the sprite to check
         * @return float
         */
        @Signature
        public native float GetSpritePhysicsCOMX(int iSpriteIndex);

        /**
         * Returns the Y component of the sprite's current offset point.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve
         * @return float
         */
        @Signature
        public native float GetSpriteOffsetY(int iSpriteIndex);

        /**
         * Returns the current number of shapes assigned to this sprite. Shape IDs are
         * valid from 1 up to and including the value returned by this command.
         *
         * @param iSpriteIndex - The ID of the sprite to check
         * @return int
         */
        @Signature
        public native int GetSpriteNumShapes(int iSpriteIndex);

        /**
         * Returns the angular velocity of the sprite in radians per second. This is the
         * speed at which the sprite is currently rotating.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return float
         */
        @Signature
        public native float GetSpritePhysicsAngularVelocity(int iSpriteIndex);

        /**
         * Cycles through the list of contacts for the given sprite only. Returns 1 if a
         * contact exists, you can get the other sprite involved in this contact using
         * GetSpriteContactSpriteID2, you can move on to the next contact by calling
         * this command again, it will return 0 when no more contacts exist. Only works
         * on sprites setup for physics.
         *
         * 
         * @return int
         */
        @Signature
        public native int GetSpriteNextContact();

        /**
         * Returns 1 if the sprite is currently within the visible area of the screen, 0
         * if it is outside the visible area. Note that if the sprite is very close to
         * the edge where it may be difficult to determine if all the pixels in the
         * sprite are outside the visible area then this command will return 1 and
         * assume it is visible. In other words if this command returns 0 then the
         * sprite is definitely off screen, if it returns 1 then the sprite is most
         * likely on screen but could actually be off screen and very close to an edge.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteInScreen(int iSpriteIndex);

        /**
         * Returns the X component of the sprite's current offset point.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve
         * @return float
         */
        @Signature
        public native float GetSpriteOffsetX(int iSpriteIndex);

        /**
         * Returns 1 if the sprite's collision shape is touching the given box in world
         * coordinates, 0 if not. If the sprite does not have a shape it is assigned a
         * box shape of its own which will remain after this command. This command takes
         * into account the rotation and scale of the sprite when checking intersection.
         *
         * @param iSprite - The ID of the sprite to check
         * @param x1      - The X coordinate of the top left corner of the box in world
         *                coordinates.
         * @param y1      - The Y coordinate of the top left corner of the box in world
         *                coordinates.
         * @param x2      - The X coordinate of the bottom right corner of the box in
         *                world coordinates.
         * @param y2      - The Y coordinate of the bottom right corner of the box in
         *                world coordinates.
         * @return int
         */
        @Signature
        public native int GetSpriteInBox(int iSprite, float x1, float y1, float x2, float y2);

        /**
         * Returns 1 if the sprite's collision shape is touching the given circle in
         * world coordinates, 0 if not. If the sprite does not have a shape it is
         * assigned a box shape of its own which will remain after this command. This
         * command takes into account the rotation and scale of the sprite when checking
         * intersection. Note that due to aspect ratio modifications this command does
         * not behave as expect when using the percentage coordinate system. Instead it
         * will check an ellipse with the correct radius in the X direction but a larger
         * radius in the Y direction.
         *
         * @param iSprite - The ID of the sprite to check
         * @param x1      - The X coordinate of the center of the circle in world
         *                coordinates.
         * @param y1      - The Y coordinate of the center of the circle in world
         *                coordinates.
         * @param radius  - The radius of the circle in world coordinates.
         * @return int
         */
        @Signature
        public native int GetSpriteInCircle(int iSprite, float x1, float y1, float radius);

        /**
         * Returns 1 if the point x,y in world coordinates lies within the sprite, 0 if
         * not. Takes into account the rotation and scale values of the sprite. Uses the
         * shape assigned to it from SetSpriteShape, if no shape is set it uses the
         * sprite width and height as a box shape. If you are testing a mouse or touch
         * coordinate, remember to convert it to world coordinates using ScreenToWorldX
         * and ScreenToWorldY.
         *
         * @param iSpriteIndex - The sprite to test.
         * @param x            - The x position in world coordinates to check.
         * @param y            - The y position in world coordinates to check.
         * @return int
         */
        @Signature
        public native int GetSpriteHitTest(int iSpriteIndex, float x, float y);

        /**
         * Returns the ID of the first sprite found under the point x,y in world
         * coordinates, 0 if none. Sprites are ordered by depth so a sprite appearing
         * above another in the draw order will be returned instead of the sprite behind
         * it. Filters results to only those sprites in the specified group. By default
         * sprites are created in group 0, you can change this with SetSpriteGroup.
         * Takes into account the rotation and scale values of the sprite. It does not
         * take into account the transparency of the sprite, only its collision shape.
         * Uses the shape assigned to it from SetSpriteShape, if no shape is set it uses
         * the sprite width and height as a box shape. If you are testing a mouse or
         * touch coordinate, remember to convert it to world coordinates using
         * ScreenToWorldX and ScreenToWorldY.
         *
         * @param group - The group ID to check.
         * @param x     - The x position in world coordinates to check.
         * @param y     - The y position in world coordinates to check.
         * @return int
         */
        @Signature
        public native int GetSpriteHitGroup(int group, float x, float y);

        /**
         * Returns the value of the group set using SetSpriteGroup. If you have not set
         * the group this will be 0.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteGroup(int iSpriteIndex);

        /**
         * Gets the ID of the image currently assigned to the sprite. This only works if
         * the image was loaded with an ID (or assigned one by AGK).
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteImageID(int iSpriteIndex);

        /**
         * Returns the total number of frames the sprite managed to get from its image.
         * May be less than the number of frames requested during setup.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve.
         * @return int
         */
        @Signature
        public native int GetSpriteFrameCount(int iSpriteIndex);

        /**
         * Returns the ID of the first sprite found under the point x,y in world
         * coordinates, 0 if none. Sprites are ordered by depth so a sprite appearing
         * above another in the draw order will be returned instead of the sprite behind
         * it. Takes into account the rotation and scale values of the sprite. It does
         * not take into account the transparency of the sprite, only its collision
         * shape. Uses the shape assigned to it from SetSpriteShape, if no shape is set
         * it uses the sprite width and height as a box shape. If you are testing a
         * mouse or touch coordinate, remember to convert it to world coordinates using
         * ScreenToWorldX and ScreenToWorldY.
         *
         * @param x - The x position in world coordinates to check.
         * @param y - The y position in world coordinates to check.
         * @return int
         */
        @Signature
        public native int GetSpriteHit(float x, float y);

        /**
         * Returns the current height of the sprite as a floating point value.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve
         * @return float
         */
        @Signature
        public native float GetSpriteHeight(int iSpriteIndex);

        /**
         * Returns the ID of the first sprite found under the point x,y in world
         * coordinates, 0 if none. Sprites are ordered by depth so a sprite appearing
         * above another in the draw order will be returned instead of the sprite behind
         * it. This function filters the results so only sprites of certain categories
         * are checked. The category parameter is a bitwise field that uses the lower 16
         * bits to represent each of the possible 16 categories used when setting up a
         * sprite. The default value of all 1s means all categories will be included,
         * whereas a value of all 0s means no categories will be included. You can set
         * individual bits to set which ones should be checked. You can set which
         * categories a sprite belongs to with SetSpriteCategoryBits. Takes into account
         * the rotation and scale values of the sprite. It does not take into account
         * the transparency of the sprite, only its collision shape. Uses the shape
         * assigned to it from SetSpriteShape, if no shape is set it uses the sprite
         * width and height as a box shape. If you are testing a mouse or touch
         * coordinate, remember to convert it to world coordinates using ScreenToWorldX
         * and ScreenToWorldY.
         *
         * @param categories - The categories to check.
         * @param x          - The x position in world coordinates to check.
         * @param y          - The y position in world coordinates to check.
         * @return int
         */
        @Signature
        public native int GetSpriteHitCategory(int categories, float x, float y);

        /**
         * Cycles through the list of contacts for the given sprite only. Returns 1 if a
         * contact exists, you can get the other sprite involved in this contact using
         * GetSpriteContactSpriteID2, you can move on to the next contact with
         * GetSpriteNextContact. Only works on sprites setup for physics. Returns 0 if
         * there are no contacts.
         *
         * @param iSprite1 - The sprite to check for physics contacts.
         * @return int
         */
        @Signature
        public native int GetSpriteFirstContact(int iSprite1);

        /**
         * Returns 1 if the sprite exists, 0 if not.
         *
         * @param iSpriteIndex - The ID of the sprite to check
         * @return int
         */
        @Signature
        public native int GetSpriteExists(int iSpriteIndex);

        /**
         * Returns the Y coordinate of the closest point on sprite 2 to sprite 1 from
         * the last call to GetSpriteDistance in world coordinates.
         *
         * 
         * @return float
         */
        @Signature
        public native float GetSpriteDistancePoint2Y();

        /**
         * Returns 1 if the sprite has been flipped horizontally with SetSpriteFlip,
         * otherwise returns 0.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteFlippedH(int iSpriteIndex);

        /**
         * Returns 1 if the sprite has been flipped vertically with SetSpriteFlip,
         * otherwise returns 0.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteFlippedV(int iSpriteIndex);

        /**
         * Returns the X coordinate of the closest point on sprite 2 to sprite 1 from
         * the last call to GetSpriteDistance in world coordinates.
         *
         * 
         * @return float
         */
        @Signature
        public native float GetSpriteDistancePoint2X();

        /**
         * Returns the X coordinate of the closest point on sprite 1 to sprite 2 from
         * the last call to GetSpriteDistance in world coordinates.
         *
         * 
         * @return float
         */
        @Signature
        public native float GetSpriteDistancePoint1X();

        /**
         * Calculates the minimum distance separating the two sprites. If the sprites
         * overlap this will be less than 0. Otherwise it will be the distance between
         * the closest points on each sprite, these points can be found using
         * GetSpriteDistancePoint1X, etc. This calculation takes longer than simply
         * checking if the sprites overlap, if you don't need the distance separating
         * the sprites use GetSpriteCollision. This function is not limited by group or
         * category settings. If you have not assigned a shape to either sprite using
         * SetSpriteShape they will use the default box shape based on the sprite's
         * width and height.
         *
         * @param iSprite1 - The sprite to check for distance with sprite 2
         * @param iSprite2 - The sprite to check for distance with sprite 1
         * @return float
         */
        @Signature
        public native float GetSpriteDistance(int iSprite1, int iSprite2);

        /**
         * Returns the current depth of the sprite in the range 0-10000, with 0 being
         * the front of the screen and 10000 being the back.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteDepth(int iSpriteIndex);

        /**
         * Returns the Y coordinate of the closest point on sprite 1 to sprite 2 from
         * the last call to GetSpriteDistance in world coordinates.
         *
         * 
         * @return float
         */
        @Signature
        public native float GetSpriteDistancePoint1Y();

        /**
         * Gets the sprite's current frame ID.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve.
         * @return int
         */
        @Signature
        public native int GetSpriteCurrentFrame(int iSpriteIndex);

        /**
         * Returns the Y coordinate of the contact point in world coordinates.
         *
         * 
         * @return float
         */
        @Signature
        public native float GetSpriteContactWorldY();

        /**
         * Returns the ID of the other sprite involved in this contact.
         *
         * 
         * @return int
         */
        @Signature
        public native int GetSpriteContactSpriteID2();

        /**
         * Returns the X coordinate of the contact point in world coordinates.
         *
         * 
         * @return float
         */
        @Signature
        public native float GetSpriteContactWorldX();

        /**
         * Returns the current red component of a sprite in the range 0-255.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteColorRed(int iSpriteIndex);

        /**
         * Returns the current green component of a sprite in the range 0-255.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteColorGreen(int iSpriteIndex);

        /**
         * Returns the current alpha value of a sprite in the range 0-255.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteColorAlpha(int iSpriteIndex);

        /**
         * Checks two sprites for collision, if they overlap then it returns 1.
         * Otherwise it returns 0. No other information can be returned about this type
         * of collision. This command is primarily for sprites that are not using
         * physics. Whilst it can be used on physics sprites the physics system will
         * have already calculated the overlap of all physics sprites during the last
         * frame and stored the results in the contact list. This function actually does
         * the calculation required to determine if the sprites overlap. This function
         * is not limited by group or category settings. This function only operates on
         * the sprite's base shape. Any additional shapes added to physics sprites will
         * not be used in this function, use GetPhysicsCollision instead. Also Chain
         * shapes will always return no collision using this command, chain shapes are
         * only used in physics calculations. If you have not assigned a shape to either
         * sprite using SetSpriteShape they will use the default box shape based on the
         * sprite's width and height.
         *
         * @param iSprite1 - The sprite to check for intersection with sprite 2
         * @param iSprite2 - The sprite to check for intersection with sprite 1
         * @return int
         */
        @Signature
        public native int GetSpriteCollision(int iSprite1, int iSprite2);

        /**
         * Returns the current blue component of a sprite in the range 0-255.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteColorBlue(int iSpriteIndex);

        /**
         * Returns 0 if the sprite has been set as inactive using SetSpriteActive,
         * otherwise returns 1.
         *
         * @param iSpriteIndex - The ID of the sprite to check.
         * @return int
         */
        @Signature
        public native int GetSpriteActive(int iSpriteIndex);

        /**
         * Returns the current angle of the sprite in radians, 0 radians being the
         * direction x=0 y=-1 and proceeding clockwise.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve.
         * @return float
         */
        @Signature
        public native float GetSpriteAngleRad(int iSpriteIndex);

        /**
         * Returns the name of the given voice. On iOS this is a human readable first
         * name, but does not give any details about the accent or language of that
         * voice. On Android the name gives the language and accent information but is
         * not as easy to read. Currently only works on iOS and Android.
         *
         * @param index - The index of the voice to check, starts at 0 for the first
         *              voice
         * @return String
         */
        @Signature
        public native String GetSpeechVoiceName(int index);

        /**
         * Returns the current angle of the sprite in degrees, 0 degrees being the
         * direction x=0 y=-1 and proceeding clockwise.
         *
         * @param iSpriteIndex - The ID of the sprite to retrieve.
         * @return float
         */
        @Signature
        public native float GetSpriteAngle(int iSpriteIndex);

        /**
         * Returns the language string of the given voice. This can be used directly
         * with the SetSpeechLanguage command to use this voice for any future speech.
         * Currently only works on iOS and Android.
         *
         * @param index - The index of the voice to check, starts at 0 for the first
         *              voice
         * @return String
         */
        @Signature
        public native String GetSpeechVoiceLanguage(int index);

        /**
         * Returns the ID of the given voice. The ID can be used with
         * SetSpeechLanguageByID to select a specific voice.
         *
         * @param index - The index of the voice to check, starts at 0 for the first
         *              voice
         * @return String
         */
        @Signature
        public native String GetSpeechVoiceID(int index);

        /**
         * Gets the minimum rate and which sound files can be played on this device. A
         * rate of 1.0 is normal speed, a rate of 2.0 would be double speed, 0.5 would
         * be half speed, and so on. If you attempt to change a sound playback rate
         * outside of these values it will be clamped to these values. If both min and
         * max return 1.0 then changing the speed of sound playback is not supported on
         * this device.
         *
         * @return float
         */
        @Signature
        public native float GetSoundMinRate();

        /**
         * Returns the number of voices that can be selected with the SetSpeechLanguage
         * command. You can use the GetSpeechVoiceName and GetSpeechVoiceLanguage
         * commands to get details about the different voices. Currently only works on
         * iOS and Android.
         *
         * @return int
         */
        @Signature
        public native int GetSpeechNumVoices();

        /**
         * Returns the number of instances of this sound ID that are currently playing
         * or looping. This is exactly the same as GetSoundInstances.
         *
         * @param iID - The sound number to check.
         * @return int
         */
        @Signature
        public native int GetSoundsPlaying(int iID);

        /**
         * Gets the maximum rate and which sound files can be played on this device. A
         * rate of 1.0 is normal speed, a rate of 2.0 would be double speed, 0.5 would
         * be half speed, and so on. If you attempt to change a sound playback rate
         * outside of these values it will be clamped to these values. If both min and
         * max return 1.0 then changing the speed of sound playback is not supported on
         * this device.
         *
         * @return float
         */
        @Signature
        public native float GetSoundMaxRate();

        /**
         * Returns the number of instances of this sound ID that are currently playing
         * or looping. This is exactly the same as GetSoundsPlaying.
         *
         * @param iID - The sound number to check.
         * @return int
         */
        @Signature
        public native int GetSoundInstances(int iID);

        /**
         * Returns the current volume of the specified instance, between 0 and 100.
         *
         * @param iID - The ID of the instance to check
         * @return int
         */
        @Signature
        public native int GetSoundInstanceVolume(int iID);

        /**
         * Returns the current playback rate of the specified instance, with 1.0 being
         * normal speed, 2.0 being double speed, and so on. Not all devices are
         * guaranteed to support modifying playback rates.
         *
         * @param iID - The ID of the instance to check
         * @return float
         */
        @Signature
        public native float GetSoundInstanceRate(int iID);

        /**
         * Returns 1 if the given instance is still playing or looping, 0 if it has
         * stopped. The instance ID is the value returned from PlaySound when you
         * initiated the playing of the sound. Once this command returns 0 the instance
         * has been deleted and can no longer be referenced, any attempt to modify it
         * will be ignored. You will need to create a new instance by using PlaySound
         * again.
         *
         * @param iID - The ID of the instance to check
         * @return int
         */
        @Signature
        public native int GetSoundInstancePlaying(int iID);

        /**
         * If the sound was played with looping turned on this command returns the
         * number of loops completed so far. If the instance is using a fixed number of
         * loops then it will never actually reach that loop count value as it will be
         * immediately deleted upon reaching the end of its last loop. The instance ID
         * is the value returned from PlaySound when you initiated the playing of the
         * sound.
         *
         * @param iID - The ID of the instance to check
         * @return int
         */
        @Signature
        public native int GetSoundInstanceLoopCount(int iID);

        /**
         * Returns a value of 1 if the specified sound number exists, otherwise 0 is
         * returned.
         *
         * @param iID - The sound number to check.
         * @return int
         */
        @Signature
        public native int GetSoundExists(int iID);

        /**
         * Will read a string from the socket connection and return it. If you are
         * sending a string from a source other than AGK then the string must begin with
         * a 4 byte length value followed by X bytes of string data, where X is the
         * length value. The string should not be null terminated. If there is less than
         * 4 bytes of data waiting to be read then this command will return immediately
         * and return an empty string. You can check how much data there is to read by
         * using GetSocketBytesAvailable. If there are 4 or more bytes waiting to be
         * read then this command will wait until the entire string has been received
         * before returning.
         *
         * @param socketID - The ID of the socket to read
         * @return String
         */
        @Signature
        public native String GetSocketString(int socketID);

        /**
         * Returns the IP address of the computer or device at the other end of the
         * connection. This could be an IPv4 or IPv6 address.
         *
         * @param socketID - The ID of the socket to check
         * @return String
         */
        @Signature
        public native String GetSocketRemoteIP(int socketID);

        /**
         * Returns the ID of a socket that has connected to your device. The listener
         * will accept connections in the background and add them to a queue, this
         * command removes one of the sockets from the queue and hands control of it to
         * you. If you do not want to accept the connection you should delete it using
         * DeleteSocket. You should call GetSocketListenerConnection in a loop until it
         * returns 0 to be sure you have dealt with all connected sockets. You can find
         * out the IP address of the device that connected to you by calling
         * GetSocketRemoteIP on the returned socket.
         *
         * @param listenerID - The ID of the listener to check
         * @return int
         */
        @Signature
        public native int GetSocketListenerConnection(int listenerID);

        /**
         * Will read a 4 byte integer from the socket connection and return it. If there
         * is less than 4 bytes of data waiting to be read then this command will return
         * immediately and return 0. You can check how much data there is to read by
         * using GetSocketBytesAvailable.
         *
         * @param socketID - The ID of the socket to read
         * @return int
         */
        @Signature
        public native int GetSocketInteger(int socketID);

        /**
         * Will read a 4 byte float from the socket connection and return it. If there
         * is less than 4 bytes of data waiting to be read then this command will return
         * immediately and return 0. You can check how much data there is to read by
         * using GetSocketBytesAvailable.
         *
         * @param socketID - The ID of the socket to read
         * @return float
         */
        @Signature
        public native float GetSocketFloat(int socketID);

        /**
         * Returns 1 if the specified socket exists, 0 otherwise.
         *
         * @param socketID - The ID of the socket to check
         * @return int
         */
        @Signature
        public native int GetSocketExists(int socketID);

        /**
         * Returns 1 if the specified socket is connected, 0 if it is still in the
         * process of connecting. If the socket becomes disconnected or fails to connect
         * then this will return -1.
         *
         * @param socketID - The ID of the socket to check
         * @return int
         */
        @Signature
        public native int GetSocketConnected(int socketID);

        /**
         * Will read a single byte from the socket connection and return it. If there is
         * no data waiting to be read then this command will return immediately and
         * return 0. You can check how much data there is to read by using
         * GetSocketBytesAvailable.
         *
         * @param socketID - The ID of the socket to read
         * @return int
         */
        @Signature
        public native int GetSocketByte(int socketID);

        /**
         * Returns the number of bytes available to be read. If this returns 0 then the
         * read commands, like GetSocketInteger will return no data.
         *
         * @param socketID - The ID of the socket to check
         * @return int
         */
        @Signature
        public native int GetSocketBytesAvailable(int socketID);

        /**
         * Returns the current state of the smart watch connection: 0=initial state,
         * ActivateSmartWatch has not been called. 1=connecting, will transition to a
         * more detailed state in a moment. 2=connection successful, you may send and
         * receive data. -1=watch commands not supported on this device. -2=connection
         * failed or no watch found. -3=watch found but it is not currently paired with
         * the device, -4=watch found but our watch app is not currently installed.
         * Currently only works on iOS.
         *
         * @return int
         */
        @Signature
        public native int GetSmartWatchState();

        /**
         * Gets the Y position of the root of the skeleton, does not change whilst
         * animating.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DY(int iSkeleton);

        /**
         * Gets the X position of the root of the skeleton, does not change whilst
         * animating.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DX(int iSkeleton);

        /**
         * returns 1 if the skeleton is tweening to an animation frame.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @return int
         */
        @Signature
        public native int GetSkeleton2DIsTweening(int iSkeleton);

        /**
         * Returns 1 if a skeleton exists at the specified ID, otherwise 0.
         *
         * @param iSkeleton - The ID of the skeleton to check
         * @return int
         */
        @Signature
        public native int GetSkeleton2DExists(int iSkeleton);

        /**
         * returns 1 if the skeleton is animating, or tweening to the first frame of a
         * playing animation
         *
         * @param iSkeleton - ID of the skeleton to check
         * @return int
         */
        @Signature
        public native int GetSkeleton2DIsAnimating(int iSkeleton);

        /**
         * Get the current time of the currently playing animation in seconds
         *
         * @param iSkeleton - ID of the skeleton to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DCurrentTime(int iSkeleton);

        /**
         * Gets the current depth of the skeleton. This is in the range 0-10000. 0 is on
         * top, 10000 is at the back
         *
         * @param iSkeleton - ID of the skeleton to check
         * @return int
         */
        @Signature
        public native int GetSkeleton2DDepth(int iSkeleton);

        /**
         * Returns the original Y position of the specified bone also known as the setup
         * pose. This value will not change whilst the bone is animating, instead the
         * animation builds on top of the setup pose to create the bone position seen on
         * screen. If the bone does not exist it will return 0. Bone IDs start at 0.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @param bone      - ID of the bone to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DBoneY(int iSkeleton, int bone);

        /**
         * Returns the ID of the parent of the specified bone. If the bone does not
         * exist or it does not / have a parent it will return -1. Indices start at 0.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @param bone      - ID of the bone to check
         * @return int
         */
        @Signature
        public native int GetSkeleton2DBoneParent(int iSkeleton, int bone);

        /**
         * Returns the original X position of the specified bone also known as the setup
         * pose. This value will not change whilst the bone is animating, instead the
         * animation builds on top of the setup pose to create the bone position seen on
         * screen. If the bone does not exist it will return 0. Bone IDs start at 0.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @param bone      - ID of the bone to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DBoneX(int iSkeleton, int bone);

        /**
         * Returns the current Y position of the specified bone in its currently
         * animated position. This value will change whilst the bone is animating. If
         * the bone does not exist it will return 0. Bone IDs start at 0.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @param bone      - ID of the bone to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DBoneCurrY(int iSkeleton, int bone);

        /**
         * Returns the current angle of the specified bone in its currently animated
         * position. This value will change whilst the bone is animating. If the bone
         * does not exist it will return 0. Bone IDs start at 0.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @param bone      - ID of the bone to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DBoneCurrAngle(int iSkeleton, int bone);

        /**
         * Returns the current X position of the specified bone in its currently
         * animated position. This value will change whilst the bone is animating. If
         * the bone does not exist it will return 0. Bone IDs start at 0.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @param bone      - ID of the bone to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DBoneCurrX(int iSkeleton, int bone);

        /**
         * Returns the original angle of the specified bone also known as the setup
         * pose. This value will not change whilst the bone is animating, instead the
         * animation builds on top of the setup pose to create the bone rotation seen on
         * screen. If the bone does not exist it will return 0. Bone IDs start at 0.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @param bone      - ID of the bone to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DBoneAngle(int iSkeleton, int bone);

        /**
         * Returns the ID of the specified bone for this skeleton. If no bone with the
         * given name exists it will return -1. Index 0 is a valid bone.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @param name      - Name of the bone to find
         * @return int
         */
        @Signature
        public native int GetSkeleton2DBone(int iSkeleton, String name);

        /**
         * get the total time of a named animation
         *
         * @param iSkeleton - ID of the skeleton to check
         * @param anim      - NAme of the animation to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DAnimationTime(int iSkeleton, String anim);

        /**
         * Gets the Angle of the root of the skeleton, does not change whilst animating.
         *
         * @param iSkeleton - ID of the skeleton to check
         * @return float
         */
        @Signature
        public native float GetSkeleton2DAngle(int iSkeleton);

        /**
         * Returns the number of polygons drawn by the GPU last frame when constructing
         * shadow maps.
         *
         * @return int
         */
        @Signature
        public native int GetShadowPolygonsDrawn();

        /**
         * Returns 1 if shadow mapping is supported on this device, 0 otherwise.
         *
         * @return int
         */
        @Signature
        public native int GetShadowMappingSupported();

        /**
         * Returns the current shadow mapping mode that was set with
         * SetShadowMappingMode
         *
         * @return int
         */
        @Signature
        public native int GetShadowMappingMode();

        /**
         * Returns 1 if a shader is currently loaded at the given ID, otherwise it
         * returns 0.
         *
         * @param shaderID - The ID of the shader to check
         * @return int
         */
        @Signature
        public native int GetShaderExists(int shaderID);

        /**
         * Returns the seconds of a given unix time value (0 to 59). Unix time is
         * represented as the number of seconds since the 1st Jan 1970, it may also be
         * negative.
         *
         * @param unixtime - A unix time value.
         * @return int
         */
        @Signature
        public native int GetSecondsFromUnix(int unixtime);

        /**
         * Get the number of whole seconds since the app was started. Accurate to 1
         * second. Calling this command will internally make a system call to get the
         * amount of time passed, so it may change each time you call it.
         *
         * @return int
         */
        @Signature
        public native int GetSeconds();

        /**
         * Converts a 3D point into screen coordinates.
         *
         * @param x - The X component of the 3D point.
         * @param y - The Y component of the 3D point.
         * @param z - The Z component of the 3D point.
         * @return float
         */
        @Signature
        public native float GetScreenYFrom3D(float x, float y, float z);

        /**
         * Converts a 3D point into screen coordinates.
         *
         * @param x - The X component of the 3D point.
         * @param y - The Y component of the 3D point.
         * @param z - The Z component of the 3D point.
         * @return float
         */
        @Signature
        public native float GetScreenXFrom3D(float x, float y, float z);

        /**
         * Returns the top edge of the visible screen. This includes any black border
         * area so if there are black borders on the top and bottom of the display then
         * this value will be negative. This represents the fact that 0 is the end of
         * the visible area and the start of the black border, and the top bound is the
         * end of the black border and the edge of the screen. If there is no black
         * border to the top then the top bound will always be 0.
         *
         * @return float
         */
        @Signature
        public native float GetScreenBoundsTop();

        /**
         * Returns the right edge of the visible screen. This includes any black border
         * area so if there are black borders on the left and right of the display then
         * this value will be greater than GetVirtualWidth. This represents the fact
         * that the virtual width is the end of the visible area and the start of the
         * black border, and the right bound is the end of the black border and the edge
         * of the screen. If there is no black border to the right then the right bound
         * will always be equal to GetVirtualWidth.
         *
         * @return float
         */
        @Signature
        public native float GetScreenBoundsRight();

        /**
         * Returns the bottom edge of the visible screen. This includes any black border
         * area so if there are black borders on the top and bottom of the display then
         * this value will be greater than GetVirtualHeight. This represents the fact
         * that the virtual height is the end of the visible area and the start of the
         * black border, and the bottom bound is the end of the black border and the
         * edge of the screen. If there is no black border on the bottom then the bottom
         * bound will always be equal to GetVirtualHeight.
         *
         * @return float
         */
        @Signature
        public native float GetScreenBoundsBottom();

        /**
         * Returns the left edge of the visible screen. This includes any black border
         * area so if there are black borders on the left and right of the display then
         * this value will be negative. This represents the fact that 0 is the end of
         * the visible area and the start of the black border, and the left bound is the
         * end of the black border and the edge of the screen. If there is no black
         * border to the left then the left bound will always be 0.
         *
         * @return float
         */
        @Signature
        public native float GetScreenBoundsLeft();

        /**
         * Returns 1 if the current device has a rotation vector sensor that is
         * currently supported by AGK, 0 if not.
         *
         * @return int
         */
        @Signature
        public native int GetRotationVectorSensorExists();

        /**
         * Returns the value of the currently loaded reward ad, this will return 0 if
         * the reward value is unknown. If no reward ad is currently loaded then this
         * value is undefined, it might be 0 or it might be the value of a previous ad.
         * You should ask the user if they want to view the reward ad before showing it,
         * along with the reward they will get for doing so. You can use this value
         * function to determine an appropriate reward. This value will remain unchanged
         * if ResetRewardAdMob is called
         *
         * @return int
         */
        @Signature
        public native int GetRewardAdValueAdMob();

        /**
         * Returns 1 if the previously displayed reward ad resulted in a reward that
         * should be given to the user, for example some in-game coins. When
         * ShowRewardAdAdMob is called this is set to 0 and only set to 1 if the user
         * completed the reward video, otherwise it will stay at 0. After you have given
         * the user a reward you can set it back to 0 by using ResetRewardAdMob.
         *
         * @return int
         */
        @Signature
        public native int GetRewardAdRewardedChartboost();

        /**
         * Returns 1 if the previously displayed reward ad resulted in a reward that
         * should be given to the user, for example some in-game coins. When
         * ShowRewardAdAdMob is called this is set to 0 and only set to 1 if the user
         * completed the reward video, otherwise it will stay at 0. After you have given
         * the user a reward you can set it back to 0 by using ResetRewardAdMob.
         *
         * @return int
         */
        @Signature
        public native int GetRewardAdRewardedAdMob();

        /**
         * Returns 1 if there is a Chartboost reward ad preloaded and ready to be
         * displayed, otherwise 0. If so you can display it with ShowRewardAdChartboost.
         * Adverts are preloaded after calling CacheRewardAdChartboost and after every
         * reward advert is dismissed by the user. If this command continues to return 0
         * then ad loading may have failed due to the provider running out of ads and
         * AGK will stop trying to load them. In this case you should try your other ad
         * providers instead. If you find all your ad providers are returning 0 then you
         * can try calling CacheRewardAdChartboost again, to restart the loading process
         * to see if any new adverts have become available.
         *
         * @return int
         */
        @Signature
        public native int GetRewardAdLoadedChartboost();

        /**
         * Returns 1 if there is an AdMob reward ad preloaded and ready to be displayed,
         * otherwise 0. If so you can display it with ShowRewardAdAdMob. Adverts are
         * preloaded as soon as you set your AdMob reward details and after every reward
         * advert is dismissed by the user. If this command continues to return 0 then
         * ad loading may have failed due to the provider running out of ads and AGK
         * will stop trying to load them. In this case you should try your other ad
         * providers instead. If you find all your ad providers are returning 0 then you
         * can try calling ShowRewardAdAdMob anyway, it will not display anything as
         * there is nothing loaded, but it will restart the loading process to see if
         * any new adverts have become available.
         *
         * @return int
         */
        @Signature
        public native int GetRewardAdLoadedAdMob();

        /**
         * Returns 1 if your app has been passed to the background and has just been
         * reactivated. You should activate a pause screen when this happens. On mobile
         * platforms apps will not run whilst they are in the background so that first
         * chance you app will get to receive this notification is when it returns from
         * the background and continues running. Since the user may not yet be ready to
         * continue playing you should check this value and show a pause screen until
         * they are ready.
         *
         * @return int
         */
        @Signature
        public native int GetResumed();

        /**
         * Returns the directory that contains the application executable on the current
         * platform that the app is running on. Note that on Android this path is
         * inaccessible in normal use and will return an empty string.
         *
         * @return String
         */
        @Signature
        public native String GetReadPath();

        /**
         * Returns the name of the current renderer, e.g. "OpenGL" or "OpenGLES"
         *
         * @return String
         */
        @Signature
        public native String GetRendererName();

        /**
         * Returns the Y coordinate of the intersection point of the most recent ray
         * cast check. The result is in world coordinates.
         *
         * @return float
         */
        @Signature
        public native float GetRayCastY();

        /**
         * Returns the X coordinate of the intersection point of the most recent ray
         * cast check. The result is in world coordinates.
         *
         * @return float
         */
        @Signature
        public native float GetRayCastX();

        /**
         * Returns the ID of the sprite hit in the most recent ray cast check. If the
         * ray hit a non-sprite shape 0 will be returned.
         *
         * 
         * @return int
         */
        @Signature
        public native int GetRayCastSpriteID();

        /**
         * Returns the X component of the normal of the most recent ray cast check. This
         * will not be a unit vector as it has been converted to world coordinates.
         *
         * @return float
         */
        @Signature
        public native float GetRayCastNormalX();

        /**
         * Returns the Y component of the normal of the most recent ray cast check. This
         * will not be a unit vector as it has been converted to world coordinates.
         *
         * @return float
         */
        @Signature
        public native float GetRayCastNormalY();

        /**
         * Returns the fraction of the ray travelled before reaching a collision. 0
         * represents the start of the ray and 1.0 represents the end of the ray.
         *
         * @return float
         */
        @Signature
        public native float GetRayCastFraction();

        /**
         * Returns the type of the given touch event. All you can be sure about with
         * unknown events is that the finger is currently on screen and has been there
         * less than 1 second. After 1 second it automatically becomes a hold event. If
         * the user lifts their finger off the screen before this then it becomes a
         * short event, and if they move their finger further than the distance
         * specified by SetRawTouchMoveSensitivity then it becomes a drag event. If the
         * current event is not known then it returns 0. Events may change from being
         * hold events to being drag events, but short and drag events do not change
         * type. Unknown events are guaranteed to change type once more information is
         * available. Possible return values are 0 to indicate unknown, 1 for a short
         * touch, 2 for a hold and 3 for dragging.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @return int
         */
        @Signature
        public native int GetRawTouchType(int iIndex);

        /**
         * Retrieves a value previously stored in this event by SetRawTouchValue.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @return int
         */
        @Signature
        public native int GetRawTouchValue(int iIndex);

        /**
         * Returns the total time that this event took, from press to release in
         * seconds.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @return float
         */
        @Signature
        public native float GetRawTouchTime(int iIndex);

        /**
         * Returns the Y position in screen coordinates where the touch event started.
         * This coordinate will be in view coordinates, if you are offsetting the view
         * port you may want to convert it to world coordinates using ScreenToWorldY.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @return float
         */
        @Signature
        public native float GetRawTouchStartY(int iIndex);

        /**
         * Returns the X position in screen coordinates where the touch event started.
         * This coordinate will be in view coordinates, if you are offsetting the view
         * port you may want to convert it to world coordinates using ScreenToWorldX.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @return float
         */
        @Signature
        public native float GetRawTouchStartX(int iIndex);

        /**
         * Returns 1 if the touch has been released, this will always be 1 for short
         * events, hold and drag events will keep reporting 0 until they are released at
         * which point you may wish to take some action. Each event will only report
         * released as 1 once before being removed from the event list. If a touch event
         * is ignored (not queried) for one frame after it is released it will be
         * deleted from the event list.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @return int
         */
        @Signature
        public native int GetRawTouchReleased(int iIndex);

        /**
         * Returns the Y position in screen coordinates where the touch event was last
         * recorded before its current location. This coordinate will be in view
         * coordinates, if you are offsetting the view port you may want to convert it
         * to world coordinates using ScreenToWorldY.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @return float
         */
        @Signature
        public native float GetRawTouchLastY(int iIndex);

        /**
         * Returns the X position in screen coordinates where the touch event was last
         * recorded before its current location. This coordinate will be in view
         * coordinates, if you are offsetting the view port you may want to convert it
         * to world coordinates using ScreenToWorldX.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @return float
         */
        @Signature
        public native float GetRawTouchLastX(int iIndex);

        /**
         * Returns the Y position in screen coordinates where the touch event is
         * currently located. This coordinate will be in view coordinates, if you are
         * offsetting the view port you may want to convert it to world coordinates
         * using ScreenToWorldY.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @return float
         */
        @Signature
        public native float GetRawTouchCurrentY(int iIndex);

        /**
         * Returns the number of touch events currently taking place. By default the AGK
         * does not count an event until it knows what type of event it is, e.g. short,
         * long, drag, etc. To count unknown events as well, set bIncludeUnknown to 1.
         * Use 0 to ignore unknown events.
         *
         * @param bIncludeUnknown - Set to 1 to count unknown events which may become
         *                        any type of touch event in the future.
         * @return int
         */
        @Signature
        public native int GetRawTouchCount(int bIncludeUnknown);

        /**
         * Returns the Z component of the current device orientation as a quaternion.
         * This can be applied to cameras with SetCameraRotationQuat to use the device
         * like a virtual reality headset. This command does internal calculations based
         * on the SetOrientationAllowed values to produce the correct camera orientation
         * for the current device orientation. This command is designed for use with
         * cameras, if you want to orientate an object use GetRawRotationVectorZ
         *
         * @return float
         */
        @Signature
        public native float GetRawRotationVectorZ2();

        /**
         * Returns the X position in screen coordinates where the touch event is
         * currently located. This coordinate will be in view coordinates, if you are
         * offsetting the view port you may want to convert it to world coordinates
         * using ScreenToWorldX.
         *
         * @param iIndex - The index of the event to check, received from
         *               GetRawNextTouchEvent or GetRawFirstTouchEvent.
         * @return float
         */
        @Signature
        public native float GetRawTouchCurrentX(int iIndex);

        /**
         * Returns the Z component of the current device orientation as a quaternion.
         * This can be applied to objects with the SetObjectRotationQuat to mimic the
         * device orientation with an object. This command is designed for use with
         * objects, if you want to orientate the camera use GetRawRotationVectorZ2
         *
         * @return float
         */
        @Signature
        public native float GetRawRotationVectorZ();

        /**
         * Returns the Y component of the current device orientation as a quaternion.
         * This can be applied to cameras with SetCameraRotationQuat to use the device
         * like a virtual reality headset. This command does internal calculations based
         * on the SetOrientationAllowed values to produce the correct camera orientation
         * for the current device orientation. This command is designed for use with
         * cameras, if you want to orientate an object use GetRawRotationVectorY
         *
         * @return float
         */
        @Signature
        public native float GetRawRotationVectorY2();

        /**
         * Returns the X component of the current device orientation as a quaternion.
         * This can be applied to cameras with SetCameraRotationQuat to use the device
         * like a virtual reality headset. This command does internal calculations based
         * on the SetOrientationAllowed values to produce the correct camera orientation
         * for the current device orientation. This command is designed for use with
         * cameras, if you want to orientate an object use GetRawRotationVectorX
         *
         * @return float
         */
        @Signature
        public native float GetRawRotationVectorX2();

        /**
         * Returns the Y component of the current device orientation as a quaternion.
         * This can be applied to objects with the SetObjectRotationQuat to mimic the
         * device orientation with an object. This command is designed for use with
         * objects, if you want to orientate the camera use GetRawRotationVectorY2
         *
         * @return float
         */
        @Signature
        public native float GetRawRotationVectorY();

        /**
         * Returns the X component of the current device orientation as a quaternion.
         * This can be applied to objects with the SetObjectRotationQuat to mimic the
         * device orientation with an object. This command is designed for use with
         * objects, if you want to orientate the camera use GetRawRotationVectorX2
         *
         * @return float
         */
        @Signature
        public native float GetRawRotationVectorX();

        /**
         * Returns the W component of the current device orientation as a quaternion.
         * This can be applied to cameras with SetCameraRotationQuat to use the device
         * like a virtual reality headset. This command does internal calculations based
         * on the SetOrientationAllowed values to produce the correct camera orientation
         * for the current device orientation. This command is designed for use with
         * cameras, if you want to orientate an object use GetRawRotationVectorW
         *
         * @return float
         */
        @Signature
        public native float GetRawRotationVectorW2();

        /**
         * Returns the W component of the current device orientation as a quaternion.
         * This can be applied to objects with the SetObjectRotationQuat to mimic the
         * device orientation with an object. This command is designed for use with
         * objects, if you want to orientate the camera use GetRawRotationVectorW2
         *
         * @return float
         */
        @Signature
        public native float GetRawRotationVectorW();

        /**
         * If a proximity sensor exists, returns the distance of the device from any
         * object currently in front of it, untested as no device supported it during
         * testing.
         *
         * @return float
         */
        @Signature
        public native float GetRawProximityDistance();

        /**
         * Returns an index to the next touch event available for reading, if no more
         * events are available it returns 0.
         *
         * 
         * @return int
         */
        @Signature
        public native int GetRawNextTouchEvent();

        /**
         * Returns the Y component of the current mouse position in screen coordinates.
         * If no mouse exists it will always return 0.
         *
         * @return float
         */
        @Signature
        public native float GetRawMouseY();

        /**
         * Returns the X component of the current mouse position in screen coordinates.
         * If no mouse exists it will always return 0.
         *
         * @return float
         */
        @Signature
        public native float GetRawMouseX();

        /**
         * Returns the difference between the current mouse wheel position and the
         * previous mouse wheel position, can be positive or negative, updated once a
         * frame. If no mouse exists it will always return 0.
         *
         * @return float
         */
        @Signature
        public native float GetRawMouseWheelDelta();

        /**
         * Returns the current position of the mouse wheel, can be positive or negative,
         * starts at 0. If no mouse exists it will always return 0.
         *
         * @return float
         */
        @Signature
        public native float GetRawMouseWheel();

        /**
         * Returns 1 if the right mouse button is currently down, 0 if not. If no mouse
         * exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseRightState();

        /**
         * Returns 1 if the right mouse button has been released, then returns 0 whilst
         * the button is up. If no mouse exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseRightReleased();

        /**
         * Returns 1 if the right mouse button has been pressed, then returns 0 whilst
         * the button is held down. If no mouse exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseRightPressed();

        /**
         * Returns 1 if the middle mouse button is currently down, 0 if not. If no mouse
         * exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseMiddleState();

        /**
         * Returns 1 if the middle mouse button has been released, then returns 0 whilst
         * the button is up. If no mouse exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseMiddleReleased();

        /**
         * Returns 1 if the middle mouse button has been pressed, then returns 0 whilst
         * the button is held down. If no mouse exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseMiddlePressed();

        /**
         * Returns 1 if the left mouse button is currently down, 0 if not. If no mouse
         * exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseLeftState();

        /**
         * Returns 1 if the left mouse button has been released, then returns 0 whilst
         * the button is up. If no mouse exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseLeftReleased();

        /**
         * Returns 1 if the left mouse button has been pressed, then returns 0 whilst
         * the button is held down. If no mouse exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseLeftPressed();

        /**
         * Returns 1 if the fourth mouse button is currently down, 0 if not. If no mouse
         * exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseFourthState();

        /**
         * Returns 1 if the fourth mouse button has been released, then returns 0 whilst
         * the button is up. If no mouse exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseFourthReleased();

        /**
         * Returns 1 if the fourth mouse button has been pressed, then returns 0 whilst
         * the button is held down. If no mouse exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseFourthPressed();

        /**
         * Returns 1 if the fifth mouse button has been released, then returns 0 whilst
         * the button is up. If no mouse exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseFifthReleased();

        /**
         * Returns 1 if the fifth mouse button is currently down, 0 if not. If no mouse
         * exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseFifthState();

        /**
         * If an magnetic sensor exists, returns the Z component of any surrounding
         * magnetic field. On iOS it may take a few seconds to start displaying data
         * other than 0, during this process the device is using motion data to
         * calibrate the magnetic sensor
         *
         * @return float
         */
        @Signature
        public native float GetRawMagneticZ();

        /**
         * Returns 1 if the fifth mouse button has been pressed, then returns 0 whilst
         * the button is held down. If no mouse exists it will always return 0.
         *
         * @return int
         */
        @Signature
        public native int GetRawMouseFifthPressed();

        /**
         * If an magnetic sensor exists, returns the Y component of any surrounding
         * magnetic field. On iOS it may take a few seconds to start displaying data
         * other than 0, during this process the device is using motion data to
         * calibrate the magnetic sensor
         *
         * @return float
         */
        @Signature
        public native float GetRawMagneticY();

        /**
         * If an magnetic sensor exists, returns the X component of any surrounding
         * magnetic field. On iOS it may take a few seconds to start displaying data
         * other than 0, during this process the device is using motion data to
         * calibrate the magnetic sensor
         *
         * @return float
         */
        @Signature
        public native float GetRawMagneticX();

        /**
         * If an ambient light sensor exists, get the measurement of the surrounding
         * light in lumels as a float.
         *
         * @return float
         */
        @Signature
        public native float GetRawLightLevel();

        /**
         * Returns the key code of the last key pressed. This only applies to platforms
         * with a full sized keyboard such as PC, Mac, and Linux. You can check if a
         * keyboard exists by using GetKeyboardExists. This function continue to return
         * the last key pressed even when the key has been released. Check out the scan
         * codes page in the guides section of the help files to see which key matches
         * which key code
         *
         * 
         * @return int
         */
        @Signature
        public native int GetRawLastKey();

        /**
         * Returns 1 if the key code given is currently down. 0 if it is up. This only
         * applies to platforms with a full sized keyboard such as PC and Mac, otherwise
         * all keys will return 0. You can check if a keyboard exists by checking
         * GetKeyboardExists returns 1. Key codes are in the range 0 to 255, anything
         * out of range will return 0. Check out the scan codes page in the guides
         * section of the help files to see which key matches which key code
         *
         * @param key - The key code of the key to check.
         * @return int
         */
        @Signature
        public native int GetRawKeyState(int key);

        /**
         * Returns 1 if the key code given was released this frame, then returns 0
         * whilst the key is up. This only applies to platforms with a full sized
         * keyboard such as PC and Mac, otherwise all keys will return 0. You can check
         * if a keyboard exists by checking GetKeyboardExists returns 1. Key codes are
         * in the range 0 to 255, anything out of range will return 0. Check out the
         * scan codes page in the guides section of the help files to see which key
         * matches which key code
         *
         * @param key - The key code of the key to check.
         * @return int
         */
        @Signature
        public native int GetRawKeyReleased(int key);

        /**
         * Returns the current Z value (if applicable) for the physical joystick at the
         * given index. This will be in the range -1.0 to 1.0 with 0 being centered.
         *
         * @param index - The ID of the joystick to check.
         * @return float
         */
        @Signature
        public native float GetRawJoystickZ(int index);

        /**
         * Returns the current Y value for the physical joystick at the given index.
         * This will be in the range -1.0 to 1.0 with 0 being centered.
         *
         * @param index - The ID of the joystick to check.
         * @return float
         */
        @Signature
        public native float GetRawJoystickY(int index);

        /**
         * Returns 1 if the key code given was pressed this frame, then returns 0 whilst
         * the key is held down. This only applies to platforms with a full sized
         * keyboard such as PC and Mac, otherwise all keys will return 0. You can check
         * if a keyboard exists by checking GetKeyboardExists returns 1. Key codes are
         * in the range 0 to 255, anything out of range will return 0. Check out the
         * scan codes page in the guides section of the help files to see which key
         * matches which key code
         *
         * @param key - The key code of the key to check.
         * @return int
         */
        @Signature
        public native int GetRawKeyPressed(int key);

        /**
         * Returns the current X value for the physical joystick at the given index.
         * This will be in the range -1.0 to 1.0 with 0 being centered.
         *
         * @param index - The ID of the joystick to check.
         * @return float
         */
        @Signature
        public native float GetRawJoystickX(int index);

        /**
         * Returns the current value of the joystick slider, this can vary based on
         * joystick type. Currently the slider index must be either 0 or 1. Sliders are
         * typically used for additional axes.
         *
         * @param index  - The ID of the joystick to check.
         * @param slider - The index of the slider to check.
         * @return int
         */
        @Signature
        public native int GetRawJoystickSlider(int index, int slider);

        /**
         * Returns the current rotational Z value (if applicable) for the physical
         * joystick at the given index. This will be in the range -1.0 to 1.0 with 0
         * being centered. In reality some joystick devices use this value for a second
         * analogue stick.
         *
         * @param index - The ID of the joystick to check.
         * @return float
         */
        @Signature
        public native float GetRawJoystickRZ(int index);

        /**
         * Returns the current rotational X value (if applicable) for the physical
         * joystick at the given index. This will be in the range -1.0 to 1.0 with 0
         * being centered. In reality some joystick devices use this value for a second
         * analogue stick.
         *
         * @param index - The ID of the joystick to check.
         * @return float
         */
        @Signature
        public native float GetRawJoystickRX(int index);

        /**
         * Returns the current rotational Y value (if applicable) for the physical
         * joystick at the given index. This will be in the range -1.0 to 1.0 with 0
         * being centered. In reality some joystick devices use this value for a second
         * analogue stick.
         *
         * @param index - The ID of the joystick to check.
         * @return float
         */
        @Signature
        public native float GetRawJoystickRY(int index);

        /**
         * Returns the current value of the joystick POV, this can vary based on
         * joystick type. Currently the POV index must be either 0, 1, 2, or 3
         *
         * @param index - The ID of the joystick to check.
         * @param pov   - The index of the POV to check.
         * @return int
         */
        @Signature
        public native int GetRawJoystickPOV(int index, int pov);

        /**
         * Returns the name of the joystick as discovered by the operating system,
         * currently only works on Windows and Linux. In Tier 2 the string is encoded in
         * UTF-8, and must be deleted with agk::DeleteString when you are done with it.
         *
         * @param index - The ID of the joystick to check.
         * @return String
         */
        @Signature
        public native String GetRawJoystickName(int index);

        /**
         * Returns 1 if a joystick exists at the given index. Physical joysticks are
         * detected at startup and placed in IDs 1-8 incrementally. You should call
         * CompleteRawJoystickDetection at some point before this command to make sure
         * that all present joysticks have been discovered. After the initial detection
         * process plugging in additional joysticks will not be detected (except on
         * Android which will detect new joysticks). Unplugging a joystick will not
         * delete its index and this command will still return 1. You can use
         * GetRawJoystickConnected to detect when a previously detected joystick is
         * disconnected. If a disconnected joystick is reattached the AGK will attempt
         * to reconnect to it. An alternative version of this command exists
         * GetJoystickExists, in which case it will return 1 if there are any raw
         * joysticks attached.
         *
         * @param index - The ID of the joystick to check.
         * @return int
         */
        @Signature
        public native int GetRawJoystickExists(int index);

        /**
         * Returns 1 if the given button is currently down, otherwise returns 0. To
         * detect the instance that a button is pressed or released use
         * GetRawJoystickButtonPressed or GetRawJoystickButtonReleased. AGK supports up
         * to 64 joystick buttons in the range 1-64.
         *
         * @param index  - The ID of the joystick to check.
         * @param button - The ID of the button to check.
         * @return int
         */
        @Signature
        public native int GetRawJoystickButtonState(int index, int button);

        /**
         * Returns 1 if the specified joystick is connected, 0 if not. This only applies
         * to joysticks that were plugged in when the app started, plugging in a new
         * joystick after the app has started will not be detected. Use
         * GetRawJoystickExists to find out which joysticks were detected at startup.
         * This command currently does not work on Mac.
         *
         * @param index - The ID of the joystick to check.
         * @return int
         */
        @Signature
        public native int GetRawJoystickConnected(int index);

        /**
         * Returns 1 if the given button was released this frame, otherwise returns 0.
         * Once the button has been released this function returns to 0, to check the
         * state of the button use GetRawJoystickButtonState. AGK supports up to 64
         * joystick buttons in the range 1-64.
         *
         * @param index  - The ID of the joystick to check.
         * @param button - The ID of the button to check.
         * @return int
         */
        @Signature
        public native int GetRawJoystickButtonReleased(int index, int button);

        /**
         * Returns 1 if the given button was pressed this frame, otherwise returns 0.
         * Once the button has been pressed this function returns to 0, to check the
         * state of the button use GetRawJoystickButtonState. AGK supports up to 64
         * joystick buttons in the range 1-64.
         *
         * @param index  - The ID of the joystick to check.
         * @param button - The ID of the button to check.
         * @return int
         */
        @Signature
        public native int GetRawJoystickButtonPressed(int index, int button);

        /**
         * If a gyroscope exists, returns the Z component of the current device rotation
         * speed. If you have not used SetOrientationAllowed to select your desired
         * orientation then this command will lock the device in the current orientation
         * to prevent the screen from rotating. You should use SetOrientationAllowed if
         * you want to enable screen rotation when using the gyroscope.
         *
         * @return float
         */
        @Signature
        public native float GetRawGyroVelocityZ();

        /**
         * If a gyroscope exists, returns the Y component of the current device rotation
         * speed. If you have not used SetOrientationAllowed to select your desired
         * orientation then this command will lock the device in the current orientation
         * to prevent the screen from rotating. You should use SetOrientationAllowed if
         * you want to enable screen rotation when using the gyroscope.
         *
         * @return float
         */
        @Signature
        public native float GetRawGyroVelocityY();

        /**
         * Returns the most up to date longitude available.
         *
         * @return float
         */
        @Signature
        public native float GetRawGPSLongitude();

        /**
         * If a gyroscope exists, returns the X component of the current device rotation
         * speed. If you have not used SetOrientationAllowed to select your desired
         * orientation then this command will lock the device in the current orientation
         * to prevent the screen from rotating. You should use SetOrientationAllowed if
         * you want to enable screen rotation when using the gyroscope.
         *
         * @return float
         */
        @Signature
        public native float GetRawGyroVelocityX();

        /**
         * Returns the most up to date latitude available.
         *
         * @return float
         */
        @Signature
        public native float GetRawGPSLatitude();

        /**
         * Returns the most up to date altitude available in meters above sea level.
         *
         * @return float
         */
        @Signature
        public native float GetRawGPSAltitude();

        /**
         * Returns the number of folders that were found when the OpenRawFolder was
         * called.
         *
         * @param ID - The ID of the folder to check
         * @return int
         */
        @Signature
        public native int GetRawFolderNumFolders(int ID);

        /**
         * Returns the number of files that were found when the OpenRawFolder was
         * called.
         *
         * @param ID - The ID of the folder to check
         * @return int
         */
        @Signature
        public native int GetRawFolderNumFiles(int ID);

        /**
         * Return a particular folder name from the file list, the index must be in the
         * range 0 to GetRawFolderNumFolders minus one.
         *
         * @param ID    - The ID of the folder to check
         * @param index - The index of the folder to return, indices start at 0
         * @return String
         */
        @Signature
        public native String GetRawFolderFolderName(int ID, int index);

        /**
         * Return a particular filename from the file list, the index must be in the
         * range 0 to GetRawFolderNumFiles minus one.
         *
         * @param ID    - The ID of the folder to check
         * @param index - The index of the file to return, indices start at 0
         * @return String
         */
        @Signature
        public native String GetRawFolderFileName(int ID, int index);

        /**
         * If an accelerometer exists, returns the current accelerometer reading for the
         * Z direction in the range -1 to 1. A positive Z value means the screen is
         * facing upwards. If no accelerometer exists this will always return 0, there
         * is no emulated command for the Z direction. If you have not used
         * SetOrientationAllowed to select your desired orientation then this command
         * will lock the device in the current orientation to prevent the accelerometer
         * rotating the screen. You should use SetOrientationAllowed if you want to
         * enable screen rotation when using the accelerometer.
         *
         * @return float
         */
        @Signature
        public native float GetRawAccelZ();

        /**
         * Returns an index to the first touch event available for reading. By default
         * the AGK does not count an event until it knows what type of event it is, e.g.
         * short, long, drag, etc. To receive unknown events as well set bIncludeUnknown
         * to 1. Use 0 to ignore unknown events. All you can be sure about with unknown
         * events is that the finger is currently on screen and has been there less than
         * 1 second. After 1 second it automatically becomes a hold event. If the user
         * lifts their finger off the screen it becomes a short event, and if they move
         * their finger it becomes a drag event. If no events are available it returns
         * 0.
         *
         * @param bIncludeUnknown - Set to true to receive unknown events which may
         *                        become any type of event in the future.
         * @return int
         */
        @Signature
        public native int GetRawFirstTouchEvent(int bIncludeUnknown);

        /**
         * If an accelerometer exists, returns the current accelerometer reading for the
         * X direction in the range -1 to 1. This matches the screen coordinate system
         * of positive being to the right. If no accelerometer exists this will always
         * return 0. You can use the GetDirectionX command to emulate a direction input.
         * If you have not used SetOrientationAllowed to select your desired orientation
         * then this command will lock the device in the current orientation to prevent
         * the accelerometer rotating the screen. You should use SetOrientationAllowed
         * if you want to enable screen rotation when using the accelerometer.
         *
         * @return float
         */
        @Signature
        public native float GetRawAccelX();

        /**
         * If an accelerometer exists, returns the current accelerometer reading for the
         * Y direction in the range -1 to 1. This matches the screen coordinate system
         * of positive being down. If no accelerometer exists this will always return 0.
         * You can use the GetDirectionY command to emulate a direction input. If you
         * have not used SetOrientationAllowed to select your desired orientation then
         * this command will lock the device in the current orientation to prevent the
         * accelerometer rotating the screen. You should use SetOrientationAllowed if
         * you want to enable screen rotation when using the accelerometer.
         *
         * @return float
         */
        @Signature
        public native float GetRawAccelY();

        /**
         * Returns the push notification token for this device, this must be sent to
         * your server that sends out the notifications so that it can send
         * notifications to this device. If PushNotificationSetup returned 1 then you
         * should keep calling this command until it returns a non-empty string. If
         * PushNotificationSetup returned 0 then this command will always return an
         * empty string. Please see the guide on Android Push Notifications for more
         * details on how to use the device token to send push notifications to this
         * device.
         *
         * @return String
         */
        @Signature
        public native String GetPushNotificationToken();

        /**
         * Returns 1 if the current device has a proximity sensor that is currently
         * supported by AGK, 0 if not.
         *
         * @return int
         */
        @Signature
        public native int GetProximitySensorExists();

        /**
         * Returns the number of polygons drawn by the GPU last frame.
         *
         * @return int
         */
        @Signature
        public native int GetPolygonsDrawn();

        /**
         * This is an emulated input method that uses whatever device inputs are
         * available to produce a screen pointer. If the device has a mouse then this
         * returns the current Y position of the mouse. Otherwise the AGK will check for
         * a touch screen and, if found, will return the Y position of the most recent
         * touch event. If no events are taking place it is the last Y position recorded
         * by a touch event. On devices that have neither mice nor touch screens the AGK
         * will attempt to create some form of screen pointer controlled by analog
         * sticks or similar. This coordinate will be in view coordinates, if you are
         * offsetting the view port you may want to convert it to world coordinates
         * using ScreenToWorldY.
         *
         * @return float
         */
        @Signature
        public native float GetPointerY();

        /**
         * This is an emulated input method that uses whatever device inputs are
         * available to produce a screen pointer. If the device has a mouse then this
         * returns the current X position of the mouse. Otherwise the AGK will check for
         * a touch screen and, if found, will return the X position of the most recent
         * touch event. If no events are taking place it is the last X position recorded
         * by a touch event. On devices that have neither mice nor touch screens the AGK
         * will attempt to create some form of screen pointer controlled by analog
         * sticks or similar. This coordinate will be in view coordinates, if you are
         * offsetting the view port you may want to convert it to world coordinates
         * using ScreenToWorldX.
         *
         * @return float
         */
        @Signature
        public native float GetPointerX();

        /**
         * This is an emulated input method that uses whatever device inputs are
         * available to produce a screen pointer. If the device has a mouse then this
         * will return 1 if the left mouse button is currently down, 0 if not. Otherwise
         * the AGK will check for a touch screen and, if found, return 1 if one or more
         * touch events are currently being pressed. On devices that have neither mice
         * nor touch screens the AGK will attempt to create some form of screen pointer
         * controlled by analog sticks or similar. There are three commands for getting
         * the state of the pointer press, GetPointerPressed returns 1 the instant the
         * pointer is pressed and then returns 0, GetPointerReleased returns 1 the
         * instant the pointer is released and then returns 0, GetPointerState returns 1
         * the entire time the pointer is in the pressed state.
         *
         * @return int
         */
        @Signature
        public native int GetPointerState();

        /**
         * This is an emulated input method that uses whatever device inputs are
         * available to produce a screen pointer. If the device has a mouse then this
         * will return 1 if the left mouse button is released, 0 if not. Otherwise the
         * AGK will check for a touch screen and, if found, return 1 if one or more
         * touch events are released. On devices that have neither mice nor touch
         * screens the AGK will attempt to create some form of screen pointer controlled
         * by analog sticks or similar. There are three commands for getting the state
         * of the pointer press, GetPointerPressed returns 1 the instant the pointer is
         * pressed and then returns 0, GetPointerReleased returns 1 the instant the
         * pointer is released and then returns 0, GetPointerState returns 1 the entire
         * time the pointer is in the pressed state.
         *
         * @return int
         */
        @Signature
        public native int GetPointerReleased();

        /**
         * This is an emulated input method that uses whatever device inputs are
         * available to produce a screen pointer. If the device has a mouse then this
         * will return 1 if the left mouse button is pressed, 0 if not. Otherwise the
         * AGK will check for a touch screen and, if found, return 1 if one or more
         * touch events exist. On devices that have neither mice nor touch screens the
         * AGK will attempt to create some form of screen pointer controlled by analog
         * sticks or similar. There are three commands for getting the state of the
         * pointer press, GetPointerPressed returns 1 the instant the pointer is pressed
         * and then returns 0, GetPointerReleased returns 1 the instant the pointer is
         * released and then returns 0, GetPointerState returns 1 the entire time the
         * pointer is in the pressed state.
         *
         * @return int
         */
        @Signature
        public native int GetPointerPressed();

        /**
         * returns 1 if the specified point light exists, 0 otherwise.
         *
         * @param lightID - The ID of the light to check.
         * @return int
         */
        @Signature
        public native int GetPointLightExists(int lightID);

        /**
         * Returns an estimate of the number of pixels that were drawn to the screen
         * last frame. Generally the lower this value the better the performance. The
         * number of pixels drawn can be greater than the number of pixels in the screen
         * since overlapping sprites might draw the same pixel twice.
         *
         * @return int
         */
        @Signature
        public native int GetPixelsDrawn();

        /**
         * Returns the number of seconds and fractions of seconds spent updating the
         * physics simulation.
         *
         * @return float
         */
        @Signature
        public native float GetPhysicsTime();

        /**
         * Returns the number of milliseconds spent in the solver
         *
         * @return float
         */
        @Signature
        public native float GetPhysicsSolveTime();

        /**
         * Returns the number of islands the solver processed last step
         *
         * @return int
         */
        @Signature
        public native int GetPhysicsIslandCount();

        /**
         * Returns the Y coordinate of the collision point from the last call to
         * GetPhysicsCollision relative to the first sprite's offset.
         *
         * 
         * @return float
         */
        @Signature
        public native float GetPhysicsCollisionY();

        /**
         * Returns the X coordinate of the collision point from the last call to
         * GetPhysicsCollision relative to the first sprite's offset.
         *
         * 
         * @return float
         */
        @Signature
        public native float GetPhysicsCollisionX();

        /**
         * Returns the X coordinate of the collision point from the last call to
         * GetPhysicsCollision in world coordinates.
         *
         * 
         * @return float
         */
        @Signature
        public native float GetPhysicsCollisionWorldX();

        /**
         * Returns the Y coordinate of the collision point from the last call to
         * GetPhysicsCollision in world coordinates.
         *
         * 
         * @return float
         */
        @Signature
        public native float GetPhysicsCollisionWorldY();

        /**
         * Returns 1 if your desktop app loses focus. You can choose to activate a pause
         * screen when this happens or let the app continue as normal. This only applies
         * to desktop platforms, on mobile platforms you should use GetResumed instead.
         *
         * @return int
         */
        @Signature
        public native int GetPaused();

        /**
         * Returns 1 if two physics sprites overlap, otherwise it returns 0. This
         * function doesn't do any calculation, it simply looks up the results of the
         * last physics step to determine if the sprites currently overlap. If this
         * function returns true you can get the point of collision using
         * GetPhysicsCollisionX and GetPhysicsCollisionY, if there is more than one
         * point of collision it is not known which point will be returned. You can
         * check the sprite's contact list to get the full list of contact points. This
         * function is affected by group and category settings.
         *
         * @param iSprite1 - The ID of the first sprite to check
         * @param iSprite2 - The ID of the second sprite to check
         * @return int
         */
        @Signature
        public native int GetPhysicsCollision(int iSprite1, int iSprite2);

        /**
         * Returns the current Y position of the emitter, this is the point that new
         * particles will appear from. It is not possible to get the position of
         * individual particles, they are merely created, follow a path influenced by
         * forces, and then disappear.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float GetParticlesY(int ID);

        /**
         * Returns the current X position of the emitter, this is the point that new
         * particles will appear from. It is not possible to get the position of
         * individual particles, they are merely created, follow a path influenced by
         * forces, and then disappear.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float GetParticlesX(int ID);

        /**
         * Returns 0 if the given particles have been set as invisible using
         * SetParticlesVisible, or 1 if they are currently set as visible (default).
         * This does not check if the particles are within the visible viewport.
         *
         * @param ID - The ID of the emitter to check.
         * @return int
         */
        @Signature
        public native int GetParticlesVisible(int ID);

        /**
         * Returns 1 if the emitter has emitted the number of particles specified in
         * SetParticlesMax and all emitted particles have since died, otherwise returns
         * 0. If the max is set at -1 this will always return 0. To reset the count and
         * make the emitter start emitting again use ResetParticleCount.
         *
         * @param ID - The ID of the emitter to check.
         * @return int
         */
        @Signature
        public native int GetParticlesMaxReached(int ID);

        /**
         * Returns the current size of all particles in world coordinates. For details
         * on setting the particle size see SetParticlesSize.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float GetParticlesSize(int ID);

        /**
         * Returns the current life of particles in seconds. It is not possible to get
         * the current life of individual particles. This value is independent of frame
         * rate.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float GetParticlesLife(int ID);

        /**
         * Returns 1 if a particle emitter exists at the given ID. 0 if not.
         *
         * @param ID - The ID of the emitter to check.
         * @return int
         */
        @Signature
        public native int GetParticlesExists(int ID);

        /**
         * Returns the current frequency of particle generation in particles per second.
         * This value is independent of frame rate.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float GetParticlesFrequency(int ID);

        /**
         * Returns the X component of the emitter direction, which is the base direction
         * that particles will be moving when they are created. Particles can vary their
         * direction slightly when emitted based on the current GetParticlesAngle value.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float GetParticlesDirectionX(int ID);

        /**
         * Returns the y component of the emitter direction, which is the base direction
         * that particles will be moving when they are created. Particles can vary their
         * direction slightly when emitted based on the current SetParticlesAngle value.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float GetParticlesDirectionY(int ID);

        /**
         * Returns the current depth that all particles will be drawn at. This value is
         * in the range 0 to 10000 with 0 being the front of the screen.
         *
         * @param ID - The ID of the emitter to check.
         * @return int
         */
        @Signature
        public native int GetParticlesDepth(int ID);

        /**
         * Returns the current emitter angle in degrees. This value represents the
         * amount of deviation a particle can have from the emitter direction when
         * emitted. An angle of 0 means there is no deviation while an angle of 360
         * means a particle can be travelling in any direction when emitted.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float GetParticlesAngle(int ID);

        /**
         * Returns the current emitter angle in radians. This value represents the
         * amount of deviation a particle can have from the emitter direction when
         * emitted. An angle of 0 means there is no deviation while an angle of 2*PI
         * means a particle can be travelling in any direction when emitted.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float GetParticlesAngleRad(int ID);

        /**
         * Returns 0 if the given particles have been paused using SetParticlesActive,
         * or 1 if they are currently updating as normal (default).
         *
         * @param ID - The ID of the emitter to check.
         * @return int
         */
        @Signature
        public native int GetParticlesActive(int ID);

        /**
         * Returns the number of individual particles that were drawn last frame using a
         * quad method. The higher this number the more work the engine is doing
         * handling particles.
         *
         * @return int
         */
        @Signature
        public native int GetParticleDrawnQuadCount();

        /**
         * As of version 108 this command will always return 0 as all particles are
         * drawn with quads. Use GetParticleDrawnQuadCount instead.
         *
         * @return int
         */
        @Signature
        public native int GetParticleDrawnPointCount();

        /**
         * Returns the current orientation of the device. The values returned are: 1 =
         * portrait mode, 2 = portrait mode - 180 degrees rotation, 3 = landscape mode -
         * 90 degrees counterclockwise, 4 = landscape mode - 90 degrees clockwise
         *
         * @return int
         */
        @Signature
        public native int GetOrientation();

        /**
         * Fills outPosVec3 with contact position. Returns false if no contact. First
         * create a vector with CreateVector3() then pass in the ID. The vector you have
         * created and passed in will be filled with the results.
         *
         * @param objA       - first object ID
         * @param objB       - second object ID
         * @param outPosVec3 - Id of the position Vector to be filled. Create this
         *                   vector first.
         * @return int
         */
        @Signature
        public native int GetObjects3DPhysicsContactPositionVector(int objA, int objB, int outPosVec3);

        /**
         * Returns the current Z position of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectZ(int objID);

        /**
         * Returns the current X position of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectX(int objID);

        /**
         * Returns the current Y position of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectY(int objID);

        /**
         * Returns the current Z position of the object in world coordinates. This takes
         * into account parent positions as a result of FixObjectToObject or
         * FixObjectToBone and returns the absolute world position of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectWorldZ(int objID);

        /**
         * Returns the current Y position of the object in world coordinates. This takes
         * into account parent positions as a result of FixObjectToObject or
         * FixObjectToBone and returns the absolute world position of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectWorldY(int objID);

        /**
         * Returns the current X position of the object in world coordinates. This takes
         * into account parent positions as a result of FixObjectToObject or
         * FixObjectToBone and returns the absolute world position of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectWorldX(int objID);

        /**
         * Returns the Y component of the object's current rotation converted to a
         * quaternion in world coordinates. This takes into account parent rotations as
         * a result of FixObjectToObject or FixObjectToBone and returns the absolute
         * world rotation of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectWorldQuatY(int objID);

        /**
         * Returns the Z component of the object's current rotation converted to a
         * quaternion in world coordinates. This takes into account parent rotations as
         * a result of FixObjectToObject or FixObjectToBone and returns the absolute
         * world rotation of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectWorldQuatZ(int objID);

        /**
         * Returns the X component of the object's current rotation converted to a
         * quaternion in world coordinates. This takes into account parent rotations as
         * a result of FixObjectToObject or FixObjectToBone and returns the absolute
         * world rotation of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectWorldQuatX(int objID);

        /**
         * Returns the W component of the object's current rotation converted to a
         * quaternion in world coordinates. This takes into account parent rotations as
         * a result of FixObjectToObject or FixObjectToBone and returns the absolute
         * world rotation of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectWorldQuatW(int objID);

        /**
         * Returns the Y component of the object's current rotation converted to Euler
         * angles in world coordinates. This takes into account parent rotations as a
         * result of FixObjectToObject or FixObjectToBone and returns the absolute world
         * rotation of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectWorldAngleY(int objID);

        /**
         * Returns the X component of the object's current rotation converted to Euler
         * angles in world coordinates. This takes into account parent rotations as a
         * result of FixObjectToObject or FixObjectToBone and returns the absolute world
         * rotation of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectWorldAngleX(int objID);

        /**
         * Returns the Z component of the object's current rotation converted to Euler
         * angles in world coordinates. This takes into account parent rotations as a
         * result of FixObjectToObject or FixObjectToBone and returns the absolute world
         * rotation of the object.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectWorldAngleZ(int objID);

        /**
         * Returns the current visibility mode for this object
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectVisible(int objID);

        /**
         * Gets the name of a texture as defined in the model file that it was loaded
         * from, but textures are not guaranteed to have names. Texture names are in the
         * range 1 to GetObjectNumTextures inclusive. If you are calling this command
         * from tier 2 you must delete the returned string with agk::DeleteString when
         * you are done with it.
         *
         * @param objID        - The ID of the object to check.
         * @param textureIndex - The index of the texture to check, first texture is at
         *                     index 1.
         * @return String
         */
        @Signature
        public native String GetObjectTextureName(int objID, int textureIndex);

        /**
         * Returns the minimum extent of the object in the Z direction, this can be
         * combined with GetObjectSizeMaxZ to determine the size of the object in the Z
         * direction. Note that the object may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the Z direction.
         * This command takes the bounds of all meshes that make up this object, to
         * check the bounds of a single mesh use GetObjectMeshSizeMinZ.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectSizeMinZ(int objID);

        /**
         * Returns the current transparency mode for this object
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectTransparency(int objID);

        /**
         * Returns the minimum extent of the object in the X direction, this can be
         * combined with GetObjectSizeMaxY to determine the size of the object in the Y
         * direction. Note that the object may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the Y direction.
         * This command takes the bounds of all meshes that make up this object, to
         * check the bounds of a single mesh use GetObjectMeshSizeMinY.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectSizeMinY(int objID);

        /**
         * Returns the maximum extent of the object in the X direction, this can be
         * combined with GetObjectSizeMinY to determine the size of the object in the Y
         * direction. Note that the object may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the Y direction.
         * This command takes the bounds of all meshes that make up this object, to
         * check the bounds of a single mesh use GetObjectMeshSizeMaxY.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectSizeMaxY(int objID);

        /**
         * Returns the minimum extent of the object in the X direction, this can be
         * combined with GetObjectSizeMaxX to determine the size of the object in the X
         * direction. Note that the object may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the X direction.
         * This command takes the bounds of all meshes that make up this object, to
         * check the bounds of a single mesh use GetObjectMeshSizeMinX.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectSizeMinX(int objID);

        /**
         * Returns the maximum extent of the object in the Z direction, this can be
         * combined with GetObjectSizeMinZ to determine the size of the object in the Z
         * direction. Note that the object may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the Z direction.
         * This command takes the bounds of all meshes that make up this object, to
         * check the bounds of a single mesh use GetObjectMeshSizeMaxZ.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectSizeMaxZ(int objID);

        /**
         * Returns the maximum extent of the object in the X direction, this can be
         * combined with GetObjectSizeMinX to determine the size of the object in the X
         * direction. Note that the object may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the X direction.
         * This command takes the bounds of all meshes that make up this object, to
         * check the bounds of a single mesh use GetObjectMeshSizeMaxX.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectSizeMaxX(int objID);

        /**
         * Returns 1 if the object is currently set to receive shadows, 0 otherwise.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectReceiveShadowMode(int objID);

        /**
         * Returns the Y component of the point of collision for the given collision
         * index in the last collision check. You can check the number of valid indices
         * with GetObjectRayCastNumHits.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastY(int index);

        /**
         * Returns the Z component of the point of collision for the given collision
         * index in the last collision check. You can check the number of valid indices
         * with GetObjectRayCastNumHits.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastZ(int index);

        /**
         * Returns the X component of the point of collision for the given collision
         * index in the last collision check. You can check the number of valid indices
         * with GetObjectRayCastNumHits.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastX(int index);

        /**
         * Returns the Y component of the final resting point for sliding collisions.
         * This is only valid for index 0 and after calling ObjectSphereSlide. Position
         * an object here to make it look like it slid after colliding.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastSlideY(int index);

        /**
         * Returns the X component of the final resting point for sliding collisions.
         * This is only valid for index 0 and after calling ObjectSphereSlide. Position
         * an object here to make it look like it slid after colliding.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastSlideX(int index);

        /**
         * Returns the number of collisions that occurred in the last collision check.
         * In the case of ObjectRayCast and ObjectSphereCast this will be 0 or 1. For
         * ObjectSphereSlide this could be anywhere between 0 and 4.
         *
         * @return int
         */
        @Signature
        public native int GetObjectRayCastNumHits();

        /**
         * Returns the Z component of the collision normal in the last collision check.
         * You can check the number of valid indices with GetObjectRayCastNumHits.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastNormalZ(int index);

        /**
         * Returns the Z component of the final resting point for sliding collisions.
         * This is only valid for index 0 and after calling ObjectSphereSlide. Position
         * an object here to make it look like it slid after colliding.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastSlideZ(int index);

        /**
         * Returns the Y component of the collision normal in the last collision check.
         * You can check the number of valid indices with GetObjectRayCastNumHits.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastNormalY(int index);

        /**
         * Returns the X component of the collision normal in the last collision check.
         * You can check the number of valid indices with GetObjectRayCastNumHits.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastNormalX(int index);

        /**
         * Returns the object ID hit for the given collision index in the last collision
         * check. You can check the number of valid indices with
         * GetObjectRayCastNumHits.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return int
         */
        @Signature
        public native int GetObjectRayCastHitID(int index);

        /**
         * Returns the distance between the start point for the ray and the collision
         * point.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastDistance(int index);

        /**
         * Returns the Y component of the bounce vector for the last collision check.
         * You can check the number of valid indices with GetObjectRayCastNumHits.
         * Position an object here to make it look like it bounced after colliding.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastBounceY(int index);

        /**
         * Returns the Z component of the bounce vector for the last collision check.
         * You can check the number of valid indices with GetObjectRayCastNumHits.
         * Position an object here to make it look like it bounced after colliding.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastBounceZ(int index);

        /**
         * Returns the X component of the bounce vector for the last collision check.
         * You can check the number of valid indices with GetObjectRayCastNumHits.
         * Position an object here to make it look like it bounced after colliding.
         *
         * @param index - The index of the collision to check, starting at index 0.
         * @return float
         */
        @Signature
        public native float GetObjectRayCastBounceX(int index);

        /**
         * Returns the Z component of the object's current rotation converted to a
         * quaternion.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectQuatZ(int objID);

        /**
         * Returns the Y component of the object's current rotation converted to a
         * quaternion.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectQuatY(int objID);

        /**
         * Returns the X component of the object's current rotation converted to a
         * quaternion.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectQuatX(int objID);

        /**
         * Gets the number of texture references that was found when loading the object.
         * An object can have multiple texture references. This information will only be
         * available if the model file have a material setup with a diffuse texture
         * reference.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectNumTextures(int objID);

        /**
         * Returns the W component of the object's current rotation converted to a
         * quaternion.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectQuatW(int objID);

        /**
         * Gets the number of meshes that belong to this object. An object can have
         * multiple meshes, usually this happens in the case of multi-material objects
         * where the object is split into multiple meshes, each using a different
         * texture. Note that instanced objects may not have any meshes.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectNumMeshes(int objID);

        /**
         * Gets the number of child objects that were loaded as a result of loading this
         * object. For example a bone animated character object may have a gun model
         * attached to the bone representing its hand, this gun model would be loaded as
         * a separate object and given its own ID, which you can manipulate separately
         * from the main object. You can even detach the gun from the hand with
         * FixObjectToBone(ID,0) to make it a normal object that will not move when the
         * character moves. It will however always remain in this list of children, for
         * reference, and will get deleted if DeleteObjectWithChildren is called on the
         * character object. For those of you that are familiar with DarkBasic, objects
         * that contained limbs in DarkBasic would be loaded as child objects in AGK.
         * However there is no hierarchy in the child objects, they would not have
         * children of their own. Instead a bone structure is created in the root object
         * that represents the limb hierarchy, and the child objects are attached to the
         * appropriate bones.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectNumChildren(int objID);

        /**
         * Returns the number of animations currently assigned to the object. Only
         * objects loaded with LoadObjectWithChildren get animations assigned to them.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectNumAnimations(int objID);

        /**
         * Gets the number of bones that were loaded as a result of loading this object.
         * This only happens if the object was loaded with LoadObjectWithChildren. If
         * the object has limb animation like in DarkBasic Classic, then the bones
         * represent the limb hierarchy and each limb is loaded as a child object
         * attached to a bone. If the object has weighted vertex animation then the
         * bones represent the skeleton and the skin is loaded as a single mesh stored
         * in the root object. The two forms of animation can be combined, so a weighted
         * vertex bone structure can have objects attached to its bones at the same time
         * as deforming the skin mesh.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectNumBones(int objID);

        /**
         * Returns the name of the object as defined in the model file. This is useful
         * when using LoadObjectWithChildren to identify child objects which can be
         * accessed with GetObjectChildID. If you are calling this command from Tier 2
         * then the returned string must be deleted with agk::DeleteString when you are
         * done with it.
         *
         * @param objID - The ID of the object to check.
         * @return String
         */
        @Signature
        public native String GetObjectName(int objID);

        /**
         * Returns the source code to the vertex shader currently being used on this
         * object. If you haven't assigned a shader to this mesh then one is generated
         * automatically, and you can use this command to get its source code if you
         * want to make adjustments to it. You can then load this modified shader source
         * with LoadShader and assign it with SetObjectMeshShader. Note that modifying
         * the number of textures, or using SetObjectLightMode will normally generate a
         * new shader to handle the changes, however if you have used
         * SetObjectMeshShader then AGK will no longer modify your shader, assuming you
         * have accounted for these changes yourself. Note that shaders which use
         * lighting will have the functions GetVSLighting() and GetPSLighting() that
         * will be filled out by AGK at runtime based on how many lights are near the
         * mesh. Removing these functions from the shader source will remove all
         * lighting from the mesh. If you call this command from tier 2 you must delete
         * the string when you are done with it.
         *
         * @param objID     - The ID of the object to check.
         * @param meshIndex - The index of the mesh to check, first mesh is at index 1.
         * @return String
         */
        @Signature
        public native String GetObjectMeshVSSource(int objID, int meshIndex);

        /**
         * Returns the minimum extent of the mesh in the Z direction, this can be
         * combined with GetObjectMeshSizeMaxZ to determine the size of the mesh in the
         * Z direction. Note that the mesh may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the Z direction.
         *
         * @param objID     - The ID of the object to check.
         * @param meshIndex - The index of the mesh to check.
         * @return float
         */
        @Signature
        public native float GetObjectMeshSizeMinZ(int objID, int meshIndex);

        /**
         * Returns the maximum extent of the mesh in the Z direction, this can be
         * combined with GetObjectMeshSizeMinZ to determine the size of the mesh in the
         * Z direction. Note that the mesh may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the Z direction.
         *
         * @param objID     - The ID of the object to check.
         * @param meshIndex - The index of the mesh to check.
         * @return float
         */
        @Signature
        public native float GetObjectMeshSizeMaxZ(int objID, int meshIndex);

        /**
         * Returns the minimum extent of the mesh in the X direction, this can be
         * combined with GetObjectMeshSizeMaxX to determine the size of the mesh in the
         * X direction. Note that the mesh may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the X direction.
         *
         * @param objID     - The ID of the object to check.
         * @param meshIndex - The index of the mesh to check.
         * @return float
         */
        @Signature
        public native float GetObjectMeshSizeMinX(int objID, int meshIndex);

        /**
         * Returns the minimum extent of the mesh in the Y direction, this can be
         * combined with GetObjectMeshSizeMaxY to determine the size of the mesh in the
         * Y direction. Note that the mesh may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the Y direction.
         *
         * @param objID     - The ID of the object to check.
         * @param meshIndex - The index of the mesh to check.
         * @return float
         */
        @Signature
        public native float GetObjectMeshSizeMinY(int objID, int meshIndex);

        /**
         * Returns the maximum extent of the mesh in the Y direction, this can be
         * combined with GetObjectMeshSizeMinY to determine the size of the mesh in the
         * Y direction. Note that the mesh may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the Y direction.
         *
         * @param objID     - The ID of the object to check.
         * @param meshIndex - The index of the mesh to check.
         * @return float
         */
        @Signature
        public native float GetObjectMeshSizeMaxY(int objID, int meshIndex);

        /**
         * Returns the maximum extent of the mesh in the X direction, this can be
         * combined with GetObjectMeshSizeMinX to determine the size of the mesh in the
         * X direction. Note that the mesh may be off center so its min value may be 10
         * whilst its max value is 12, meaning its size is 2 units in the X direction.
         *
         * @param objID     - The ID of the object to check.
         * @param meshIndex - The index of the mesh to check.
         * @return float
         */
        @Signature
        public native float GetObjectMeshSizeMaxX(int objID, int meshIndex);

        /**
         * Returns the source code to the pixel shader currently being used on this
         * object. If you haven't assigned a shader to this mesh then one is generated
         * automatically, and you can use this command to get its source code if you
         * want to make adjustments to it. You can then load this modified shader source
         * with LoadShader and assign it with SetObjectMeshShader. Note that modifying
         * the number of textures, or using SetObjectLightMode will normally generate a
         * new shader to handle the changes, however if you have used
         * SetObjectMeshShader then AGK will no longer modify your shader, assuming you
         * have accounted for these changes yourself. Note that shaders which use
         * lighting will have the functions GetVSLighting() and GetPSLighting() that
         * will be filled out by AGK at runtime based on how many lights are near the
         * mesh. Removing these functions from the shader source will remove all
         * lighting from the mesh. If you call this command from tier 2 you must delete
         * the string when you are done with it.
         *
         * @param objID     - The ID of the object to check.
         * @param meshIndex - The index of the mesh to check, first mesh is at index 1.
         * @return String
         */
        @Signature
        public native String GetObjectMeshPSSource(int objID, int meshIndex);

        /**
         * Gets the name of a mesh as defined in the model file that it was loaded from,
         * but meshes are not guaranteed to have names. Mesh indices are in the range 1
         * to GetObjectNumMeshes inclusive. If you are calling this command from tier 2
         * you must delete the returned string with agk::DeleteString when you are done
         * with it.
         *
         * @param objID     - The ID of the object to check.
         * @param meshIndex - The index of the mesh to check, first mesh is at index 1.
         * @return String
         */
        @Signature
        public native String GetObjectMeshName(int objID, int meshIndex);

        /**
         * Returns 1 if the object is currently tweening to an animation frame or the
         * beginning or an animation about to play. This only occurs immediately after
         * PlayObjectAnimation or SetObjectAnimationFrame if you specified a tween time
         * greater than 0. It does not occur at any other time during an animation.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectIsTweening(int objID);

        /**
         * Returns 1 if the object is currently playing an animation, this includes
         * tween to the start of an animation, but not tweening to a single frame.
         * Essentially it returns 1 if the object should be playing an animation. If the
         * animation is set to loop a specified number of times, or to only play once,
         * then this command will return 0 when the animation is finished.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectIsAnimating(int objID);

        /**
         * Returns 1 if AGK thinks the object is currently on screen, 0 if not. This is
         * an estimate and if in doubt will assume the object is on screen. As such if
         * this command returns 0 then the object is definitely off screen, if it
         * returns 1 the object may or may not be on screen.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectInScreen(int objID);

        /**
         * Returns the current depth write mode for this object
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectDepthWrite(int objID);

        /**
         * Returns 1 if an object exists at the given ID, 0 otherwise.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectExists(int objID);

        /**
         * If the object was created with CreateObjectFromHeightMap then this command
         * can be used to quickly get the height of the object at a particular world
         * position. This accounts for the object's position and Y rotation to provide
         * the height regardless of where the object is positioned. If the object is
         * rotated in the X or Z angles then this will produce incorrect values. You
         * should provide the X and Z coordinates in world units, if the point lies
         * outside the object then 0 will be returned.
         *
         * @param objID - The ID of the object to check.
         * @param x     - The X component of the position to check
         * @param z     - The Z component of the position to check
         * @return float
         */
        @Signature
        public native float GetObjectHeightMapHeight(int objID, float x, float z);

        /**
         * Returns the current depth read mode for this object
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectDepthReadMode(int objID);

        /**
         * Returns the current depth bias for this object
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectDepthBias(int objID);

        /**
         * Returns the current cull mode for this object
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectCullMode(int objID);

        /**
         * Returns the current red value of this object's color, as set by
         * SetObjectColor.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectColorRed(int objID);

        /**
         * Returns the current green value of this object's color, as set by
         * SetObjectColor.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectColorGreen(int objID);

        /**
         * Returns the current blue value of this object's color, as set by
         * SetObjectColor.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectColorBlue(int objID);

        /**
         * Returns the object ID for a specified child object that was loaded as a
         * result of this object. To find the number of child objects use
         * GetObjectNumChildren. childIndex is in the range 1 to the number of children
         * inclusive. For those of you that are familiar with DarkBasic, objects that
         * contained limbs in DarkBasic would be loaded as child objects in AGK. However
         * there is no hierarchy in the child objects, they would not have children of
         * their own. Instead a bone structure is created in the root object that
         * represents the limb hierarchy, and the child objects are attached to the
         * appropriate bones.
         *
         * @param objID      - The ID of the object to check.
         * @param childIndex - The index of the child to get.
         * @return int
         */
        @Signature
        public native int GetObjectChildID(int objID, int childIndex);

        /**
         * Returns the current Z position of the bone.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneZ(int objID, int boneIndex);

        /**
         * Returns the current Y position of the bone.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneY(int objID, int boneIndex);

        /**
         * Returns 1 if the object is currently set to cast shadows, 0 otherwise.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectCastShadowMode(int objID);

        /**
         * Returns the current X position of the bone.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneX(int objID, int boneIndex);

        /**
         * Returns the current Y position of the bone in world coordinates.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneWorldY(int objID, int boneIndex);

        /**
         * Returns the current Z position of the bone in world coordinates.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneWorldZ(int objID, int boneIndex);

        /**
         * Returns the Z component of the bone's current rotation converted to a
         * quaternion.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneWorldQuatZ(int objID, int boneIndex);

        /**
         * Returns the current X position of the bone in world coordinates.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneWorldX(int objID, int boneIndex);

        /**
         * Returns the Y component of the bone's current rotation converted to a
         * quaternion.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneWorldQuatY(int objID, int boneIndex);

        /**
         * Returns the Z component of the bone's current rotation converted to Euler
         * angles.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneWorldAngleZ(int objID, int boneIndex);

        /**
         * Returns the X component of the bone's current rotation converted to a
         * quaternion.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneWorldQuatX(int objID, int boneIndex);

        /**
         * Returns the W component of the bone's current rotation converted to a
         * quaternion.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneWorldQuatW(int objID, int boneIndex);

        /**
         * Returns the Y component of the bone's current rotation converted to Euler
         * angles.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneWorldAngleY(int objID, int boneIndex);

        /**
         * Returns the X component of the bone's current rotation in world coordinates
         * converted to Euler angles.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneWorldAngleX(int objID, int boneIndex);

        /**
         * Returns the Z component of the bone's current rotation converted to a
         * quaternion.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneQuatZ(int objID, int boneIndex);

        /**
         * Returns the W component of the bone's current rotation converted to a
         * quaternion.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneQuatW(int objID, int boneIndex);

        /**
         * Returns the X component of the bone's current rotation converted to a
         * quaternion.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneQuatX(int objID, int boneIndex);

        /**
         * Returns the Y component of the bone's current rotation converted to a
         * quaternion.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneQuatY(int objID, int boneIndex);

        /**
         * Gets the index of a bone by its name. Names are loaded from the model file
         * when LoadObjectWithChildren is used, otherwise no bones are loaded. Indexes
         * will be in the range 1 to num bones, or 0 if not found.
         *
         * @param objID - The ID of the object to check.
         * @param name  - The name of the bone to find.
         * @return int
         */
        @Signature
        public native int GetObjectBoneByName(int objID, String name);

        /**
         * Returns the name of the bone. If this command is called from tier 2 then you
         * must delete the returned string when you are done with it.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return String
         */
        @Signature
        public native String GetObjectBoneName(int objID, int boneIndex);

        /**
         * Returns the Y component of the bone's current rotation converted to Euler
         * angles.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneAngleY(int objID, int boneIndex);

        /**
         * Returns the Z component of the bone's current rotation converted to Euler
         * angles.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneAngleZ(int objID, int boneIndex);

        /**
         * Returns the X component of the bone's current rotation converted to Euler
         * angles.
         *
         * @param objID     - The ID of the object that contains the bone to check.
         * @param boneIndex - The index of the bone to check.
         * @return float
         */
        @Signature
        public native float GetObjectBoneAngleX(int objID, int boneIndex);

        /**
         * Returns the current time of a playing animation, or if the animation has
         * stopped then the last time used for interpolation is returned.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectAnimationTime(int objID);

        /**
         * Returns the duration of a specified animation in seconds.
         *
         * @param objID    - The ID of the object to check.
         * @param animName - The name of the animation to check, defined by the
         *                 modelling program
         * @return float
         */
        @Signature
        public native float GetObjectAnimationDuration(int objID, String animName);

        /**
         * Returns the name of the specified animation for the given object. You can
         * find the number of animations for this object with GetObjectNumAnimations.
         * The index should be in the range 1 to numAnimations inclusive.
         *
         * @param objID - The ID of the object to check.
         * @param index - The index of the animation to check, indices start at 1.
         * @return String
         */
        @Signature
        public native String GetObjectAnimationName(int objID, int index);

        /**
         * Returns the Z component of the object's current rotation converted to Euler
         * angles.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectAngleZ(int objID);

        /**
         * Returns the Y component of the object's current rotation converted to Euler
         * angles.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectAngleY(int objID);

        /**
         * Returns the X component of the object's current rotation converted to Euler
         * angles.
         *
         * @param objID - The ID of the object to check.
         * @return float
         */
        @Signature
        public native float GetObjectAngleX(int objID);

        /**
         * Gets the current restitution value for the physics object.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsRestitution(int objID);

        /**
         * Returns true if there is another contact to report.
         *
         * @return int
         */
        @Signature
        public native int GetObject3DPhysicsNextContact();

        /**
         * Returns the rolling friction for the physics object.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsRollingFriction(int objID);

        /**
         * Returns the current alpha value of this object's color, as set by
         * SetObjectColor or SetObjectAlpha.
         *
         * @param objID - The ID of the object to check.
         * @return int
         */
        @Signature
        public native int GetObjectAlpha(int objID);

        /**
         * Returns the max linear velocity for the physics object.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsMaxLinearVelocity(int objID);

        /**
         * Returns the objects mass
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsMass(int objID);

        /**
         * Returns the objects collision mask. By default all physics objects are in one
         * group and are not masked. If you use collision groups and masks you must use
         * them for all physics objects.
         *
         * @param objID - object ID
         * @return int
         */
        @Signature
        public native int GetObject3DPhysicsMask(int objID);

        /**
         * Returns the X component of the Linear Velocity vector.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsLinearVelocityZ(int objID);

        /**
         * Returns the X component of the Linear Velocity vector.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsLinearVelocityY(int objID);

        /**
         * Returns the X component of the Linear Velocity vector.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsLinearVelocityX(int objID);

        /**
         * Return the linear Damping value
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsLinearDamp(int objID);

        /**
         * Returns the linear Sleeping threshold for the Physics Object.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsLinearSleepingThreshold(int objID);

        /**
         * Returns the objects collision group. By default all physics objects are in
         * one group and are not masked. If you use collision groups and masks you must
         * use them for all physics objects.
         *
         * @param objID - object ID
         * @return int
         */
        @Signature
        public native int GetObject3DPhysicsGroup(int objID);

        /**
         * Returns the friction for the physics object.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsFriction(int objID);

        /**
         * Returns true if object has had a contact in the physics step.
         *
         * @param objID - object ID
         * @return int
         */
        @Signature
        public native int GetObject3DPhysicsFirstContact(int objID);

        /**
         * Returns Z position of contact
         *
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsContactZ();

        /**
         * Returns X position of contact
         *
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsContactX();

        /**
         * Returns true if there is a contact vector and fills the vector outPosVec3.
         * First create a vector with CreateVector3() then pass in the ID. The vector
         * you have created and passed in will be filled with the results.
         *
         * @param outPosVec3 - The ID of the vector to be filled with the results.
         * @return int
         */
        @Signature
        public native int GetObject3DPhysicsContactVector(int outPosVec3);

        /**
         * Returns Y position of contact
         *
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsContactY();

        /**
         * Returns the object ID of the second object in the contact.
         *
         * @return int
         */
        @Signature
        public native int GetObject3DPhysicsContactObjectB();

        /**
         * Return the Z component of the angular velocity vector.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsAngularVelocityZ(int objID);

        /**
         * Return the Y component of the angular velocity vector.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsAngularVelocityY(int objID);

        /**
         * Return the X component of the angular velocity vector.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsAngularVelocityX(int objID);

        /**
         * Returns the angular Sleeping threshold for the Physics Object.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsAngularSleepingThreshold(int objID);

        /**
         * Returns the Angular Damping value
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float GetObject3DPhysicsAngularDamp(int objID);

        /**
         * Returns the number of logical processor cores on the device
         *
         * @return int
         */
        @Signature
        public native int GetNumProcessors();

        /**
         * Returns the number of cameras available for SetDeviceCameraToImage. Currently
         * only works on Android, iOS, and Windows
         *
         * @return int
         */
        @Signature
        public native int GetNumDeviceCameras();

        /**
         * Returns the name of the next folder found in the current folder, which is set
         * using SetFolder. GetFirstFolder must have been called first for this to work,
         * any call to SetFolder or OpenToWrite will require starting again with
         * GetFirstFolder. Returns an empty string if there are no more folders in the
         * current folder. Does not include . or ..
         *
         * @return String
         */
        @Signature
        public native String GetNextFolder();

        /**
         * Returns the name of the next file found in the current folder, which is set
         * using SetFolder. GetFirstFile must have been called first for this to work,
         * any call to SetFolder or OpenToWrite will require starting again with
         * GetFirstFile. Returns an empty string if there are no more files in the
         * current folder.
         *
         * @return String
         */
        @Signature
        public native String GetNextFile();

        /**
         * Returns 1 if a contact exists, you can get the sprites involved in this
         * contact using GetContactSpriteID1 and GetContactSpriteID2, you can move on to
         * the next contact by calling this command again, when there are no more
         * contacts it will return 0.
         *
         * @return int
         */
        @Signature
        public native int GetNextContact();

        /**
         * Returns the IP address being used by the server. This command only works on
         * clients as the server can get its own IP using GetDeviceIP and GetDeviceIPv6.
         *
         * @param iNetID - The ID of the network to check.
         * @return String
         */
        @Signature
        public native String GetNetworkServerIP(int iNetID);

        /**
         * Returns the client ID of the host's client. This is useful if you use the
         * server to handle game setup variables such as board size, game length, etc,
         * as only the host client should have a copy of these such variables.
         *
         * @param iNetID - The ID of the network to check.
         * @return int
         */
        @Signature
        public native int GetNetworkServerID(int iNetID);

        /**
         * Returns the number of clients connected to the specified network. The host
         * counts as a client as does the local client. Meaning that on a connected
         * network there should be at least 2 clients. A host waiting for clients
         * returns 1 if it is on its own. A client trying to connect returns 0 until it
         * connects and the host accepts the client, giving it a unique ID, it should
         * then return 2.
         *
         * @param iNetID - The ID of the network to check.
         * @return int
         */
        @Signature
        public native int GetNetworkNumClients(int iNetID);

        /**
         * Returns the Client ID of the next client in the client list. Use this
         * function to continue going through the list of clients started with
         * GetNetworkFirstClient. It is very important that this command is called until
         * it returns 0 as the background network code cannot continue until it knows
         * you are finished with the client list. The local client will also be returned
         * at some point, which can be detected by comparing the returned ID with
         * GetNetworkMyClientID. The host client will also be returned at some point
         * which can be detected by comparing the returned ID with GetNetworkServerID.
         *
         * @param iNetID - The ID of the network to check.
         * @return int
         */
        @Signature
        public native int GetNetworkNextClient(int iNetID);

        /**
         * Each client is assigned a unique ID by the host when it connects. This
         * function returns the ID that you have been assigned. The host also assigns
         * itself an ID which can be found using GetNetworkServerID.
         *
         * @param iNetID - The ID of the network to check.
         * @return int
         */
        @Signature
        public native int GetNetworkMyClientID(int iNetID);

        /**
         * Gets a single string from the message and advances the message pointer to the
         * next message item. Messages should be created and read according to known
         * formats, e.g. string, int, string as there is no immediate way for the
         * receiver to know the format of a message. You could use an initial integer to
         * specify a message type ID which you can use to identify the message format.
         *
         * @param iMsgID - The ID of the message to read.
         * @return String
         */
        @Signature
        public native String GetNetworkMessageString(int iMsgID);

        /**
         * Gets a single integer from the message and advances the message pointer to
         * the next message item. Messages should be created and read according to known
         * formats, e.g. string, int, string as there is no immediate way for the
         * receiver to know the format of a message. You could use an initial integer to
         * specify a message type ID which you can use to identify the message format.
         *
         * @param iMsgID - The ID of the message to read.
         * @return int
         */
        @Signature
        public native int GetNetworkMessageInteger(int iMsgID);

        /**
         * Returns the source port that was used by this message. Only applicable to
         * messages received from UDP and broadcast listeners, network messages will
         * return 0 for this function. It will also return 0 for messages created using
         * CreateNetworkMessage. This will be in the range 0 to 65535.
         *
         * @param iMsgID - The ID of the message to read.
         * @return int
         */
        @Signature
        public native int GetNetworkMessageFromPort(int iMsgID);

        /**
         * Returns the IP that sent this message. Only applicable to messages received
         * from UDP and broadcast listeners, network messages will return an empty
         * string for this function. It will also return an empty string for messages
         * created using CreateNetworkMessage. This could be an IPv4 or IPv6 address.
         *
         * @param iMsgID - The ID of the message to read.
         * @return String
         */
        @Signature
        public native String GetNetworkMessageFromIP(int iMsgID);

        /**
         * Returns the client ID that sent this message. Only applicable to messages
         * received from networks, broadcast listener and UDP messages will return 0 for
         * this function. It will also return 0 for messages created using
         * CreateNetworkMessage.
         *
         * @param iMsgID - The ID of the message to read.
         * @return int
         */
        @Signature
        public native int GetNetworkMessageFromClient(int iMsgID);

        /**
         * Gets a single float from the message and advances the message pointer to the
         * next message item. Messages should be created and read according to known
         * formats, e.g. string, int, string as there is no immediate way for the
         * receiver to know the format of a message. You could use an initial integer to
         * specify a message type ID which you can use to identify the message format.
         *
         * @param iMsgID - The ID of the message to read.
         * @return float
         */
        @Signature
        public native float GetNetworkMessageFloat(int iMsgID);

        /**
         * Gets a single unsigned byte from the message and advances the message pointer
         * to the next message item. Messages should be created and read according to
         * known formats, e.g. string, int, string as there is no immediate way for the
         * receiver to know the format of a message. You could use an initial integer to
         * specify a message type ID which you can use to identify the message format.
         *
         * @param iMsgID - The ID of the message to read.
         * @return int
         */
        @Signature
        public native int GetNetworkMessageByte(int iMsgID);

        /**
         * Returns the Client ID of the first client in the client list. Use this
         * function to start going through the list of clients and continue with
         * GetNetworkNextClient until it returns 0. It is very important that once this
         * command is called GetNetworkNextClient is called until it returns 0 as the
         * background network code cannot continue until it knows you are finished with
         * the client list. The local client will also be returned at some point, which
         * can be detected by comparing the returned ID with GetNetworkMyClientID. The
         * host client will also be returned at some point which can be detected by
         * comparing the returned ID with GetNetworkServerID.
         *
         * @param iNetID - The ID of the network to check.
         * @return int
         */
        @Signature
        public native int GetNetworkFirstClient(int iNetID);

        /**
         * Check the network for any messages sent to this client. If none are found it
         * returns 0. If a message is found it returns a message ID you can use to read
         * the message. You must delete the message using DeleteNetworkMessage when you
         * are done reading it. You should keep calling GetNetworkMessage until it
         * returns 0 to make sure you have received all the messages. You can use the
         * message reading commands to find out which client ID sent the message.
         *
         * @param iNetID - The ID of the network to check for messages.
         * @return int
         */
        @Signature
        public native int GetNetworkMessage(int iNetID);

        /**
         * Returns 1 if a network exists at the given ID, otherwise it returns 0.
         *
         * @param iNetID - The ID of the network to check
         * @return int
         */
        @Signature
        public native int GetNetworkExists(int iNetID);

        /**
         * Reads one of the local data slots assigned to the client set using
         * SetNetworkClientUserData.
         *
         * @param iNetID - The ID of the network to get the value from.
         * @param client - The ID of the client on the network to get the value from.
         * @param index  - The index (0-4) of the data slot to read.
         * @return int
         */
        @Signature
        public native int GetNetworkClientUserData(int iNetID, int client, int index);

        /**
         * Returns the ping between the given client and the host. To get the total
         * transit time of data from one client to another you must add the two ping
         * times for both clients together as all data goes via the host. If you use the
         * host's client ID it will return 0 as the host has no ping to itself. The
         * value returned is in seconds as a floating point value.
         *
         * @param iNetID - The ID of the network to check.
         * @param client - The ID of the client to check.
         * @return float
         */
        @Signature
        public native float GetNetworkClientPing(int iNetID, int client);

        /**
         * Returns the name the client used to identify itself when it connected to the
         * host.
         *
         * @param iNetID - The ID of the network to check.
         * @param client - the ID of the client to check.
         * @return String
         */
        @Signature
        public native String GetNetworkClientName(int iNetID, int client);

        /**
         * Returns the IP address being used by the specified client. This command only
         * works on the server as clients do not connect directly to each other
         *
         * @param iNetID - The ID of the network to check.
         * @param client - the ID of the client to check.
         * @return String
         */
        @Signature
        public native String GetNetworkClientIP(int iNetID, int client);

        /**
         * Gets a copy of a remote client's float variable by name. Can also be used on
         * the client's own variables if the clientID equals GetNetworkMyClientID. If
         * the variable was set as a resetting variable it will return to 0 once read,
         * this does not affect other clients ability to read the original value. They
         * will each reset their own copy. If the specified client has not set a
         * variable of the given name the value 0 is returned.
         *
         * @param iNetID - The ID of the network to check.
         * @param client - The ID of the client to check.
         * @param name   - The name of the variable to return.
         * @return float
         */
        @Signature
        public native float GetNetworkClientFloat(int iNetID, int client, String name);

        /**
         * Gets a copy of a remote client's integer variable by name. Can also be used
         * on the client's own variables if the clientID equals GetNetworkMyClientID. If
         * the variable was set as a resetting variable it will return to 0 once read,
         * this does not affect other clients ability to read the original value. They
         * will each reset their own copy. If the specified client has not set a
         * variable of the given name the value 0 is returned.
         *
         * @param iNetID - The ID of the network to check.
         * @param client - The ID of the client to check.
         * @param name   - The name of the variable to return.
         * @return int
         */
        @Signature
        public native int GetNetworkClientInteger(int iNetID, int client, String name);

        /**
         * Checks whether the specified client has disconnected. Disconnected clients
         * are not automatically removed from the client list, allowing you to handle
         * their clean up properly. Once you have dealt with this client you must remove
         * it from the client list by calling DeleteNetworkClient. The client may
         * persist for a little while until the background network code gets around to
         * actually deleting it so be prepared for this client to hang around for a few
         * frames declaring that it is disconnected and make sure you only clean it up
         * once. You can detect this by setting one of the SetNetworkClientUserData
         * values to notify yourself that it has been dealt with.
         *
         * @param iNetID - The ID of the network to check.
         * @param client - the ID of the client to check.
         * @return int
         */
        @Signature
        public native int GetNetworkClientDisconnected(int iNetID, int client);

        /**
         * Returns 1 if the current device has an NFC device built-in, otherwise 0 is
         * returned. This command is not yet functional.
         *
         * @return int
         */
        @Signature
        public native int GetNFCExists();

        /**
         * Returns the current position in the music file, between 0 for the beginning
         * of the file and GetMusicDurationOGG for the end of the file.
         *
         * @param musicID - The ID of the music file to check
         * @return float
         */
        @Signature
        public native float GetMusicPositionOGG(int musicID);

        /**
         * Returns the number of seconds played of the current music file. If no music
         * is currently playing this command will return 0.
         *
         * @return float
         */
        @Signature
        public native float GetMusicPosition();

        /**
         * Returns 1 if the music file is currently playing, 0 otherwise. This will
         * continue to return 1 whilst the file is paused.
         *
         * @param musicID - The ID of the music file to check
         * @return int
         */
        @Signature
        public native int GetMusicPlayingOGG(int musicID);

        /**
         * Returns the ID of the currently playing music file. If no music is playing it
         * returns 0.
         *
         * @return int
         */
        @Signature
        public native int GetMusicPlaying();

        /**
         * Returns 1 if a music file exists at the specified ID, 0 otherwise.
         *
         * @param musicID - The ID to check
         * @return int
         */
        @Signature
        public native int GetMusicExistsOGG(int musicID);

        /**
         * Returns the number of times this music file has looped.
         *
         * @param musicID - The ID of the music file to check
         * @return int
         */
        @Signature
        public native int GetMusicLoopCountOGG(int musicID);

        /**
         * Returns 1 if a music file exists at the current ID, 0 if not.
         *
         * @param iID - The ID to check.
         * @return int
         */
        @Signature
        public native int GetMusicExists(int iID);

        /**
         * Returns the duration of the music file in seconds as a floating point value
         *
         * @param musicID - The ID of the music file to check
         * @return float
         */
        @Signature
        public native float GetMusicDurationOGG(int musicID);

        /**
         * Returns the number of seconds it will take to play the given music file from
         * start to finish. There must be no sounds playing for this command to work, or
         * the given ID must be the track currently playing. For example if you try to
         * get the duration of ID 2 and ID 1 is currently playing then it will fail, but
         * if ID 2 is currently playing it will succeed. For variable bit rate files
         * this command will return an approximation.
         *
         * @param iID - The ID of the music to check.
         * @return float
         */
        @Signature
        public native float GetMusicDuration(int iID);

        /**
         * Returns 1 if the current device has a mouse, 0 if not.
         *
         * @return int
         */
        @Signature
        public native int GetMouseExists();

        /**
         * Returns the minutes of a given unix time value (0 to 59). Unix time is
         * represented as the number of seconds since the 1st Jan 1970, it may also be
         * negative.
         *
         * @param unixtime - A unix time value.
         * @return int
         */
        @Signature
        public native int GetMinutesFromUnix(int unixtime);

        /**
         * Returns the month of a given unix time value (1 to 12). Unix time is
         * represented as the number of seconds since the 1st Jan 1970, it may also be
         * negative.
         *
         * @param unixtime - A unix time value.
         * @return int
         */
        @Signature
        public native int GetMonthFromUnix(int unixtime);

        /**
         * Returns 1 if the current device supports multitouch, 0 if not.
         *
         * @return int
         */
        @Signature
        public native int GetMultiTouchExists();

        /**
         * Get the number of milliseconds since the app was started. Calling this
         * command will internally make a system call to get the amount of time passed,
         * so it may change each time you call it.
         *
         * @return int
         */
        @Signature
        public native int GetMilliseconds();

        /**
         * Provides a quick way to get the Y position of the specified vertex from the
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and the location of the position values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return float
         */
        @Signature
        public native float GetMeshMemblockVertexY(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the V value of the specified vertex from the
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and the location of the UV values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return float
         */
        @Signature
        public native float GetMeshMemblockVertexV(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the Z position of the specified vertex from the
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and the location of the position values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return float
         */
        @Signature
        public native float GetMeshMemblockVertexZ(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the X position of the specified vertex from the
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and the location of the position values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return float
         */
        @Signature
        public native float GetMeshMemblockVertexX(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the U value of the specified vertex from the
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and the location of the UV values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return float
         */
        @Signature
        public native float GetMeshMemblockVertexU(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the red value of the specified vertex from the
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and the location of the color values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return int
         */
        @Signature
        public native int GetMeshMemblockVertexRed(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the Y component of the normal of the specified
         * vertex from the memblock. It uses the attribute data from the beginning of
         * the memblock to work out the vertex offset and the location of the normal
         * values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return float
         */
        @Signature
        public native float GetMeshMemblockVertexNormalY(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the X component of the normal of the specified
         * vertex from the memblock. It uses the attribute data from the beginning of
         * the memblock to work out the vertex offset and the location of the normal
         * values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return float
         */
        @Signature
        public native float GetMeshMemblockVertexNormalX(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the Z component of the normal of the specified
         * vertex from the memblock. It uses the attribute data from the beginning of
         * the memblock to work out the vertex offset and the location of the normal
         * values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return float
         */
        @Signature
        public native float GetMeshMemblockVertexNormalZ(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the green value of the specified vertex from the
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and the location of the color values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return int
         */
        @Signature
        public native int GetMeshMemblockVertexGreen(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the blue value of the specified vertex from the
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and the location of the color values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return int
         */
        @Signature
        public native int GetMeshMemblockVertexBlue(int memID, int vertexIndex);

        /**
         * Provides a quick way to get the alpha value of the specified vertex from the
         * memblock. It uses the attribute data from the beginning of the memblock to
         * work out the vertex offset and the location of the color values.
         *
         * @param memID       - The ID of the memblock to check
         * @param vertexIndex - The index of the vertex to check
         * @return int
         */
        @Signature
        public native int GetMeshMemblockVertexAlpha(int memID, int vertexIndex);

        /**
         * Returns a given number of bytes at the given offset and interprets them as a
         * string. The offset plus length must be less than the size of the memblock.
         * The first value is at offset 0. The string will be null terminated even if no
         * null terminator is found in the memblock. If a null terminator occurs before
         * length is reached then all the bytes will still be read, but only the
         * characters up to the first null terminator will be accessible in AGK. If you
         * are using tier 2 you must delete the pointer returned from this function.
         *
         * @param memID  - The ID of the memblock to check.
         * @param offset - The offset from the start of the memblock of the value to
         *               return, between 0 and size.
         * @param length - The number of bytes to read
         * @return String
         */
        @Signature
        public native String GetMemblockString(int memID, int offset, int length);

        /**
         * Returns the short (2 byte) value at the given offset. The offset must be less
         * than the size of the memblock. The first value is at offset 0. For best
         * performance the offset should be a multiple of 2 because reading short values
         * that are not aligned to 2 byte boundaries incurs a hardware performance
         * penalty. Short values are stored in little endian format so writing a short
         * of 23 at offset 0 and then reading it back in bytes would return the byte at
         * offset 0 as 23 and the byte at offset 1 as 0. The returned value will be a
         * signed short between -32768 and 32767.
         *
         * @param memID  - The ID of the memblock to check.
         * @param offset - The offset from the start of the memblock of the value to
         *               return, between 0 and size.
         * @return int
         */
        @Signature
        public native int GetMemblockShort(int memID, int offset);

        /**
         * Returns the size of the given memblock in bytes.
         *
         * @param memID - The ID of the memblock to check.
         * @return int
         */
        @Signature
        public native int GetMemblockSize(int memID);

        /**
         * Hashes the memblock with SHA256 and returns the resulting hash
         *
         * @param memID - The ID of the memblock to hash
         * @return String
         */
        @Signature
        public native String GetMemblockSHA256(int memID);

        /**
         * Hashes the memblock with SHA1 and returns the resulting hash
         *
         * @param memID - The ID of the memblock to hash
         * @return String
         */
        @Signature
        public native String GetMemblockSHA1(int memID);

        /**
         * Returns the int (4 byte) value at the given offset. The offset must be less
         * than the size of the memblock. The first value is at offset 0. For best
         * performance the offset should be a multiple of 4 because reading integer
         * values that are not aligned to 4 byte boundaries incurs a hardware
         * performance penalty. Int values are stored in little endian format so writing
         * an int of 23 at offset 0 and then reading it back in bytes would return the
         * byte at offset 0 as 23, the byte at offset 1 as 0, the byte at offset 2 as 0,
         * and the byte at offset 3 as 0. The returned value will be a signed integer
         * between -2,147,483,648 and 2,147,483,647.
         *
         * @param memID  - The ID of the memblock to check.
         * @param offset - The offset from the start of the memblock of the value to
         *               return, between 0 and size.
         * @return int
         */
        @Signature
        public native int GetMemblockInt(int memID, int offset);

        /**
         * Returns the float (4 byte) value at the given offset. The offset must be less
         * than the size of the memblock. The first value is at offset 0. For best
         * performance the offset should be a multiple of 4 because reading float values
         * that are not aligned to 4 byte boundaries incurs a hardware performance
         * penalty. Float values are stored in IEEE 754 format so writing an float and
         * then reading it back in bytes would return various components of the float
         * format.
         *
         * @param memID  - The ID of the memblock to check.
         * @param offset - The offset from the start of the memblock of the value to
         *               return, between 0 and size.
         * @return float
         */
        @Signature
        public native float GetMemblockFloat(int memID, int offset);

        /**
         * Returns 1 if a memblock with the given ID exists, 0 if not.
         *
         * @param memID - The ID of the memblock to check.
         * @return int
         */
        @Signature
        public native int GetMemblockExists(int memID);

        /**
         * Returns the byte value at the given offset. The offset must be less than the
         * size of the memblock. The first value is at offset 0. The returned value will
         * be an unsigned byte between 0 and 255.
         *
         * @param memID  - The ID of the memblock to check.
         * @param offset - The offset from the start of the memblock of the value to
         *               return, between 0 and size.
         * @return int
         */
        @Signature
        public native int GetMemblockByte(int memID, int offset);

        /**
         * Gets the maximum width that your app window can be. For platforms that
         * support windowed mode such as Windows and Mac your app can only achieve this
         * size in full screen mode as windowed mode has a border around your app. For
         * HTML5 apps this will return the size of the current HTML document, and is not
         * guaranteed to work if the HTML5 app is running in full screen mode. A better
         * name for this command would be GetMaxWindowWidth, but it is now set in stone.
         *
         * @return int
         */
        @Signature
        public native int GetMaxDeviceWidth();

        /**
         * Returns the byte value at the given offset. The offset must be less than the
         * size of the memblock. The first value is at offset 0. The returned value will
         * be a signed byte between -128 and 127.
         *
         * @param memID  - The ID of the memblock to check.
         * @param offset - The offset from the start of the memblock of the value to
         *               return, between 0 and size.
         * @return int
         */
        @Signature
        public native int GetMemblockByteSigned(int memID, int offset);

        /**
         * Gets the maximum height that your app window can be. For platforms that
         * support windowed mode such as Windows and Mac your app can only achieve this
         * size in full screen mode as windowed mode has a border around your app. For
         * HTML5 apps this will return the size of the current HTML document, and is not
         * guaranteed to work if the HTML5 app is running in full screen mode. A better
         * name for this command would be GetMaxWindowHeight, but it is now set in
         * stone.
         *
         * @return int
         */
        @Signature
        public native int GetMaxDeviceHeight();

        /**
         * Returns the number of sprites that the internal sprite manager had to sort
         * into their correct positions since the last frame. Sprites only need
         * resorting if they change depth or texture during the current frame.
         *
         * @return int
         */
        @Signature
        public native int GetManagedSpriteSortedCount();

        /**
         * Returns the number of OpenGL draw calls used to draw all managed sprites.
         * Generally the lower this number the better the performance. AGK attempts to
         * batch sprites into as few draw calls as possible, it does this by looking for
         * sprites with the same texture and drawing them at the same time.
         *
         * @return int
         */
        @Signature
        public native int GetManagedSpriteDrawCalls();

        /**
         * Returns the number of sprites that were actually sent for rendering to the
         * GPU last frame, the more that get drawn the slower the app will run.
         *
         * @return int
         */
        @Signature
        public native int GetManagedSpriteDrawnCount();

        /**
         * Returns the number of sprites that are being managed by the internal sprite
         * manager. It is responsible for updating sprite animation and calculating
         * which sprites are visible and need to be sent for drawing. It also sorts the
         * sprites when necessary for correct transparency drawing. As long as not too
         * many sprites are sent for drawing the sprite manager should be able to handle
         * several hundred sprites.
         *
         * @return int
         */
        @Signature
        public native int GetManagedSpriteCount();

        /**
         * Returns 1 if the current device has a magnetism sensor that is currently
         * supported by AGK, 0 if not.
         *
         * @return int
         */
        @Signature
        public native int GetMagneticSensorExists();

        /**
         * Returns the date and time that the specified notification is due to display.
         * The returned time will be in unix timestamp format, which is measured by the
         * number of seconds since 1st Jan 1970. If no notification exists at the
         * specified ID then 0 is returned
         *
         * @param iID - The ID of the notification to check
         * @return int
         */
        @Signature
        public native int GetLocalNotificationTime(int iID);

        /**
         * Returns 1 if a notification with this ID is waiting to be displayed,
         * otherwise 0. Notifications are refreshed every 5 seconds, so this may
         * continue to return 1 shortly after a notification has fired.
         *
         * @param iID - The ID of the notification to check
         * @return int
         */
        @Signature
        public native int GetLocalNotificationExists(int iID);

        /**
         * Returns the message that the specified notification will display. If no
         * notification exists at the specified ID then an empty string will be returned
         *
         * @param iID - The ID of the notification to check
         * @return String
         */
        @Signature
        public native String GetLocalNotificationMessage(int iID);

        /**
         * Returns the number of images currently loaded into the app.
         *
         * @return int
         */
        @Signature
        public native int GetLoadedImages();

        /**
         * Returns 1 if the current device has an ambient light sensor that is currently
         * supported by AGK, 0 if not.
         *
         * @return int
         */
        @Signature
        public native int GetLightSensorExists();

        /**
         * Returns 1 if the given year is a leap year, otherwise 0.
         *
         * @param year - The year to check.
         * @return int
         */
        @Signature
        public native int GetLeapYear(int year);

        /**
         * Returns a string describing the last error that occurred. This function will
         * continue to return the same string until another error occurs. This does not
         * include warnings.
         *
         * @return String
         */
        @Signature
        public native String GetLastError();

        /**
         * Returns 1 if the current device has a full sized keyboard, 2 if the device
         * has a virtual or mobile phone keyboard and 0 for no keyboard at all.
         *
         * @return int
         */
        @Signature
        public native int GetKeyboardExists();

        /**
         * Returns the unicode value of the last character input
         *
         * @return int
         */
        @Signature
        public native int GetLastChar();

        /**
         * The AGK joystick is an emulated input method that uses whatever device inputs
         * are available to produce a joystick style input in the range -1 to 1. If a
         * physical joystick is attached to the system then that will be used, otherwise
         * if a full sized keyboard is found the keys W,A,S,D will be used as the four
         * directions for the joystick. If neither of these exist then a virtual
         * joystick will be created on screen that can be controlled with either a touch
         * screen or mouse. The virtual joystick used will be index 1, if it already
         * exists its values will be fed into this emulated joystick command. You may
         * position this virtual joystick at a position of your choice on screen using
         * SetJoystickScreenPosition. Every platform is guaranteed to have a method of
         * generating an AGK joystick Y value.
         *
         * @return float
         */
        @Signature
        public native float GetJoystickY();

        /**
         * The AGK joystick is an emulated input method that uses whatever device inputs
         * are available to produce a joystick style input in the range -1 to 1. If a
         * physical joystick is attached to the system then that will be used, otherwise
         * if a full sized keyboard is found the keys W,A,S,D will be used as the four
         * directions for the joystick. If neither of these exist then a virtual
         * joystick will be created on screen that can be controlled with either a touch
         * screen or mouse. The virtual joystick used will be index 1, if it already
         * exists its values will be fed into this emulated joystick command. You may
         * position this virtual joystick at a position of your choice on screen using
         * SetJoystickScreenPosition. Every platform is guaranteed to have a method of
         * generating an AGK joystick X value.
         *
         * @return float
         */
        @Signature
        public native float GetJoystickX();

        /**
         * Returns the amount of torque applied to the joint in the last time step. You
         * can use this to detect large forces and delete the joint to simulate
         * breaking. Torque applies to joints that rotate such as revolute joints.
         *
         * @param iJointIndex - The ID of the joint to check.
         * @return float
         */
        @Signature
        public native float GetJointReactionTorque(int iJointIndex);

        /**
         * Returns 1 if the current device has at least one physical joystick available
         * as an input method. 0 if it has no joystick physical joysticks. If you find
         * that the platform has no physical joysticks you can create virtual ones that
         * appear on screen for use by touch screens or mice with AddVirtualJoystick.
         * GetJoystickExists does not count virtual joysticks in its check. On some
         * platforms joystick detection is run on a background thread that may not
         * complete for some time after your app has started, to wait for the thread to
         * complete use CompleteRawJoystickDetection to be sure that any connected
         * joysticks have been found.
         *
         * @return int
         */
        @Signature
        public native int GetJoystickExists();

        /**
         * Returns the amount of force applied to the joint in the Y direction in the
         * last time step. You can use this to detect large forces and delete the joint
         * to simulate breaking.
         *
         * @param iJointIndex - The ID of the joint to check.
         * @return float
         */
        @Signature
        public native float GetJointReactionForceY(int iJointIndex);

        /**
         * Returns the amount of force applied to the joint in the X direction in the
         * last time step. You can use this to detect large forces and delete the joint
         * to simulate breaking.
         *
         * @param iJointIndex - The ID of the joint to check.
         * @return float
         */
        @Signature
        public native float GetJointReactionForceX(int iJointIndex);

        /**
         * Returns 1 if the specified joint still exists, 0 otherwise. Joints can be
         * deleted by the system.
         *
         * @param iJointIndex - The ID of the joint to check.
         * @return int
         */
        @Signature
        public native int GetJointExists(int iJointIndex);

        /**
         * Returns the current price of the specified in app purchase product in the
         * local currency, this will be a string with the currency symbol included where
         * possible. It may take a few seconds after calling InAppPurchaseSetup for this
         * data to become available, so if you get an empty string try again later. When
         * calling this from Tier 2 you must deleted the returned string when you are
         * done with it.
         *
         * @param iID - this ID corresponds to the product IDs that have been added e.g.
         *            your first product
         * @return String
         */
        @Signature
        public native String GetInAppPurchaseLocalPrice(int iID);

        /**
         * Return the current state of the attempt to activate content. A value of 0
         * indicates that the process is on going, while 1 confirms the process is
         * complete. Currently this command is only supported on iOS and Android.
         *
         * @return int
         */
        @Signature
        public native int GetInAppPurchaseState();

        /**
         * Returns the signature for the last purchase of the given item, this can be
         * checked against your public key to confirm the purchase was valid. It is
         * recommended that you pass this signature to a server to do the check so that
         * the check cannot be bypassed.
         *
         * @param iID - The ID of the product to check. e.g. your first product ID is 0,
         *            your second is 1 etc.
         * @return String
         */
        @Signature
        public native String GetInAppPurchaseSignature(int iID);

        /**
         * Returns the description for the specified product, as defined by the current
         * platform store. It may take a few seconds after calling InAppPurchaseSetup
         * for this data to become available, so if you get an empty string try again
         * later. When calling this from Tier 2 you must deleted the returned string
         * when you are done with it.
         *
         * @param iID - this ID corresponds to the product IDs that have been added e.g.
         *            your first product
         * @return String
         */
        @Signature
        public native String GetInAppPurchaseDescription(int iID);

        /**
         * Returns 1 if the device is connected to the internet, 0 if not.
         *
         * @return int
         */
        @Signature
        public native int GetInternetState();

        /**
         * Opens the image file to extract the width and height values and then
         * immediately closes the file. This is much faster than loading the entire
         * image. This can be useful when using LoadImageResized to know how much to
         * scale the image before loading it. Both the width and height will be returned
         * in a single integer value, the top 16bits will be the width and the lower
         * 16bits will be the height. You can extract these values in Tier 1 by doing
         * width = result >> 16 height = result && 0xFFFF
         *
         * @param filename - The filename of the image to check
         * @return int
         */
        @Signature
        public native int GetImageSizeFromFile(String filename);

        /**
         * Returns the amount of memory in megabytes currently being used by all loaded
         * images (including images used by fonts). This can help track down problems
         * with GPU memory which can cause a crash if it runs out. Every image you load
         * will be placed in GPU memory, even if you don't use it, so loading too many
         * large images could use up all the memory.
         *
         * @return float
         */
        @Signature
        public native float GetImageMemoryUsage();

        /**
         * Returns the height of the image in pixels. Even though this command returns a
         * float the value is guaranteed to be a whole number.
         *
         * @param iImageIndex - The ID of the image to retrieve.
         * @return float
         */
        @Signature
        public native float GetImageHeight(int iImageIndex);

        /**
         * Returns the width of the image in pixels. Even though this command returns a
         * float the value is guaranteed to be a whole number.
         *
         * @param iImageIndex - The ID of the image to retrieve.
         * @return float
         */
        @Signature
        public native float GetImageWidth(int iImageIndex);

        /**
         * Returns 1 if the extra content has been purchased and is therefore available.
         * Returns 0 if the content is not available. Currently this command is only
         * supported on iOS and Android.
         *
         * @param iID - this ID corresponds to the product IDs that have been added e.g.
         *            your first product
         * @return int
         */
        @Signature
        public native int GetInAppPurchaseAvailable(int iID);

        /**
         * Returns 1 if the image exists, 0 if not.
         *
         * @param iImageIndex - The ID of the image to check
         * @return int
         */
        @Signature
        public native int GetImageExists(int iImageIndex);

        /**
         * Returns the file name used to load this image. In tier 2 the returned string
         * must be deleted when you are done with it.
         *
         * @param imageID - The ID of the image to check.
         * @return String
         */
        @Signature
        public native String GetImageFilename(int imageID);

        /**
         * Grabs a portion of the backbuffer and creates a new image from it. The
         * position and size values must be in screen coordinates. Returns the ID of the
         * new image, this must be deleted when you are done with it. To use this
         * command effectively you must know how AGK draws to the back buffer. When Sync
         * is called AGK updates the positions of all objects with Update, then draws
         * them all to the back buffer with Render, without clearing it, then displays
         * the back buffer to the screen with Swap. It then clears the back buffer and
         * returns to your code, so if you were to call GetImage immediately after Sync
         * you would get a blank image filled with the current clear color. Therefore if
         * you want to grab an image of the current scene fully drawn you must call
         * Render then GetImage then ClearScreen to clear the back buffer so Sync
         * doesn't redraw everything over a fully drawn depth buffer. If you are already
         * using Update, Render, and Swap yourself instead of Sync, then call GetImage
         * between Render and Swap. This also allows you to do things such as drawing
         * lines to the back buffer, getting an image of the result and then clearing it
         * so it doesn't effect what is displayed to the screen. Calling GetImage is a
         * slow command and it is not recommended that it be called every frame. Note
         * that the image produced by this command is not guaranteed to have the same
         * width and height as those given to the command, this is because the image is
         * created from a portion of the screen which has a different size on different
         * devices. For example, with a virtual resolution of 480x360, you would get an
         * image of the full screen by calling this command with a width of 480 and a
         * height of 360, but on an iPod this would produce an image of 480x360 pixels,
         * whilst on an iPad it would be around 1024x768 pixels. This should not effect
         * how you use the image as applying it to a sprite and setting the sprite size
         * to the same 480x360 will make the sprite fill the screen in both cases. It
         * simply means that on the iPad you have a higher quality image to play with.
         * This also applies to the line drawing commands, drawing a line from 0,0 to
         * 100,100 and then getting an image from 0,0 to 100,100 will produce a diagonal
         * line image on all devices, but high resolution screen devices will produce an
         * image of higher quality containing more pixels. Use GetImageWidth and
         * GetImageHeight if you need to know the actual size of the image produced in
         * pixels.
         *
         * @param imageID - The image number that will contain the image captured
         * @param x       - The x coordinate of the top left corner of the box to copy
         * @param y       - The y coordinate of the top left corner of the box to copy
         * @param width   - The width of the box to copy
         * @param height  - The height of the box to copy
         * @return void
         */
        @Signature
        public native void GetImage(int imageID, float x, float y, float width, float height);

        /**
         * Grabs a portion of the backbuffer and creates a new image from it. The
         * position and size values must be in screen coordinates. Returns the ID of the
         * new image, this must be deleted when you are done with it. To use this
         * command effectively you must know how AGK draws to the back buffer. When Sync
         * is called AGK updates the positions of all objects with Update, then draws
         * them all to the back buffer with Render, without clearing it, then displays
         * the back buffer to the screen with Swap. It then clears the back buffer and
         * returns to your code, so if you were to call GetImage immediately after Sync
         * you would get a blank image filled with the current clear color. Therefore if
         * you want to grab an image of the current scene fully drawn you must call
         * Render then GetImage then ClearScreen to clear the back buffer so Sync
         * doesn't redraw everything over a fully drawn depth buffer. If you are already
         * using Update, Render, and Swap yourself instead of Sync, then call GetImage
         * between Render and Swap. This also allows you to do things such as drawing
         * lines to the back buffer, getting an image of the result and then clearing it
         * so it doesn't effect what is displayed to the screen. Calling GetImage is a
         * slow command and it is not recommended that it be called every frame. Note
         * that the image produced by this command is not guaranteed to have the same
         * width and height as those given to the command, this is because the image is
         * created from a portion of the screen which has a different size on different
         * devices. For example, with a virtual resolution of 480x360, you would get an
         * image of the full screen by calling this command with a width of 480 and a
         * height of 360, but on an iPod this would produce an image of 480x360 pixels,
         * whilst on an iPad it would be around 1024x768 pixels. This should not effect
         * how you use the image as applying it to a sprite and setting the sprite size
         * to the same 480x360 will make the sprite fill the screen in both cases. It
         * simply means that on the iPad you have a higher quality image to play with.
         * This also applies to the line drawing commands, drawing a line from 0,0 to
         * 100,100 and then getting an image from 0,0 to 100,100 will produce a diagonal
         * line image on all devices, but high resolution screen devices will produce an
         * image of higher quality containing more pixels. Use GetImageWidth and
         * GetImageHeight if you need to know the actual size of the image produced in
         * pixels.
         *
         * @param x      - The x coordinate of the top left corner of the box to copy
         * @param y      - The y coordinate of the top left corner of the box to copy
         * @param width  - The width of the box to copy
         * @param height - The height of the box to copy
         * @return int
         */
        @Signature
        public native int GetImage(float x, float y, float width, float height);

        /**
         * Returns the hours of a given unix time value (0 to 23). Unix time is
         * represented as the number of seconds since the 1st Jan 1970, it may also be
         * negative.
         *
         * @param unixtime - A unix time value.
         * @return int
         */
        @Signature
        public native int GetHoursFromUnix(int unixtime);

        /**
         * Returns the status code that was returned from the server in the response.
         * You must wait for GetHTTPResponseReady to return a non-zero value before
         * checking this command, otherwise it will return 0. Usually the status code is
         * equal to 200 when the request was successful
         *
         * @param iHTTP - The ID of the connection to check.
         * @return int
         */
        @Signature
        public native int GetHTTPStatusCode(int iHTTP);

        /**
         * Returns the progress of the file download as a float value from 0 to 100.
         * This should not be relied upon to work out when the download has finished and
         * on some platforms may not produce an accurate representation of the download
         * progress. Use GetHTTPFileComplete or GetHTTPResponseReady to work out if the
         * download has completed.
         *
         * @param iHTTP - The ID of the connection to check.
         * @return float
         */
        @Signature
        public native float GetHTTPFileProgress(int iHTTP);

        /**
         * Returns 1 if the request previously sent with SendHTTPRequestASync has
         * completed. You can get the response with GetHTTPResponse. Returns 0 if the
         * request is still in progress, or -1 if the request failed.
         *
         * @param iHTTP - The ID of the connection to check.
         * @return int
         */
        @Signature
        public native int GetHTTPResponseReady(int iHTTP);

        /**
         * Returns the reply from the server from a previous sent SendHTTPRequestASync
         * request. You must wait for GetHTTPResponseReady to return 1 before calling
         * this command. In tier 2 you must delete the returned string with
         * agk::DeleteString when you are done using it. Tier 2 has the additional
         * command GetHTTPResponseReadyC which returns a const char that does not need
         * deleting.
         *
         * @param iHTTP - The ID of the connection to check.
         * @return String
         */
        @Signature
        public native String GetHTTPResponse(int iHTTP);

        /**
         * Returns 1 if the file download previously started with GetHTTPFile has
         * completed, 0 otherwise. Even if this returns 1 to say the download is
         * finished it may have failed, check GetHTTPResponseReady for negative values
         * before assuming the download was successful.
         *
         * @param iHTTP - The ID of the connection to check.
         * @return int
         */
        @Signature
        public native int GetHTTPFileComplete(int iHTTP);

        /**
         * Returns 1 if the current device has a gyroscope that is currently supported
         * by AGK, 0 if not.
         *
         * @return int
         */
        @Signature
        public native int GetGyroSensorExists();

        /**
         * Returns the unique ID for the currently logged in player. If no one is logged
         * in, or the platform does not support GameCenter commands then this will
         * return an empty string. If calling this command from Tier 2 then the returned
         * string must be deleted with agk::DeleteString when you are done with it.
         *
         * @return String
         */
        @Signature
        public native String GetGameCenterPlayerID();

        /**
         * Downloads an HTTP file from the server specified in SetHTTPHost and saves it
         * to the location specified. Also allows you to send POST data to the server
         * which can include variables or file data, e.g. "myvar=5&var2=test". This
         * command returns immediately and continues the file download in the
         * background. You can check on the progress of the download with
         * GetHTTPFileProgress and GetHTTPFileComplete. The file will then be at the
         * location you specified ready for use with AGK.
         *
         * @param iHTTP        - The ID of the connection to use.
         * @param szServerFile - The file to request from the server, include everything
         *                     after the domain part of the URL.
         * @param szLocalFile  - The location to save to file, this will be inside the
         *                     write folder for the current device.
         * @param szPostData   - The raw post data to send to the server, note that &
         *                     and = are special characters that separate variables.
         * @return int
         */
        @Signature
        public native int GetHTTPFile(int iHTTP, String szServerFile, String szLocalFile, String szPostData);

        /**
         * Downloads an HTTP file from the server specified in SetHTTPHost and saves it
         * to the location specified. Also allows you to send POST data to the server
         * which can include variables or file data, e.g. "myvar=5&var2=test". This
         * command returns immediately and continues the file download in the
         * background. You can check on the progress of the download with
         * GetHTTPFileProgress and GetHTTPFileComplete. The file will then be at the
         * location you specified ready for use with AGK.
         *
         * @param iHTTP        - The ID of the connection to use.
         * @param szServerFile - The file to request from the server, include everything
         *                     after the domain part of the URL.
         * @param szLocalFile  - The location to save to file, this will be inside the
         *                     write folder for the current device.
         * @return int
         */
        @Signature
        public native int GetHTTPFile(int iHTTP, String szServerFile, String szLocalFile);

        /**
         * Returns the display name for the currently logged in player. If no one is
         * logged in, or the platform does not support GameCenter commands then this
         * will return an empty string. If calling this command from Tier 2 then the
         * returned string must be deleted with agk::DeleteString when you are done with
         * it.
         *
         * @return String
         */
        @Signature
        public native String GetGameCenterPlayerDisplayName();

        /**
         * Will return 1 if the user is logged in to Game Center or Google Play Games, 0
         * if not. The login process is Asynchronous so after calling GameCenterLogin it
         * may take a few seconds for this command to return 1. If the user fails to
         * login or GameCenter is not available then this will return -1.
         *
         * @return int
         */
        @Signature
        public native int GetGameCenterLoggedIn();

        /**
         * Returns 1 if the current platform supports Game Center or Google Play Games.
         *
         * @return int
         */
        @Signature
        public native int GetGameCenterExists();

        /**
         * Returns 1 if there is an Chartboost interstitial ad preloaded and ready to be
         * displayed, otherwise 0. If so you can display it with
         * ShowFullscreenAdvertChartboost. Adverts are preloaded as soon as you set your
         * Chartboost details and after every fullscreen advert is dismissed by the
         * user. If this command continues to return 0 then ad loading may have failed
         * due to the provider running out of ads and AGK will stop trying to load them.
         * In this case you should try your other ad providers instead. If you find all
         * your ad providers are returning 0 then you can try calling
         * ShowFullscreenAdvertChartboost anyway, it will not display anything as there
         * is nothing loaded, but it will restart the loading process to see if any new
         * adverts have become available.
         *
         * @return int
         */
        @Signature
        public native int GetFullscreenAdvertLoadedChartboost();

        /**
         * Returns 1 if there is an Amazon interstitial ad preloaded and ready to be
         * displayed, otherwise 0. If so you can display it with
         * ShowFullscreenAdvertAmazon. Adverts are preloaded as soon as you set your
         * Amazon details and after every fullscreen advert is dismissed by the user. If
         * this command continues to return 0 then ad loading may have failed due to the
         * provider running out of ads and AGK will stop trying to load them. In this
         * case you should try your other ad providers instead. If you find all your ad
         * providers are returning 0 then you can try calling ShowFullscreenAdvertAmazon
         * anyway, it will not display anything as there is nothing loaded, but it will
         * restart the loading process to see if any new adverts have become available.
         *
         * @return int
         */
        @Signature
        public native int GetFullscreenAdvertLoadedAmazon();

        /**
         * Returns 1 if the current device has a GPS receiver that is currently
         * supported by AGK, 0 if not.
         *
         * @return int
         */
        @Signature
        public native int GetGPSSensorExists();

        /**
         * Returns 1 if there is an AdMob interstitial ad preloaded and ready to be
         * displayed, otherwise 0. If so you can display it with
         * ShowFullscreenAdvertAdMob. Adverts are preloaded as soon as you set your
         * AdMob details and after every fullscreen advert is dismissed by the user. If
         * this command continues to return 0 then ad loading may have failed due to the
         * provider running out of ads and AGK will stop trying to load them. In this
         * case you should try your other ad providers instead. If you find all your ad
         * providers are returning 0 then you can try calling ShowFullscreenAdvertAdMob
         * anyway, it will not display anything as there is nothing loaded, but it will
         * restart the loading process to see if any new adverts have become available.
         *
         * @return int
         */
        @Signature
        public native int GetFullscreenAdvertLoadedAdMob();

        /**
         * Get the time in seconds spent processing and rendering the last frame. Only
         * updated when Sync or Swap are called. This is limited to a max value of 0.2
         * seconds to prevent internal timer based code from interpolating large time
         * gaps. To find the true frame time you can use the Timer() command.
         *
         * @return float
         */
        @Signature
        public native float GetFrameTime();

        /**
         * Returns 1 if a font has been loaded successfully at the given ID.
         *
         * @param iFontID - The ID of the font to check.
         * @return int
         */
        @Signature
        public native int GetFontExists(int iFontID);

        /**
         * Returns the number of folders in the current folder. Does not include . or ..
         *
         * @param mode - 0 to count only folders in the read folder, 1 to only count the
         *             write folder, 2 to count both
         * @return int
         */
        @Signature
        public native int GetFolderCount(int mode);

        /**
         * Returns the number of folders in the current folder. Does not include . or ..
         *
         * @return int
         */
        @Signature
        public native int GetFolderCount();

        /**
         * Returns the current folder previously set with SetFolder. The returned path
         * will always have a slash as the final character except when in the root
         * folder in which case an empty string will be returned.
         *
         * @return String
         */
        @Signature
        public native String GetFolder();

        /**
         * Returns the name of the first folder found in the current folder, which is
         * set using SetFolder. You can call GetNextFolder to continue down the list of
         * folders in the current folder. Returns an empty string if there are no
         * folders in the current folder. Does not include . or .. Note that there is a
         * known limitation on Android that any folders within the "assets" folder
         * cannot be found using this command. You may be able to work around this by
         * using MakeFolder to create the same folder structure in the write folder
         * which AGK can then use to find files in the assets folder with GetFirstFile.
         * By default this command will combine the folder lists from the read and write
         * folders into a single list (mode=2) this can be changed to only return
         * folders in the read folder (mode=0) or only return folders from the write
         * folder (mode=1)
         *
         * @return String
         */
        @Signature
        public native String GetFirstFolder();

        /**
         * Returns the name of the first folder found in the current folder, which is
         * set using SetFolder. You can call GetNextFolder to continue down the list of
         * folders in the current folder. Returns an empty string if there are no
         * folders in the current folder. Does not include . or .. Note that there is a
         * known limitation on Android that any folders within the "assets" folder
         * cannot be found using this command. You may be able to work around this by
         * using MakeFolder to create the same folder structure in the write folder
         * which AGK can then use to find files in the assets folder with GetFirstFile.
         * By default this command will combine the folder lists from the read and write
         * folders into a single list (mode=2) this can be changed to only return
         * folders in the read folder (mode=0) or only return folders from the write
         * folder (mode=1)
         *
         * @param mode - 0 to only return folders from the read folder, 1 to only return
         *             folders from the write folder, 2 for both (default)
         * @return String
         */
        @Signature
        public native String GetFirstFolder(int mode);

        /**
         * Returns the name of the first file found in the current folder, which is set
         * using SetFolder. You can call GetNextFile to continue down the list of files
         * in the current folder. Returns an empty string if there are no files in the
         * current folder. By default this command will combine the file lists from the
         * read and write folders into a single list (mode=2) this can be changed to
         * only return files in the read folder (mode=0) or only return files from the
         * write folder (mode=1) Note that the read folder does not exist when using
         * broadcast or debug to run the app, as files are copied into the write folder
         * of the AGK Player for these run modes. On the other hand the write folder
         * starts out as empty when running the app directly from the IDE, or when
         * running the final app executable in the project folder.
         *
         * @param mode - 0 to only return files from the read folder, 1 to only return
         *             files from the write folder, 2 for both (default)
         * @return String
         */
        @Signature
        public native String GetFirstFile(int mode);

        /**
         * Returns the name of the first file found in the current folder, which is set
         * using SetFolder. You can call GetNextFile to continue down the list of files
         * in the current folder. Returns an empty string if there are no files in the
         * current folder. By default this command will combine the file lists from the
         * read and write folders into a single list (mode=2) this can be changed to
         * only return files in the read folder (mode=0) or only return files from the
         * write folder (mode=1) Note that the read folder does not exist when using
         * broadcast or debug to run the app, as files are copied into the write folder
         * of the AGK Player for these run modes. On the other hand the write folder
         * starts out as empty when running the app directly from the IDE, or when
         * running the final app executable in the project folder.
         *
         * @return String
         */
        @Signature
        public native String GetFirstFile();

        /**
         * Returns 1 if 3D fog is currently on, otherwise it returns 0.
         *
         * @return int
         */
        @Signature
        public native int GetFogMode();

        /**
         * Cycles through the list of all contacts detected in the last physics step.
         * Returns 1 if a contact exists, you can get the sprites involved in this
         * contact using GetContactSpriteID1 and GetContactSpriteID2, you can move on to
         * the next contact with GetNextContact. Returns 0 if there are no contacts.
         *
         * @return int
         */
        @Signature
        public native int GetFirstContact();

        /**
         * Returns the size in bytes of the opened file.
         *
         * @param iFileID - The ID of the file to check.
         * @return int
         */
        @Signature
        public native int GetFileSize(int iFileID);

        /**
         * Returns the number of files in the current folder.
         *
         * @param mode - 0 to count only files in the read folder, 1 to only count the
         *             write folder, 2 to count both
         * @return int
         */
        @Signature
        public native int GetFileCount(int mode);

        /**
         * Returns the number of files in the current folder.
         *
         * @return int
         */
        @Signature
        public native int GetFileCount();

        /**
         * Returns 1 if the given file is located in either the resource directory or
         * the write directory assigned to the app.
         *
         * @param szFile - The filename to check.
         * @return int
         */
        @Signature
        public native int GetFileExists(String szFile);

        /**
         * Returns the current read position in the file
         *
         * @param iFileID - The ID of the file to check.
         * @return int
         */
        @Signature
        public native int GetFilePos(int iFileID);

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return int
         */
        @Signature
        public native int GetFacebookLoggedIn();

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return int
         */
        @Signature
        public native int GetFacebookDownloadState();

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return String
         */
        @Signature
        public native String GetFacebookDownloadFile();

        /**
         * Returns the state of any expansion file used by this platform, currently only
         * applicable to Android. Returns -1 if an error occurred during download, 0 if
         * the expansion file is not used on this platform, 1 if it should exist but
         * doesn't (you call DownloadExpansionFile() in this case), 2 if it is currently
         * being downloaded, and 3 if everything has completed and the file exists.
         *
         * @return int
         */
        @Signature
        public native int GetExpansionFileState();

        /**
         * Returns the error code of the most recent error that occurred when
         * downloading the expansion file. Possible errors include: 15 = Unlicensed 16 =
         * Failed fetching URL 17 = SDcard full 18 = Cancelled 19 = Unknown error
         *
         * @return int
         */
        @Signature
        public native int GetExpansionFileError();

        /**
         * Checks the progress of a download started by DownloadExpansionFile, returns a
         * float value between 0 and 100 Use GetExpansionFileState to check if the
         * download has completed.
         *
         * @return float
         */
        @Signature
        public native float GetExpansionFileProgress();

        /**
         * Returns 1 if an error occurred since the last call to this command. 0 if not.
         * This does not include warnings.
         *
         * @return int
         */
        @Signature
        public native int GetErrorOccurred();

        /**
         * Returns the current X position of the edit box. This is the top left corner
         * of the actual text entry box, any border will extend to the left of this
         * point.
         *
         * @param index - The ID of the edit box to check.
         * @return float
         */
        @Signature
        public native float GetEditBoxX(int index);

        /**
         * Returns the current Y position of the edit box. This is the top left corner
         * of the actual text entry box, any border will extend above this point.
         *
         * @param index - The ID of the edit box to check.
         * @return float
         */
        @Signature
        public native float GetEditBoxY(int index);

        /**
         * Returns 1 if the edit box is visible and can be clicked on, 0 if the edit box
         * is invisible and cannot be changed.
         *
         * @param index - The ID of the edit box to check.
         * @return int
         */
        @Signature
        public native int GetEditBoxVisible(int index);

        /**
         * Returns the current width of the edit box. This is the width of the actual
         * text entry box, any border will extend beyond this value.
         *
         * @param index - The ID of the edit box to check.
         * @return float
         */
        @Signature
        public native float GetEditBoxWidth(int index);

        /**
         * Returns the text currently being displayed in the edit box.
         *
         * @param index - The ID of the edit box to check.
         * @return String
         */
        @Signature
        public native String GetEditBoxText(int index);

        /**
         * Returns the number of lines of text the user has entered into the edit box.
         *
         * @param index - The ID of the edit box to check.
         * @return int
         */
        @Signature
        public native int GetEditBoxLines(int index);

        /**
         * Returns the current height of the edit box. This is the height of the actual
         * text entry box, any border will extend beyond this value.
         *
         * @param index - The ID of the edit box to check.
         * @return float
         */
        @Signature
        public native float GetEditBoxHeight(int index);

        /**
         * Returns 1 if an edit box with the given ID exists, 0 otherwise.
         *
         * @param index - The ID of the edit box to check.
         * @return int
         */
        @Signature
        public native int GetEditBoxExists(int index);

        /**
         * Returns 1 if the edit box has been clicked on and is accepting input.
         *
         * @param index - The ID of the edit box to check.
         * @return int
         */
        @Signature
        public native int GetEditBoxHasFocus(int index);

        /**
         * Returns the current depth of the edit box with 0 being the front of the
         * screen and 10000 being the back.
         *
         * @param index - The ID of the edit box to check.
         * @return int
         */
        @Signature
        public native int GetEditBoxDepth(int index);

        /**
         * Returns 1 if the edit box has just lost focus, meaning the text may have
         * changed and is not likely to change again in the short term.
         *
         * @param index - The ID of the edit box to check.
         * @return int
         */
        @Signature
        public native int GetEditBoxChanged(int index);

        /**
         * Gets the cursor to the specified position in the text, i.e. position 0 is
         * left of the first character, position 1 is left of the second character, and
         * so on.
         *
         * @param index - The ID of the edit box to check.
         * @return int
         */
        @Signature
        public native int GetEditBoxCursorPosition(int index);

        /**
         * Returns the time spent swapping the backbuffer and (if necessary) waiting for
         * the GPU to catch up ready for the next frame.
         *
         * @return float
         */
        @Signature
        public native float GetDrawingTime();

        /**
         * Returns 1 if the edit box is enabled and can be clicked on, 0 if the edit box
         * is disabled and cannot be changed.
         *
         * @param index - The ID of the edit box to check.
         * @return int
         */
        @Signature
        public native int GetEditBoxActive(int index);

        /**
         * Returns the number of seconds and fractions of seconds spent setting up the
         * world ready for drawing. This includes calculating what is visible,
         * transforming sprites into their screen positions and sending vertices to the
         * GPU.
         *
         * @return float
         */
        @Signature
        public native float GetDrawingSetupTime();

        /**
         * Returns the directory that contains the current users documents. On Windows
         * this will be something like "C:\Users\Me\My Documents", on iOS this will just
         * be the app write directory. By default all apps write to the system specified
         * app settings folder, for example "C:\Users\Me\AppData" on Windows,
         * "/home/user/.config" on Linux, and a protected app data folder on Android.
         * Where possible the contents pf the documents path is visible to the user, for
         * example on Android 10 and below it will be the sdcard folder. iOS and Android
         * 11 and higher can't provide a publicly accessible location to write to so
         * will return the app write directory instead, which is not visible to the
         * user.
         *
         * @return String
         */
        @Signature
        public native String GetDocumentsPath();

        /**
         * Returns the current aspect ratio for the screen. This is not the aspect ratio
         * of the coordinate system being used, instead this value stretches the
         * coordinate system into the desired shape. For an explanation of the
         * coordinate system see SetVirtualResolution.
         *
         * @return float
         */
        @Signature
        public native float GetDisplayAspect();

        /**
         * Returns the current direction value in the X direction. The direction is an
         * emulated value that will use an accelerometer where available or keyboard
         * arrow keys if not.
         *
         * @return float
         */
        @Signature
        public native float GetDirectionX();

        /**
         * Returns the current direction value in the Y direction. The direction is an
         * emulated value that will use an accelerometer where available or keyboard
         * arrow keys if not.
         *
         * @return float
         */
        @Signature
        public native float GetDirectionY();

        /**
         * Returns the current direction speed as an absolute value between 0 and 1.4,
         * this is used with GetDirectionAngle to determine the extent of the direction.
         * The direction is an emulated value that will use an accelerometer where
         * available or keyboard arrow keys if not.
         *
         * @return float
         */
        @Signature
        public native float GetDirectionSpeed();

        /**
         * Returns the current direction angle with respect to x=0, y=-1 (up). The angle
         * will be in the range 0-360. The direction is an emulated value that will use
         * an accelerometer where available or keyboard arrow keys if not.
         *
         * @return float
         */
        @Signature
        public native float GetDirectionAngle();

        /**
         * Returns the width in pixels of the current device's backbuffer. This value
         * will change if the device orientation changes from portrait to landscape, but
         * only if orientation changes are allowed.
         *
         * @return int
         */
        @Signature
        public native int GetDeviceWidth();

        /**
         * On Android this returns 0 if this app is running on a Google device, or 1 if
         * it is running on an Amazon device. On all other platforms this returns 0.
         *
         * @return int
         */
        @Signature
        public native int GetDevicePlatform();

        /**
         * Returns a string containing a device specific string, this will be different
         * for each platform, for example on Windows it will return the OS version
         * "vista, "7", "xp", etc. On iOS it will return the iOS device name "ipad1,1",
         * "ipod2,1", "iphone1,2", etc. For Android it will return the device model
         * "nexus 7", etc. For Mac it will return the OS version "10.7", "10.8", etc.
         * This string will always be lower case
         *
         * @return String
         */
        @Signature
        public native String GetDeviceType();

        /**
         * Returns the type of network connection the device has to the internet.
         * Returns 0 if a mobile connection is being used, 1 if a Wifi or Ethernet
         * connection is being used, or -1 if the network type could not be determined.
         * Currently only implemented on iOS and Android, other platforms will return
         * -1.
         *
         * @return int
         */
        @Signature
        public native int GetDeviceNetworkType();

        /**
         * Returns a string containing the language of the current device in the form
         * "en", "fr", "de", etc.
         *
         * 
         * @return String
         */
        @Signature
        public native String GetDeviceLanguage();

        /**
         * Returns the IPv6 address of the current device, this can be used by other
         * devices to connect to this device. To get the IPv4 address use GetDeviceIP
         * instead.
         *
         * @return String
         */
        @Signature
        public native String GetDeviceIPv6();

        /**
         * This command is deprecated, please use GetDeviceBaseName and GetDeviceType
         * instead. Returns a string containing the name of the current platform. e.g.
         * "windows". When dealing with iOS more information is returned e.g. on iPad 1
         * "ios|iPad1,1" and on iPod 2nd gen: "ios|iPod2,1" and on iPhone 3G:
         * "ios|iPhone1,2". The first number is the major model number, the second is
         * the minor model number.
         *
         * 
         * @return String
         */
        @Signature
        public native String GetDeviceName();

        /**
         * Returns the IPv4 address of the current device, this can be used by other
         * devices to connect to this device. To get the IPv6 address use GetDeviceIPv6
         * instead.
         *
         * @return String
         */
        @Signature
        public native String GetDeviceIP();

        /**
         * Returns a string that can be used to identify this device
         *
         * @return String
         */
        @Signature
        public native String GetDeviceID();

        /**
         * Returns the height in pixels of the current device's backbuffer. This value
         * will change if the device orientation changes from portrait to landscape, but
         * only if orientation changes are allowed.
         *
         * @return int
         */
        @Signature
        public native int GetDeviceHeight();

        /**
         * Returns 1 if the given camera ID is a back facing camera, 2 if it is a front
         * facing camera, or 0 if this is unknown.
         *
         * @param cameraID - The ID of the device camera you want to check
         * @return int
         */
        @Signature
        public native int GetDeviceCameraType(int cameraID);

        /**
         * Gets the Dots Per Inch (also called Pixels Per Inch) of the device screen.
         * This only works on iOS and Android, other platforms will return 0. On iOS
         * this value is hardcoded by device, so if a new device is released then an AGK
         * update will be required to get an accurate value. In the meantime an
         * estimated value will be generated.
         *
         * @return int
         */
        @Signature
        public native int GetDeviceDPI();

        /**
         * Returns a string containing the name of the current platform. This will only
         * refer to the base platform, i.e. "windows", "ios", "android", "mac", "linux",
         * or "html5". Use GetDeviceType to get more information about the specific
         * device. This string will always be lower case.
         *
         * @return String
         */
        @Signature
        public native String GetDeviceBaseName();

        /**
         * Returns the days of a given unix time value (1 to 31). Unix time is
         * represented as the number of seconds since the 1st Jan 1970, it may also be
         * negative.
         *
         * @param unixtime - A unix time value.
         * @return int
         */
        @Signature
        public native int GetDaysFromUnix(int unixtime);

        /**
         * Returns a string representing the current time in the format HH-MM-SS, for
         * example 15:23:04.
         *
         * @return String
         */
        @Signature
        public native String GetCurrentTime();

        /**
         * Returns the ID of the currently active edit box, only one edit box may focus
         * at a time. If no edit box currently has focus it returns 0.
         *
         * @return int
         */
        @Signature
        public native int GetCurrentEditBox();

        /**
         * This command is deprecated and has been replaced with GetFolder.
         *
         * @return String
         */
        @Signature
        public native String GetCurrentDir();

        /**
         * Returns an integer representing the current day of the week in the range 0-6
         * with 0 as Sunday, 1 as Monday, etc.
         *
         * @return int
         */
        @Signature
        public native int GetDayOfWeek();

        /**
         * Returns a string representing the current date in the format YYYY-MM-DD, for
         * example 2012-01-09.
         *
         * @return String
         */
        @Signature
        public native String GetCurrentDate();

        /**
         * Returns the X position of the contact point in world coordinates.
         *
         * @return float
         */
        @Signature
        public native float GetContactWorldX();

        /**
         * Returns the Y position of the contact point in world coordinates.
         *
         * @return float
         */
        @Signature
        public native float GetContactWorldY();

        /**
         * Returns the ID of the second sprite involved in this contact. If this half of
         * the contact is with an item not associated to a sprite this will return 0.
         *
         * @return int
         */
        @Signature
        public native int GetContactSpriteID2();

        /**
         * Returns the ID of the first sprite involved in this contact. If this half of
         * the contact is with an item not associated to a sprite this will return 0.
         *
         * @return int
         */
        @Signature
        public native int GetContactSpriteID1();

        /**
         * Returns the current user consent status, it returns one of the following
         * values: -2 = LoadConsentStatusAdMob has not yet been called, you must call it
         * before proceeding further -1 = LoadConsentStatusAdMob is in the process of
         * loading the user consent status, please wait 0 = User has not yet been asked,
         * AdMob ads will default to not using personal information, call
         * RequestConsentAdMob to prompt the user for consent 1 = User has refused
         * consent, any AdMob ads displayed will not use personal information 2 = User
         * has given consent, any AdMob ads displayed will use personal information
         *
         * @return int
         */
        @Signature
        public native int GetConsentStatusAdMob();

        /**
         * Returns the red component of a compound color value created with MakeColor
         *
         * @param color - The color value to decompose.
         * @return int
         */
        @Signature
        public native int GetColorRed(int color);

        /**
         * Returns the value of a cloud data variable by name. If the variable does not
         * exist then the default value passed in will be returned instead. If you are
         * calling this command from Tier 2 then you must delete the returned string
         * when you are done with it by calling agk::DeleteString.
         *
         * @param varName      - The name of the variable to check, must be less than 64
         *                     bytes
         * @param defaultValue - The value to return if the variable doesn't exist
         * @return String
         */
        @Signature
        public native String GetCloudDataVariable(String varName, String defaultValue);

        /**
         * Returns the green component of a compound color value created with MakeColor
         *
         * @param color - The color value to decompose.
         * @return int
         */
        @Signature
        public native int GetColorGreen(int color);

        /**
         * Returns the blue component of a compound color value created with MakeColor
         *
         * @param color - The color value to decompose.
         * @return int
         */
        @Signature
        public native int GetColorBlue(int color);

        /**
         * Returns 1 if the cloud data has changed due to another device changing a
         * value, this will remain 1 until you call GetCloudDataVariable. Otherwise
         * returns 0. This will not become 1 when you change the value locally.
         *
         * @return int
         */
        @Signature
        public native int GetCloudDataChanged();

        /**
         * Returns 1 if the cloud data commands are available to use. Returns 0 if the
         * user hasn't decided whether to allow or block access yet, this will be
         * prompted in SetupCloudData if applicable. Returns -1 if the user has
         * specifically denied access. Returns -2 if the user is not logged in or the
         * device does not have iCloud or Google Drive. You can prompt the user to login
         * and enable these when your app first starts, or when they choose to enable
         * cloud backup in your own app settings. If this command returns -3 on Android
         * then the Google cloud data has become corrupted and must be cleared in the
         * Drive settings.
         *
         * @return int
         */
        @Signature
        public native int GetCloudDataAllowed();

        /**
         * Gets any text currently held in the device clipboard, the text remains in the
         * clipboard so it can still be used by other apps. The clipboard is the same as
         * that used by the copy/paste functionality of the device.
         *
         * @return String
         */
        @Signature
        public native String GetClipboardText();

        /**
         * Returns the current length of the char buffer wihtout modifying it. Note that
         * this is the length in characters, not bytes, which may be different when the
         * string contains unicode characters.
         *
         * @return int
         */
        @Signature
        public native int GetCharBufferLength();

        /**
         * Returns the ID of a newly chosen image picked using ShowChooseImageScreen. If
         * this returns 0 then the user cancelled the process or you have not yet
         * started it with ShowChooseImageScreen. Once you have called this command to
         * retrieve the image ID it will return 0 until ShowChooseImageScreen is called
         * again.
         *
         * @return int
         */
        @Signature
        public native int GetChosenImage();

        /**
         * Returns a string of all the characters pressed since the last time this
         * command was called, after this command is called the buffer is cleared. This
         * only works on devices with a physical keyboard. The buffer is limited to 1024
         * characters, after which additional characters will be ignored. In Tier 2 the
         * string is encoded in UTF-8, and must be deleted with agk::DeleteString when
         * you are done with it.
         *
         * @return String
         */
        @Signature
        public native String GetCharBuffer();

        /**
         * This function has been deprecated, use SetDeviceCameraToImage instead.
         * Returns the ID of a newly captured image created using
         * ShowImageCaptureScreen. If this returns 0 then the user cancelled the process
         * or you have not yet started it with ShowImageCaptureScreen. Once you have
         * called this command to retrieve the image ID it will return 0 until
         * ShowImageCaptureScreen is called again.
         *
         * @return int
         */
        @Signature
        public native int GetCapturedImage();

        /**
         * Returns the current Z position of the camera.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraZ(int cameraID);

        /**
         * Returns the current Y position of the camera.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraY(int cameraID);

        /**
         * Returns the current X position of the camera.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraX(int cameraID);

        /**
         * Returns the current Z position of the camera after all transformations due to
         * FixCameraToObject.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraWorldZ(int cameraID);

        /**
         * Returns the current X position of the camera after all transformations due to
         * FixCameraToObject.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraWorldX(int cameraID);

        /**
         * Returns the current Y position of the camera after all transformations due to
         * FixCameraToObject.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraWorldY(int cameraID);

        /**
         * Returns the Y component of the camera's current rotation converted to a
         * quaternion.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraQuatY(int cameraID);

        /**
         * Returns the Z component of the camera's current rotation converted to a
         * quaternion.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraQuatZ(int cameraID);

        /**
         * Returns the X component of the camera's current rotation converted to a
         * quaternion.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraQuatX(int cameraID);

        /**
         * Returns the W component of the camera's current rotation converted to a
         * quaternion.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraQuatW(int cameraID);

        /**
         * Returns 1 if the current device has a camera, 0 if not. On some platforms
         * this command enumerates the hardware devices to check for a camera which may
         * be slow. It is not recommended that you call this every frame. On Windows
         * this command will successfully detect a new camera being plugged in whilst
         * the app is running.
         *
         * @return int
         */
        @Signature
        public native int GetCameraExists();

        /**
         * Returns the current Field Of View for the specified camera
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraFOV(int cameraID);

        /**
         * Returns the Z component of the camera's current rotation converted to Euler
         * angles.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraAngleZ(int cameraID);

        /**
         * Returns the Y component of the camera's current rotation converted to Euler
         * angles.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraAngleY(int cameraID);

        /**
         * Returns the X component of the camera's current rotation converted to Euler
         * angles.
         *
         * @param cameraID - The ID of the camera to check, the main camera is ID 1.
         * @return float
         */
        @Signature
        public native float GetCameraAngleX(int cameraID);

        /**
         * This function returns 1 if the specified button is currently being held down.
         * The AGK buttons are an emulated input method that uses whatever device inputs
         * are available to produce 5 buttons. If a real joystick is found then the
         * first 5 buttons from that will be used for the AGK button commands. Otherwise
         * the AGK looks for a full-size keyboard and if found will use the following
         * keys in the following order Space, E, R, Q, Control, to represent buttons 1
         * to 5 respectively. If neither a joystick nor keyboard is found then a virtual
         * button is created that will appear on screen and can be pressed with either
         * touch screen inputs or a mouse. Every platform is guaranteed to have a method
         * of activating the AGK buttons.
         *
         * @param index - The ID of the button to check, must be in the range 1 to 5
         *              inclusive.
         * @return int
         */
        @Signature
        public native int GetButtonState(int index);

        /**
         * This function returns 1 if the specified button has just been released, then
         * returns 0 whilst the button is up. The AGK buttons are an emulated input
         * method that uses whatever device inputs are available to produce 5 buttons.
         * If a real joystick is found then the first 5 buttons from that will be used
         * for the AGK button commands. Otherwise the AGK looks for a full-size keyboard
         * and if found will use the following keys in the following order Space, E, R,
         * Q, Control, to represent buttons 1 to 5 respectively. If neither a joystick
         * nor keyboard is found then a virtual button is created that will appear on
         * screen and can be pressed with either touch screen inputs or a mouse. Every
         * platform is guaranteed to have a method of activating the AGK buttons.
         *
         * @param index - The ID of the button to check, must be in the range 1 to 5
         *              inclusive.
         * @return int
         */
        @Signature
        public native int GetButtonReleased(int index);

        /**
         * This function returns 1 if the specified button has just been pressed, then
         * returns 0 while the button is held down. The AGK buttons are an emulated
         * input method that uses whatever device inputs are available to produce 5
         * buttons. If a real joystick is found then the first 5 buttons from that will
         * be used for the AGK button commands. Otherwise the AGK looks for a full-size
         * keyboard and if found will use the following keys in the following order
         * Space, E, R, Q, Control, to represent buttons 1 to 5 respectively. If neither
         * a joystick nor keyboard is found then a virtual button is created that will
         * appear on screen and can be pressed with either touch screen inputs or a
         * mouse. Every platform is guaranteed to have a method of activating the AGK
         * buttons.
         *
         * @param index - The ID of the button to check, must be in the range 1 to 5
         *              inclusive.
         * @return int
         */
        @Signature
        public native int GetButtonPressed(int index);

        /**
         * Checks a broadcast listener for any broadcasts. Returns 0 if nothing has been
         * received. Returns a message ID if something has been received, you can access
         * the contents of this message using network message commands. The message must
         * be deleted when you have finished reading from it.
         *
         * @param iID - The ID of the broadcast listener to check.
         * @return int
         */
        @Signature
        public native int GetBroadcastMessage(int iID);

        /**
         * Returns 1 if the specified app ID is still running, 0 if it is not.
         *
         * @param appID - The app ID to check, returned from RunApp()
         * @return int
         */
        @Signature
        public native int GetAppRunning(int appID);

        /**
         * On Android this returns the package name used when exporting the app, for
         * example for the AGK Player this would be com.thegamecreators.agk_player2. On
         * iOS it returns the Bundle ID used for the app, for example for the AGK Player
         * this would be com.thegamecreators.agk2player. On all other platforms this
         * currently returns an empty string. If calling this from tier 2 then the
         * returned string must be deleted when it is no longer needed.
         *
         * @return String
         */
        @Signature
        public native String GetAppPackageName();

        /**
         * Returns the name of the exe.
         *
         * 
         * @return String
         */
        @Signature
        public native String GetAppName();

        /**
         * Returns 1 if the specified app is installed and enabled on the device. For
         * Android this should be the package name of the app, e.g. com.faceboook.katana
         * for the Facebook App. Currently this only works on Android
         *
         * @param packageName - The package name of the app to check
         * @return int
         */
        @Signature
        public native int GetAppInstalled(String packageName);

        /**
         * Returns 1 if the current device has an accelerometer that is currently
         * supported by AGK, 0 if not.
         *
         * @return int
         */
        @Signature
        public native int GetAccelerometerExists();

        /**
         * Converts a 2D point on the screen into a vector pointing into the 3D world.
         * The vector is normalised to 1 unit long, to extend it into the world simply
         * multiply it by your desired distance. If the camera is using an orthographic
         * projection matrix then this command behaves slightly differently, since all
         * points on the screen would produce the same vector pointing away from the
         * camera, but each originating from a different point in 3D space. This differs
         * from a perspective projection where all vectors start at the camera position
         * and fan out as they move away from the camera. So when using an orthographic
         * projection matrix this command will instead return a sideways unnormalised
         * vector from the camera position to the point in 3D space that the vector
         * should start. This can then be combined with a vector that points away from
         * the camera to create a ray cast into the scene.
         *
         * @param x - The X component of the screen position.
         * @param y - The Y component of the screen position.
         * @return float
         */
        @Signature
        public native float Get3DVectorZFromScreen(float x, float y);

        /**
         * Converts a 2D point on the screen into a vector pointing into the 3D world.
         * The vector is normalised to 1 unit long, to extend it into the world simply
         * multiply it by your desired distance. If the camera is using an orthographic
         * projection matrix then this command behaves slightly differently, since all
         * points on the screen would produce the same vector pointing away from the
         * camera, but each originating from a different point in 3D space. This differs
         * from a perspective projection where all vectors start at the camera position
         * and fan out as they move away from the camera. So when using an orthographic
         * projection matrix this command will instead return a sideways unnormalised
         * vector from the camera position to the point in 3D space that the vector
         * should start. This can then be combined with a vector that points away from
         * the camera to create a ray cast into the scene.
         *
         * @param x - The X component of the screen position.
         * @param y - The Y component of the screen position.
         * @return float
         */
        @Signature
        public native float Get3DVectorXFromScreen(float x, float y);

        /**
         * Converts a 2D point on the screen into a vector pointing into the 3D world.
         * The vector is normalised to 1 unit long, to extend it into the world simply
         * multiply it by your desired distance. If the camera is using an orthographic
         * projection matrix then this command behaves slightly differently, since all
         * points on the screen would produce the same vector pointing away from the
         * camera, but each originating from a different point in 3D space. This differs
         * from a perspective projection where all vectors start at the camera position
         * and fan out as they move away from the camera. So when using an orthographic
         * projection matrix this command will instead return a sideways unnormalised
         * vector from the camera position to the point in 3D space that the vector
         * should start. This can then be combined with a vector that points away from
         * the camera to create a ray cast into the scene.
         *
         * @param x - The X component of the screen position.
         * @param y - The Y component of the screen position.
         * @return float
         */
        @Signature
        public native float Get3DVectorYFromScreen(float x, float y);

        /**
         * Returns the total number of physics objects in the world.
         *
         * @return int
         */
        @Signature
        public native int Get3DPhysicsTotalObjects();

        /**
         * Returns the total number of joints in the physics world
         *
         * @return int
         */
        @Signature
        public native int Get3DPhysicsTotalJoints();

        /**
         * Return the ID of the Object hit by the ray at the index.
         *
         * @param rayID         - ID of the ray
         * @param fractionIndex - value returned by Get3DPhysicsRayCastFraction()
         *                      command.
         * @return int
         */
        @Signature
        public native int Get3DPhysicsRayCastObjectHit(int rayID, float fractionIndex);

        /**
         * Returns the distance along the ray until collision where 1.0 = full length,
         * 0.0 = beginning.
         *
         * @param rayID - ID of the ray
         * @return float
         */
        @Signature
        public native float Get3DPhysicsRayCastFraction(int rayID);

        /**
         * Fills the vector passed in with the Normals values from the ray. first create
         * a physics ray then cast the ray before calling
         * Get3DPhysicsRayCastNormalVector().
         *
         * @param rayID        - The ID of the ray which is returned by calling
         *                     Create3DPhysicsRay().
         * @param returnVec3ID - The Id of a vector. Vector ID is the return value from
         *                     CreateVector3() command.
         * @return void
         */
        @Signature
        public native void Get3DPhysicsRayCastNormalVector(int rayID, int returnVec3ID);

        /**
         * Returns the total number of hits the ray has along its length.
         *
         * @param rayID - The ID of the ray which is returned by calling
         *              Create3DPhysicsRay().
         * @return int
         */
        @Signature
        public native int Get3DPhysicsRayCastNumHits(int rayID);

        /**
         * Returns true if there is a contact vector and fills the vector outVec3ID.
         * First create a vector with CreateVector3() then pass in the ID. The vector
         * you have created and passed in will be filled with the results.
         *
         * @param rayID         - ID of the ray
         * @param fractionIndex - value returned by Get3DPhysicsRayCastFraction()
         *                      command.
         * @param outVec3ID     - Id of the vector that will be filled with the
         *                      position.
         * @return int
         */
        @Signature
        public native int Get3DPhysicsRayCastContactPosition(int rayID, float fractionIndex, int outVec3ID);

        /**
         * Return the Closest Object hit by the ray.
         *
         * @param rayID - ID of the ray
         * @return int
         */
        @Signature
        public native int Get3DPhysicsRayCastClosestObjectHit(int rayID);

        /**
         * Returns true if there is a closest contact vector and fills the vector
         * outVec3ID. First create a vector with CreateVector3() then pass in the ID.
         * The vector you have created and passed in will be filled with the results.
         *
         * @param rayID     - ID of the ray
         * @param outVec3ID - Id of the vector that will be filled with the position.
         * @return int
         */
        @Signature
        public native int Get3DPhysicsRayCastClosestContactPosition(int rayID, int outVec3ID);

        /**
         * Returns true if a ragdoll exists for the object.
         *
         * @param objID - object ID
         * @return int
         */
        @Signature
        public native int Get3DPhysicsRagdollExist(int objID);

        /**
         * Returns the object ID of the Model with the ragdoll which contains the
         * ragdoll bone object passed in.
         *
         * @param objID - object ID of a ragdoll bone capsule.
         * @return int
         */
        @Signature
        public native int Get3DPhysicsRagdollFromBoneObject(int objID);

        /**
         * Returns the joints X rotation angle in degrees
         *
         * @param jointID - The ID of the joint.
         * @return int
         */
        @Signature
        public native int Get3DPhysicsJointRotationVector(int jointID);

        /**
         * Returns the vector ID
         *
         * @param jointID - Id of a Joint
         * @return int
         */
        @Signature
        public native int Get3DPhysicsJointPositionVector(int jointID);

        /**
         * Returns the maximum slope in degrees.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float Get3DPhysicsCharacterControllerMaxSlope(int objID);

        /**
         * Returns the controller gravity.
         *
         * @param objID - object ID
         * @return float
         */
        @Signature
        public native float Get3DPhysicsCharacterControllerGravity(int objID);

        /**
         * Returns the breaking threshold for the joint.
         *
         * @param jointID - Id of joint
         * @return int
         */
        @Signature
        public native int Get3DPhysicsJointEnabled(int jointID);

        /**
         * Returns a 1 if the object has a controller otherwise 0.
         *
         * @param objID - object ID
         * @return int
         */
        @Signature
        public native int Get3DPhysicsCharacterControllerExists(int objID);

        /**
         * Returns the total number of active objects in the physics world.
         *
         * @return int
         */
        @Signature
        public native int Get3DPhysicsActiveObjects();

        /**
         * Returns the current Z position of the emitter, this is the point that new
         * particles will appear from. It is not possible to get the position of
         * individual particles, they are merely created, follow a path influenced by
         * forces, and then disappear.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesZ(int ID);

        /**
         * Returns the current X position of the emitter, this is the point that new
         * particles will appear from. It is not possible to get the position of
         * individual particles, they are merely created, follow a path influenced by
         * forces, and then disappear.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesX(int ID);

        /**
         * Returns the current Y position of the emitter, this is the point that new
         * particles will appear from. It is not possible to get the position of
         * individual particles, they are merely created, follow a path influenced by
         * forces, and then disappear.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesY(int ID);

        /**
         * Returns 0 if the given particles have been set as invisible using
         * Set3DParticlesVisible, or 1 if they are currently set as visible (default).
         * This does not check if the particles are within the visible viewport.
         *
         * @param ID - The ID of the emitter to check.
         * @return int
         */
        @Signature
        public native int Get3DParticlesVisible(int ID);

        /**
         * Returns the current size of all particles in world coordinates. For details
         * on setting the particle size see Set3DParticlesSize.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesSize(int ID);

        /**
         * Returns 1 if the emitter has emitted the number of particles specified in
         * Set3DParticlesMax and all emitted particles have since died, otherwise
         * returns 0. If the max is set at -1 this will always return 0. To reset the
         * count and make the emitter start emitting again use Reset3DParticleCount.
         *
         * @param ID - The ID of the emitter to check.
         * @return int
         */
        @Signature
        public native int Get3DParticlesMaxReached(int ID);

        /**
         * Returns the current life of particles in seconds. It is not possible to get
         * the current life of individual particles. This value is independent of frame
         * rate.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesLife(int ID);

        /**
         * Returns the current frequency of particle generation in particles per second.
         * This value is independent of frame rate.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesFrequency(int ID);

        /**
         * Returns 1 if a 3D particle emitter exists at the given ID. 0 if not.
         *
         * @param ID - The ID of the emitter to check.
         * @return int
         */
        @Signature
        public native int Get3DParticlesExists(int ID);

        /**
         * Returns the z component of the emitter direction, which is the base direction
         * that particles will be moving when they are created. Particles can vary their
         * direction slightly when emitted based on the current Set3DParticlesDirection
         * value.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesDirectionZ(int ID);

        /**
         * Returns the y component of the emitter direction, which is the base direction
         * that particles will be moving when they are created. Particles can vary their
         * direction slightly when emitted based on the current Set3DParticlesDirection
         * value.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesDirectionY(int ID);

        /**
         * Returns the X component of the emitter direction, which is the base direction
         * that particles will be moving when they are created. Particles can vary their
         * direction slightly when emitted based on the current Set3DParticlesDirection
         * value.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesDirectionX(int ID);

        /**
         * Returns the second emitter angle in degrees. This value represents the amount
         * of deviation a particle can have from the emitter direction when emitted. An
         * angle of 0 means there is no deviation while an angle of 360 means a particle
         * can be travelling in any direction in that plane when emitted.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesDirectionRange2(int ID);

        /**
         * Returns the first emitter angle in degrees. This value represents the amount
         * of deviation a particle can have from the emitter direction when emitted. An
         * angle of 0 means there is no deviation while an angle of 360 means a particle
         * can be travelling in any direction in that plane when emitted.
         *
         * @param ID - The ID of the emitter to check.
         * @return float
         */
        @Signature
        public native float Get3DParticlesDirectionRange1(int ID);

        /**
         * Returns 0 if the given particles have been paused using Set3DParticlesActive,
         * or 1 if they are currently updating as normal (default).
         *
         * @param ID - The ID of the emitter to check.
         * @return int
         */
        @Signature
        public native int Get3DParticlesActive(int ID);

        /**
         * Submits a score to a named leader board, this must match the Leaderboard ID
         * given to your board in iTunes connect, Google Game Services, or GameCircle.
         *
         * @param iScore    - The score to submit
         * @param szBoardID - The name of the leader board
         * @return void
         */
        @Signature
        public native void GameCenterSubmitScore(int iScore, String szBoardID);

        /**
         * Change the users progress on reaching a named achievement, the name must
         * match the Achievement ID given to the achievement in iTunes connect, Google
         * Game Services, or GameCircle. The iPercentageComplete values should be
         * between 0 and 100. However, for incremental achievements this value is
         * actually the number of steps completed and may be outside of this range. The
         * value will overwrite the current percentage or steps completed of the
         * achievement.
         *
         * @param szAchievementID     - The name of the achievement
         * @param iPercentageComplete - The users progress towards getting this
         *                            achievement, or the number of steps completed
         * @return void
         */
        @Signature
        public native void GameCenterSubmitAchievement(String szAchievementID, int iPercentageComplete);

        /**
         * Shows the user the named leaderboard, the name must match the Leaderboard ID
         * given to your board in iTunes connect, Google Game Services, or GameCircle.
         *
         * @param szBoardID - The name of the leader board
         * @return void
         */
        @Signature
        public native void GameCenterShowLeaderBoard(String szBoardID);

        /**
         * Call this once to setup your app for further Game Center commands.
         *
         * @return void
         */
        @Signature
        public native void GameCenterSetup();

        /**
         * Call this to log the user out of Google Play Games. After this you may call
         * GameCenterLogin again. On Game Center (iOS) this has no affect, the user must
         * logout from the Game Center app.
         *
         * @return void
         */
        @Signature
        public native void GameCenterLogout();

        /**
         * Call this once to log the user in to Game Center (iOS) or Google Play Games
         * (Android), if they have logged in before this happens in the background and
         * does not interrupt the user, otherwise a popup will appear asking them to log
         * in and grant permission to continue.
         *
         * @return void
         */
        @Signature
        public native void GameCenterLogin();

        /**
         * Shows the user their achievements and progress.
         *
         * 
         * @return void
         */
        @Signature
        public native void GameCenterAchievementsShow();

        /**
         * Not yet functional
         *
         * 
         * @return void
         */
        @Signature
        public native void GameCenterAchievementsReset();

        /**
         * Immediately sends any waiting data to the remote host. If you do not call
         * this then data will will wait forever in the buffer until you write more than
         * 1400 bytes to the socket, at which point it will automatically be flushed.
         * Every time you call this command a new packet will be sent, so when you are
         * sending multiple values you should not call it after each value, as that
         * would waste network bandwidth. You should write all the values and then flush
         * so they will be sent together. If there is no data waiting to be sent this
         * command does nothing. Returns 1 if the socket was successfully flushed, 0 if
         * the socket disconnected.
         *
         * @param socketID - The ID of the socket to check
         * @return int
         */
        @Signature
        public native int FlushSocket(int socketID);

        /**
         * Rounds a float to the next lowest integer. This differs from Trunc when using
         * negative numbers, Trunc( -1.6 ) is -1 but Floor( -1.6 ) is -2.
         *
         * @param a - The value to floor.
         * @return int
         */
        @Signature
        public native int Floor(float a);

        /**
         * By default text objects are created in world coordinates and SetViewOffset
         * can be used to move around the world. Use this command to instead fix the
         * text to the screen so it will move with the viewport when the viewport is
         * moved around. You can still reposition a text that is fixed to the screen, it
         * only affects what happens when the viewport is moved.
         *
         * @param iTextIndex - The ID of the text to change.
         * @param mode       - 1=screen text, 0=world text
         * @return void
         */
        @Signature
        public native void FixTextToScreen(int iTextIndex, int mode);

        /**
         * Attaches the specified sprite to the given skeleton and bone ID. The bone ID
         * can be found by using the GetSkeleton2DBone command. When a sprite is
         * attached to a skeleton bone then it's position and rotation become relative
         * to the bone's position. For example if the sprite position was 0,0 then it
         * would be drawn in the same position as the bone, but if the position was 0,10
         * then the sprite would be drawn above the bone, relative to the bone. i.e. if
         * the bone is rotated left by 90 degrees then 'above' the bone would be to the
         * left of the screen in world coordinates. The ZOrder can be specified to draw
         * the sprite in between two of the skeleton's existing sprites, any integer
         * value is valid and corresponds to the current order of the sprites in the
         * skeleton. For example a ZOrder of 0 would always draw before the first sprite
         * in the skeleton's ZOrder, a value of 1 would always draw before the second
         * sprite in the skeleton, and so on. Note that this ian't affected by other
         * sprites you have attached to the skeleton, it only counts sprites that were
         * originally loaded with the skeleton. For example if you fixed two new sprites
         * to the skeleton both with a zorder equal to 1, then they would both be drawn
         * between between the first and second sprites in the original skeleton. Any
         * sprites that are attached to the skeleton using the same zorder value will be
         * drawn in the order they were attached. Whilst this sprite is attached to a
         * skeleton it will be removed from the normal drawing routines and only drawn
         * when the skeleton is visible. You can still force the sprite to draw by
         * calling DrawSprite but it will not be ordered with the other sprites in the
         * skeleton. To detach a sprite from a skeleton call this command with 0 as the
         * skeletonID, the bone ID and zorder parameters do not matter in this case.
         *
         * @param spriteID    - The ID of the sprite to attach
         * @param iSkeletonID - ID of the skeleton to attach to
         * @param bone        - The ID of the bone in the skeleton to attach to
         * @param zorder      - The ZOrder to place the new sprite in the skeleton draw
         *                    order
         * @return void
         */
        @Signature
        public native void FixSpriteToSkeleton2D(int spriteID, int iSkeletonID, int bone, int zorder);

        /**
         * By default sprites are created in world coordinates and SetViewOffset can be
         * used to move around the world. Use this command to instead fix the sprite to
         * the screen so it will move with the viewport when the viewport is moved
         * around. You can still reposition a sprite that is fixed to the screen, it
         * only affects what happens when the viewport is moved. You should not use
         * physics or collision commands on sprites fixed to the screen as their debug
         * shapes will not line up and they will interfere with physics sprites not
         * fixed to the screen.
         *
         * @param iSpriteIndex - The ID of the sprite to change.
         * @param mode         - 1=screen sprite, 0=world sprite
         * @return void
         */
        @Signature
        public native void FixSpriteToScreen(int iSpriteIndex, int mode);

        /**
         * Fixing particles to the screen will ensure they are not affected by scrolling
         * of the viewport.
         *
         * @param ID   - The ID of the emitter to modify.
         * @param mode - Use 1 to fix to the screen. Use 0 to allow the particles to be
         *             affected by scrolling.
         * @return void
         */
        @Signature
        public native void FixParticlesToScreen(int ID, int mode);

        /**
         * Fixes an object to another object so that any movement of the parent also
         * affects the child. The object being fixed uses its current position,
         * rotation, and scale as an offset to the parent. For example if the parent was
         * placed at 10,5,0 and an object was fixed to it with the current position
         * 0,10,0 then the child would now inherit the position of the parent, combine
         * it with its own, and the child would be placed at 10,15,0. The same applies
         * to rotation and scaling, so if the parent was rotated around the Y axis then
         * the child would rotate by the same amount. Note that using GetObjectY on the
         * child would only show its local position relative to its parent (in this case
         * it would return 10). To get the final world position of the child use
         * GetObjectWorldY on it, which in this case would return 15. There is no limit
         * to the number of objects an object can have fixed to it, nor is there a limit
         * to objects being fixed to objects which are fixed to other objects, just
         * don't create any loops. To stop an object being fixed to anything set toObjID
         * to 0 and it will become independent again.
         *
         * @param objID   - The ID of the object to fix.
         * @param toObjID - The ID of the object to fix it to.
         * @return void
         */
        @Signature
        public native void FixObjectToObject(int objID, int toObjID);

        /**
         * Fixes the specified skeleton to the screen so that it is not affected by
         * SetViewOffset
         *
         * @param iSkeleton - ID of the skeleton to modify
         * @param mode      - 1 to fix to screen, 0 to behave normally (default)
         * @return void
         */
        @Signature
        public native void FixSkeleton2DToScreen(int iSkeleton, int mode);

        /**
         * Similar to FixObjectToObject except the parent will be a bone in the other
         * object.
         *
         * @param objID       - The ID of the object to fix.
         * @param toObjID     - The ID of the object to fix it to.
         * @param toBoneIndex - The index of the bone to fix it to.
         * @return void
         */
        @Signature
        public native void FixObjectToBone(int objID, int toObjID, int toBoneIndex);

        /**
         * Resets the object's position and rotation to 0 whilst keeping the object's
         * vertices where they are. This can be used to change the center of rotation of
         * an object or adjust its default orientation when it's rotation is 0. This
         * command modifies the vertices of the object's meshes so is not recommended to
         * call this every frame, unless the target platform is quite powerful i.e.
         * Windows, Mac, or Linux.
         *
         * @param objID - The ID of the object to modify.
         * @return void
         */
        @Signature
        public native void FixObjectPivot(int objID);

        /**
         * By default sprites and edit boxes are created in world coordinates and
         * SetViewOffset can be used to move around the world. Use this command to
         * instead fix the edit box to the screen so it will move with the viewport when
         * the viewport is moved around. You can still reposition an edit box that is
         * fixed to the screen, it only affects what happens when the viewport is moved.
         *
         * @param index - The ID of the edit box to modify.
         * @param fix   - 0=to move when the view port moves, 1=stay fixed to the screen
         *              no matter where the viewport is moved to.
         * @return void
         */
        @Signature
        public native void FixEditBoxToScreen(int index, int fix);

        /**
         * Fixes a camera to an object so that any movement of the object also affects
         * the camera. The camera uses its current position, rotation, and scale as an
         * offset to the object. For example if the object was placed at 10,5,0 and a
         * camera was fixed to it with a current position of 0,10,0 then the camera
         * would now inherit the position of the object, combine it with its own, and
         * the camera would be placed at 10,15,0. The same applies to rotation and
         * scaling, so if the object was rotated around the Y axis then the camera would
         * rotate by the same amount. Note that using GetCameraY would only show its
         * local position relative to the parent object (in this case it would return
         * 10). To get the final world position of the camera use GetCameraWorldY, which
         * in this case would return 15. There is no limit to the number of objects or
         * cameras an object can have fixed to it, nor is there a limit to objects being
         * fixed to objects which are fixed to other objects, just don't create any
         * loops. To stop a camera being fixed to anything set objID to 0 and it will
         * become independent again.
         *
         * @param cameraID - The ID of the camera to fix, must be equal to 1
         * @param objID    - The ID of the object to fix it to.
         * @return void
         */
        @Signature
        public native void FixCameraToObject(int cameraID, int objID);

        /**
         * Starts the Firebase analytics system and the tracking of some automated
         * events. Additional events can be tracked by using FirebaseLogEvent. You must
         * include the google services config file that was created when you setup your
         * Firebase project, this can be added during export for Android or iOS. If you
         * do not specify your own google services config file during export then all
         * your tracking data will go to our AGK Firebase project and be ignored.
         * Similarly if you use these commands during broadcasting then the tracking
         * data will go to the AGK project and be ignored.
         *
         * @return void
         */
        @Signature
        public native void FirebaseSetup();

        /**
         * Tells Firebase to record an event that happened in your app, for example
         * unlocking an achievement. These will appear in your Firebase project
         * analytics page. Note that event names must not contain dashes or spaces,
         * otherwise they will fail to register.
         *
         * @param event_name - The name of the event to pass to Firebase, some of these
         *                   are reserved for automated events e.g. "first_open"
         * @return void
         */
        @Signature
        public native void FirebaseLogEvent(String event_name);

        /**
         * Creates a pulley joint between two sprites. This the second half of a two
         * command setup. Due to the number of parameters required you must call
         * CreatePulleyJoint2 first with the initial set of parameters to create the
         * joint. This command returns the ID of the new joint.
         *
         * @param gnd1x - The x coordinate of the first ground point
         * @param gnd1y - The y coordinate of the first ground point
         * @param gnd2x - The x coordinate of the second ground point
         * @param gnd2y - The y coordinate of the second ground point
         * @param a1x   - The x coordinate of the first anchor point
         * @param a1y   - The y coordinate of the first anchor point
         * @param a2x   - The x coordinate of the second anchor point
         * @param a2y   - The y coordinate of the second anchor point
         * @return int
         */
        @Signature
        public native int FinishPulleyJoint(float gnd1x, float gnd1y, float gnd2x, float gnd2y, float a1x, float a1y,
                        float a2x, float a2y);

        /**
         * Returns the index of the first occurrence of findStr in the given string,
         * starting from the end of the string and moving backwards. Use a start value
         * of -1 to start at the very end of the string regardless of length. Index 1 is
         * the first character in the string, returns 0 if not found. By default this is
         * case insensitive, use the ignoreCase parameter to set case sensitivity.
         *
         * @param str        - The string to check
         * @param findStr    - The string to find
         * @param ignoreCase - 1 to ignore case when searching, 0 to match case
         * @param start      - The index to start from, the first character is at index
         *                   1, use minus 1 to start at the very end
         * @return int
         */
        @Signature
        public native int FindStringReverse(String str, String findStr, int ignoreCase, int start);

        /**
         * Returns the index of the first occurrence of findStr in the given string,
         * starting from the end of the string and moving backwards. Use a start value
         * of -1 to start at the very end of the string regardless of length. Index 1 is
         * the first character in the string, returns 0 if not found. By default this is
         * case insensitive, use the ignoreCase parameter to set case sensitivity.
         *
         * @param str     - The string to check
         * @param findStr - The string to find
         * @return int
         */
        @Signature
        public native int FindStringReverse(String str, String findStr);

        /**
         * Returns the number of times findStr appears in the given string. By default
         * this is case insensitive, use the ignoreCase parameter to set case
         * sensitivity.
         *
         * @param str     - The string to check
         * @param findStr - The string to find
         * @return int
         */
        @Signature
        public native int FindStringCount(String str, String findStr);

        /**
         * Returns the number of times findStr appears in the given string. By default
         * this is case insensitive, use the ignoreCase parameter to set case
         * sensitivity.
         *
         * @param str        - The string to check
         * @param findStr    - The string to find
         * @param ignoreCase - 1 to ignore case when searching, 0 to match case
         * @param start      - The index to start from, the first character is at index
         *                   1
         * @return int
         */
        @Signature
        public native int FindStringCount(String str, String findStr, int ignoreCase, int start);

        /**
         * Returns the index of the first occurrence of findStr in the given string.
         * Index 1 is the first character in the string, returns 0 if not found. By
         * default this is case insensitive, use the ignoreCase parameter to set case
         * sensitivity.
         *
         * @param str        - The string to check
         * @param findStr    - The string to find
         * @param ignoreCase - 1 to ignore case when searching, 0 to match case
         * @param start      - The index to start from, the first character is at index
         *                   1
         * @return int
         */
        @Signature
        public native int FindString(String str, String findStr, int ignoreCase, int start);

        /**
         * Returns the index of the first occurrence of findStr in the given string.
         * Index 1 is the first character in the string, returns 0 if not found. By
         * default this is case insensitive, use the ignoreCase parameter to set case
         * sensitivity.
         *
         * @param str     - The string to check
         * @param findStr - The string to find
         * @return int
         */
        @Signature
        public native int FindString(String str, String findStr);

        /**
         * Finishes the construction of the ragdoll. Call this command when you have
         * added all the bones and joints for your ragdoll. Make sure you call
         * Create3DPhysicsRagDoll first before calling this command.
         *
         * @return void
         */
        @Signature
        public native void Finalize3DPhysicsRagDoll();

        /**
         * Returns 1 if the given file was opened successfully, 0 if not. You can use
         * GetErrorOccurred to check if it was the result of an error and GetLastError
         * to get said error.
         *
         * @param iFileID - The ID of the file to check.
         * @return int
         */
        @Signature
        public native int FileIsOpen(int iFileID);

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @param szID - your Facebook app ID.
         * @return void
         */
        @Signature
        public native void FacebookSetup(String szID);

        /**
         * Returns 1 if the given file has reached the end of its data stream, 0
         * otherwise. Only used when reading.
         *
         * @param iFileID - The ID of the file to check.
         * @return int
         */
        @Signature
        public native int FileEOF(int iFileID);

        /**
         * This command is not currently supported
         *
         * @param szURL   - URL that you want to like.
         * @param iX      - x position of like button.
         * @param iY      - y position of like button.
         * @param iWidth  - width of like button.
         * @param iHeight - height of like button.
         * @return void
         */
        @Signature
        public native void FacebookShowLikeButton(String szURL, int iX, int iY, int iWidth, int iHeight);

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * 
         * @return void
         */
        @Signature
        public native void FacebookPostOnFriendsWall(String szID, String szLink, String szPicture, String szName,
                        String szCaption, String szDescription);

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return void
         */
        @Signature
        public native void FacebookLogout();

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything. You can use ShareText or ShareImage give the user the option
         * of how to share their information.
         *
         * 
         * @return void
         */
        @Signature
        public native void FacebookPostOnMyWall(String szLink, String szPicture, String szName, String szCaption,
                        String szDescription);

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * 
         * @return void
         */
        @Signature
        public native void FacebookInviteFriend(String szID, String szMessage);

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return void
         */
        @Signature
        public native void FacebookLogin();

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return String
         */
        @Signature
        public native String FacebookGetUserName();

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * 
         * @return String
         */
        @Signature
        public native String FacebookGetFriendsID(int iIndex);

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return int
         */
        @Signature
        public native int FacebookGetFriendsState();

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return String
         */
        @Signature
        public native String FacebookGetUserID();

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * 
         * @return String
         */
        @Signature
        public native String FacebookGetFriendsName(int iIndex);

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return int
         */
        @Signature
        public native int FacebookGetFriendsCount();

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return String
         */
        @Signature
        public native String FacebookGetAccessToken();

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * 
         * @return void
         */
        @Signature
        public native void FacebookDownloadFriendsPhoto(int iIndex);

        /**
         * This command is not currently supported
         *
         * @return void
         */
        @Signature
        public native void FacebookDestroyLikeButton();

        /**
         * The Facebook SDK has been removed from AppGameKit, this command no longer
         * does anything
         *
         * @return void
         */
        @Signature
        public native void FacebookGetFriends();

        /**
         * Activates tracking in the Facebook SDK, this is useful if you are using
         * Facebook Ads as this will associate installs to adverts previously seen and
         * clicked on Facebook. Note that on iOS this functionality requires the IDFA
         * (Advertising Identifier) and you must declare this if you submit the app to
         * Apple. Apple will ask if you use the IDFA and what you use it for. For
         * install tracking with Facebook Ads you MUST tick "Attribute this app
         * installation to a previously served Advertisement" and "Attribute an action
         * taken within this app to a previously served advertisement". If you are also
         * using AdMob, Amazon Ads, or Chartboost in your app then you must also tick
         * "Serve advertisements within the app". This command does not require the user
         * to be logged in.
         *
         * @return void
         */
        @Signature
        public native void FacebookActivateAppTracking();

        /**
         * Returns the remainder of the float division a/b.
         *
         * @param a - The numerator.
         * @param b - The denominator.
         * @return float
         */
        @Signature
        public native float FMod(float a, float b);

        /**
         * This command does the same as ExtractZip except it returns immediately and
         * the zip extraction is done on a thread in the background. You can use
         * GetZipExtractProgress and GetZipExtractComplete to check on its progress. If
         * you call this command whilst a zip extraction is already in progress then
         * nothing will happen. If the specified zip has no password then use an empty
         * string.
         *
         * @param zipfilename - The path to the zip file to extract.
         * @param path        - The path to place the newly extracted zip files.
         * @param password    - The password that was used to create the zip file.
         * @return void
         */
        @Signature
        public native void ExtractZipASync(String zipfilename, String path, String password);

        /**
         * Extracts a zip file to a specified directory. Any folders created inside the
         * zip file will be created in the extraction process. If the zip file is
         * password protected specify the password to extract it. If you specify a wrong
         * password, the extracted files from the zip archive will be empty. The local
         * file path is relative to the current directory set using SetFolder unless you
         * start the path with a forward slash, in which case the path will be relative
         * to the root of the write directory on the current platform.
         *
         * @param zipfilename - The path to the zip file to extract.
         * @param path        - The path to place the newly extracted zip files.
         * @param password    - The password that was used to create the zip file.
         * @return void
         */
        @Signature
        public native void ExtractZip(String zipfilename, String path, String password);

        /**
         * Extracts a zip file to a specified directory. Any folders created inside the
         * zip file will be created in the extraction process. If the zip file is
         * password protected specify the password to extract it. If you specify a wrong
         * password, the extracted files from the zip archive will be empty. The local
         * file path is relative to the current directory set using SetFolder unless you
         * start the path with a forward slash, in which case the path will be relative
         * to the root of the write directory on the current platform.
         *
         * @param zipfilename - The path to the zip file to extract.
         * @param path        - The path to place the newly extracted zip files.
         * @return void
         */
        @Signature
        public native void ExtractZip(String zipfilename, String path);

        /**
         * Encodes the given text into a QR code and returns a new image ID containing
         * that code. You can select the amount of error correction included in the code
         * to allow part of the QR code to become damaged but still be readable. The
         * higher the error correction mode the more likely it is that a damaged or
         * obscured QR code will be read correctly, but higher error correction modes
         * may produce a larger QR code. Level 0 still provides a minimal level of error
         * correction rather than none.
         *
         * @param text      - The text to encode.
         * @param errormode - The level of error correction to include in the code from
         *                  0 (lowest) to 3 (highest)
         * @return int
         */
        @Signature
        public native int EncodeQRCode(String text, int errormode);

        /**
         * Sets whether the depth buffer should be cleared when Sync or Swap are called.
         * By default this is set to true. Disabling this is not recommended as anything
         * that uses the depth buffer will only appear for one frame and then seeming
         * disappear. This function may not have any effect on mobile devices.
         *
         * @param clear - Set to 1 to clear the depth buffer, 0 to not clear it.
         * @return void
         */
        @Signature
        public native void EnableClearDepth(int clear);

        /**
         * Sets whether the frame buffer should be cleared when Sync or Swap are called.
         * By default this is set to true. The only reason to call this command is if
         * you have a background sprite, or set of sprites, that completely cover the
         * screen so the background color will never be visible. In these cases some
         * GPUs can benefit from turning the clear color off. Please note that in many
         * cases the last drawn frame will remain on screen, however, this is not
         * guaranteed, and you should not create effects that rely on it as they may not
         * work in future, and won't work on mobile devices. To create effects that
         * maintain the contents of the previous frame it is recommended that you use
         * SetRenderToImage to capture the output of one frame and then draw it into the
         * next frame, i.e. you render everything to image 1, then in the next frame you
         * paste image 1 into the background of a new render target and then draw the
         * new frame. For example draw everything in frame 1 to image 1, then in frame 2
         * you draw image 1 with a full screen Quad object to image 2, and then draw
         * everything in frame 2 to image 2. You can then swap the render targets so in
         * frame 3 you draw image 2 with a full screen quad back into image 1, then draw
         * the objects in frame 3 to image 1. Continue to alternate between image 1 and
         * 2, so frame 4 would first have image 1 drawn with a full screen quad to image
         * 2, then draw everything in frame 4 to image 2. It is important to not
         * continue drawing everything to the same image, i.e. draw frame 1 to image 1,
         * then frame 2 to image 1, and so on because mobile devices use an internal
         * deferred renderer that will keep an ever increasing list of things to draw to
         * image 1. If the image is never cleared then performance will degrade.
         *
         * @param clear - Set to 1 to clear the frame buffer, 0 to not clear it.
         * @return void
         */
        @Signature
        public native void EnableClearColor(int clear);

        /**
         * Immediately draws the sprite to the backbuffer at its current position, size,
         * and rotation. This is useful if you want to setup a scene for GetImage to
         * capture. Remember to use ClearScreen to clear any of your own drawing before
         * calling Sync or Render for the actual frame otherwise your drawing may appear
         * twice in the final render.
         *
         * @param iSpriteIndex - The ID of the sprite to draw.
         * @return void
         */
        @Signature
        public native void DrawSprite(int iSpriteIndex);

        /**
         * Immediately draws the text to the backbuffer at its current position, size,
         * and rotation. This is useful if you want to setup a scene for GetImage to
         * capture. Remember to use ClearScreen to clear any of your own drawing before
         * calling Sync or Render for the actual frame otherwise your drawing may appear
         * twice in the final render.
         *
         * @param iTextIndex - The ID of the text to draw.
         * @return void
         */
        @Signature
        public native void DrawText(int iTextIndex);

        /**
         * Immediately draws the particle emitter to the backbuffer at its current
         * position, size, and rotation. This is useful if you want to setup a scene for
         * GetImage to capture. Remember to use ClearScreen to clear any of your own
         * drawing before calling Sync or Render for the actual frame otherwise your
         * drawing may appear twice in the final render.
         *
         * @param ID - The ID of the emitter to draw.
         * @return void
         */
        @Signature
        public native void DrawParticles(int ID);

        /**
         * Immediately draws the object to the current render target at its current
         * position, size, and rotation. This is useful if you want to draw particular
         * objects like sky boxes before any other objects. In this case be sure to make
         * the object invisible for calls to Render() or Sync() otherwise the object may
         * appear twice.
         *
         * @param objID - The ID of the object to draw.
         * @return void
         */
        @Signature
        public native void DrawObject(int objID);

        /**
         * Draws a 2D line from one point on the screen to another with a chosen color.
         * Lines appear above all other drawing except the Print command and can be used
         * with the GetImage function to create new images. The XY coordinates are in
         * screen coordinates so are not affected by the SetViewOffset command.
         *
         * @param x     - The X component of the start position of the line.
         * @param y     - The Y component of the start position of the line.
         * @param x2    - The X component of the end position of the line.
         * @param y2    - The Y component of the end position of the line.
         * @param red   - The red component of the line color.
         * @param green - The green component of the line color.
         * @param blue  - The blue component of the line color.
         * @return void
         */
        @Signature
        public native void DrawLine(float x, float y, float x2, float y2, int red, int green, int blue);

        /**
         * Draws a 2D line from one point on the screen to another with a chosen color.
         * Lines appear above all other drawing except the Print command and can be used
         * with the GetImage function to create new images. The XY coordinates are in
         * screen coordinates so are not affected by the SetViewOffset command.
         *
         * @param x      - The X component of the start position of the line.
         * @param y      - The Y component of the start position of the line.
         * @param x2     - The X component of the end position of the line.
         * @param y2     - The Y component of the end position of the line.
         * @param color1 - The color to use at the start of the line.
         * @param color2 - The color to use at the end of the line.
         * @return void
         */
        @Signature
        public native void DrawLine(float x, float y, float x2, float y2, int color1, int color2);

        /**
         * Draws a 2D ellipse centered on the coordinates given with a chosen color or
         * gradient. 2D shapes appear above all other drawing except the Print command
         * and can be used with the GetImage function to create new images. The XY
         * coordinates are in screen coordinates so are not affected by the
         * SetViewOffset command.
         *
         * @param x       - The X component of the center of the ellipse.
         * @param y       - The Y component of the center of the ellipse.
         * @param radiusx - The radius of the ellipse in the X direction.
         * @param radiusy - The radius of the ellipse in the Y direction.
         * @param color1  - The color at the top of the ellipse.
         * @param color2  - The color at the bottom of the ellipse.
         * @param filled  - 1=filled, 0=empty.
         * @return void
         */
        @Signature
        public native void DrawEllipse(float x, float y, float radiusx, float radiusy, int color1, int color2,
                        int filled);

        /**
         * Draws a 2D box from one point on the screen to another with a chosen color
         * using lines. Lines appear above all other drawing except the Print command
         * and can be used with the GetImage function or SetRenderToImage to create new
         * images. The XY coordinates are in screen coordinates so are not affected by
         * the SetViewOffset command. Colors can be created using the MakeColor command
         * or by using the bitwise operators like so, mycolor = (blue
         *
         * @param x      - The X component of the top left corner of the box.
         * @param y      - The Y component of the top left corner of the box.
         * @param x2     - The X component of the bottom right corner of the box.
         * @param y2     - The Y component of the bottom right corner of the box.
         * @param color1 - The color to use in the top left corner.
         * @param color2 - The color to use in the top right corner.
         * @param color3 - The color to use in the bottom left corner.
         * @param color4 - The color to use in the bottom right corner.
         * @param filled - 1 to draw a filled box, 0 to draw an empty box.
         * @return void
         */
        @Signature
        public native void DrawBox(float x, float y, float x2, float y2, int color1, int color2, int color3, int color4,
                        int filled);

        /**
         * Immediately draws the particles to the backbuffer at its current position,
         * size, and rotation. This is useful if you want to setup a scene for GetImage
         * to capture. Remember to use ClearScreen to clear any of your own drawing
         * before calling Sync or Render for the actual frame otherwise your drawing may
         * appear twice in the final render.
         *
         * @param ID - The ID of the emitter to draw.
         * @return void
         */
        @Signature
        public native void Draw3DParticles(int ID);

        /**
         * Starts the download of any expansion file that this platform and app needs,
         * currently only applicable to Android. If the download has already started
         * this has no effect. You can use GetExpansionFileProgress to check on the
         * progress of the download and GetExpanionFileState to check when it has
         * completed. After calling this command you should wait for
         * GetExpanionFileState to return -1 (error) or 3 (complete) whilst displaying a
         * progress bar.
         *
         * @return void
         */
        @Signature
        public native void DownloadExpansionFile();

        /**
         * Deletes a virtual joystick and removes it from screen. No further virtual
         * joystick commands can be called on this index unless it is recreated using
         * AddVirtualJoystick.
         *
         * @param index - The ID of the virtual joystick to delete.
         * @return void
         */
        @Signature
        public native void DeleteVirtualJoystick(int index);

        /**
         * Deletes the virtual button at the given index. No further virtual button
         * commands can be called on this index unless it is recreated using
         * AddVirtualButton.
         *
         * @param index - The ID of the virtual button to delete.
         * @return void
         */
        @Signature
        public native void DeleteVirtualButton(int index);

        /**
         * Deletes the Vector
         *
         * @param vectorID - Id of Vector
         * @return void
         */
        @Signature
        public native void DeleteVector3(int vectorID);

        /**
         * Stops any playing video and deletes any loaded video from memory.
         *
         * @return void
         */
        @Signature
        public native void DeleteVideo();

        /**
         * Deletes the specified UDP listenere and frees up the port it was using.
         *
         * @param listenerID - The ID of the listener to delete
         * @return void
         */
        @Signature
        public native void DeleteUDPListener(int listenerID);

        /**
         * Deletes a chain and stops any tweens that were associated with it. Any tweens
         * that were added to it are unaffected and can be used in future chains.
         *
         * @param chainID - ID of the chain to delete
         * @return void
         */
        @Signature
        public native void DeleteTweenChain(int chainID);

        /**
         * Delete a given tween ID. This can be used for all types of tween, sprite,
         * text, object, etc.
         *
         * @param tweenID - ID of the tween to delete
         * @return void
         */
        @Signature
        public native void DeleteTween(int tweenID);

        /**
         * Deletes a text object.
         *
         * @param iTextIndex - The ID of the text object to delete.
         * @return void
         */
        @Signature
        public native void DeleteText(int iTextIndex);

        /**
         * Deletes the sprite at the given ID.
         *
         * @param iSpriteIndex - The ID of the sprite to delete
         * @return void
         */
        @Signature
        public native void DeleteSprite(int iSpriteIndex);

        /**
         * Delete the sound at the specified sound number. This will also delete all
         * instances of the sound.
         *
         * @param iID - The sound number to delete.
         * @return void
         */
        @Signature
        public native void DeleteSound(int iID);

        /**
         * Deletes the socket ID so it can be used again. If the socket is currently
         * connected then the connection is closed first.
         *
         * @param socketID - The ID of the socket to delete
         * @return void
         */
        @Signature
        public native void DeleteSocket(int socketID);

        /**
         * Stops the socket listener from receiving connections and frees the ID to be
         * used again. If any connections are still in the queue and have yet to be
         * collected using GetSocketListenerConnection then they will be closed and
         * deleted.
         *
         * @param listenerID - The ID of the listener to check
         * @return void
         */
        @Signature
        public native void DeleteSocketListener(int listenerID);

        /**
         * Deletes the skeleton at the specified ID. If no skeleton exists at this ID
         * then nothing happens.
         *
         * @param iSkeleton - The ID of the skeleton to delete
         * @return void
         */
        @Signature
        public native void DeleteSkeleton2D(int iSkeleton);

        /**
         * Deletes a shared variable by name. If the variable doesn't exist then this
         * will do nothing. Once the variable is deleted then LoadSharedVariable will
         * return the default value for any requests to load it.
         *
         * @param varName - The name of the variable to delete
         * @return void
         */
        @Signature
        public native void DeleteSharedVariable(String varName);

        /**
         * Deletes a shader and frees the ID. The shader must not currently be assigned
         * to any object, mesh, quad, or sprite, otherwise it may cause a crash when it
         * tries to draw.
         *
         * @param shaderID - The ID of the shader to delete
         * @return void
         */
        @Signature
        public native void DeleteShader(int shaderID);

        /**
         * Deletes the specified point light. If the point light doesn't exist this
         * command does nothing.
         *
         * @param lightID - The ID of the light to delete.
         * @return void
         */
        @Signature
        public native void DeletePointLight(int lightID);

        /**
         * Deletes the specified global force.
         *
         * @param iForceIndex - The ID of the force to delete.
         * @return void
         */
        @Signature
        public native void DeletePhysicsForce(int iForceIndex);

        /**
         * Deletes a particle emitter and all its particles. If any particles were
         * currently visible they will disappear instantly.
         *
         * @param ID - The ID of the emitter to delete.
         * @return void
         */
        @Signature
        public native void DeleteParticles(int ID);

        /**
         * Deletes the object at the given ID, if the object doesn't exist then this
         * command does nothing. This command also deletes any child objects that were
         * created when this object was loaded, if you do not want to delete those then
         * use DeleteObject instead. If you use this command on an object that was
         * loaded with LoadObject then it deletes it as normal.
         *
         * @param objID - The ID of the object to delete.
         * @return void
         */
        @Signature
        public native void DeleteObjectWithChildren(int objID);

        /**
         * Deletes the object at the given ID, if the object doesn't exist then this
         * command does nothing. This command also deletes any child objects that were
         * created when this object was loaded, and any objects that are currently
         * attached to this object from using FixObjectToObject or FixObjectToBone.
         *
         * @param objID - The ID of the object to delete.
         * @return void
         */
        @Signature
        public native void DeleteObjectTree(int objID);

        /**
         * Deletes a network message, this should be called on messages received from
         * network devices and messages that have not been sent to a network device (if
         * code decides to back out of sending a message). Messages that have been
         * created and sent will be handled and deleted by the network code and should
         * not be deleted using this command.
         *
         * @param iMsgID - The ID of the message to read.
         * @return void
         */
        @Signature
        public native void DeleteNetworkMessage(int iMsgID);

        /**
         * Deletes the object at the given ID, if the object doesn't exist then this
         * command does nothing. Note that if the object was loaded with
         * LoadObjectWithChildren then any child objects that were created during that
         * loading process will not be deleted by this command. You can use
         * GetObjectChildID to get and delete those objects manually, or use
         * DeleteObjectWithChildren to delete everything that was created when this
         * object was loaded.
         *
         * @param objID - The ID of the object to delete.
         * @return void
         */
        @Signature
        public native void DeleteObject(int objID);

        /**
         * Deletes a disconnected client from the client list. If this function is
         * called on a client that is not disconnected it will produce an error and not
         * affect the client. Does not delete the client immediately, the background
         * code may take a few frames to get around to deleting it. Calling this command
         * multiple times on a disconnected client should not cause a problem.
         *
         * @param iNetID - The ID of the network to check.
         * @param client - the ID of the client to delete.
         * @return void
         */
        @Signature
        public native void DeleteNetworkClient(int iNetID, int client);

        /**
         * Deletes the music file and frees up the ID to be used again.
         *
         * @param musicID - The ID of the music file to delete
         * @return void
         */
        @Signature
        public native void DeleteMusicOGG(int musicID);

        /**
         * Deletes a joint and allows the connected sprites to move freely again. Joints
         * should be deleted before sprites. Gear joints should be deleted before the
         * joints it depends on. Deleting a joint that does not exist will not cause an
         * error.
         *
         * @param iJointIndex - The ID of the joint to delete.
         * @return void
         */
        @Signature
        public native void DeleteJoint(int iJointIndex);

        /**
         * Deletes the memblock at the given ID. If the memblock does not exist or has
         * already been deleted then this command does nothing.
         *
         * @param memID - The ID of the memblock to delete.
         * @return void
         */
        @Signature
        public native void DeleteMemblock(int memID);

        /**
         * Deletes a music file from the playlist.
         *
         * @param iID - The ID of the music to delete.
         * @return void
         */
        @Signature
        public native void DeleteMusic(int iID);

        /**
         * Delete an image from the global store using its ID.
         *
         * @param iImageIndex - The ID of the image to delete
         * @return void
         */
        @Signature
        public native void DeleteImage(int iImageIndex);

        /**
         * Deletes a previously created HTTP connection.
         *
         * @param iHTTP - The ID of the connection to delete.
         * @return void
         */
        @Signature
        public native void DeleteHTTPConnection(int iHTTP);

        /**
         * Deletes the font at the given ID. The font must not currently be in use by
         * any text objects.
         *
         * @param iFontID - The ID of the font to delete.
         * @return void
         */
        @Signature
        public native void DeleteFont(int iFontID);

        /**
         * Deletes any edit box at the given ID.
         *
         * @param index - The ID of the edit box to delete.
         * @return void
         */
        @Signature
        public native void DeleteEditBox(int index);

        /**
         * Deletes a given file from the write folder. File paths must be relative, not
         * absolute, you cannot delete files from the application folder or from
         * elsewhere on the disk.
         *
         * @param szFile - The filename to delete.
         * @return void
         */
        @Signature
        public native void DeleteFile(String szFile);

        /**
         * Deletes a folder at the current path. By default this is determined by the
         * command SetFolder. You can also use a filename beginning with "raw:" to
         * delete a folder anywhere on the file system, for example
         * DeleteFolder("raw:C:\Temp\MyFolder"). The folder must be empty for this
         * command to succeed.
         *
         * @param szName - The name of the folder create.
         * @return void
         */
        @Signature
        public native void DeleteFolder(String szName);

        /**
         * Deletes the variable with the specified name and removes any data stored in
         * the cloud for that variable. If the variable doesn't exist then this does
         * nothing.
         *
         * @param varName - The name of the variable to delete, must be less than 64
         *                bytes
         * @return void
         */
        @Signature
        public native void DeleteCloudDataVariable(String varName);

        /**
         * Deletes a broadcast listener and frees up the port for something else to
         * listen on it.
         *
         * @param iID - The ID of the broadcast listener to delete.
         * @return void
         */
        @Signature
        public native void DeleteBroadcastListener(int iID);

        /**
         * Deletes all objects created with an ID. This also resets the auto object ID
         * to 10000.
         *
         * @return void
         */
        @Signature
        public native void DeleteAllObjects();

        /**
         * Deletes all sprites created with CreateSprite, CreateDummySprite, or
         * LoadSprite. This also resets the auto sprite ID to 10000.
         *
         * @return void
         */
        @Signature
        public native void DeleteAllSprites();

        /**
         * Deletes all text objects create by CreateText. This also resets the auto text
         * ID to 10000.
         *
         * @return void
         */
        @Signature
        public native void DeleteAllText();

        /**
         * Deletes all images loaded by LoadImage or LoadSubImage. This also resets the
         * auto image ID to 10000.
         *
         * @return void
         */
        @Signature
        public native void DeleteAllImages();

        /**
         * Clears a previously displayed ad.
         *
         * @return void
         */
        @Signature
        public native void DeleteAdvert();

        /**
         * Deletes the entire 3D physics world.
         *
         * @return void
         */
        @Signature
        public native void Delete3DPhysicsWorld();

        /**
         * Deletes a physics ray and all associated data.
         *
         * @param rayID - ID of the ray to delete.
         * @return void
         */
        @Signature
        public native void Delete3DPhysicsRay(int rayID);

        /**
         * Deletes the static plane.
         *
         * @param planeID - static plane ID
         * @return void
         */
        @Signature
        public native void Delete3DPhysicsStaticPlane(int planeID);

        /**
         * Deletes the Ragdoll for the object.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void Delete3DPhysicsRagdoll(int objID);

        /**
         * Deletes pick joint.
         *
         * @param jointID - ID of Joint
         * @return void
         */
        @Signature
        public native void Delete3DPhysicsPickJoint(int jointID);

        /**
         * Deletes the physics joint
         *
         * @param jointID - Id of joint
         * @return void
         */
        @Signature
        public native void Delete3DPhysicsJoint(int jointID);

        /**
         * Deletes the controller for the object.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void Delete3DPhysicsCharacterController(int objID);

        /**
         * Removes the physics body from the world and deletes it.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void Delete3DPhysicsBody(int objID);

        /**
         * Deletes a 3D particle emitter and all its particles. If any particles were
         * currently visible they will disappear instantly.
         *
         * @param ID - The ID of the emitter to delete.
         * @return void
         */
        @Signature
        public native void Delete3DParticles(int ID);

        /**
         * Call in loop before step physics. Draws the debug overlay of the 3D physics
         * world. Note: This command does not currently work needs the ability to draw
         * wireframe in AGK.
         *
         * @return void
         */
        @Signature
        public native void Debug3DPhysicsWorld();

        /**
         * Attempts to decode a QR code and return the string encoded within it. Returns
         * an empty string if it could not find a QR code in the image or failed to
         * decode it. Multiple QR codes in the image are likely to cause the decode to
         * fail.
         *
         * @param image - The ID of the image to decode, can be an image captured from
         *              the camera
         * @return String
         */
        @Signature
        public native String DecodeQRCode(int image);

        /**
         * Shows the Capsule objects the represent the controller.
         *
         * @param objID   - object ID
         * @param isDebug - 1 = true, 0 = false
         * @return void
         */
        @Signature
        public native void Debug3DPhysicsCharacterController(int objID, int isDebug);

        /**
         * Crouches the controller
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void Crouch3DPhysicsCharacterController(int objID);

        /**
         * Creates a zip file at the specified location and opens it ready for files to
         * be added. Files cannot be read or extracted from a zip file using this
         * command. Use ExtractZip to retrieve files from it. The file path is relative
         * to the current directory set using SetFolder unless you start the path with a
         * forward slash, in which case the path will be relative to the root of the
         * write directory on the current platform.
         *
         * @param filename - The file name and path for this new zip file.
         * @return int
         */
        @Signature
        public native int CreateZip(String filename);

        /**
         * Creates a zip file at the specified location and opens it ready for files to
         * be added. Files cannot be read or extracted from a zip file using this
         * command. Use ExtractZip to retrieve files from it. The file path is relative
         * to the current directory set using SetFolder unless you start the path with a
         * forward slash, in which case the path will be relative to the root of the
         * write directory on the current platform.
         *
         * @param zipID    - The ID used to reference this zip file.
         * @param filename - The file name and path for this new zip file.
         * @return void
         */
        @Signature
        public native void CreateZip(int zipID, String filename);

        /**
         * Creates a weld joint between two sprites. The weld joint attempts to limit
         * all relative movement and rotation between the two sprites. Specify a single
         * anchor point in world coordinates with the sprites already in the desired
         * positions. The joint is not a perfect fixture and given a large enough force
         * the sprites may shift out of position. The anchor point can be offset from
         * the sprite center positions. A joint may be deleted by the system if any of
         * the sprites it connects are deleted.
         *
         * @param iJointIndex   - The ID to use for this joint.
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the anchor point.
         * @param y             - The y coordinate of the anchor point.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return void
         */
        @Signature
        public native void CreateWeldJoint(int iJointIndex, int iSpriteIndex1, int iSpriteIndex2, float x, float y,
                        int colConnected);

        /**
         * Creates a weld joint between two sprites. The weld joint attempts to limit
         * all relative movement and rotation between the two sprites. Specify a single
         * anchor point in world coordinates with the sprites already in the desired
         * positions. The joint is not a perfect fixture and given a large enough force
         * the sprites may shift out of position. The anchor point can be offset from
         * the sprite center positions. A joint may be deleted by the system if any of
         * the sprites it connects are deleted.
         *
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the anchor point.
         * @param y             - The y coordinate of the anchor point.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return int
         */
        @Signature
        public native int CreateWeldJoint(int iSpriteIndex1, int iSpriteIndex2, float x, float y, int colConnected);

        /**
         * Creates a vector and fills it with the values passed in. Returns a vector ID
         *
         * @param x - The x component of the vector
         * @param y - The y component of the vector
         * @param z - The z component of the vector
         * @return int
         */
        @Signature
        public native int CreateVector3(float x, float y, float z);

        /**
         * Creates a vector and fills it with the values passed in. Returns a vector ID
         *
         * @return int
         */
        @Signature
        public native int CreateVector3();

        /**
         * Creates a sprite tween with a given duration and returns an ID for it. This
         * tween is merely a template that can be applied to multiple sprites or chains
         * at the same time. All tween types share the same ID space, so a sprite tween
         * of ID 1 cannot exist at the same time as a text tween with ID 1. You can set
         * multiple parameters for this tween, such as X position and Angle, that will
         * all move from their start values to their end values over the given duration.
         *
         * @param duration - The duration of the tween in seconds
         * @return int
         */
        @Signature
        public native int CreateTweenSprite(float duration);

        /**
         * Creates a sprite tween with a given duration and returns an ID for it. This
         * tween is merely a template that can be applied to multiple sprites or chains
         * at the same time. All tween types share the same ID space, so a sprite tween
         * of ID 1 cannot exist at the same time as a text tween with ID 1. You can set
         * multiple parameters for this tween, such as X position and Angle, that will
         * all move from their start values to their end values over the given duration.
         *
         * @param tweenID  - ID of the tween
         * @param duration - The duration of the tween in seconds
         * @return void
         */
        @Signature
        public native void CreateTweenSprite(int tweenID, float duration);

        /**
         * Creates a UDP listener that will recieve UDP packets on the specified IP and
         * port. The port value must be in the range 1 to 65535, although values below
         * 1024 are likely to be protected by the operating system. If the port is
         * already occupied then this command will fail and return 0. The IP address may
         * be an IPv4 or IPv6 address, and can be used to bind to a single incomming
         * network connection when a device has more than one IP. To bind to any IP
         * address use the IP address "anyip4" or "anyip6". A single UDP listener can
         * listen on either an IPv4 or an IPv6 address, but not both at the same time.
         * To listen on both you should create two listeners, one for IPv4 and one for
         * IPv6, in this case they may both use the same port. This command will return
         * the ID of the listener that you can use to reference it in future commands.
         *
         * @param listenerID - The ID to use to reference this listener in future.
         * @param ip         - The local IP address to bind to.
         * @param port       - The local port to bind to.
         * @return int
         */
        @Signature
        public native int CreateUDPListener(int listenerID, String ip, int port);

        /**
         * Creates a UDP listener that will recieve UDP packets on the specified IP and
         * port. The port value must be in the range 1 to 65535, although values below
         * 1024 are likely to be protected by the operating system. If the port is
         * already occupied then this command will fail and return 0. The IP address may
         * be an IPv4 or IPv6 address, and can be used to bind to a single incomming
         * network connection when a device has more than one IP. To bind to any IP
         * address use the IP address "anyip4" or "anyip6". A single UDP listener can
         * listen on either an IPv4 or an IPv6 address, but not both at the same time.
         * To listen on both you should create two listeners, one for IPv4 and one for
         * IPv6, in this case they may both use the same port. This command will return
         * the ID of the listener that you can use to reference it in future commands.
         *
         * @param ip   - The local IP address to bind to.
         * @param port - The local port to bind to.
         * @return int
         */
        @Signature
        public native int CreateUDPListener(String ip, int port);

        /**
         * Creates a text tween with a given duration and returns an ID for it. This
         * tween is merely a template that can be applied to multiple text objects or
         * chains at the same time. All tween types share the same ID space, so a sprite
         * tween of ID 1 cannot exist at the same time as a text tween with ID 1. You
         * can set multiple parameters for this tween, such as X position and Angle,
         * that will all move from their start values to their end values over the given
         * duration.
         *
         * @param duration - The duration of the tween in seconds
         * @return int
         */
        @Signature
        public native int CreateTweenText(float duration);

        /**
         * Creates a text tween with a given duration and returns an ID for it. This
         * tween is merely a template that can be applied to multiple text objects or
         * chains at the same time. All tween types share the same ID space, so a sprite
         * tween of ID 1 cannot exist at the same time as a text tween with ID 1. You
         * can set multiple parameters for this tween, such as X position and Angle,
         * that will all move from their start values to their end values over the given
         * duration.
         *
         * @param tweenID  - ID of the tween
         * @param duration - The duration of the tween in seconds
         * @return void
         */
        @Signature
        public native void CreateTweenText(int tweenID, float duration);

        /**
         * Creates an object tween with a given duration and returns an ID for it. This
         * tween is merely a template that can be applied to multiple objects or chains
         * at the same time. All tween types share the same ID space, so a sprite tween
         * of ID 1 cannot exist at the same time as an object tween with ID 1. You can
         * set multiple parameters for this tween, such as X position and Angle, that
         * will all move from their start values to their end values over the given
         * duration.
         *
         * @param duration - The duration of the tween in seconds
         * @return int
         */
        @Signature
        public native int CreateTweenObject(float duration);

        /**
         * Creates an object tween with a given duration and returns an ID for it. This
         * tween is merely a template that can be applied to multiple objects or chains
         * at the same time. All tween types share the same ID space, so a sprite tween
         * of ID 1 cannot exist at the same time as an object tween with ID 1. You can
         * set multiple parameters for this tween, such as X position and Angle, that
         * will all move from their start values to their end values over the given
         * duration.
         *
         * @param tweenID  - ID of the tween
         * @param duration - The duration of the tween in seconds
         * @return void
         */
        @Signature
        public native void CreateTweenObject(int tweenID, float duration);

        /**
         * Creates a custom tween with a given duration and returns an ID for it. This
         * tween is not associated with any item and its values can be read whilst it is
         * running. This makes it useful for controlling values that are not covered by
         * any of the other tween templates. All tween types share the same ID space, so
         * a custom tween of ID 1 cannot exist at the same time as a sprite tween with
         * ID 1. You can set multiple parameters for this tween, up to 4 float values
         * and 4 integer values, that will all move from their start values to their end
         * values over the given duration.
         *
         * @param duration - The duration of the tween in seconds
         * @return int
         */
        @Signature
        public native int CreateTweenCustom(float duration);

        /**
         * Creates a custom tween with a given duration and returns an ID for it. This
         * tween is not associated with any item and its values can be read whilst it is
         * running. This makes it useful for controlling values that are not covered by
         * any of the other tween templates. All tween types share the same ID space, so
         * a custom tween of ID 1 cannot exist at the same time as a sprite tween with
         * ID 1. You can set multiple parameters for this tween, up to 4 float values
         * and 4 integer values, that will all move from their start values to their end
         * values over the given duration.
         *
         * @param tweenID  - ID of the tween
         * @param duration - The duration of the tween in seconds
         * @return void
         */
        @Signature
        public native void CreateTweenCustom(int tweenID, float duration);

        /**
         * Creates a char tween with a given duration and returns an ID for it. This can
         * be applied to individual characters of a text object. This tween is merely a
         * template that can be applied to multiple text characters or chains at the
         * same time. All tween types share the same ID space, so a sprite tween of ID 1
         * cannot exist at the same time as a char tween with ID 1. You can set multiple
         * parameters for this tween, such as X position and Angle, that will all move
         * from their start values to their end values over the given duration.
         *
         * @param duration - The duration of the tween in seconds
         * @return int
         */
        @Signature
        public native int CreateTweenChar(float duration);

        /**
         * Creates a char tween with a given duration and returns an ID for it. This can
         * be applied to individual characters of a text object. This tween is merely a
         * template that can be applied to multiple text characters or chains at the
         * same time. All tween types share the same ID space, so a sprite tween of ID 1
         * cannot exist at the same time as a char tween with ID 1. You can set multiple
         * parameters for this tween, such as X position and Angle, that will all move
         * from their start values to their end values over the given duration.
         *
         * @param tweenID  - ID of the tween
         * @param duration - The duration of the tween in seconds
         * @return void
         */
        @Signature
        public native void CreateTweenChar(int tweenID, float duration);

        /**
         * Creates an camera tween with a given duration and returns an ID for it. This
         * tween is merely a template that can be applied to multiple cameras or chains
         * at the same time. All tween types share the same ID space, so a camera tween
         * of ID 1 cannot exist at the same time as an object tween with ID 1. You can
         * set multiple parameters for this tween, such as X position and Angle, that
         * will all move from their start values to their end values over the given
         * duration.
         *
         * @param duration - The duration of the tween in seconds
         * @return int
         */
        @Signature
        public native int CreateTweenCamera(float duration);

        /**
         * Creates an camera tween with a given duration and returns an ID for it. This
         * tween is merely a template that can be applied to multiple cameras or chains
         * at the same time. All tween types share the same ID space, so a camera tween
         * of ID 1 cannot exist at the same time as an object tween with ID 1. You can
         * set multiple parameters for this tween, such as X position and Angle, that
         * will all move from their start values to their end values over the given
         * duration.
         *
         * @param tweenID  - ID of the tween
         * @param duration - The duration of the tween in seconds
         * @return void
         */
        @Signature
        public native void CreateTweenCamera(int tweenID, float duration);

        /**
         * Creates a tween chain that can be used to order tweens so they play one after
         * the other. A tween chain can contain multiple sprites, characters, objects,
         * etc, so that a camera tween can be triggered after a sprite tween has
         * finished or vice versa. Multiple chains can be applied to the same sprites,
         * objects, or others as long as the chains do not modify the same parameter at
         * the same time. For example if chain 1 starts by modifying a sprites X value,
         * and is played at the same time as chain 2 which also starts modifying the X
         * value of the same sprite one chain will overwrite the changes of the other.
         * Otherwise multiple chains on the same sprite will work correctly.
         *
         * @return int
         */
        @Signature
        public native int CreateTweenChain();

        /**
         * Creates a tween chain that can be used to order tweens so they play one after
         * the other. A tween chain can contain multiple sprites, characters, objects,
         * etc, so that a camera tween can be triggered after a sprite tween has
         * finished or vice versa. Multiple chains can be applied to the same sprites,
         * objects, or others as long as the chains do not modify the same parameter at
         * the same time. For example if chain 1 starts by modifying a sprites X value,
         * and is played at the same time as chain 2 which also starts modifying the X
         * value of the same sprite one chain will overwrite the changes of the other.
         * Otherwise multiple chains on the same sprite will work correctly.
         *
         * @param chainID - ID of the chain
         * @return void
         */
        @Signature
        public native void CreateTweenChain(int chainID);

        /**
         * Creates a text object for displaying text on the screen using a blank ID,
         * returns the ID used. By default text is drawn at depth 9 above the default
         * depth of sprites (10). Any sprites set to a depth of 8 or less will appear
         * above the text. You can override this using SetTextDepth to set your own draw
         * order.
         *
         * @param string - The initial string to use in this text object, can be an
         *               empty string.
         * @return int
         */
        @Signature
        public native int CreateText(String string);

        /**
         * Creates a text object for displaying text on the screen using a blank ID,
         * returns the ID used. By default text is drawn at depth 9 above the default
         * depth of sprites (10). Any sprites set to a depth of 8 or less will appear
         * above the text. You can override this using SetTextDepth to set your own draw
         * order.
         *
         * @param iTextIndex - The text ID to use to reference this text later (separate
         *                   from image and sprite IDs, so there can be both a sprite 1
         *                   and a text 1)
         * @param string     - The initial string to use in this text object, can be an
         *                   empty string.
         * @return void
         */
        @Signature
        public native void CreateText(int iTextIndex, String string);

        /**
         * Creates a sprite in a blank sprite ID with an image to use when rendering, it
         * returns the sprite ID used. By default sprites are created with a depth of
         * 10, are sized using the given image as a guide, and positioned at 0,0 using
         * their top left corner. You may use an image ID of 0 to create a blank sprite
         * drawn with color only. If the assigned image has alpha pixels the sprite is
         * create with a transparency mode of 1, otherwise it uses a transparency mode
         * of 0 (opaque)
         *
         * @param iImageIndex - The ID of the image to use when drawing this sprite
         * @return int
         */
        @Signature
        public native int CreateSprite(int iImageIndex);

        /**
         * Creates a sprite in a blank sprite ID with an image to use when rendering, it
         * returns the sprite ID used. By default sprites are created with a depth of
         * 10, are sized using the given image as a guide, and positioned at 0,0 using
         * their top left corner. You may use an image ID of 0 to create a blank sprite
         * drawn with color only. If the assigned image has alpha pixels the sprite is
         * create with a transparency mode of 1, otherwise it uses a transparency mode
         * of 0 (opaque)
         *
         * @param iSpriteIndex - The sprite ID to use to reference this sprite later
         *                     (separate from image IDs, so there can be both a sprite 1
         *                     and an image 1)
         * @param iImageIndex  - The ID of the image to use when drawing this sprite
         * @return void
         */
        @Signature
        public native void CreateSprite(int iSpriteIndex, int iImageIndex);

        /**
         * Creates an sound from a memblock. The memblock must exist, this creates a new
         * sound and returns the ID. This will not affect any sound instances already
         * playing, only future ones. The memblock must contain a valid OGG file such as
         * one loaded with CreateMemblockFromFile(memID, "sound.ogg")
         *
         * @param memID - The ID of the memblock to read, the memblock is unaffected by
         *              this command.
         * @return int
         */
        @Signature
        public native int CreateSoundFromOGGMemblock(int memID);

        /**
         * Creates an sound from a memblock. The memblock must exist, this creates a new
         * sound and returns the ID. This will not affect any sound instances already
         * playing, only future ones. The memblock must contain a valid OGG file such as
         * one loaded with CreateMemblockFromFile(memID, "sound.ogg")
         *
         * @param soundID - The ID of the sound to create or modify.
         * @param memID   - The ID of the memblock to read, the memblock is unaffected
         *                by this command.
         * @return void
         */
        @Signature
        public native void CreateSoundFromOGGMemblock(int soundID, int memID);

        /**
         * Creates an sound from a memblock. The memblock must exist, this creates a new
         * sound and returns the ID. This will not affect any sound instances already
         * playing, only future ones. The first 2 bytes of the memlbock store the number
         * of channels (1 or 2 supported), the next 2 bytes store the bits per sample (8
         * or 16 supported), the next 4 bytes store the samples per second, for example
         * 44100. The next 4 bytes are the number of frames in the sound data, the size
         * of the sound data in bytes can be calculated from this with the formula
         * numFrames*(bitsPerSample/8)*channels. In a 2 channel sound a frame contains 2
         * samples, one for each channel. In a mono sound a frame contains 1 sample. The
         * rest of the memblock is raw sound data, for example in an 8bit stereo sound
         * with 3 frames the raw data would look like this. byte offset 0 = Frame 1,
         * left channel data byte offset 1 = Frame 1, right channel data byte offset 2 =
         * Frame 2, left channel data byte offset 3 = Frame 2, right channel data byte
         * offset 4 = Frame 3, left channel data byte offset 5 = Frame 3, right channel
         * data Returns the ID of the new sound.
         *
         * @param memID - The ID of the memblock to read, the memblock is unaffected by
         *              this command.
         * @return int
         */
        @Signature
        public native int CreateSoundFromMemblock(int memID);

        /**
         * Creates an sound from a memblock. The memblock must exist, this creates a new
         * sound and returns the ID. This will not affect any sound instances already
         * playing, only future ones. The first 2 bytes of the memlbock store the number
         * of channels (1 or 2 supported), the next 2 bytes store the bits per sample (8
         * or 16 supported), the next 4 bytes store the samples per second, for example
         * 44100. The next 4 bytes are the number of frames in the sound data, the size
         * of the sound data in bytes can be calculated from this with the formula
         * numFrames*(bitsPerSample/8)*channels. In a 2 channel sound a frame contains 2
         * samples, one for each channel. In a mono sound a frame contains 1 sample. The
         * rest of the memblock is raw sound data, for example in an 8bit stereo sound
         * with 3 frames the raw data would look like this. byte offset 0 = Frame 1,
         * left channel data byte offset 1 = Frame 1, right channel data byte offset 2 =
         * Frame 2, left channel data byte offset 3 = Frame 2, right channel data byte
         * offset 4 = Frame 3, left channel data byte offset 5 = Frame 3, right channel
         * data Returns the ID of the new sound.
         *
         * @param soundID - The ID of the sound to create or modify.
         * @param memID   - The ID of the memblock to read, the memblock is unaffected
         *                by this command.
         * @return void
         */
        @Signature
        public native void CreateSoundFromMemblock(int soundID, int memID);

        /**
         * Creates a socket listener that listens on a specified port for incoming
         * socket connections. When a connection occurs it will be held in a queue until
         * you retrieve it with GetSocketListenerConnection. If you want to reject a
         * connection you must retrieve it and then delete it. The listener will
         * continue accepting connections until it is deleted. If your device has
         * multiple network interfaces then you can specify which one to listen on by
         * using the IP address parameter. To listen on all interfaces use an empty
         * string as the IP address. If the device has both IPv4 and IPv6 addresses then
         * the listener can only listen on one or the other, not both. To listen for
         * both IPv4 and IPv6 connections you need to create two listeners, one for the
         * IPv4 connections and one for the IPv6 connections. Connections from either
         * will behave exactly the same after they are connected. To create an IPv6
         * listener pass an IPv6 IP address to CreateSocketListener, or "anyip6" to
         * listen on any suitable IPv6 address. If you pass an empty string or "anyip4"
         * as the IP address then it will listen for IPv4 connections. You can have
         * multiple listeners active at the same time, but they must all use different
         * ports or IPs. When choosing a port number you should avoid low values as
         * these will frequently be used by other apps and services. If something is
         * already listening on a port then your attempt to listen on it will fail.
         * Returns 0 if it failed to start listening.
         *
         * @param listenerID - An ID to use to reference this listener in the future
         * @param szIP       - The IP address of the interface to listen on, can be IPv4
         *                   or IPv6, or "anyip4", or "anyip6"
         * @param port       - The TCP port to listen on, in the range 1025 to 65535
         * @return int
         */
        @Signature
        public native int CreateSocketListener(int listenerID, String szIP, int port);

        /**
         * Creates a socket listener that listens on a specified port for incoming
         * socket connections. When a connection occurs it will be held in a queue until
         * you retrieve it with GetSocketListenerConnection. If you want to reject a
         * connection you must retrieve it and then delete it. The listener will
         * continue accepting connections until it is deleted. If your device has
         * multiple network interfaces then you can specify which one to listen on by
         * using the IP address parameter. To listen on all interfaces use an empty
         * string as the IP address. If the device has both IPv4 and IPv6 addresses then
         * the listener can only listen on one or the other, not both. To listen for
         * both IPv4 and IPv6 connections you need to create two listeners, one for the
         * IPv4 connections and one for the IPv6 connections. Connections from either
         * will behave exactly the same after they are connected. To create an IPv6
         * listener pass an IPv6 IP address to CreateSocketListener, or "anyip6" to
         * listen on any suitable IPv6 address. If you pass an empty string or "anyip4"
         * as the IP address then it will listen for IPv4 connections. You can have
         * multiple listeners active at the same time, but they must all use different
         * ports or IPs. When choosing a port number you should avoid low values as
         * these will frequently be used by other apps and services. If something is
         * already listening on a port then your attempt to listen on it will fail.
         * Returns 0 if it failed to start listening.
         *
         * @param szIP - The IP address of the interface to listen on, can be IPv4 or
         *             IPv6, or "anyip4", or "anyip6"
         * @param port - The TCP port to listen on, in the range 1025 to 65535
         * @return int
         */
        @Signature
        public native int CreateSocketListener(String szIP, int port);

        /**
         * Creates a 2D skeleton the can be used to animate sprites using bones.
         * Currently this command is not very useful as there aren't many commands for
         * setting up a skeleton. Instead skeletons should be loaded with
         * LoadSkeleton2DFromSpineFile
         *
         * @return int
         */
        @Signature
        public native int CreateSkeleton2D();

        /**
         * Creates a 2D skeleton the can be used to animate sprites using bones.
         * Currently this command is not very useful as there aren't many commands for
         * setting up a skeleton. Instead skeletons should be loaded with
         * LoadSkeleton2DFromSpineFile
         *
         * @param iSkeleton - ID to use to reference this skeleton
         * @return void
         */
        @Signature
        public native void CreateSkeleton2D(int iSkeleton);

        /**
         * Creates a rope joint between two sprites. The rope joint enforces a maximum
         * distance between the sprites without any other restrictions. It does not stop
         * them getting closer together. Specify two anchor points in world coordinates
         * with the maximum length you want to allow, the current position of the
         * sprites does not affect the initialisation of the joint. The anchor points
         * can be offset from the sprite positions. A joint may be deleted by the system
         * if any of the sprites it connects are deleted.
         *
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the sprite 1 anchor point.
         * @param y             - The y coordinate of the sprite 1 anchor point.
         * @param x2            - The x coordinate of the sprite 2 anchor point.
         * @param y2            - The y coordinate of the sprite 2 anchor point.
         * @param maxLength     - The maximum length allowed between the sprite anchor
         *                      points.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return int
         */
        @Signature
        public native int CreateRopeJoint(int iSpriteIndex1, int iSpriteIndex2, float x, float y, float x2, float y2,
                        float maxLength, int colConnected);

        /**
         * Creates a rope joint between two sprites. The rope joint enforces a maximum
         * distance between the sprites without any other restrictions. It does not stop
         * them getting closer together. Specify two anchor points in world coordinates
         * with the maximum length you want to allow, the current position of the
         * sprites does not affect the initialisation of the joint. The anchor points
         * can be offset from the sprite positions. A joint may be deleted by the system
         * if any of the sprites it connects are deleted.
         *
         * @param iJointIndex   - The ID to use for this joint.
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the sprite 1 anchor point.
         * @param y             - The y coordinate of the sprite 1 anchor point.
         * @param x2            - The x coordinate of the sprite 2 anchor point.
         * @param y2            - The y coordinate of the sprite 2 anchor point.
         * @param maxLength     - The maximum length allowed between the sprite anchor
         *                      points.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return void
         */
        @Signature
        public native void CreateRopeJoint(int iJointIndex, int iSpriteIndex1, int iSpriteIndex2, float x, float y,
                        float x2, float y2, float maxLength, int colConnected);

        /**
         * Creates a revolute joint between two sprites. The revolute joint allows the
         * sprites to only rotate around the given point. Specify a single anchor point
         * in world coordinates with the sprites already at the desired relative
         * position. The anchor point can be offset from the sprite center positions. A
         * joint ID will be returned to reference this joint later, a joint may be
         * deleted by the system if any of the sprites it connects are deleted. This
         * joint supports motors and limits.
         *
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the anchor point.
         * @param y             - The y coordinate of the anchor point.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return int
         */
        @Signature
        public native int CreateRevoluteJoint(int iSpriteIndex1, int iSpriteIndex2, float x, float y, int colConnected);

        /**
         * Creates a revolute joint between two sprites. The revolute joint allows the
         * sprites to only rotate around the given point. Specify a single anchor point
         * in world coordinates with the sprites already at the desired relative
         * position. The anchor point can be offset from the sprite center positions. A
         * joint ID will be returned to reference this joint later, a joint may be
         * deleted by the system if any of the sprites it connects are deleted. This
         * joint supports motors and limits.
         *
         * @param iJointIndex   - The ID to use for this joint.
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the anchor point.
         * @param y             - The y coordinate of the anchor point.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return void
         */
        @Signature
        public native void CreateRevoluteJoint(int iJointIndex, int iSpriteIndex1, int iSpriteIndex2, float x, float y,
                        int colConnected);

        /**
         * Creates a blank image suitable for rendering and returns an ID to reference
         * it. This can be used with SetRenderToImage to draw things to images. You can
         * create RGBA images for normal rendering or depth images for capturing the
         * depth buffer on devices that support it. You can also choose to use
         * mipmapping on this image or not, this overrides the global
         * SetGenerateMipmaps() command for this image only, this is because mipmaps on
         * rendered images can be a performance hit so it should not be used unless
         * necessary. Mipmaps should only be necessary if you intend to use this image
         * to texture objects in your scene, if you are only using this image for full
         * screen shaders you should not use mipmapping on it.
         *
         * @param width  - The width of the image to create
         * @param height - The height of the image to create
         * @param format - 0=RGBA (32bit), 1=Depth
         * @param mipmap - 1 to use mipmapping on this image, 0 to turn it off
         * @return int
         */
        @Signature
        public native int CreateRenderImage(int width, int height, int format, int mipmap);

        /**
         * Creates a blank image suitable for rendering and returns an ID to reference
         * it. This can be used with SetRenderToImage to draw things to images. You can
         * create RGBA images for normal rendering or depth images for capturing the
         * depth buffer on devices that support it. You can also choose to use
         * mipmapping on this image or not, this overrides the global
         * SetGenerateMipmaps() command for this image only, this is because mipmaps on
         * rendered images can be a performance hit so it should not be used unless
         * necessary. Mipmaps should only be necessary if you intend to use this image
         * to texture objects in your scene, if you are only using this image for full
         * screen shaders you should not use mipmapping on it.
         *
         * @param imageID - The image ID to use for this image
         * @param width   - The width of the image to create
         * @param height  - The height of the image to create
         * @param format  - 0=RGBA (32bit), 1=Depth
         * @param mipmap  - 1 to use mipmapping on this image, 0 to turn it off
         * @return void
         */
        @Signature
        public native void CreateRenderImage(int imageID, int width, int height, int format, int mipmap);

        /**
         * Creates a pulley joint between two sprites. This the first half of a two
         * command setup. Due to the number of parameters required you must call
         * FinishPulleyJoint with the rest of the parameters to create the joint. This
         * command returns nothing, the joint ID is returned by FinishPulleyJoint.
         *
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param ratio         - The ratio between the two sides of the pulley.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return void
         */
        @Signature
        public native void CreatePulleyJoint2(int iSpriteIndex1, int iSpriteIndex2, float ratio, int colConnected);

        /**
         * Creates a pulley joint between two sprites. The anchor points are world space
         * coordinates that attach the joint to the sprite, the anchor points do not
         * have to be on the sprite's center, or anywhere near the sprite, but this
         * point will become the new center of rotation for the time the sprite is
         * attached to the pulley. The ground points are where the pulley rope will
         * attach to the imaginary pulleys, and will remain fixed for the life of the
         * joint, they need not be in the same location. The ratio value determines the
         * gear ratio between the two sides of the pulley, for example a value of 2
         * would mean that sprite 1 moves at twice the speed of sprite 2, but will
         * experience half the force applied to sprite 2.
         *
         * @param iJointIndex   - The ID to use for this joint.
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param gnd1x         - The x coordinate of the ground point for sprite 1.
         * @param gnd1y         - The y coordinate of the ground point for sprite 1.
         * @param gnd2x         - The x coordinate of the ground point for sprite 2.
         * @param gnd2y         - The y coordinate of the ground point for sprite 2.
         * @param a1x           - The x coordinate of the anchor point for sprite 1.
         * @param a1y           - The y coordinate of the anchor point for sprite 1.
         * @param a2x           - The x coordinate of the anchor point for sprite 2.
         * @param a2y           - The y coordinate of the anchor point for sprite 2.
         * @param ratio         - The ratio between the two sides of the pulley.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return void
         */
        @Signature
        public native void CreatePulleyJoint(int iJointIndex, int iSpriteIndex1, int iSpriteIndex2, float gnd1x,
                        float gnd1y, float gnd2x, float gnd2y, float a1x, float a1y, float a2x, float a2y, float ratio,
                        int colConnected);

        /**
         * Creates a prismatic joint between two sprites. The prismatic joint allows the
         * sprites to only move along a given axis relative to each other. It can be
         * thought of as a piston with the sprites unable to rotate at each end. It is
         * similar to a line joint except that relative rotation is prevented. Specify a
         * single anchor point in world coordinates with the sprites already at the
         * desired relative position, at the piston's minimal extent. From this point
         * the sprites will be allowed to separate along the given axis and rotate as a
         * whole, but not rotate relative to each other. The anchor point can be offset
         * from the sprite center positions. A joint ID will be returned to reference
         * this joint later, a joint may be deleted by the system if any of the sprites
         * it connects are deleted. This joint supports motors and limits.
         *
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the anchor point.
         * @param y             - The y coordinate of the anchor point.
         * @param vx            - The x component of the axis.
         * @param vy            - The y component of the axis.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return int
         */
        @Signature
        public native int CreatePrismaticJoint(int iSpriteIndex1, int iSpriteIndex2, float x, float y, float vx,
                        float vy, int colConnected);

        /**
         * Creates a prismatic joint between two sprites. The prismatic joint allows the
         * sprites to only move along a given axis relative to each other. It can be
         * thought of as a piston with the sprites unable to rotate at each end. It is
         * similar to a line joint except that relative rotation is prevented. Specify a
         * single anchor point in world coordinates with the sprites already at the
         * desired relative position, at the piston's minimal extent. From this point
         * the sprites will be allowed to separate along the given axis and rotate as a
         * whole, but not rotate relative to each other. The anchor point can be offset
         * from the sprite center positions. A joint ID will be returned to reference
         * this joint later, a joint may be deleted by the system if any of the sprites
         * it connects are deleted. This joint supports motors and limits.
         *
         * @param iJointIndex   - The ID to use for this joint.
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the anchor point.
         * @param y             - The y coordinate of the anchor point.
         * @param vx            - The x component of the axis.
         * @param vy            - The y component of the axis.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return void
         */
        @Signature
        public native void CreatePrismaticJoint(int iJointIndex, int iSpriteIndex1, int iSpriteIndex2, float x, float y,
                        float vx, float vy, int colConnected);

        /**
         * Creates a point light that shines equally in all directions. This affects all
         * objects using the default internal shader with SetObjectLightMode set to 1.
         * If you are using a custom shader then AGK will add lighting functions to your
         * shader during loading if you reference them, see the guide to shaders for
         * more information on this. By default, lights are created in vertex mode, this
         * is faster than pixel mode but lower quality. To change this use
         * SetPointLightMode. Color values should be in the range 0-255 but are not
         * limited to it. Values greater than 255 will over saturate things and values
         * less than 0 will take light away.
         *
         * @param lightID - The ID of the light to reference it in other commands.
         * @param x       - The X component of the light position.
         * @param y       - The Y component of the light position.
         * @param z       - The Z component of the light position.
         * @param radius  - The range that the light affects.
         * @param red     - The red component of the light color.
         * @param green   - The green component of the light color.
         * @param blue    - The blue component of the light color.
         * @return void
         */
        @Signature
        public native void CreatePointLight(int lightID, float x, float y, float z, float radius, int red, int green,
                        int blue);

        /**
         * Creates a particle emitter in a free ID and at the given location in world
         * coordinates. It returns the ID used to create the emitter. Particle emitters
         * create a flow of small sprites that last for a fixed amount of time before
         * disappearing. The particles can be influenced by forces during their life
         * using AddParticlesForce. They can also change color over time using
         * AddParticlesColorKeyFrame. Particles cannot be modified individually and
         * behave as a group using the same texture and depth. This allows the AGK to
         * draw them more efficiently than a similar number of normal sprites.
         *
         * @param x - The x coordinate to position this emitter.
         * @param y - The y coordinate to position this emitter.
         * @return int
         */
        @Signature
        public native int CreateParticles(float x, float y);

        /**
         * Creates a particle emitter in a free ID and at the given location in world
         * coordinates. It returns the ID used to create the emitter. Particle emitters
         * create a flow of small sprites that last for a fixed amount of time before
         * disappearing. The particles can be influenced by forces during their life
         * using AddParticlesForce. They can also change color over time using
         * AddParticlesColorKeyFrame. Particles cannot be modified individually and
         * behave as a group using the same texture and depth. This allows the AGK to
         * draw them more efficiently than a similar number of normal sprites.
         *
         * @param ID - The ID to use when referencing this particle emitter.
         * @param x  - The x coordinate to position this emitter.
         * @param y  - The y coordinate to position this emitter.
         * @return void
         */
        @Signature
        public native void CreateParticles(int ID, float x, float y);

        /**
         * Creates a global force that affects all physics sprites. Can be set to either
         * attract to or repel sprites from a specific location. It returns a force ID
         * that can be used to modify or delete the force later. Forces continue to act
         * until they are deleted.
         *
         * @param x     - The x position of the force location in world coordinates.
         * @param y     - The y position of the force location in world coordinates.
         * @param power - The strength of the force at 1 unit from the force point for
         *              fading forces, or the strength at all times for non fading.
         * @param limit - Applies to fading forces only, the maximum force that will be
         *              applied to a sprite, used when the sprite is closer than 1 unit.
         * @param range - The range that this force can act, sprites greater than this
         *              distance from the force point feel no effects. less than 0 means
         *              infinite range.
         * @param fade  - Set to 1 if the force should be weaker when sprites are
         *              further from the force point, 0 if the force is equal at all
         *              distances.
         * @return int
         */
        @Signature
        public native int CreatePhysicsForce(float x, float y, float power, float limit, float range, int fade);

        /**
         * Creates a 3D sphere with the given diameter, and an optional number of
         * polygons. The rows parameter determines how many rows of polygons make up the
         * sphere and must be at least 2. The columns parameter determines how many
         * columns of polygons make up the sphere and must be at least 3. The formula
         * for calculating the total number of polygons used in the sphere is
         * 2*columns*(rows-1)
         *
         * @param objID    - The ID to use for the new object.
         * @param diameter - The diameter of the sphere.
         * @param rows     - The number of rows of polygons that make up the sphere.
         * @param columns  - The number of columns of polygons that make up the sphere.
         * @return void
         */
        @Signature
        public native void CreateObjectSphere(int objID, float diameter, int rows, int columns);

        /**
         * Creates a 3D sphere with the given diameter, and an optional number of
         * polygons. The rows parameter determines how many rows of polygons make up the
         * sphere and must be at least 2. The columns parameter determines how many
         * columns of polygons make up the sphere and must be at least 3. The formula
         * for calculating the total number of polygons used in the sphere is
         * 2*columns*(rows-1)
         *
         * @param diameter - The diameter of the sphere.
         * @param rows     - The number of rows of polygons that make up the sphere.
         * @param columns  - The number of columns of polygons that make up the sphere.
         * @return int
         */
        @Signature
        public native int CreateObjectSphere(float diameter, int rows, int columns);

        /**
         * Creates a plane that will fill the entire screen and can be used to render
         * full screen shaders.
         *
         * @param objID - The ID to use for the new object.
         * @return void
         */
        @Signature
        public native void CreateObjectQuad(int objID);

        /**
         * Creates a plane that will fill the entire screen and can be used to render
         * full screen shaders.
         *
         * @return int
         */
        @Signature
        public native int CreateObjectQuad();

        /**
         * Creates a 3D double sided plane with the given width (X) and height (Y). The
         * plane is created in the XY plane and has no size in the Z direction.
         *
         * @param objID  - The ID to use for the new object.
         * @param width  - The width of the plane.
         * @param height - The height of the plane.
         * @return void
         */
        @Signature
        public native void CreateObjectPlane(int objID, float width, float height);

        /**
         * Creates a 3D double sided plane with the given width (X) and height (Y). The
         * plane is created in the XY plane and has no size in the Z direction.
         *
         * @param width  - The width of the plane.
         * @param height - The height of the plane.
         * @return int
         */
        @Signature
        public native int CreateObjectPlane(float width, float height);

        /**
         * Creates an object from a specified .raw or .dat height map, useful for making
         * terrain. The file should be in raw 16-bit data. If you use extension ".dat"
         * in szFilename it will expect that this is a GameGuru 32-bit raw height map
         * and convert that to 16-bit. If the file is not a GameGuru height map then you
         * must change the extension to ".raw". If you convert a GameGuru height map
         * (.dat) file, rawWidth and rawHeight should always be set to 1024. The object
         * will have a single UV channel with the range 0 to 1 mapped to the entire
         * terrain. If you wish to modify this then you can use SetObjectUVOffset and
         * SetObjectUVScale, or use a shader that multiplies the UV coordinates by a
         * specified amount. A shader can also be used to create multiple UV channels
         * from this single channel by applying different scale factors to each.
         * Normally when using 16-bit data you don't need to set a smoothing value, but
         * if its not already been smoothed adjust as necessary. The split value lets
         * you create multiple meshes which can improve performance, as unseen meshes
         * will not be drawn. The split value specifies how many meshes to create along
         * each edge, for example a split value of 5 will create 5x5 = 25 meshes in
         * total. Unlike other objects collision data is not generated by default on
         * this object as it can consume a lot of memory, use SetObjectCollisionMode if
         * you want to turn it on. For terrains greater than 1024x1024 this is not
         * recommended on mobile devices, and you should use GetObjectHeightMapHeight
         * instead if possible. Turning on physics for this object will use even more
         * memory and is not recommended on terrains greater than 1024x1024 on any
         * platform.
         *
         * @param szFilename - The filename of the height map, must end in .raw or .dat
         * @param width      - The desired width of the new object in the X direction
         * @param height     - The desired height of the new object in the Y direction
         * @param length     - The desired length of the new object in the Z direction
         * @param smoothing  - The amount of smoothing to apply to the height values,
         *                   0=none, 1=one pass, 2=two passes, etc
         * @param split      - 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen
         *                   meshes, etc
         * @param rawWidth   - The width of the height map data
         * @param rawHeight  - The height of the height map data
         * @return int
         */
        @Signature
        public native int CreateObjectFromRawHeightMap(String szFilename, float width, float height, float length,
                        int smoothing, int split, int rawWidth, int rawHeight);

        /**
         * Creates an object from a specified .raw or .dat height map, useful for making
         * terrain. The file should be in raw 16-bit data. If you use extension ".dat"
         * in szFilename it will expect that this is a GameGuru 32-bit raw height map
         * and convert that to 16-bit. If the file is not a GameGuru height map then you
         * must change the extension to ".raw". If you convert a GameGuru height map
         * (.dat) file, rawWidth and rawHeight should always be set to 1024. The object
         * will have a single UV channel with the range 0 to 1 mapped to the entire
         * terrain. If you wish to modify this then you can use SetObjectUVOffset and
         * SetObjectUVScale, or use a shader that multiplies the UV coordinates by a
         * specified amount. A shader can also be used to create multiple UV channels
         * from this single channel by applying different scale factors to each.
         * Normally when using 16-bit data you don't need to set a smoothing value, but
         * if its not already been smoothed adjust as necessary. The split value lets
         * you create multiple meshes which can improve performance, as unseen meshes
         * will not be drawn. The split value specifies how many meshes to create along
         * each edge, for example a split value of 5 will create 5x5 = 25 meshes in
         * total. Unlike other objects collision data is not generated by default on
         * this object as it can consume a lot of memory, use SetObjectCollisionMode if
         * you want to turn it on. For terrains greater than 1024x1024 this is not
         * recommended on mobile devices, and you should use GetObjectHeightMapHeight
         * instead if possible. Turning on physics for this object will use even more
         * memory and is not recommended on terrains greater than 1024x1024 on any
         * platform.
         *
         * @param objID      - The ID of the object to create
         * @param szFilename - The filename of the height map, must end in .raw or .dat
         * @param width      - The desired width of the new object in the X direction
         * @param height     - The desired height of the new object in the Y direction
         * @param length     - The desired length of the new object in the Z direction
         * @param smoothing  - The amount of smoothing to apply to the height values,
         *                   0=none, 1=one pass, 2=two passes, etc
         * @param split      - 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen
         *                   meshes, etc
         * @param rawWidth   - The width of the height map data
         * @param rawHeight  - The height of the height map data
         * @return void
         */
        @Signature
        public native void CreateObjectFromRawHeightMap(int objID, String szFilename, float width, float height,
                        float length, int smoothing, int split, int rawWidth, int rawHeight);

        /**
         * Creates an object by copying a single mesh from another object. An object can
         * contain many meshes, and using CloneObject would copy them all. Use this
         * command if you only want to copy a single mesh. Mesh indices are in the range
         * 1 to GetObjectNumMeshes inclusive.
         *
         * @param objID     - The ID of the new object
         * @param fromObjID - The ID of the object that contains the mesh to copy
         * @param meshIndex - The index of the mesh to copy
         * @return void
         */
        @Signature
        public native void CreateObjectFromObjectMesh(int objID, int fromObjID, int meshIndex);

        /**
         * Creates an object by copying a single mesh from another object. An object can
         * contain many meshes, and using CloneObject would copy them all. Use this
         * command if you only want to copy a single mesh. Mesh indices are in the range
         * 1 to GetObjectNumMeshes inclusive.
         *
         * @param fromObjID - The ID of the object that contains the mesh to copy
         * @param meshIndex - The index of the mesh to copy
         * @return int
         */
        @Signature
        public native int CreateObjectFromObjectMesh(int fromObjID, int meshIndex);

        /**
         * Creates an object with a single mesh constructed from the given memblock. Any
         * subsequent changes to the memblock will not affect the mesh, you should call
         * SetObjectMeshFromMemblock to modify an existing mesh. The first 4 bytes of
         * the memblock represent the number of vertices in the mesh. The second 4 bytes
         * represent the number of indices in the mesh, this may be 0 in which case
         * every three vertices represents a polygon, and no vertices can be shared. If
         * the number of indices is greater than 0 then every three indices represent a
         * polygon and vertices may be shared between polygons. Indices start at 0 so
         * index 0 references the first vertex in the list. The third 4 bytes represents
         * the number of attributes per vertex, e.g. position, normals, and UV data are
         * all potential attributes, so a vertex containing all three would have 3
         * attributes. A vertex must have a position attribute, everything else is
         * optional. The fourth 4 bytes represent the size of a single vertex in bytes,
         * this can be calculated from the attribute data but is given for convenience.
         * The fifth 4 bytes is offset for the beginning of the vertex data, so you can
         * reach it easily. The sixth 4 bytes is offset for the beginning of the index
         * data, will be 0 if there are no indices. After those 6 values, starting at
         * offset 24, is the vertex attribute data. The vertex attribute data describes
         * how the vertex data is laid out, for example if it has normals, UV data, etc.
         * For each attribute there is a 1 byte data type, 1 byte component count, 1
         * byte normalize flag, 1 byte string length, and X bytes of string data for the
         * attribute name. The data type will be 0 for floats (used for almost
         * everything, e.g. position, normals, etc) or 1 for unsigned bytes (used for
         * vertex colors). The component count is the number of values per attribute,
         * e.g. position has 3 components, x,y,z, UV data has 2 components, and vertex
         * colors have 4 components. Note that any unsigned byte data type must have 4
         * components even if some are unused. The normalize flag is only used for
         * unsigned byte data types and will convert values in the range 0-255 into
         * 0.0-1.0 for use in a shader. Usually the normalize flag will be 1 for color
         * attributes and 0 for everything else. The string length byte must always be a
         * multiple of 4 for alignment reasons, the string itself might have slightly
         * less characters but always round up to the nearest multiple of 4 for the
         * string length value. e.g. a string of length 5 should have a string length
         * value of 8. Note that a string of 4 characters has a null terminator on the
         * end which makes it length 5, so even though it has a multiple of 4 characters
         * already it must use a length value of 8 due to the null terminator. The
         * attribute name string will be used by the shader to recognise what the vertex
         * data is, the attribute names recognised by AGK are "position", "normal",
         * "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
         * "boneindices", however you may add attributes with any name you like as long
         * as you write a matching shader that has the same names. If you are not using
         * your own shader and instead rely on AGK to draw the object then you must
         * stick to the above attribute names. Following the attribute data is the raw
         * vertex data, which usually starts with the "position" attribute. It will be a
         * 4 byte float for the X position, a 4 byte float for the Y position, and a 4
         * byte float for the Z position. This continues for each attribute specified in
         * the attribute data. Note that color data will always be 4 bytes in total, 1
         * unsigned byte for each color channel. You can access individual vertices by
         * using the vertex size provided above and the vertex index like so
         * offset=vertexDataOffset+(vertexIndex*vertexSize). Lastly is the index data,
         * if present. Each index is a 4 byte integer which references a vertex in the
         * vertex data. Every three indices represents a polygon.
         *
         * @param memID - The index of the memblock to use to create the object mesh
         * @return int
         */
        @Signature
        public native int CreateObjectFromMeshMemblock(int memID);

        /**
         * Creates an object with a single mesh constructed from the given memblock. Any
         * subsequent changes to the memblock will not affect the mesh, you should call
         * SetObjectMeshFromMemblock to modify an existing mesh. The first 4 bytes of
         * the memblock represent the number of vertices in the mesh. The second 4 bytes
         * represent the number of indices in the mesh, this may be 0 in which case
         * every three vertices represents a polygon, and no vertices can be shared. If
         * the number of indices is greater than 0 then every three indices represent a
         * polygon and vertices may be shared between polygons. Indices start at 0 so
         * index 0 references the first vertex in the list. The third 4 bytes represents
         * the number of attributes per vertex, e.g. position, normals, and UV data are
         * all potential attributes, so a vertex containing all three would have 3
         * attributes. A vertex must have a position attribute, everything else is
         * optional. The fourth 4 bytes represent the size of a single vertex in bytes,
         * this can be calculated from the attribute data but is given for convenience.
         * The fifth 4 bytes is offset for the beginning of the vertex data, so you can
         * reach it easily. The sixth 4 bytes is offset for the beginning of the index
         * data, will be 0 if there are no indices. After those 6 values, starting at
         * offset 24, is the vertex attribute data. The vertex attribute data describes
         * how the vertex data is laid out, for example if it has normals, UV data, etc.
         * For each attribute there is a 1 byte data type, 1 byte component count, 1
         * byte normalize flag, 1 byte string length, and X bytes of string data for the
         * attribute name. The data type will be 0 for floats (used for almost
         * everything, e.g. position, normals, etc) or 1 for unsigned bytes (used for
         * vertex colors). The component count is the number of values per attribute,
         * e.g. position has 3 components, x,y,z, UV data has 2 components, and vertex
         * colors have 4 components. Note that any unsigned byte data type must have 4
         * components even if some are unused. The normalize flag is only used for
         * unsigned byte data types and will convert values in the range 0-255 into
         * 0.0-1.0 for use in a shader. Usually the normalize flag will be 1 for color
         * attributes and 0 for everything else. The string length byte must always be a
         * multiple of 4 for alignment reasons, the string itself might have slightly
         * less characters but always round up to the nearest multiple of 4 for the
         * string length value. e.g. a string of length 5 should have a string length
         * value of 8. Note that a string of 4 characters has a null terminator on the
         * end which makes it length 5, so even though it has a multiple of 4 characters
         * already it must use a length value of 8 due to the null terminator. The
         * attribute name string will be used by the shader to recognise what the vertex
         * data is, the attribute names recognised by AGK are "position", "normal",
         * "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
         * "boneindices", however you may add attributes with any name you like as long
         * as you write a matching shader that has the same names. If you are not using
         * your own shader and instead rely on AGK to draw the object then you must
         * stick to the above attribute names. Following the attribute data is the raw
         * vertex data, which usually starts with the "position" attribute. It will be a
         * 4 byte float for the X position, a 4 byte float for the Y position, and a 4
         * byte float for the Z position. This continues for each attribute specified in
         * the attribute data. Note that color data will always be 4 bytes in total, 1
         * unsigned byte for each color channel. You can access individual vertices by
         * using the vertex size provided above and the vertex index like so
         * offset=vertexDataOffset+(vertexIndex*vertexSize). Lastly is the index data,
         * if present. Each index is a 4 byte integer which references a vertex in the
         * vertex data. Every three indices represents a polygon.
         *
         * @param objID - The ID of the object to create
         * @param memID - The index of the memblock to use to create the object mesh
         * @return void
         */
        @Signature
        public native void CreateObjectFromMeshMemblock(int objID, int memID);

        /**
         * Creates an object from a specified height map, useful for making terrain. The
         * image should be PNG 8-bit greyscale or RGB, if it is RGB then only the red
         * channel is read. 16-bit greyscale support may be added in future. The object
         * will have a single UV channel with the range 0 to 1 mapped to the entire
         * terrain. If you wish to modify this then you can use SetObjectUVOffset and
         * SetObjectUVScale, or use a shader that multiplies the UV coordinates by a
         * specified amount. A shader can also be used to create multiple UV channels
         * from this single channel by applying different scale factors to each. A
         * smoothing value of 1 is recommended to remove stepping artifacts, adjust as
         * necessary. The split value lets you create multiple meshes which can improve
         * performance, as unseen meshes will not be drawn. The split value specifies
         * how many meshes to create along each edge, for example a split value of 5
         * will create 5x5 = 25 meshes in total. Unlike other objects collision data is
         * not generated by default on this object as it can consume a lot of memory,
         * use SetObjectCollisionMode if you want to turn it on. For terrains greater
         * than 1024x1024 this is not recommended on mobile devices, and you should use
         * GetObjectHeightMapHeight instead if possible. Turning on physics for this
         * object will use even more memory and is not recommended on terrains greater
         * than 1024x1024 on any platform.
         *
         * @param objID       - The ID of the object to create
         * @param szImageFile - The filename of the image to use as a height map, PNG
         *                    preferred, also supports JPEG
         * @param width       - The desired width of the new object in the X direction
         * @param height      - The desired height of the new object in the Y direction
         * @param length      - The desired length of the new object in the Z direction
         * @param smoothing   - The amount of smoothing to apply to the height values,
         *                    0=none, 1=one pass, 2=two passes, etc
         * @param split       - 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen
         *                    meshes, etc
         * @return void
         */
        @Signature
        public native void CreateObjectFromHeightMap(int objID, String szImageFile, float width, float height,
                        float length, int smoothing, int split);

        /**
         * Creates an object from a specified height map, useful for making terrain. The
         * image should be PNG 8-bit greyscale or RGB, if it is RGB then only the red
         * channel is read. 16-bit greyscale support may be added in future. The object
         * will have a single UV channel with the range 0 to 1 mapped to the entire
         * terrain. If you wish to modify this then you can use SetObjectUVOffset and
         * SetObjectUVScale, or use a shader that multiplies the UV coordinates by a
         * specified amount. A shader can also be used to create multiple UV channels
         * from this single channel by applying different scale factors to each. A
         * smoothing value of 1 is recommended to remove stepping artifacts, adjust as
         * necessary. The split value lets you create multiple meshes which can improve
         * performance, as unseen meshes will not be drawn. The split value specifies
         * how many meshes to create along each edge, for example a split value of 5
         * will create 5x5 = 25 meshes in total. Unlike other objects collision data is
         * not generated by default on this object as it can consume a lot of memory,
         * use SetObjectCollisionMode if you want to turn it on. For terrains greater
         * than 1024x1024 this is not recommended on mobile devices, and you should use
         * GetObjectHeightMapHeight instead if possible. Turning on physics for this
         * object will use even more memory and is not recommended on terrains greater
         * than 1024x1024 on any platform.
         *
         * @param szImageFile - The filename of the image to use as a height map, PNG
         *                    preferred, also supports JPEG
         * @param width       - The desired width of the new object in the X direction
         * @param height      - The desired height of the new object in the Y direction
         * @param length      - The desired length of the new object in the Z direction
         * @param smoothing   - The amount of smoothing to apply to the height values,
         *                    0=none, 1=one pass, 2=two passes, etc
         * @param split       - 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen
         *                    meshes, etc
         * @return int
         */
        @Signature
        public native int CreateObjectFromHeightMap(String szImageFile, float width, float height, float length,
                        int smoothing, int split);

        /**
         * Creates a 3D cylinder with the given diameter and height, and an optional
         * number of polygons. The segments parameter determines how many columns of
         * polygons make up the cylinder and must be at least 3. The formula for
         * calculating the total number of polygons used in the cylinder is 3*segments.
         * Returns an ID you can use to reference this object in other commands.
         *
         * @param height   - The height of the cylinder.
         * @param diameter - The diameter of the base of the cylinder.
         * @param segments - The number of columns of polygons that make up the
         *                 cylinder.
         * @return int
         */
        @Signature
        public native int CreateObjectCylinder(float height, float diameter, int segments);

        /**
         * Creates a 3D cylinder with the given diameter and height, and an optional
         * number of polygons. The segments parameter determines how many columns of
         * polygons make up the cylinder and must be at least 3. The formula for
         * calculating the total number of polygons used in the cylinder is 3*segments.
         * Returns an ID you can use to reference this object in other commands.
         *
         * @param objID    - The ID to use for the new object.
         * @param height   - The height of the cylinder.
         * @param diameter - The diameter of the base of the cylinder.
         * @param segments - The number of columns of polygons that make up the
         *                 cylinder.
         * @return void
         */
        @Signature
        public native void CreateObjectCylinder(int objID, float height, float diameter, int segments);

        /**
         * Creates a Capsule primitive.
         *
         * @param objID    - The ID to use for the new object.
         * @param diameter - The diameter of the capsule.
         * @param height   - The height of the capsule
         * @param axis     - 0 = X, 1 = Y, Z = 2
         * @return void
         */
        @Signature
        public native void CreateObjectCapsule(int objID, float diameter, float height, int axis);

        /**
         * Creates a Capsule primitive.
         *
         * @param diameter - The diameter of the capsule.
         * @param height   - The height of the capsule
         * @param axis     - 0 = X, 1 = Y, Z = 2
         * @return int
         */
        @Signature
        public native int CreateObjectCapsule(float diameter, float height, int axis);

        /**
         * Creates a 3D cone with the given diameter and height, and an optional number
         * of polygons. The segments parameter determines how many columns of polygons
         * make up the cone and must be at least 3. The formula for calculating the
         * total number of polygons used in the cone is 2*segments. Returns an ID you
         * can use to reference this object in other commands.
         *
         * @param height   - The height of the cone.
         * @param diameter - The diameter of the base of the cone.
         * @param segments - The number of columns of polygons that make up the cone.
         * @return int
         */
        @Signature
        public native int CreateObjectCone(float height, float diameter, int segments);

        /**
         * Creates a 3D cone with the given diameter and height, and an optional number
         * of polygons. The segments parameter determines how many columns of polygons
         * make up the cone and must be at least 3. The formula for calculating the
         * total number of polygons used in the cone is 2*segments. Returns an ID you
         * can use to reference this object in other commands.
         *
         * @param objID    - The ID to use for the new object.
         * @param height   - The height of the cone.
         * @param diameter - The diameter of the base of the cone.
         * @param segments - The number of columns of polygons that make up the cone.
         * @return void
         */
        @Signature
        public native void CreateObjectCone(int objID, float height, float diameter, int segments);

        /**
         * Creates a 3D box with the given width (X), height (Y), and length (Z).
         * Returns an ID you can use to reference this object in other commands.
         *
         * @param width  - The size of the object in the X direction.
         * @param height - The size of the object in the Y direction.
         * @param length - The size of the object in the Z direction.
         * @return int
         */
        @Signature
        public native int CreateObjectBox(float width, float height, float length);

        /**
         * Creates a 3D box with the given width (X), height (Y), and length (Z).
         * Returns an ID you can use to reference this object in other commands.
         *
         * @param objID  - The ID to use for the new object.
         * @param width  - The size of the object in the X direction.
         * @param height - The size of the object in the Y direction.
         * @param length - The size of the object in the Z direction.
         * @return void
         */
        @Signature
        public native void CreateObjectBox(int objID, float width, float height, float length);

        /**
         * Creates a network message that can be sent to another network device. It
         * returns an ID that can be used to interact with the message. Messages created
         * in this way can only be added to, not read from. Once passed to a network the
         * message ID is destroyed and handled by the background network code.
         *
         * 
         * @return int
         */
        @Signature
        public native int CreateNetworkMessage();

        /**
         * Creates a music entity from a memblock. The memblock must exist. This will
         * create a new music ID and return it The memblock must contain a valid OGG
         * file such as one loaded with CreateMemblockFromFile(memID, "music.ogg")
         *
         * @param memID - The ID of the memblock to read, the memblock is unaffected by
         *              this command.
         * @return int
         */
        @Signature
        public native int CreateMusicFromOGGMemblock(int memID);

        /**
         * Creates a music entity from a memblock. The memblock must exist. This will
         * create a new music ID and return it The memblock must contain a valid OGG
         * file such as one loaded with CreateMemblockFromFile(memID, "music.ogg")
         *
         * @param musicID - The ID of the music to create.
         * @param memID   - The ID of the memblock to read, the memblock is unaffected
         *                by this command.
         * @return void
         */
        @Signature
        public native void CreateMusicFromOGGMemblock(int musicID, int memID);

        /**
         * Creates a memblock from an object mesh. An object can contain one or more
         * meshes, mesh indices are in the range 1 to GetObjectNumMeshes inclusive. The
         * mesh is copied into the memblock so any changes to the memblock do not
         * immediately affect the mesh, you must use one of the other commands such as
         * SetObjectMeshFromMemblock to copy the memblock back into a mesh. The first 4
         * bytes of the memblock represent the number of vertices in the mesh. The
         * second 4 bytes represent the number of indices in the mesh, this may be 0 in
         * which case every three vertices represents a polygon, and no vertices can be
         * shared. If the number of indices is greater than 0 then every three indices
         * represent a polygon and vertices may be shared between polygons. Indices
         * start at 0 so index 0 references the first vertex in the list. The third 4
         * bytes represents the number of attributes per vertex, e.g. position, normals,
         * and UV data are all potential attributes, so a vertex containing all three
         * would have 3 attributes. A vertex must have a position attribute, everything
         * else is optional. The fourth 4 bytes represent the size of a single vertex in
         * bytes, this can be calculated from the attribute data but is given for
         * convenience. The fifth 4 bytes is offset for the beginning of the vertex
         * data, so you can reach it easily. The sixth 4 bytes is offset for the
         * beginning of the index data, will be 0 if there are no indices. After those 6
         * values, starting at offset 24, is the vertex attribute data. The vertex
         * attribute data describes how the vertex data is laid out, for example if it
         * has normals, UV data, etc. For each attribute there is a 1 byte data type, 1
         * byte component count, 1 byte normalize flag, 1 byte string length, and X
         * bytes of string data for the attribute name. The data type will be 0 for
         * floats (used for almost everything, e.g. position, normals, etc) or 1 for
         * unsigned bytes (used for vertex colors). The component count is the number of
         * values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
         * components, and vertex colors have 4 components. Note that any unsigned byte
         * data type must have 4 components even if some are unused. The normalize flag
         * is only used for unsigned byte data types and will convert values in the
         * range 0-255 into 0.0-1.0 for use in a shader. Usually the normalize flag will
         * be 1 for color attributes and 0 for everything else. The string length byte
         * will always be a multiple of 4 to simplify alignment issues, the string
         * itself might have slightly less characters and be padded with null
         * terminators, but read all the bytes specified and you will get the correct
         * length string. The attribute name string will be used by the shader to
         * recognise what the vertex data is, the attribute names recognised by AGK are
         * "position", "normal", "tangent", "binormal", "color", "uv", "uv1",
         * "boneweights", and "boneindices", however you may add attributes with any
         * name you like as long as you write a matching shader that has the same names.
         * If you are not using your own shader and instead rely on AGK to draw the
         * object then you must stick to the above attribute names. Following the
         * attribute data is the raw vertex data, which usually starts with the
         * "position" attribute. It will be a 4 byte float for the X position, a 4 byte
         * float for the Y position, and a 4 byte float for the Z position. This
         * continues for each attribute specified in the attribute data. Note that color
         * data will always be 4 bytes in total, 1 unsigned byte for each color channel.
         * You can access individual vertices by using the vertex size provided above
         * and the vertex index like so
         * offset=vertexDataOffset+(vertexIndex*vertexSize). Lastly is the index data,
         * if present. Each index is a 4 byte integer which references a vertex in the
         * vertex data. Every three indices represents a polygon. If you plan on making
         * regular changes to the mesh you should keep the memblock around after using
         * SetObjectMeshFromMemblock instead of regenerating from the object it every
         * time you want to make a change. Then call SetObjectMeshFromMemblock again
         * when you want to push your new changes onto the object.
         *
         * @param objID     - The ID of the object containing the mesh to read
         * @param meshIndex - The index of the mesh to copy into a memblock
         * @return int
         */
        @Signature
        public native int CreateMemblockFromObjectMesh(int objID, int meshIndex);

        /**
         * Creates a memblock from an object mesh. An object can contain one or more
         * meshes, mesh indices are in the range 1 to GetObjectNumMeshes inclusive. The
         * mesh is copied into the memblock so any changes to the memblock do not
         * immediately affect the mesh, you must use one of the other commands such as
         * SetObjectMeshFromMemblock to copy the memblock back into a mesh. The first 4
         * bytes of the memblock represent the number of vertices in the mesh. The
         * second 4 bytes represent the number of indices in the mesh, this may be 0 in
         * which case every three vertices represents a polygon, and no vertices can be
         * shared. If the number of indices is greater than 0 then every three indices
         * represent a polygon and vertices may be shared between polygons. Indices
         * start at 0 so index 0 references the first vertex in the list. The third 4
         * bytes represents the number of attributes per vertex, e.g. position, normals,
         * and UV data are all potential attributes, so a vertex containing all three
         * would have 3 attributes. A vertex must have a position attribute, everything
         * else is optional. The fourth 4 bytes represent the size of a single vertex in
         * bytes, this can be calculated from the attribute data but is given for
         * convenience. The fifth 4 bytes is offset for the beginning of the vertex
         * data, so you can reach it easily. The sixth 4 bytes is offset for the
         * beginning of the index data, will be 0 if there are no indices. After those 6
         * values, starting at offset 24, is the vertex attribute data. The vertex
         * attribute data describes how the vertex data is laid out, for example if it
         * has normals, UV data, etc. For each attribute there is a 1 byte data type, 1
         * byte component count, 1 byte normalize flag, 1 byte string length, and X
         * bytes of string data for the attribute name. The data type will be 0 for
         * floats (used for almost everything, e.g. position, normals, etc) or 1 for
         * unsigned bytes (used for vertex colors). The component count is the number of
         * values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
         * components, and vertex colors have 4 components. Note that any unsigned byte
         * data type must have 4 components even if some are unused. The normalize flag
         * is only used for unsigned byte data types and will convert values in the
         * range 0-255 into 0.0-1.0 for use in a shader. Usually the normalize flag will
         * be 1 for color attributes and 0 for everything else. The string length byte
         * will always be a multiple of 4 to simplify alignment issues, the string
         * itself might have slightly less characters and be padded with null
         * terminators, but read all the bytes specified and you will get the correct
         * length string. The attribute name string will be used by the shader to
         * recognise what the vertex data is, the attribute names recognised by AGK are
         * "position", "normal", "tangent", "binormal", "color", "uv", "uv1",
         * "boneweights", and "boneindices", however you may add attributes with any
         * name you like as long as you write a matching shader that has the same names.
         * If you are not using your own shader and instead rely on AGK to draw the
         * object then you must stick to the above attribute names. Following the
         * attribute data is the raw vertex data, which usually starts with the
         * "position" attribute. It will be a 4 byte float for the X position, a 4 byte
         * float for the Y position, and a 4 byte float for the Z position. This
         * continues for each attribute specified in the attribute data. Note that color
         * data will always be 4 bytes in total, 1 unsigned byte for each color channel.
         * You can access individual vertices by using the vertex size provided above
         * and the vertex index like so
         * offset=vertexDataOffset+(vertexIndex*vertexSize). Lastly is the index data,
         * if present. Each index is a 4 byte integer which references a vertex in the
         * vertex data. Every three indices represents a polygon. If you plan on making
         * regular changes to the mesh you should keep the memblock around after using
         * SetObjectMeshFromMemblock instead of regenerating from the object it every
         * time you want to make a change. Then call SetObjectMeshFromMemblock again
         * when you want to push your new changes onto the object.
         *
         * @param memID     - The ID of the new memblock
         * @param objID     - The ID of the object containing the mesh to read
         * @param meshIndex - The index of the mesh to copy into a memblock
         * @return void
         */
        @Signature
        public native void CreateMemblockFromObjectMesh(int memID, int objID, int meshIndex);

        /**
         * Creates a memblock from a loaded sound file. The sound file must have been
         * loaded with LoadSound and is unaffected by this command. The first 2 bytes of
         * the memlbock store the number of channels (1 or 2 supported), the next 2
         * bytes store the bits per sample (8 or 16 supported), the next 4 bytes store
         * the samples per second, for example 44100. The next 4 bytes are the number of
         * frames in the sound data, the size of the sound data in bytes can be
         * calculated from this with the formula numFrames*(bitsPerSample/8)*channels.
         * In a 2 channel sound a frame contains 2 samples, one for each channel. In a
         * mono sound a frame contains 1 sample. The rest of the memblock is raw sound
         * data, for example in an 8bit stereo sound with 3 frames the raw data would
         * look like this. byte offset 0 = Frame 1, left channel data byte offset 1 =
         * Frame 1, right channel data byte offset 2 = Frame 2, left channel data byte
         * offset 3 = Frame 2, right channel data byte offset 4 = Frame 3, left channel
         * data byte offset 5 = Frame 3, right channel data The duration of the sound
         * can be calculated with the following formula, numFrames/samplesPerSecond.
         * This command does not work with sound instance IDs, only sound file IDs.
         * Returns an ID that can be used to reference this memblock in other commands.
         *
         * @param soundID - The ID of the sound to read.
         * @return int
         */
        @Signature
        public native int CreateMemblockFromSound(int soundID);

        /**
         * Creates a memblock from a loaded sound file. The sound file must have been
         * loaded with LoadSound and is unaffected by this command. The first 2 bytes of
         * the memlbock store the number of channels (1 or 2 supported), the next 2
         * bytes store the bits per sample (8 or 16 supported), the next 4 bytes store
         * the samples per second, for example 44100. The next 4 bytes are the number of
         * frames in the sound data, the size of the sound data in bytes can be
         * calculated from this with the formula numFrames*(bitsPerSample/8)*channels.
         * In a 2 channel sound a frame contains 2 samples, one for each channel. In a
         * mono sound a frame contains 1 sample. The rest of the memblock is raw sound
         * data, for example in an 8bit stereo sound with 3 frames the raw data would
         * look like this. byte offset 0 = Frame 1, left channel data byte offset 1 =
         * Frame 1, right channel data byte offset 2 = Frame 2, left channel data byte
         * offset 3 = Frame 2, right channel data byte offset 4 = Frame 3, left channel
         * data byte offset 5 = Frame 3, right channel data The duration of the sound
         * can be calculated with the following formula, numFrames/samplesPerSecond.
         * This command does not work with sound instance IDs, only sound file IDs.
         * Returns an ID that can be used to reference this memblock in other commands.
         *
         * @param memID   - The ID of the memblock to create.
         * @param soundID - The ID of the sound to read.
         * @return void
         */
        @Signature
        public native void CreateMemblockFromSound(int memID, int soundID);

        /**
         * Creates a mouse joint between a point and a sprite. This is typically used
         * when dragging a shape with the mouse pointer, and attempts to move the sprite
         * towards the given point using a force up to the maximum given. Specify an
         * anchor point in world coordinates that will act as the initial hold point on
         * the sprite. Any further change in the target position will attempt to move
         * that point of the sprite to the new location. Use SetJointMouseTarget to
         * change the location of the target position.
         *
         * @param iJointIndex  - The ID to use for this joint.
         * @param iSpriteIndex - The ID of the sprite to move.
         * @param x            - The x coordinate of the initial anchor point on the
         *                     sprite.
         * @param y            - The y coordinate of the initial anchor point on the
         *                     sprite.
         * @param maxForce     - The maximum force the joint can use to move the sprite.
         * @return void
         */
        @Signature
        public native void CreateMouseJoint(int iJointIndex, int iSpriteIndex, float x, float y, float maxForce);

        /**
         * Creates a mouse joint between a point and a sprite. This is typically used
         * when dragging a shape with the mouse pointer, and attempts to move the sprite
         * towards the given point using a force up to the maximum given. Specify an
         * anchor point in world coordinates that will act as the initial hold point on
         * the sprite. Any further change in the target position will attempt to move
         * that point of the sprite to the new location. Use SetJointMouseTarget to
         * change the location of the target position.
         *
         * @param iSpriteIndex - The ID of the sprite to move.
         * @param x            - The x coordinate of the initial anchor point on the
         *                     sprite.
         * @param y            - The y coordinate of the initial anchor point on the
         *                     sprite.
         * @param maxForce     - The maximum force the joint can use to move the sprite.
         * @return int
         */
        @Signature
        public native int CreateMouseJoint(int iSpriteIndex, float x, float y, float maxForce);

        /**
         * Creates a memblock from a loaded image, atlas sub images are not supported.
         * The image must exist and is unaffected by this command. The first 4 bytes of
         * the memlbock store the image width, the next 4 bytes store the image height,
         * the next 4 bytes store the bit depth, currently this will always be 32. After
         * that the raw image data begins in the format RGBA, with each component stored
         * in a single byte, so each pixel takes up 4 bytes. The size of the image data
         * can be calculated by width*height*4 bytes (for now bit depth can be assumed
         * to be 32 bits = 4 bytes). Note that due to little endian format reading the
         * image data with bytes will return offsets 0=R, 1=G, 2=B, 3=A, but reading
         * them all as a single integer will produce a value with A as the most
         * significant byte, followed by B, then G, then R as the least significant
         * byte. The pixel data starts in the top left corner of the image an proceeds
         * left to right then top to bottom resulting in the image being stored as a
         * sequence of rows ending in the bottom right corner. Returns an ID that can be
         * used to reference this memblock in other commands.
         *
         * @param imageID - The ID of the image to read.
         * @return int
         */
        @Signature
        public native int CreateMemblockFromImage(int imageID);

        /**
         * Creates a memblock from a loaded image, atlas sub images are not supported.
         * The image must exist and is unaffected by this command. The first 4 bytes of
         * the memlbock store the image width, the next 4 bytes store the image height,
         * the next 4 bytes store the bit depth, currently this will always be 32. After
         * that the raw image data begins in the format RGBA, with each component stored
         * in a single byte, so each pixel takes up 4 bytes. The size of the image data
         * can be calculated by width*height*4 bytes (for now bit depth can be assumed
         * to be 32 bits = 4 bytes). Note that due to little endian format reading the
         * image data with bytes will return offsets 0=R, 1=G, 2=B, 3=A, but reading
         * them all as a single integer will produce a value with A as the most
         * significant byte, followed by B, then G, then R as the least significant
         * byte. The pixel data starts in the top left corner of the image an proceeds
         * left to right then top to bottom resulting in the image being stored as a
         * sequence of rows ending in the bottom right corner. Returns an ID that can be
         * used to reference this memblock in other commands.
         *
         * @param memID   - The ID of the memblock to create.
         * @param imageID - The ID of the image to read.
         * @return void
         */
        @Signature
        public native void CreateMemblockFromImage(int memID, int imageID);

        /**
         * Creates a line joint between two sprites. The line joint allows the sprites
         * to only move along a given axis relative to each other whilst rotating freely
         * at either end. It is similar to a prismatic joint except that relative
         * rotation is allowed. Specify a single anchor point in world coordinates with
         * the sprites already at the desired relative position, at the piston's minimal
         * extent. From this point the sprites will be allowed to separate along the
         * given axis relative to one another. The anchor point can be offset from the
         * sprite center positions. A joint ID will be returned to reference this joint
         * later, a joint may be deleted by the system if any of the sprites it connects
         * are deleted. This joint supports motors and limits. Box2D has renamed this
         * joint the Wheel Joint and it now contains a spring component to simulate a
         * vehicle wheel. The AGK command name will remain the same for backwards
         * compatibility, however the functionality may have changed
         *
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the anchor point.
         * @param y             - The y coordinate of the anchor point.
         * @param vx            - The x component of the axis.
         * @param vy            - The y component of the axis.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return int
         */
        @Signature
        public native int CreateLineJoint(int iSpriteIndex1, int iSpriteIndex2, float x, float y, float vx, float vy,
                        int colConnected);

        /**
         * Creates a line joint between two sprites. The line joint allows the sprites
         * to only move along a given axis relative to each other whilst rotating freely
         * at either end. It is similar to a prismatic joint except that relative
         * rotation is allowed. Specify a single anchor point in world coordinates with
         * the sprites already at the desired relative position, at the piston's minimal
         * extent. From this point the sprites will be allowed to separate along the
         * given axis relative to one another. The anchor point can be offset from the
         * sprite center positions. A joint ID will be returned to reference this joint
         * later, a joint may be deleted by the system if any of the sprites it connects
         * are deleted. This joint supports motors and limits. Box2D has renamed this
         * joint the Wheel Joint and it now contains a spring component to simulate a
         * vehicle wheel. The AGK command name will remain the same for backwards
         * compatibility, however the functionality may have changed
         *
         * @param iJointIndex   - The ID to use for this joint.
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the anchor point.
         * @param y             - The y coordinate of the anchor point.
         * @param vx            - The x component of the axis.
         * @param vy            - The y component of the axis.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return void
         */
        @Signature
        public native void CreateLineJoint(int iJointIndex, int iSpriteIndex1, int iSpriteIndex2, float x, float y,
                        float vx, float vy, int colConnected);

        /**
         * Creates a section of memory of the given size for read or write access. The
         * contents of the memory is undefined until you write to it. A memblock must
         * not already exist with your chosen memID.
         *
         * @param memID - The ID of the memblock you want to use.
         * @param size  - The size of the memblock in bytes. max 100,000,000.
         * @return void
         */
        @Signature
        public native void CreateMemblock(int memID, int size);

        /**
         * Creates a section of memory of the given size for read or write access. The
         * contents of the memory is undefined until you write to it. A memblock must
         * not already exist with your chosen memID.
         *
         * @param size - The size of the memblock in bytes. max 100,000,000.
         * @return int
         */
        @Signature
        public native int CreateMemblock(int size);

        /**
         * Creates an image from a memblock. The memblock must exist, if the image
         * exists it will be overwritten, if not it will be created. The memblock must
         * contain a valid PNG file such as one loaded with
         * CreateMemblockFromFile(memID, "image.png")
         *
         * @param imageID - The ID of the image to create.
         * @param memID   - The ID of the memblock to read, the memblock is unaffected
         *                by this command.
         * @return void
         */
        @Signature
        public native void CreateImageFromPNGMemblock(int imageID, int memID);

        /**
         * Creates an image from a memblock. The memblock must exist, if the image
         * exists it will be overwritten, if not it will be created. The memblock must
         * contain a valid PNG file such as one loaded with
         * CreateMemblockFromFile(memID, "image.png")
         *
         * @param memID - The ID of the memblock to read, the memblock is unaffected by
         *              this command.
         * @return int
         */
        @Signature
        public native int CreateImageFromPNGMemblock(int memID);

        /**
         * Creates a memblock from a file without any processing of the file data, the
         * memblock will be a byte for byte copy of the file. Returns an ID that can be
         * used to reference this memblock later. You can use relative paths in the file
         * name to read from sub folders or use SetFolder to browse there first. You can
         * use absolute paths by adding a forward slash to the beginning of the
         * filename, in this case the folder set with SetFolder is ignored. For example
         * /media/file.txt will read it from the media folder even if SetFolder was used
         * to browse to /media/somefolder
         *
         * @param filename - The name of the file to read, if it doesn't exist this will
         *                 fail.
         * @return int
         */
        @Signature
        public native int CreateMemblockFromFile(String filename);

        /**
         * Creates a memblock from a file without any processing of the file data, the
         * memblock will be a byte for byte copy of the file. Returns an ID that can be
         * used to reference this memblock later. You can use relative paths in the file
         * name to read from sub folders or use SetFolder to browse there first. You can
         * use absolute paths by adding a forward slash to the beginning of the
         * filename, in this case the folder set with SetFolder is ignored. For example
         * /media/file.txt will read it from the media folder even if SetFolder was used
         * to browse to /media/somefolder
         *
         * @param memID    - The ID of the memblock to create.
         * @param filename - The name of the file to read, if it doesn't exist this will
         *                 fail.
         * @return void
         */
        @Signature
        public native void CreateMemblockFromFile(int memID, String filename);

        /**
         * Creates an image from a memblock. The memblock must exist, if the image
         * exists it will be overwritten, if not it will be created. The first 4 bytes
         * of the memlbock store the image width, the next 4 bytes store the image
         * height, the next 4 bytes store the bit depth, currently this must be 32.
         * After that the raw image data begins in the format RGBA, with each component
         * stored in a single byte, so each pixel takes up 4 bytes. The size of the
         * image data can be calculated by width*height*4 bytes (for now bit depth can
         * be assumed to be 32 bits = 4 bytes). Note that due to little endian format
         * writing the image data with bytes will result in offsets 0=R, 1=G, 2=B, 3=A,
         * but writing them all as a single integer will be interpreted as a value with
         * A as the most significant byte, followed by B, then G, then R as the least
         * significant byte. The pixel data starts in the top left corner of the image
         * an proceeds left to right then top to bottom resulting in the image being
         * stored as a sequence of rows ending in the bottom right corner. This command
         * uses a lot of GPU bandwidth so it is not recommended that this command be
         * called every frame on large images.
         *
         * @param imageID - The ID of the image to create or modify.
         * @param memID   - The ID of the memblock to read, the memblock is unaffected
         *                by this command.
         * @return void
         */
        @Signature
        public native void CreateImageFromMemblock(int imageID, int memID);

        /**
         * Creates an image from a memblock. The memblock must exist, if the image
         * exists it will be overwritten, if not it will be created. The first 4 bytes
         * of the memlbock store the image width, the next 4 bytes store the image
         * height, the next 4 bytes store the bit depth, currently this must be 32.
         * After that the raw image data begins in the format RGBA, with each component
         * stored in a single byte, so each pixel takes up 4 bytes. The size of the
         * image data can be calculated by width*height*4 bytes (for now bit depth can
         * be assumed to be 32 bits = 4 bytes). Note that due to little endian format
         * writing the image data with bytes will result in offsets 0=R, 1=G, 2=B, 3=A,
         * but writing them all as a single integer will be interpreted as a value with
         * A as the most significant byte, followed by B, then G, then R as the least
         * significant byte. The pixel data starts in the top left corner of the image
         * an proceeds left to right then top to bottom resulting in the image being
         * stored as a sequence of rows ending in the bottom right corner. This command
         * uses a lot of GPU bandwidth so it is not recommended that this command be
         * called every frame on large images.
         *
         * @param memID - The ID of the memblock to read, the memblock is unaffected by
         *              this command.
         * @return int
         */
        @Signature
        public native int CreateImageFromMemblock(int memID);

        /**
         * Creates an HTTP connection ready for use later. Returns the ID used to
         * reference it later.
         *
         * @return int
         */
        @Signature
        public native int CreateHTTPConnection();

        /**
         * Creates a gear joint between two existing joints. The gear joint allows
         * appearance of two existing joints to be locked together in perfect friction.
         * The sprites that will be joined will be sprite 2 on both joints, sprite 1 on
         * both joints must be a static sprite. A joint ID will be returned to reference
         * this joint later, a joint may be deleted by the system if any of the sprites
         * it connects are deleted. This joint should be deleted before any of the
         * joints it depends on are deleted.
         *
         * @param iJoint1 - The ID of the first joint to join.
         * @param iJoint2 - The ID of the second joint to join.
         * @param ratio   - The gear ratio to use in moving one joint from the other.
         * @return int
         */
        @Signature
        public native int CreateGearJoint(int iJoint1, int iJoint2, float ratio);

        /**
         * Creates a gear joint between two existing joints. The gear joint allows
         * appearance of two existing joints to be locked together in perfect friction.
         * The sprites that will be joined will be sprite 2 on both joints, sprite 1 on
         * both joints must be a static sprite. A joint ID will be returned to reference
         * this joint later, a joint may be deleted by the system if any of the sprites
         * it connects are deleted. This joint should be deleted before any of the
         * joints it depends on are deleted.
         *
         * @param iJointIndex - The ID for the gear joint.
         * @param iJoint1     - The ID of the first joint to join.
         * @param iJoint2     - The ID of the second joint to join.
         * @param ratio       - The gear ratio to use in moving one joint from the
         *                    other.
         * @return void
         */
        @Signature
        public native void CreateGearJoint(int iJointIndex, int iJoint1, int iJoint2, float ratio);

        /**
         * Creates a 1x1 pixel image of a specified color. This can be used to texture
         * any object or sprite with a solid color.
         *
         * @param imageID - The image ID to use for this image.
         * @param red     - The red component of the image (0 to 255)
         * @param green   - The green component of the image (0 to 255)
         * @param blue    - The blue component of the image (0 to 255)
         * @param alpha   - The alpha component of the image (0 to 255), 0 is completely
         *                transparent
         * @return void
         */
        @Signature
        public native void CreateImageColor(int imageID, int red, int green, int blue, int alpha);

        /**
         * Creates a 1x1 pixel image of a specified color. This can be used to texture
         * any object or sprite with a solid color.
         *
         * @param red   - The red component of the image (0 to 255)
         * @param green - The green component of the image (0 to 255)
         * @param blue  - The blue component of the image (0 to 255)
         * @param alpha - The alpha component of the image (0 to 255), 0 is completely
         *              transparent
         * @return int
         */
        @Signature
        public native int CreateImageColor(int red, int green, int blue, int alpha);

        /**
         * This command is deprecated, you should use ShowFullscreenAdvertAdMob,
         * ShowFullscreenAdvertChartboost, or ShowFullscreenAdvertAmazon instead.
         * Creates a fullscreen (interstitial) advert for revenue generation. Before
         * calling this function you must have set your ad account details with one of
         * the other commands such as SetAdMobDetails, SetChartboostDetails, or or
         * SetAmazonAdDetails Not all platforms support all ad providers so setting as
         * many account details as possible will allow AGK to select a suitable ad for
         * this platform. Both iOS and Android use caching to preload ads before
         * displaying them. If an ad has been loaded when you call this command then it
         * will be displayed immediately, otherwise this command will do nothing.
         * Failure to load an ad may be because the ad provider has run out of ads to
         * show to users in a particular country. You can check if an ad is waiting to
         * be displayed for a particular provider with GetFullscreenAdvertLoadedAdMob,
         * GetFullscreenAdvertLoadedChartboost, or GetFullscreenAdvertLoadedAmazon. Your
         * app will be paused when the advert is displayed, and will resume when the
         * advert is dismissed.
         *
         * @return void
         */
        @Signature
        public native void CreateFullscreenAdvert();

        /**
         * Creates a file from a memblock without any processing of the memblock data,
         * the file will be a byte for byte copy of the memblock data. You can use
         * relative paths in the file name to write to sub folders or use SetFolder to
         * browse there first. You can use absolute paths by adding a forward slash to
         * the beginning of the filename, in this case the folder set with SetFolder is
         * ignored. For example /media/file.txt will place it in the media folder even
         * if SetFolder was used to browse to /media/somefolder
         *
         * @param filename - The name of the file to create, if it already exists it
         *                 will be overwritten.
         * @param memID    - The ID of the memblock to read, the memblock is unaffected
         *                 by this command.
         * @return void
         */
        @Signature
        public native void CreateFileFromMemblock(String filename, int memID);

        /**
         * Create an edit box that can be positioned anywhere on screen. It returns the
         * ID used to reference this edit box later.
         *
         * @return int
         */
        @Signature
        public native int CreateEditBox();

        /**
         * Create an edit box that can be positioned anywhere on screen. It returns the
         * ID used to reference this edit box later.
         *
         * @param index - The ID to use for this edit box.
         * @return void
         */
        @Signature
        public native void CreateEditBox(int index);

        /**
         * Creates a sprite in the given sprite ID, it returns the sprite ID used. Dummy
         * sprites behave as normal sprites but have no image or other visual aspect to
         * them. They will not be drawn even if an image is assigned to them. They are
         * useful for adding physics objects to a scene without needing visuals to
         * accompany the physics shape. You can use the physics contact and feedback
         * commands to work out what has hit these hidden physics shapes if desired. If
         * you do not need to know what has hit your hidden shapes then you can add them
         * all to a single dummy sprite using the AddSpriteShape commands for best
         * performance. SetSpriteShape will not work on dummy sprites as they have no
         * image to calculate a shape, shapes must be defined manually using
         * SetSpriteShapeBox, SetSpriteShapeCircle, or SetSpriteShapePolygon. Dummy
         * sprites will not update their stored angle and position with the latest
         * physics versions, so calls to GetSpriteX, GetSpriteY, or GetSpriteAngle will
         * return the last value you set. Setting the sprite's position will update the
         * physics body to the position you set.
         *
         * @param iSpriteIndex - The ID to use for this sprite.
         * @return void
         */
        @Signature
        public native void CreateDummySprite(int iSpriteIndex);

        /**
         * Creates a sprite in the given sprite ID, it returns the sprite ID used. Dummy
         * sprites behave as normal sprites but have no image or other visual aspect to
         * them. They will not be drawn even if an image is assigned to them. They are
         * useful for adding physics objects to a scene without needing visuals to
         * accompany the physics shape. You can use the physics contact and feedback
         * commands to work out what has hit these hidden physics shapes if desired. If
         * you do not need to know what has hit your hidden shapes then you can add them
         * all to a single dummy sprite using the AddSpriteShape commands for best
         * performance. SetSpriteShape will not work on dummy sprites as they have no
         * image to calculate a shape, shapes must be defined manually using
         * SetSpriteShapeBox, SetSpriteShapeCircle, or SetSpriteShapePolygon. Dummy
         * sprites will not update their stored angle and position with the latest
         * physics versions, so calls to GetSpriteX, GetSpriteY, or GetSpriteAngle will
         * return the last value you set. Setting the sprite's position will update the
         * physics body to the position you set.
         *
         * 
         * @return int
         */
        @Signature
        public native int CreateDummySprite();

        /**
         * Creates a distance joint between two sprites. The distance joint keeps the
         * sprites a certain distance apart whilst being allowed to rotate freely around
         * the anchor points. Specify two anchor points in world coordinates with the
         * sprites already at the desired distance apart. The anchor points can be
         * offset from the sprite positions. A joint may be deleted by the system if any
         * of the sprites it connects are deleted.
         *
         * @param iJointIndex   - The ID to use for this joint.
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the sprite 1 anchor point.
         * @param y             - The y coordinate of the sprite 1 anchor point.
         * @param x2            - The x coordinate of the sprite 2 anchor point.
         * @param y2            - The y coordinate of the sprite 2 anchor point.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return void
         */
        @Signature
        public native void CreateDistanceJoint(int iJointIndex, int iSpriteIndex1, int iSpriteIndex2, float x, float y,
                        float x2, float y2, int colConnected);

        /**
         * Creates a distance joint between two sprites. The distance joint keeps the
         * sprites a certain distance apart whilst being allowed to rotate freely around
         * the anchor points. Specify two anchor points in world coordinates with the
         * sprites already at the desired distance apart. The anchor points can be
         * offset from the sprite positions. A joint may be deleted by the system if any
         * of the sprites it connects are deleted.
         *
         * @param iSpriteIndex1 - The ID of the first sprite to join.
         * @param iSpriteIndex2 - The ID of the second sprite to join.
         * @param x             - The x coordinate of the sprite 1 anchor point.
         * @param y             - The y coordinate of the sprite 1 anchor point.
         * @param x2            - The x coordinate of the sprite 2 anchor point.
         * @param y2            - The y coordinate of the sprite 2 anchor point.
         * @param colConnected  - Set whether the two sprites connected by the joint can
         *                      collide with one another, 0=no, 1=yes.
         * @return int
         */
        @Signature
        public native int CreateDistanceJoint(int iSpriteIndex1, int iSpriteIndex2, float x, float y, float x2,
                        float y2, int colConnected);

        /**
         * Broadcasts are special network communications as they do not use a
         * destination address and are instead received by all devices on a network.
         * Broadcast packets are not forwarded by routers so can only be used on the
         * local area network, or more specifically the local subnet. This can be useful
         * for discovering devices as one device can send a broadcast packet containing
         * its IP address and another device can pick it up, read the IP and connect
         * back to the first device to create a two-way connection. AGK networks are
         * broadcast in this manner on port 45631 and send a packet containing the name
         * of a network that has been hosted by another AGK device. By using a broadcast
         * listener you can pick these messages up, extract the network names and
         * display them to the user for them to choose which network they want to
         * connect to. If the device is on an IPv6 network then these rules change
         * slightly. CreateBroadcastListener must be called with a multicast address,
         * which begins with ff, for example ff02::1 and the broadcast listener will
         * only receive packets sent to this multicast address. If no address is
         * specified then the broadcaster will only receive IPv4 broadcasts. If you pass
         * the address "anyip6" then the broadcast listener will listen on the AGK
         * multicast address "FF02::41:474B" which is used for named network discovery
         * on port 45631. Returns an ID you can use to interact with this broadcast
         * listener.
         *
         * @param szIP - The multicast IP to listen for, only applies to IPv6 networks,
         *             if left empty then it will listen for IPv4 broadcasts.
         * @param port - The port that the messages are being broadcast on, in the case
         *             of AGK networks this will be port 45631.
         * @return int
         */
        @Signature
        public native int CreateBroadcastListener(String szIP, int port);

        /**
         * Broadcasts are special network communications as they do not use a
         * destination address and are instead received by all devices on a network.
         * Broadcast packets are not forwarded by routers so can only be used on the
         * local area network, or more specifically the local subnet. This can be useful
         * for discovering devices as one device can send a broadcast packet containing
         * its IP address and another device can pick it up, read the IP and connect
         * back to the first device to create a two-way connection. AGK networks are
         * broadcast in this manner on port 45631 and send a packet containing the name
         * of a network that has been hosted by another AGK device. By using a broadcast
         * listener you can pick these messages up, extract the network names and
         * display them to the user for them to choose which network they want to
         * connect to. If the device is on an IPv6 network then these rules change
         * slightly. CreateBroadcastListener must be called with a multicast address,
         * which begins with ff, for example ff02::1 and the broadcast listener will
         * only receive packets sent to this multicast address. If no address is
         * specified then the broadcaster will only receive IPv4 broadcasts. If you pass
         * the address "anyip6" then the broadcast listener will listen on the AGK
         * multicast address "FF02::41:474B" which is used for named network discovery
         * on port 45631. Returns an ID you can use to interact with this broadcast
         * listener.
         *
         * @param port - The port that the messages are being broadcast on, in the case
         *             of AGK networks this will be port 45631.
         * @return int
         */
        @Signature
        public native int CreateBroadcastListener(int port);

        /**
         * Creates an advert for revenue generation. Before calling this function you
         * must have set your ad account details with one of the other commands such as
         * SetAdMobDetails. Not all platforms support all ad providers so setting as
         * many account details as possible will allow AGK to select a suitable ad for
         * this platform. This advert will typically be a 320x50 banner displayed
         * somewhere around the edge of your app. Creating an ad when one already exists
         * will replace the existing ad. This is an extended version of the CreateAdvert
         * command that takes optional offset values for positioning the ad. The type
         * parameter can be used to select the size of the banner: 0=Banner(320x50),
         * 1=LargeBanner, 2=MediumRectangle, 3=FullBanner, 4=Leaderboard, 5=SmartBanner,
         * 6=FluidBanner
         *
         * @param type    - The size of the banner to create
         * @param horz    - The horizontal position of the ad, 0=left, 1=center, 2=right
         * @param vert    - The vertical position of the ad, 0=top, 1=center, 2=bottom
         * @param test    - Set to 1 to receive a non-paying test ad, 0 to receive a
         *                real ad.
         * @param offsetx - when horz is equal to 0 or 2 this value offsets the ad from
         *                the specified edge
         * @param offsety - when vert is equal to 0 or 2 this value offsets the ad from
         *                the specified edge
         * @return void
         */
        @Signature
        public native void CreateAdvertEx(int type, int horz, int vert, int test, float offsetx, float offsety);

        /**
         * Creates an advert for revenue generation. Before calling this function you
         * must have set your ad account details with one of the other commands such as
         * SetAdMobDetails. Not all platforms support all ad providers so setting as
         * many account details as possible will allow AGK to select a suitable ad for
         * this platform. This advert will typically be a 320x50 banner displayed
         * somewhere around the edge of your app. Creating an ad when one already exists
         * will replace the existing ad. The type parameter can be used to select the
         * size of the banner, 0=Banner(320x50), 1=LargeBanner, 2=MediumRectangle,
         * 3=FullBanner, 4=Leaderboard, 5=SmartBanner, 6=FluidBanner
         *
         * @param type - The size of the banner to create
         * @param horz - The horizontal position of the ad, 0=left, 1=center, 2=right
         * @param vert - The vertical postion of the ad, 0=top, 1=center, 2=bottom
         * @param test - Set to 1 to receive a non paying test ad, 0 to receive a real
         *             ad.
         * @return void
         */
        @Signature
        public native void CreateAdvert(int type, int horz, int vert, int test);

        /**
         * Creates a static plane. Returns a static Plane ID
         *
         * @param normalX        - x value of the normal vector.
         * @param normalY        - y value of the normal vector.
         * @param normalZ        - z value of the normal vector.
         * @param offsetPosition - How much the plane will be offset from its world
         *                       position.
         * @return int
         */
        @Signature
        public native int Create3DPhysicsStaticPlane(float normalX, float normalY, float normalZ, float offsetPosition);

        /**
         * You must create the the Physics world before calling any other physics
         * commands. Create3DPhysicsWorld Creates the physics world using the default
         * scale factor of 40. This function will create the physics world with a
         * different scale factor. The scale is not the size of the world, it is the
         * factor by which all the data passed in is scaled down by to convert it to the
         * Bullet Physics scale for the physics calculations. Then the data from Bullet
         * is scaled up before it is passed to the AGK 3D world. The default scale
         * factor will be correct if your average character size is 72 AGK units tall.
         * Then the default gravity of -10.0 meters per second on the Y axis will give
         * the correct visual result. The Bullet Physics solver has a minimum size for
         * objects. Objects below this size will cause instability with the solver. At
         * the default scale factor of 40 the smallest dimension that the solver can
         * handle is about 3.5 AGK units. To calculate the scale factor first determine
         * your character's height in meters, a character of 72 units tall would be
         * 1.8288 meters (or 6ft). Then divide the character's height in units by the
         * characters height in meters, for this example the scale factor would be (72 /
         * 1.8) = 40.
         *
         * @param scaleFactor - The default scale factor is 40.
         * @return void
         */
        @Signature
        public native void Create3DPhysicsWorld(float scaleFactor);

        /**
         * You must create the the Physics world before calling any other physics
         * commands. Create3DPhysicsWorld Creates the physics world using the default
         * scale factor of 40. This function will create the physics world with a
         * different scale factor. The scale is not the size of the world, it is the
         * factor by which all the data passed in is scaled down by to convert it to the
         * Bullet Physics scale for the physics calculations. Then the data from Bullet
         * is scaled up before it is passed to the AGK 3D world. The default scale
         * factor will be correct if your average character size is 72 AGK units tall.
         * Then the default gravity of -10.0 meters per second on the Y axis will give
         * the correct visual result. The Bullet Physics solver has a minimum size for
         * objects. Objects below this size will cause instability with the solver. At
         * the default scale factor of 40 the smallest dimension that the solver can
         * handle is about 3.5 AGK units. To calculate the scale factor first determine
         * your character's height in meters, a character of 72 units tall would be
         * 1.8288 meters (or 6ft). Then divide the character's height in units by the
         * characters height in meters, for this example the scale factor would be (72 /
         * 1.8) = 40.
         *
         * @return void
         */
        @Signature
        public native void Create3DPhysicsWorld();

        /**
         * Deletes the existing physics body and creates a Static triangle mesh
         * collision shape and physics body for the object.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void Create3DPhysicsStaticBody(int objID);

        /**
         * Creates a Slider joint between object a and b. The rotationVec3 parameter
         * should be an axis in the form (0,1,0) for vertical, (1,0,0) for horizontal
         * along the X axis, (0,0,1) for horizontal along the Z axis, or any combination
         * of these. The rotation vector does not need to be normalized. Returns a joint
         * ID.
         *
         * @param objA         - first object ID
         * @param objB         - second object ID
         * @param positionVec3 - vector ID
         * @param rotationVec3 - vector ID
         * @return int
         */
        @Signature
        public native int Create3DPhysicsSliderJoint(int objA, int objB, int positionVec3, int rotationVec3);

        /**
         * Returns the ID of the ray created.
         *
         * @return int
         */
        @Signature
        public native int Create3DPhysicsRay();

        /**
         * Starts the creation of a Physics ragdoll for the object. You must add at
         * least one bone to the ragdoll before you call Finalize3DPhysicsRagDoll(). The
         * models bones must have a zero rotation in the default position/first frame of
         * the animation.
         *
         * @param objID          - object ID
         * @param objTotalWeight - Total weight in lbs. This weight gets divided up
         *                       among the ragdoll bones based on volume of the bones.
         * @return void
         */
        @Signature
        public native void Create3DPhysicsRagDoll(int objID, float objTotalWeight);

        /**
         * Returns Joint ID
         *
         * @param objID        - object ID
         * @param positionVec3 - Id of the position Vector
         * @return int
         */
        @Signature
        public native int Create3DPhysicsPickJoint(int objID, int positionVec3);

        /**
         * Deletes the existing physics body and creates a box collision shape and
         * kinematic physics body for the object. A kinematic body can be moved by using
         * the agk commands for position and rotation of objects. Note: A kinematic body
         * can only interact with a dynamic body and will pass through a static body.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void Create3DPhysicsKinematicBody(int objID);

        /**
         * Creates a hinge joint between object a and b. The rotationVec3 parameter
         * should be an axis in the form (0,1,0) for vertical, (1,0,0) for horizontal
         * along the X axis, (0,0,1) for horizontal along the Z axis, or any combination
         * of these. The rotation vector does not need to be normalized. Returns a joint
         * ID.
         *
         * @param objA              - first object ID
         * @param objB              - second object ID
         * @param positionVec3      - vector ID
         * @param rotationVec3      - vector ID
         * @param disableCollisions - 1 = collisions will be disabled between linked
         *                          objects, 0 collisions will be enabled between linked
         *                          objects.
         * @return int
         */
        @Signature
        public native int Create3DPhysicsHingeJoint(int objA, int objB, int positionVec3, int rotationVec3,
                        int disableCollisions);

        /**
         * Creates a Fixed joint between object a and b. Returns a joint ID.
         *
         * @param objA         - first object ID
         * @param objB         - second object ID
         * @param positionVec3 - vector ID
         * @return int
         */
        @Signature
        public native int Create3DPhysicsFixedJoint(int objA, int objB, int positionVec3);

        /**
         * Deletes the existing physics body and creates a dynamic body for the object
         * with a box collision shape and a mass of 5.0 Based on the objects size.
         *
         * @param objID - object ID
         * @return void
         */
        @Signature
        public native void Create3DPhysicsDynamicBody(int objID);

        /**
         * Creates a Cone Twist joint between object a and b. The rotationVec3 parameter
         * should be an axis in the form (0,1,0) for vertical, (1,0,0) for horizontal
         * along the X axis, (0,0,1) for horizontal along the Z axis, or any combination
         * of these. The rotation vector does not need to be normalized. The joint will
         * spin along the given axis and rotate freely within a cone along this axis.
         * The cone limits can be specified with Set3DPhysicsJointConeTwistLimits.
         * Returns a joint ID.
         *
         * @param objA              - first object ID
         * @param objB              - second object ID
         * @param positionVec3      - vector ID
         * @param rotationVec3      - vector ID
         * @param disableCollisions - 1 = collisions will be disabled between linked
         *                          objects, 0 collisions will be enabled between linked
         *                          objects.
         * @return int
         */
        @Signature
        public native int Create3DPhysicsConeTwistJoint(int objA, int objB, int positionVec3, int rotationVec3,
                        int disableCollisions);

        /**
         * Creates a 3D physics Character Controller for the model. Character controller
         * can be created on the X, Y, or Z axis. For example a standing character would
         * be on the Y axis. A lying down character could be on the X or Z. If the model
         * has an offset from origin the objOffsetVec3 is neede to line up the character
         * controller with the object. If the object does not face down the positive Z
         * axis use the objOrientationVec3 to adjust. Crouch scale adjusts the crouch
         * capsule size to fit the height of your crouched model.
         *
         * @param objID              - object ID
         * @param axis               - 0 = X axis, 1= Y axis, 2 = Z axis,
         * @param objOffsetVec3      - This vector is half the amount that the model is
         *                           offset from origin.
         * @param objOrientationVec3 - This vector is used to line up the rotation of
         *                           your model with the character controller.
         * @param crouchScale        - Percentage amount to scale the crouched capsule
         *                           to fit crouched model.
         * @return void
         */
        @Signature
        public native void Create3DPhysicsCharacterController(int objID, int axis, int objOffsetVec3,
                        int objOrientationVec3, float crouchScale);

        /**
         * Creates a 6 degrees of freedom joint between object a and b. Returns a joint
         * ID.
         *
         * @param objA         - first object ID
         * @param objB         - second object ID
         * @param positionVec3 - vector ID
         * @param rotationVec3 - vector ID
         * @return int
         */
        @Signature
        public native int Create3DPhysics6DOFJoint(int objA, int objB, int positionVec3, float rotationVec3);

        /**
         * Returns the number of drives currently available on this devices, only
         * applies to Windows. Other platforms will return 0.
         *
         * @return int
         */
        @Signature
        public native int CountWindowsDrives();

        /**
         * Creates a particle emitter with the given ID and the given location in world
         * coordinates. Particle emitters create a flow of small sprites that last for a
         * fixed amount of time before disappearing. The particles can be influenced by
         * forces during their life using Add3DParticlesForce. They can also change
         * color over time using Add3DParticleColorKeyFrame. Particles cannot be
         * modified individually and behave as a group using the same texture. This
         * allows AGK to draw them more efficiently than a similar number of normal
         * objects.
         *
         * @param x - The x coordinate to position this emitter.
         * @param y - The y coordinate to position this emitter.
         * @param z - The z coordinate to position this emitter.
         * @return int
         */
        @Signature
        public native int Create3DParticles(float x, float y, float z);

        /**
         * Creates a particle emitter with the given ID and the given location in world
         * coordinates. Particle emitters create a flow of small sprites that last for a
         * fixed amount of time before disappearing. The particles can be influenced by
         * forces during their life using Add3DParticlesForce. They can also change
         * color over time using Add3DParticleColorKeyFrame. Particles cannot be
         * modified individually and behave as a group using the same texture. This
         * allows AGK to draw them more efficiently than a similar number of normal
         * objects.
         *
         * @param ID - The ID to use when referencing this 3D particle emitter.
         * @param x  - The x coordinate to position this emitter.
         * @param y  - The y coordinate to position this emitter.
         * @param z  - The z coordinate to position this emitter.
         * @return void
         */
        @Signature
        public native void Create3DParticles(int ID, float x, float y, float z);

        /**
         * Counts the number of tokens separated by a specified delimiter, for example a
         * string containing "first:second:third" has three tokens delimited by ":".
         * Similar to CountStringTokens except that this command accepts only a single
         * character as the delimiter and recognises empty fields. For example
         * "first:second::fourth" has four tokens with the third being an empty string.
         *
         * @param str       - The string to check.
         * @param delimiter - The character that delimits the string
         * @return int
         */
        @Signature
        public native int CountStringTokens2(String str, String delimiter);

        /**
         * Counts the number of tokens separated by a specified set of delimiters, for
         * example a string containing "first:second:third" has three tokens delimited
         * by ":" and "first:second;third" has three tokens separated by the delimiters
         * ":;". You can have multiple delimiters between each token, for example
         * "first:;second:third" is valid, and has three tokens. This command is useful
         * for separating words in a sentence, which can be delimited by both white
         * space and punctuation.
         *
         * @param str        - The string to check.
         * @param delimiters - The set of characters that delimit the string
         * @return int
         */
        @Signature
        public native int CountStringTokens(String str, String delimiters);

        /**
         * Returns the cosine of a value in radians.
         *
         * @param a - The value to pass into the cosine function.
         * @return float
         */
        @Signature
        public native float CosRad(float a);

        /**
         * Creates a network message that is a copy of an existing message. It returns
         * an ID that can be used to interact with the message. Messages created in this
         * way can read from the beginning or added to, and the source messsage can be
         * either a message you have created, or one you have received. The new message
         * becomes completely independent of the source message and can be sent using
         * SendNetworkMessage without affecting the original.
         *
         * @param iFromMsgID - The ID of the message to copy
         * @return int
         */
        @Signature
        public native int CopyNetworkMessage(int iFromMsgID);

        /**
         * Returns the cosine of a value in degrees.
         *
         * @param a - The value to pass into the cosine function.
         * @return float
         */
        @Signature
        public native float Cos(float a);

        /**
         * Copies a portion of the given image into a new image. The x, y, width, height
         * values are in pixels and represent the portion of the image you would like to
         * copy into a new image. The new image with have the same size as the width and
         * height values given. If an image already exists with the new ID given it must
         * be deleted before calling this command. This is a slow command and should not
         * be called every frame.
         *
         * @param newImage  - The ID of the new image to create, this image must not
         *                  exist
         * @param fromImage - The ID of the image to copy
         * @param x         - The x coordinate of the top left corner of the box to copy
         * @param y         - The y coordinate of the top left corner of the box to copy
         * @param width     - The width of the box to copy
         * @param height    - The height of the box to copy
         * @return void
         */
        @Signature
        public native void CopyImage(int newImage, int fromImage, int x, int y, int width, int height);

        /**
         * Copies a portion of the given image into a new image. The x, y, width, height
         * values are in pixels and represent the portion of the image you would like to
         * copy into a new image. The new image with have the same size as the width and
         * height values given. If an image already exists with the new ID given it must
         * be deleted before calling this command. This is a slow command and should not
         * be called every frame.
         *
         * @param fromImage - The ID of the image to copy
         * @param x         - The x coordinate of the top left corner of the box to copy
         * @param y         - The y coordinate of the top left corner of the box to copy
         * @param width     - The width of the box to copy
         * @param height    - The height of the box to copy
         * @return int
         */
        @Signature
        public native int CopyImage(int fromImage, int x, int y, int width, int height);

        /**
         * Copies a portion of one memblock to another. Both memblocks must exist and
         * can be of different sizes.
         *
         * @param memSrcID  - The ID of the memblock to copy from.
         * @param memDstID  - The ID of the memblock to copy to.
         * @param srcOffset - The offset in the source memblock to start copying from.
         * @param dstOffset - The offset of the destination memblock to copy to.
         * @param size      - The number of bytes to copy.
         * @return void
         */
        @Signature
        public native void CopyMemblock(int memSrcID, int memDstID, int srcOffset, int dstOffset, int size);

        /**
         * Creates a socket and attempts to connect to the specified IP address. This
         * will create a TCP connection that you can then use to send and receive data.
         * This command will return immediately and connect in the background, you
         * should use GetSocketConnected to check if the socket connects successfully or
         * fails. You should give a timeout value that is long enough for the socket to
         * connect, typically 3000 milliseconds is a good value, but high latency
         * connections might need longer. If the connection times out then this command
         * will return 0. The port number must match the listening port of the device
         * you are connecting to. This works slightly differently when exported to
         * HTML5, it uses a WebSocket which sends an HTTP style header and requires an
         * HTTP style response to connect.
         *
         * @param socketID - An ID to use to reference this socket later
         * @param szIP     - The IP address to connect to, this can be IPv4 or IPv6
         * @param port     - The TCP port to connect to, in the range 1025 to 65535
         * @param timeout  - The time in milliseconds to wait before aborting the
         *                 connection attempt
         * @return int
         */
        @Signature
        public native int ConnectSocket(int socketID, String szIP, int port, int timeout);

        /**
         * Creates a socket and attempts to connect to the specified IP address. This
         * will create a TCP connection that you can then use to send and receive data.
         * This command will return immediately and connect in the background, you
         * should use GetSocketConnected to check if the socket connects successfully or
         * fails. You should give a timeout value that is long enough for the socket to
         * connect, typically 3000 milliseconds is a good value, but high latency
         * connections might need longer. If the connection times out then this command
         * will return 0. The port number must match the listening port of the device
         * you are connecting to. This works slightly differently when exported to
         * HTML5, it uses a WebSocket which sends an HTTP style header and requires an
         * HTTP style response to connect.
         *
         * @param szIP    - The IP address to connect to, this can be IPv4 or IPv6
         * @param port    - The TCP port to connect to, in the range 1025 to 65535
         * @param timeout - The time in milliseconds to wait before aborting the
         *                connection attempt
         * @return int
         */
        @Signature
        public native int ConnectSocket(String szIP, int port, int timeout);

        /**
         * Waits for the detection of physical joysticks to complete, on some systems
         * this may take a few seconds so is run in a separate thread along side the
         * main application. If you do not use any of the real joystick commands
         * (include the AGK joystick) you may ignore this command and let the joystick
         * detection complete whenever it likes. However if you do wish to use joystick
         * commands in your app you must call this command to make sure that the total
         * number of joysticks connected have been found. After this initial detection
         * process plugging in additional joysticks will not be detected.
         *
         * @return void
         */
        @Signature
        public native void CompleteRawJoystickDetection();

        /**
         * Returns 1 if the two strings are equal to each other, otherwise returns 0. By
         * default this is case insensitive, use the ignoreCase parameter to set case
         * sensitivity. Use the maxChars parameter to specify the maximum number of
         * characters to check, if the strings match after that many characters have
         * been checked then they are considered equal. Use a value of -1 to check all
         * characters regardless of length.
         *
         * @param str  - The first string to check
         * @param str2 - The second string to check
         * @return int
         */
        @Signature
        public native int CompareString(String str, String str2);

        /**
         * Returns 1 if the two strings are equal to each other, otherwise returns 0. By
         * default this is case insensitive, use the ignoreCase parameter to set case
         * sensitivity. Use the maxChars parameter to specify the maximum number of
         * characters to check, if the strings match after that many characters have
         * been checked then they are considered equal. Use a value of -1 to check all
         * characters regardless of length.
         *
         * @param str        - The first string to check
         * @param str2       - The second string to check
         * @param ignoreCase - 1 to ignore case when comparing, 0 to match case
         * @param maxChars   - The number of characters to check, minus 1 for all
         * @return int
         */
        @Signature
        public native int CompareString(String str, String str2, int ignoreCase, int maxChars);

        /**
         * Closes a zip file opened with CreateZip. This finalizes the zip and allows it
         * to be opened for extraction.
         *
         * @param zipID - The ID of the zip file to close.
         * @return void
         */
        @Signature
        public native void CloseZip(int zipID);

        /**
         * Closes a previously open folder and frees the file list that was generated
         * for it. No actual file system changes are made, i.e. the folder is not held
         * open on the file system. The folder is read in its entirety during
         * OpenRawFolder so it does not need to exist on the file system after calling
         * that command.
         *
         * @param ID - The ID of the folder to close
         * @return void
         */
        @Signature
        public native void CloseRawFolder(int ID);

        /**
         * Disconnects from the specified network. The ID is freed and can no longer be
         * used in other network commands.
         *
         * @param iNetID - The ID of the network to disconnect from.
         * @return void
         */
        @Signature
        public native void CloseNetwork(int iNetID);

        /**
         * Closes the connection to the server, further connections can be created if
         * you call SetHTTPHost again.
         *
         * @param iHTTP - The ID of the connection to close.
         * @return void
         */
        @Signature
        public native void CloseHTTPConnection(int iHTTP);

        /**
         * Closes a file and clears the ID used to create it, no further file commands
         * can be called with this ID.
         *
         * @param iFileID - The ID of the file to close
         * @return void
         */
        @Signature
        public native void CloseFile(int iFileID);

        /**
         * Clones a sprite into a given sprite ID. The new sprite will be in in exactly
         * the same position as the original. Any physics values or shapes assigned to
         * the sprite will not be copied. The new sprite will not be setup for physics.
         *
         * @param iSpriteIndex - The ID to use for the new sprite.
         * @param iOtherSprite - The ID of the sprite to copy.
         * @return void
         */
        @Signature
        public native void CloneSprite(int iSpriteIndex, int iOtherSprite);

        /**
         * Clones a sprite into a given sprite ID. The new sprite will be in in exactly
         * the same position as the original. Any physics values or shapes assigned to
         * the sprite will not be copied. The new sprite will not be setup for physics.
         *
         * @param iOtherSprite - The ID of the sprite to copy.
         * @return int
         */
        @Signature
        public native int CloneSprite(int iOtherSprite);

        /**
         * Copies an object into a new ID, the new object is completely separate from
         * the original object. Cloning an instanced object will produce another
         * instance that shares vertex data with the original object.
         *
         * @param newobjID - The ID of the new object.
         * @param objID    - The ID of the object to copy.
         * @return void
         */
        @Signature
        public native void CloneObject(int newobjID, int objID);

        /**
         * Copies an object into a new ID, the new object is completely separate from
         * the original object. Cloning an instanced object will produce another
         * instance that shares vertex data with the original object.
         *
         * @param objID - The ID of the object to copy.
         * @return int
         */
        @Signature
        public native int CloneObject(int objID);

        /**
         * Clears the currently stored URL scheme text so you can signal that you have
         * acted upon it. This is not necessary but can make your code easier by not
         * having to remember that you have dealt with a URL scheme event.
         *
         * @return void
         */
        @Signature
        public native void ClearURLSchemeText();

        /**
         * Empties a chain of all tweens and stops any that were running. Any tweens
         * that were added to it are unaffected and can be used in future chains.
         *
         * @param chainID - ID of the tween chain to clear
         * @return void
         */
        @Signature
        public native void ClearTweenChain(int chainID);

        /**
         * Removes all additional shapes applied to the sprite and keeps only the base
         * shape at shapeID 1.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @return void
         */
        @Signature
        public native void ClearSpriteShapes(int iSpriteIndex);

        /**
         * Removes all animation frames from a sprite returning it to a single image
         * sprite. If you added images individually to the sprite using
         * AddSpriteAnimationFrame then the sprite's image will be undefined and it is
         * recommended that you assign it a new image.
         *
         * @param iSpriteIndex - The ID of the sprite to clear.
         * @return void
         */
        @Signature
        public native void ClearSpriteAnimationFrames(int iSpriteIndex);

        /**
         * Clears the back buffer and depth buffer of all drawing and fills it with the
         * chosen clear color set by SetClearColor. This does not effect what is seen on
         * screen unless Swap is called to display the back buffer to screen. This
         * allows you to draw some things to the backbuffer, use GetImage to store the
         * result and then ClearScreen to draw something else.
         *
         * @return void
         */
        @Signature
        public native void ClearScreen();

        /**
         * Deletes all point lights.
         *
         * @return void
         */
        @Signature
        public native void ClearPointLights();

        /**
         * Clears all size modifiers that have been assigned to the emitter, the
         * particles will maintain whatever size they currently are.
         *
         * @param ID - The ID of the emitter to modify.
         * @return void
         */
        @Signature
        public native void ClearParticlesScales(int ID);

        /**
         * Clears all forces assigned to this emitter. All forces will immediately stop
         * influencing particles.
         *
         * @param ID - The ID of the emitter to modify.
         * @return void
         */
        @Signature
        public native void ClearParticlesForces(int ID);

        /**
         * Clears all colors that have been assigned to the emitter, the particles will
         * maintain whatever color they currently have.
         *
         * @param ID - The ID of the emitter to modify.
         * @return void
         */
        @Signature
        public native void ClearParticlesColors(int ID);

        /**
         * Clears all size modifiers that have been assigned to the emitter, the
         * particles will maintain whatever size they currently are.
         *
         * @param ID - The ID of the emitter to modify.
         * @return void
         */
        @Signature
        public native void Clear3DParticlesScales(int ID);

        /**
         * Clears the depth buffer of all objects. This will clear the buffer even if
         * depth clearing has been turned off with EnableClearDepth.
         *
         * @return void
         */
        @Signature
        public native void ClearDepthBuffer();

        /**
         * Clears all colors that have been assigned to the emitter, the particles will
         * maintain whatever color they currently have.
         *
         * @param ID - The ID of the emitter to modify.
         * @return void
         */
        @Signature
        public native void Clear3DParticlesColors(int ID);

        /**
         * Clears all forces assigned to this emitter. All forces will immediately stop
         * influencing particles.
         *
         * @param ID - The ID of the emitter to modify.
         * @return void
         */
        @Signature
        public native void Clear3DParticlesForces(int ID);

        /**
         * Returns the string of the Unicode value passed in.
         *
         * @param unicodevalue - The string to measure the length of
         * @return String
         */
        @Signature
        public native String Chr(int unicodevalue);

        /**
         * Presents the user with an option to choose a file stored on their current
         * platform (Windows/Mac only), for example a photo or sound file. If the user
         * cancels the operation an empty string will be returned, otherwise the file
         * will be copied to the apps current directory and the filename returned so
         * that it can be used by your app. You may specify an optional extension filter
         * to limit the types of files the user will see when browsing. For example
         * using an extension filter of "*.wav" would limit the user to choosing .wav
         * files. For multiple extensions separate them with a semicolon like so
         * "*.wav;*.mp3;*.png". If using this command is used in tier 2 the returned
         * string must be deleted when you are finished with it, even if it is an empty
         * string. A null string will not be returned. If you set returnFullPath to 1
         * then the file will not be copied to the write folder, instead the full path
         * will be returned to you and you can load it using the "raw:" prefix with the
         * normal file commands.
         *
         * @param ext - The extensions to allow
         * @return String
         */
        @Signature
        public native String ChooseRawFile(String ext);

        /**
         * Presents the user with an option to choose a file stored on their current
         * platform (Windows/Mac only), for example a photo or sound file. If the user
         * cancels the operation an empty string will be returned, otherwise the file
         * will be copied to the apps current directory and the filename returned so
         * that it can be used by your app. You may specify an optional extension filter
         * to limit the types of files the user will see when browsing. For example
         * using an extension filter of "*.wav" would limit the user to choosing .wav
         * files. For multiple extensions separate them with a semicolon like so
         * "*.wav;*.mp3;*.png". If using this command is used in tier 2 the returned
         * string must be deleted when you are finished with it, even if it is an empty
         * string. A null string will not be returned. If you set returnFullPath to 1
         * then the file will not be copied to the write folder, instead the full path
         * will be returned to you and you can load it using the "raw:" prefix with the
         * normal file commands.
         *
         * @param ext            - The extensions to allow
         * @param returnFullPath - 1 to return the full path, 0 to copy it to the write
         *                       folder and return the write folder path
         * @return String
         */
        @Signature
        public native String ChooseRawFile(String ext, int returnFullPath);

        /**
         * Only for Android, all other platforms will return 1 and do nothing. Checks if
         * the user has granted your app the specified permission to use certain Android
         * commands. The permissions are as follows "WriteExternal" - used by the
         * SaveSharedVariable commands and any "raw:" paths that access the sdcard.
         * "Location" - used by the GPS commands "Camera" - used by the
         * SetDeviceCameraToImage command "RecordAudio" - used by the
         * StartScreenRecording command and for the AR camera feed This command will
         * return 0 if you don't have permission and the user hasn't been asked yet, you
         * should call RequestPermission if you need it. This command returns 1 if the
         * user is in the process of being asked for permission, you should wait for a
         * reply by continuing to call this command. It will return -1 if the user
         * rejected permission, or 2 if the user granted permission. If the user rejects
         * your request then you can ask again but you should explain why your app needs
         * it first so they can make an informed choice. If they still reject it you
         * should not normally ask a third time. After the first attempt Android will
         * give the user the option to never allow the permission. In this case this
         * command will always return -1 and RequestPermission will do nothing. The user
         * will have to go into the device app settings to reverse this decision. Any
         * permission not listed here does not require you to prompt the user for
         * permission, it will be auto granted on install if your app requires it. All
         * permissions that your app uses, even those that require prompting, must be
         * specified in the APK export dialog by ticking the appropriate check boxes.
         *
         * @param szPermission - The permission to check
         * @return int
         */
        @Signature
        public native int CheckPermission(String szPermission);

        /**
         * Stops any asynchronous zip extraction that is currently in progress, it may
         * take a moment to finish the current file and then it will stop. Once it
         * finishes GetZipExtractComplete will return 1 and GetZipExtractProgress will
         * remain at whatever value it was currently at.
         *
         * @return void
         */
        @Signature
        public native void CancelZipExtract();

        /**
         * Rounds a float to the next highest integer. This differs from Trunc when
         * using positive numbers, Trunc( 1.6 ) is 1 but Ceil( 1.6 ) is 2.
         *
         * @param a - The value to round up.
         * @return int
         */
        @Signature
        public native int Ceil(float a);

        /**
         * Cancels a notification that was scheduled by this application
         *
         * @param iID - The ID of the notification to cancel
         * @return void
         */
        @Signature
        public native void CancelLocalNotification(int iID);

        /**
         * Caches a fullscreen reward video advert for display later using Chartboost.
         * Before calling this function you must have set your ad account details with
         * SetChartboostDetails. Both iOS and Android use caching to preload ads before
         * displaying them. If an ad has already been cached then this will do nothing.
         * Unlike AdMob, reward videos will not automatically start caching with
         * Chartboost unless you call this command. This is because Chartboost uses the
         * same details for both interstitials and reward videos so AGK can't know in
         * advance which you are using. Since video ads can use a lot of mobile data
         * their caching process will not be started automatically. You only need to
         * call this once, after a reward video ad has been displayed a new one will be
         * cached automatically. Failure to load an ad may be because the ad provider
         * has run out of ads to show to users in a particular country. You can check if
         * an ad is waiting to be displayed with GetRewardAdLoadedChartboost.
         *
         * @return void
         */
        @Signature
        public native void CacheRewardAdChartboost();

        /**
         * Recalculates the COM based on the shapes attached to the sprite, if you have
         * overridden the COM this will set it back to a location decided by the AGK. If
         * the COM is very different from the offset point the sprite may seem unstable
         * as it will behave like an unbalanced spinning top.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @return void
         */
        @Signature
        public native void CalculateSpritePhysicsCOM(int iSpriteIndex);

        /**
         * Returns the number of bytes in the given string. Note that for strings
         * encoded in UTF-8 this may not be equal to the number of characters in the
         * string, as each character can use up to 4 bytes. To determine the number of
         * characters in a string use the Len command.
         *
         * @param strin - The string to measure the length of
         * @return int
         */
        @Signature
        public native int ByteLen(String strin);

        /**
         * Converts an integer value into a string containing its binary representation.
         * For example Bin(7) would return a string containing "111". If you are calling
         * this command from tier 2 this string must be deleted when you are done with
         * it.
         *
         * @param i - Inegert value to convert into a binary string
         * @return String
         */
        @Signature
        public native String Bin(int i);

        /**
         * Converts a single character string to the Unicode value it represents.
         *
         * @param strin - The string character to convert to the Unicode value
         * @return int
         */
        @Signature
        public native int Asc(String strin);

        /**
         * Adds a local file into the zip file. The path variable is the path to the
         * local file, the zipPath variable is the path that will be used inside the zip
         * file, this is the only way to add folders to the zip file (by adding a file
         * with a zipPath such as "folder1/myfile.txt"). The local file path is relative
         * to the current directory set using SetFolder unless you start the path with a
         * forward slash, in which case the path will be relative to the root of the
         * write directory on the current platform.
         *
         * @param zipID   - The ID of the zip file to add to.
         * @param path    - The path of the file to add.
         * @param zipPath - The path for the file inside the zip.
         * @return void
         */
        @Signature
        public native void AddZipEntry(int zipID, String path, String zipPath);

        /**
         * Creates an on-screen button that can be controlled by a touch screen, mouse,
         * or other pointer device. These are separate to physical joystick buttons or
         * keyboard keys so you could have a virtual button with ID 1 and a real
         * joystick button with ID 1. You may have up to 100 virtual buttons on screen
         * at the same time. If a virtual button is on screen and is clicked or touched
         * the button will capture that event and GetRawMouseLeftState will return 0
         * (up), and a touch event will not be generated for that action.
         *
         * @param index - The ID of the virtual button to create, must be in the range 1
         *              to 100.
         * @param x     - The x position of the center of the button in screen
         *              coordinates.
         * @param y     - The y position of the center of the button in screen
         *              coordinates.
         * @param size  - The diameter of the button in screen coordinates.
         * @return void
         */
        @Signature
        public native void AddVirtualButton(int index, float x, float y, float size);

        /**
         * Creates an on-screen joystick that can be controlled by a touch screen,
         * mouse, or other pointer device. These are separate to physical joysticks so
         * you could have a virtual joystick with ID 1 and a real joystick with ID 1.
         * You may have up to 4 virtual joysticks on screen at the same time. If a
         * virtual joystick is on screen and is clicked or touched the joystick will
         * capture that event and GetRawMouseLeftState will return 0 (up), and a touch
         * event will not be generated for that action.
         *
         * @param index - The ID of the virtual joystick to create, must be in the range
         *              1 to 4.
         * @param x     - The x position of the center of the joystick in screen
         *              coordinates.
         * @param y     - The y position of the center of the joystick in screen
         *              coordinates.
         * @param size  - The diameter of the joystick in screen coordinates.
         * @return void
         */
        @Signature
        public native void AddVirtualJoystick(int index, float x, float y, float size);

        /**
         * Applies the given tween ID to a given text object ID with an optional delay
         * and adds it to the end of the chain. A tween can be added to multiple text
         * objects at the same time, simply call this command again with a different
         * text object ID. The text object will not be modified until all preceding
         * tweens in this chain have finished and the delay time has passed, at which
         * point the tween will start at the begin values and move towards the end
         * values over the tween duration. If a tween end value is modified whilst the
         * tween is playing on a text object the text will adjust its interpolation
         * accordingly. Modifying the duration whilst playing is undefined and not
         * compatible with chains.
         *
         * @param chainID - ID of the chain to add to
         * @param tweenID - ID of the tween to add
         * @param textID  - ID of the text to modify
         * @param delay   - Number of seconds to wait before playing this tween when it
         *                is triggered
         * @return void
         */
        @Signature
        public native void AddTweenChainText(int chainID, int tweenID, int textID, float delay);

        /**
         * Applies the given tween ID to a given sprite ID with an optional delay and
         * adds it to the end of the chain. A tween can be added to multiple sprites at
         * the same time, simply call this command again with a different sprite ID. The
         * sprite will not be modified until all preceding tweens in this chain have
         * finished and the delay time has passed, at which point the tween will start
         * at the begin values and move towards the end values over the tween duration.
         * If a tween end value is modified whilst the tween is playing on a sprite the
         * sprite will adjust its interpolation accordingly. Modifying the duration
         * whilst playing is undefined and not compatible with chains.
         *
         * @param chainID  - ID of the chain to add to
         * @param tweenID  - ID of the tween to add
         * @param spriteID - ID of the sprite to modify
         * @param delay    - Number of seconds to wait before playing this tween when it
         *                 is triggered
         * @return void
         */
        @Signature
        public native void AddTweenChainSprite(int chainID, int tweenID, int spriteID, float delay);

        /**
         * Applies the given tween ID to a given object ID with an optional delay and
         * adds it to the end of the chain. A tween can be added to multiple objects at
         * the same time, simply call this command again with a different object ID. The
         * object will not be modified until all preceding tweens in this chain have
         * finished and the delay time has passed, at which point the tween will start
         * at the begin values and move towards the end values over the tween duration.
         * If a tween end value is modified whilst the tween is playing on an object the
         * object will adjust its interpolation accordingly. Modifying the duration
         * whilst playing is undefined and not compatible with chains.
         *
         * @param chainID  - ID of the chain to add to
         * @param tweenID  - ID of the tween to add
         * @param objectID - ID of the object to modify
         * @param delay    - Number of seconds to wait before playing this tween when it
         *                 is triggered
         * @return void
         */
        @Signature
        public native void AddTweenChainObject(int chainID, int tweenID, int objectID, float delay);

        /**
         * Adds the given custom tween ID to the end of the chain with an optional
         * delay. The tween will not start until all preceding tweens in this chain have
         * finished and the delay time has passed, at which point the tween will start
         * at the begin values and move towards the end values over the tween duration.
         * If a tween end value is modified whilst the tween is playing it will adjust
         * its interpolation accordingly. Modifying the duration whilst playing is
         * undefined and not compatible with chains.
         *
         * @param chainID - ID of the chain to add to
         * @param tweenID - ID of the tween to add
         * @param delay   - Number of seconds to wait before playing this tween when it
         *                is triggered
         * @return void
         */
        @Signature
        public native void AddTweenChainCustom(int chainID, int tweenID, float delay);

        /**
         * Applies the given tween ID to a given character in a text object with an
         * optional delay and adds it to the end of the chain. A tween can be added to
         * multiple characters at the same time, simply call this command again with a
         * different character or text ID. The character will not be modified until all
         * preceding tweens in this chain have finished and the delay time has passed,
         * at which point the tween will start at the begin values and move towards the
         * end values over the tween duration. If a tween end value is modified whilst
         * the tween is playing on a character the character will adjust its
         * interpolation accordingly. Modifying the duration whilst playing is undefined
         * and not compatible with chains.
         *
         * @param chainID - ID of the chain to add to
         * @param tweenID - ID of the tween to add
         * @param textID  - ID of the text object containing the character
         * @param charID  - Index of the character to modify, indices start at 0
         * @param delay   - Number of seconds to wait before playing this tween when it
         *                is triggered
         * @return void
         */
        @Signature
        public native void AddTweenChainChar(int chainID, int tweenID, int textID, int charID, float delay);

        /**
         * Applies the given tween ID to a given camera ID with an optional delay and
         * adds it to the end of the chain. A tween can be added to multiple cameras at
         * the same time, simply call this command again with a different camera ID. The
         * camera will not be modified until all preceding tweens in this chain have
         * finished and the delay time has passed, at which point the tween will start
         * at the begin values and move towards the end values over the tween duration.
         * If a tween end value is modified whilst the tween is playing on a camera the
         * camera will adjust its interpolation accordingly. Modifying the duration
         * whilst playing is undefined and not compatible with chains.
         *
         * @param chainID  - ID of the chain to add to
         * @param tweenID  - ID of the tween to add
         * @param cameraID - ID of the camera to modify
         * @param delay    - Number of seconds to wait before playing this tween when it
         *                 is triggered
         * @return void
         */
        @Signature
        public native void AddTweenChainCamera(int chainID, int tweenID, int cameraID, float delay);

        /**
         * Adds a new shape to the sprite, in addition to any it already has. These
         * additional shapes only apply to physics sprites and must be added after a
         * sprite has been set to use physics. The polygon is defined by a set of points
         * (between 2 and 12) relative to the current sprite's offset. For example, a
         * point of 0,0 would be centered on the sprite's offset point, any other value
         * will be offset from this point. Points are defined one at a time by calling
         * this command multiple times, with index starting at 0. Once the index equals
         * numPoints-1 then the shape will be created using the previously defined
         * points. Once you start defining points you must complete the process by
         * reaching index=numPoints-1 before defining points for any other shape. This
         * will recalculate the sprite's mass and center of mass values.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param numPoints    - The number of points to use in the polygon, min 2, max
         *                     12.
         * @param index        - Index for points, so you can specify index 0, 1, 2 etc.
         * @param x            - X position for the specified point.
         * @param y            - Y position for the specified point.
         * @return void
         */
        @Signature
        public native void AddSpriteShapePolygon(int iSpriteIndex, int numPoints, int index, float x, float y);

        /**
         * Adds a new shape to the sprite, in addition to any it already has. These
         * additional shapes only apply to physics sprites and must be added after a
         * sprite has been set to use physics. The circle is defined by specifying its
         * center point relative to the sprite's current offset and a radius. For
         * example, if the circle was to be centered on the sprite's offset point it
         * would be specified at position 0,0. Any other value will offset the circle
         * from the sprite. The radius is defined in x coordinates, due to world
         * coordinates not necessarily representing the size of items on screen (e.g. 10
         * units in X may not be the same apparent size as 10 units in Y). This will
         * recalculate the sprite's mass and center of mass values.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The X coordinate of the center of the circle in sprite
         *                     space.
         * @param y            - The Y coordinate of the center of the circle in sprite
         *                     space.
         * @param radius       - The radius of the circle.
         * @return void
         */
        @Signature
        public native void AddSpriteShapeCircle(int iSpriteIndex, float x, float y, float radius);

        /**
         * Adds a new shape to the sprite, in addition to any it already has. Shapes can
         * be added even if the sprite is not setup for physics. The chain is defined by
         * a set of points (at least 2) relative to the current sprite's offset. For
         * example, a point of 0,0 would be centered on the sprite's offset point, any
         * other value will be offset from this point. Chains are rigid and can be used
         * to create hollow concave polygons, or 2D terrains. Set the loop parameter to
         * 1 to join to two ends of the chain together creating a hollow polygon. Points
         * are defined one at a time by calling this command multiple times, with index
         * starting at 0. Once the index equals numPoints-1 then the shape will be
         * created using the previously defined points. Once you start defining points
         * you must complete the process by reaching index=numPoints-1 before defining
         * points for any other shape. This will recalculate the sprite's mass and
         * center of mass values.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param numPoints    - The number of points to use in the chain, minimum of 2,
         *                     no maximum.
         * @param index        - The index of the point to set, if it equals numPoints-1
         *                     then the shape will be created
         * @param loop         - 1=connect this back to the first point creating a loop,
         *                     0=leave this point hanging on the end (default)
         * @param x            - X position for the specified point.
         * @param y            - Y position for the specified point.
         * @return void
         */
        @Signature
        public native void AddSpriteShapeChain(int iSpriteIndex, int numPoints, int index, int loop, float x, float y);

        /**
         * Adds a new shape to the sprite, in addition to any it already has. These
         * additional shapes only apply to physics sprites and must be added after a
         * sprite has been set to use physics. The box is defined by specifying its top
         * left and bottom right coordinates in sprite space, relative to its current
         * offset. For example if the current sprite offset was 0,0 the top left box
         * corner would be 0,0, but if the sprite offset was the middle of the sprite
         * (default) the top left corner would be -width/2,-height/2. You may also
         * specify an angle to offset the box relative to the current sprite rotation.
         * This will recalculate the sprite's mass and center of mass values.
         *
         * @param iSpriteIndex - The ID of the sprite to modify.
         * @param x            - The X coordinate of the top left corner of the new box
         *                     in sprite space.
         * @param y            - The Y coordinate of the top left corner of the new box
         *                     in sprite space.
         * @param x2           - The X coordinate of the bottom right corner of the new
         *                     box in sprite space.
         * @param y2           - The Y coordinate of the bottom right corner of the new
         *                     box in sprite space.
         * @param angle        - The angle of the box in radians.
         * @return void
         */
        @Signature
        public native void AddSpriteShapeBox(int iSpriteIndex, float x, float y, float x2, float y2, float angle);

        /**
         * Adds an image to the sprite as a new animation frame. Frame indices start at
         * 1 and increase incrementally. This image may be shared by multiple sprites
         * either as single images or as animation frames, the image may also be a part
         * of an atlas texture. Alternatively if you have all your animation frames on a
         * single image you can use the faster SetSpriteAnimation that avoids image
         * changes during rendering by modifying the UV coordinates to change frame
         * instead.
         *
         * @param iSpriteIndex - The ID of the sprite to set for animation.
         * @param iImageIndex  - The ID of the image to add.
         * @return void
         */
        @Signature
        public native void AddSpriteAnimationFrame(int iSpriteIndex, int iImageIndex);

        /**
         * Adds a force that will act at a given time in every particle's life. For
         * example a force set to start at time 2 and end at time 3 will start
         * influencing particles when they have been alive for 2 seconds. It will
         * continue to act on those particles until they have been alive for 3 seconds.
         * The force's influence is defined by an x and y value that represent
         * acceleration in units per second. For example a force with x=5 will adjust a
         * particle's horizontal speed by adding 5 units for every second the force is
         * active, if the force is only active for 0.5 seconds the particle would then
         * be moving 2.5 units per second faster towards the right. Multiple forces can
         * be acting on a particle at the same time if their timings overlap.
         *
         * @param ID        - The ID of the emitter to modify.
         * @param starttime - The time in a particle's life at which this force should
         *                  start having an effect.
         * @param endtime   - The time in a particle's life at which this force should
         *                  stop having an effect.
         * @param x         - The x component of the force's influence on a particle's
         *                  speed in units per second.
         * @param y         - The y component of the force's influence on a particle's
         *                  speed in units per second.
         * @return void
         */
        @Signature
        public native void AddParticlesForce(int ID, float starttime, float endtime, float x, float y);

        /**
         * Adds a size change at a certain point in a particle's life. Scale values are
         * relative to the value set by SetParticlesSize so a scale of 2 means double
         * its normal size and 0.5 is half its normal size. A scale added with time=1
         * will make the particle equal the given size when it has been alive for 1
         * second. The particle will gradually transform from its current size to the
         * next size.
         *
         * @param ID    - The ID of the emitter to modify.
         * @param time  - The time that particles should become this size.
         * @param scale - The scale relative to the normal particle size, must be
         *              greater then or equal to 0.
         * @return void
         */
        @Signature
        public native void AddParticlesScaleKeyFrame(int ID, float time, float scale);

        /**
         * Adds a color change at a certain point in a particle's life. For example a
         * color added with time=1 will make the particle equal the given color when it
         * has been alive for 1 second. If color interpolation is turned on using
         * SetParticlesColorInterpolation the particle will gradually transform from its
         * current color to the next color. For example if you add three colors, red
         * when time=1, green when time=2, and blue when time=3, then the particle will
         * start its life as red (as that is the nearest color) and remain completely
         * red until it is 1 second old. When the particle is between 1 and 2 seconds
         * old it will gradually change from red to green until it is 2 seconds old, at
         * this point it is completely green. When the particle is between 2 and 3
         * seconds old it will gradually change from green to blue until it is 3 seconds
         * old, at this point it is completely blue. The particle will remain completely
         * blue until the end of its life as no other colors have been added.
         *
         * @param ID    - The ID of the emitter to modify.
         * @param time  - The time that particles should become this color.
         * @param red   - The red component of the new color.
         * @param green - The green component of the new color.
         * @param blue  - The blue component of the new color.
         * @param alpha - The alpha component of the new color.
         * @return void
         */
        @Signature
        public native void AddParticlesColorKeyFrame(int ID, float time, int red, int green, int blue, int alpha);

        /**
         * Adds a cylinder collision shape to a compound shape. First set the objects
         * shape to a compound collision shape with SetObjectShapeCompound().
         *
         * @param objID        - object ID
         * @param positionVec3 - The vector Id of the vector with the world position for
         *                     the center of the shape.
         * @param rotationVec3 - The vector ID of the vector with the world rotation of
         *                     the shape.
         * @param sizeVec3     - The vector ID of the vector with the size of the shape.
         * @param axis         - 0 = X axis, 1 = Y axis, 2 = Z axis.
         * @return void
         */
        @Signature
        public native void AddObjectShapeCylinder(int objID, int positionVec3, int rotationVec3, int sizeVec3,
                        int axis);

        /**
         * Adds a sphere collision shape to a compound shape. First set the objects
         * shape to a compound collision shape with SetObjectShapeCompound().
         *
         * @param objID        - object ID
         * @param positionVec3 - The vector Id of the vector with the world position for
         *                     the center of the shape.
         * @param diameter     - size of sphere shape
         * @return void
         */
        @Signature
        public native void AddObjectShapeSphere(int objID, int positionVec3, float diameter);

        /**
         * Adds a cone collision shape to a compound shape. First set the objects shape
         * to a compound collision shape with SetObjectShapeCompound().
         *
         * @param objID        - object ID
         * @param positionVec3 - The vector Id of the vector with the world position for
         *                     the center of the shape.
         * @param rotationVec3 - The vector ID of the vector with the world rotation of
         *                     the shape.
         * @param sizeVec3     - The vector ID of the vector with the size of the shape.
         * @param axis         - 0 = X axis, 1 = Y axis, 2 = Z axis.
         * @return void
         */
        @Signature
        public native void AddObjectShapeCone(int objID, int positionVec3, int rotationVec3, int sizeVec3, int axis);

        /**
         * Adds a capsule collision shape to a compound shape. First set the objects
         * shape to a compound collision shape with SetObjectShapeCompound().
         *
         * @param objID        - object ID
         * @param positionVec3 - The vector Id of the vector with the world position for
         *                     the center of the shape.
         * @param rotationVec3 - The vector ID of the vector with the world rotation of
         *                     the shape.
         * @param sizeVec3     - The vector ID of the vector with the size of the shape.
         * @param axis         - 0 = X axis, 1 = Y axis, 2 = Z axis.
         * @return void
         */
        @Signature
        public native void AddObjectShapeCapsule(int objID, int positionVec3, int rotationVec3, int sizeVec3, int axis);

        /**
         * Adds a box collision shape to a compound shape. First set the objects shape
         * to a compound collision shape with SetObjectShapeCompound().
         *
         * @param objID        - object ID
         * @param positionVec3 - The vector Id of the vector with the world position for
         *                     the center of the shape.
         * @param rotationVec3 - The vector ID of the vector with the world rotation of
         *                     the shape.
         * @param sizeVec3     - The vector ID of the vector with the size of the shape.
         * @return void
         */
        @Signature
        public native void AddObjectShapeBox(int objID, int positionVec3, int rotationVec3, int sizeVec3);

        /**
         * Adds a new mesh to the object, constructed from the given memblock. The first
         * 4 bytes of the memblock represent the number of vertices in the mesh. The
         * second 4 bytes represent the number of indices in the mesh, this may be 0 in
         * which case every three vertices represents a polygon, and no vertices can be
         * shared. If the number of indices is greater than 0 then every three indices
         * represent a polygon and vertices may be shared between polygons. Indices
         * start at 0 so index 0 references the first vertex in the list. The third 4
         * bytes represents the number of attributes per vertex, e.g. position, normals,
         * and UV data are all potential attributes, so a vertex containing all three
         * would have 3 attributes. A vertex must have a position attribute, everything
         * else is optional. The fourth 4 bytes represent the size of a single vertex in
         * bytes, this can be calculated from the attribute data but is given for
         * convenience. The fifth 4 bytes is offset for the beginning of the vertex
         * data, so you can reach it easily. The sixth 4 bytes is offset for the
         * beginning of the index data, will be 0 if there are no indices. After those 6
         * values, starting at offset 24, is the vertex attribute data. The vertex
         * attribute data describes how the vertex data is laid out, for example if it
         * has normals, UV data, etc. For each attribute there is a 1 byte data type, 1
         * byte component count, 1 byte normalize flag, 1 byte string length, and X
         * bytes of string data for the attribute name. The data type will be 0 for
         * floats (used for almost everything, e.g. position, normals, etc) or 1 for
         * unsigned bytes (used for vertex colors). The component count is the number of
         * values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
         * components, and vertex colors have 4 components. Note that any unsigned byte
         * data type must have 4 components even if some are unused. The normalize flag
         * is only used for unsigned byte data types and will convert values in the
         * range 0-255 into 0.0-1.0 for use in a shader. Usually the normalize flag will
         * be 1 for color attributes and 0 for everything else. The string length byte
         * must always be a multiple of 4 for alignment reasons, the string itself might
         * have slightly less characters but always round up to the nearest multiple of
         * 4 for the string length value. e.g. a string of length 5 should have a string
         * length value of 8. Note that a string of 4 characters has a null terminator
         * on the end which makes it length 5, so even though it has a multiple of 4
         * characters already it must use a length value of 8 due to the null
         * terminator. The attribute name string will be used by the shader to recognise
         * what the vertex data is, the attribute names recognised by AGK are
         * "position", "normal", "tangent", "binormal", "color", "uv", "uv1",
         * "boneweights", and "boneindices", however you may add attributes with any
         * name you like as long as you write a matching shader that has the same names.
         * If you are not using your own shader and instead rely on AGK to draw the
         * object then you must stick to the above attribute names. Following the
         * attribute data is the raw vertex data, which usually starts with the
         * "position" attribute. It will be a 4 byte float for the X position, a 4 byte
         * float for the Y position, and a 4 byte float for the Z position. This
         * continues for each attribute specified in the attribute data. Note that color
         * data will always be 4 bytes in total, 1 unsigned byte for each color channel.
         * You can access individual vertices by using the vertex size provided above
         * and the vertex index like so
         * offset=vertexDataOffset+(vertexIndex*vertexSize). Lastly is the index data,
         * if present. Each index is a 4 byte integer which references a vertex in the
         * vertex data. Every three indices represents a polygon.
         *
         * @param objID - The ID of the object to modify
         * @param memID - The index of the memblock to use to create the new mesh
         * @return void
         */
        @Signature
        public native void AddObjectMeshFromMemblock(int objID, int memID);

        /**
         * Adds a float to a previously created network message. This can be called on
         * messages created by CreateNetworkMessage or on messages received from the
         * network.
         *
         * @param iMsgID - The ID of the message to modify.
         * @param value  - The value to add to the message.
         * @return void
         */
        @Signature
        public native void AddNetworkMessageFloat(int iMsgID, float value);

        /**
         * Adds an integer to a previously created network message. This can be called
         * on messages created by CreateNetworkMessage or on messages received from the
         * network.
         *
         * @param iMsgID - The ID of the message to modify.
         * @param value  - The value to add to the message.
         * @return void
         */
        @Signature
        public native void AddNetworkMessageInteger(int iMsgID, int value);

        /**
         * Adds a string to a previously created network message. This can be called on
         * messages created by CreateNetworkMessage or on messages received from the
         * network.
         *
         * @param iMsgID - The ID of the message to modify.
         * @param value  - The string to add to the message.
         * @return void
         */
        @Signature
        public native void AddNetworkMessageString(int iMsgID, String value);

        /**
         * Adds an unsigned byte to a previously created network message. This can be
         * called on messages created by CreateNetworkMessage or on messages received
         * from the network.
         *
         * @param iMsgID - The ID of the message to modify.
         * @param value  - The value to add to the message.
         * @return void
         */
        @Signature
        public native void AddNetworkMessageByte(int iMsgID, int value);

        /**
         * Creates a ragdoll bone capsule between the objects start and end bone
         * location. Returns ragdoll bone ID. If this command fails to create a bone it
         * will return a -1.
         *
         * @param startBoneID    - objects bone ID
         * @param endBoneID      - objects bone ID
         * @param diameter       - size of the capsule that will be the ragdoll bone.
         * @param collisionGroup - collision group that this Physics object belongs too.
         * @param collisionMask  - collision groups you want masked from collision.
         * @return int
         */
        @Signature
        public native int Add3DPhysicsRagDollBone(int startBoneID, int endBoneID, float diameter, int collisionGroup,
                        int collisionMask);

        /**
         * Adds the specified header to all future requests. If the header already
         * exists then its value will be overwritten by the new value. If the header is
         * a standard header that is normally present then its value will be overwritten
         * by the value you give. If the header is a standard header that is normally
         * present and the value you give is the empty string then the standard header
         * will be removed. Do not add the colon to either field, it will be added
         * automatically between them. Note that this command does not work in the HTML5
         * version.
         *
         * @param iHTTP       - The ID of the connection to change.
         * @param headerName  - The name of the header to set, e.g. "Content-Type"
         * @param headerValue - The new value for the header
         * @return void
         */
        @Signature
        public native void AddHTTPHeader(int iHTTP, String headerName, String headerValue);

        /**
         * Adds a size change at a certain point in a particle's life. Scale values are
         * relative to the value set by Set3DParticlesSize so a scale of 2 means double
         * its normal size and 0.5 is half its normal size. A scale added with time=1
         * will make the particle gradually transform to the given until it has been
         * alive for 1 second when it will match the given size. The particle will then
         * gradually transform from that size to the next size (if a next size exists).
         *
         * @param ID    - The ID of the emitter to modify.
         * @param time  - The time that particles should become this size.
         * @param scale - The scale relative to the normal particle size, must be
         *              greater then or equal to 0.
         * @return void
         */
        @Signature
        public native void Add3DParticlesScaleKeyFrame(int ID, float time, float scale);

        /**
         * Adds a force that will act at a given time in every particle's life. For
         * example a force set to start at time 2 and end at time 3 will start
         * influencing particles when they have been alive for 2 seconds. It will
         * continue to act on those particles until they have been alive for 3 seconds.
         * The force's influence is defined by an x, y, and z value that represent
         * acceleration in units per second. For example a force with x=5 will adjust a
         * particle's horizontal speed by adding 5 units for every second the force is
         * active, if the force is only active for 0.5 seconds the particle would then
         * be moving 2.5 units per second faster in the X direction. Multiple forces can
         * be acting on a particle at the same time if their timings overlap.
         *
         * @param ID        - The ID of the emitter to modify.
         * @param starttime - The time in a particle's life at which this force should
         *                  start having an effect.
         * @param endtime   - The time in a particle's life at which this force should
         *                  stop having an effect.
         * @param x         - The x component of the force's influence on a particle's
         *                  speed in units per second.
         * @param y         - The y component of the force's influence on a particle's
         *                  speed in units per second.
         * @param z         - The z component of the force's influence on a particle's
         *                  speed in units per second.
         * @return void
         */
        @Signature
        public native void Add3DParticlesForce(int ID, float starttime, float endtime, float x, float y, float z);

        /**
         * Adds a color change at a certain point in a particle's life. For example a
         * color added with time=1 will make the particle equal the given color when it
         * has been alive for 1 second. If color interpolation is turned on using
         * Set3DParticlesColorInterpolation the particle will gradually transform from
         * its current color to the next color. For example if you add three colors, red
         * when time=1, green when time=2, and blue when time=3, then the particle will
         * start its life as red (as that is the nearest color) and remain completely
         * red until it is 1 second old. When the particle is between 1 and 2 seconds
         * old it will gradually change from red to green until it is 2 seconds old, at
         * this point it is completely green. When the particle is between 2 and 3
         * seconds old it will gradually change from green to blue until it is 3 seconds
         * old, at this point it is completely blue. The particle will remain completely
         * blue until the end of its life as no other colors have been added.
         *
         * @param ID    - The ID of the emitter to modify.
         * @param time  - The time that particles should become this color.
         * @param red   - The red component of the new color.
         * @param green - The green component of the new color.
         * @param blue  - The blue component of the new color.
         * @param alpha - The alpha component of the new color.
         * @return void
         */
        @Signature
        public native void Add3DParticlesColorKeyFrame(int ID, float time, int red, int green, int blue, int alpha);

        /**
         * Attempts to connect to the smart watch connected to the current device. It
         * will attempt to maintain that connection for the life of the app, for example
         * if the watch is unpaired and then repaired then your app will reconnect to
         * the watch automatically. So you only need to call this command once at the
         * beginning of your app. Currently only works on iOS. To create a watch app you
         * will need to use the Tier 2 project interpreter_ios and add a watch app to
         * it.
         *
         * @param szReserved - Reserved for future use, must be an empty string
         * @return void
         */
        @Signature
        public native void ActivateSmartWatch(String szReserved);

        /**
         * Returns absolute of a value, that is the positive version of the number.
         *
         * @param a - The value to convert.
         * @return float
         */
        @Signature
        public native float Abs(float a);

        /**
         * Returns the arctangent of a value in radians in the range -pi/2 to pi/2.
         *
         * @param a - The value to pass into the arctangent function.
         * @return float
         */
        @Signature
        public native float ATanRad(float a);

        /**
         * Returns the angle in radians between x=0 y=-1 (up) and the given vector in a
         * clockwise direction. Returns a value from 0 to 2*PI. This command is
         * proprietary to AGK and is useful in 2D situations. If you are looking for an
         * equivalent to atan2 in C++ use the AGK command ATan2Rad instead.
         *
         * @param x - The x component of the vector to check
         * @param y - The y component of the vector to check
         * @return float
         */
        @Signature
        public native float ATanFullRad(float x, float y);

        /**
         * Returns the angle in degrees between x=0 y=-1 (up) and the given vector in a
         * clockwise direction. Returns a value from 0 to 360. This command is
         * proprietary to AGK and is useful in 2D situations. If you are looking for an
         * equivalent to atan2 in C++ use the AGK command ATan2 instead.
         *
         * @param x - The x component of the vector to check
         * @param y - The y component of the vector to check
         * @return float
         */
        @Signature
        public native float ATanFull(float x, float y);

        /**
         * Returns the angle of an x,y vector in degrees in the range -180 to 180. This
         * exactly matches the C++ atan2 function with degrees.
         *
         * @param y - The y value to pass to atan2
         * @param x - The x value to pass to atan2
         * @return float
         */
        @Signature
        public native float ATan2(float y, float x);

        /**
         * Returns the angle of an x,y vector in radians in the range -pi to pi. This
         * exactly matches the C++ atan2 function.
         *
         * @param y - The y value to pass to atan2
         * @param x - The x value to pass to atan2
         * @return float
         */
        @Signature
        public native float ATan2Rad(float y, float x);

        /**
         * Returns the arctangent of a value in degrees in the range -90 to 90.
         *
         * @param a - The value to pass into the arctangent function.
         * @return float
         */
        @Signature
        public native float ATan(float a);

        /**
         * Returns the arcsine of a value in radians.
         *
         * @param a - The value to pass into the arcsine function.
         * @return float
         */
        @Signature
        public native float ASinRad(float a);

        /**
         * Sets the plane detection mode for AR, by default this is turned on. Detected
         * planes can be discovered with the ARGetPlanes command.
         *
         * @param mode - 1=Turn plane detection on, 0=Turn plane detection off
         * @return void
         */
        @Signature
        public native void ARSetPlaneDetectionMode(int mode);

        /**
         * Returns the arcsine of a value in degrees.
         *
         * @param a - The value to pass into the arcsine function.
         * @return float
         */
        @Signature
        public native float ASin(float a);

        /**
         * Only available on iOS and Android. This command sets up the AR features of
         * the device, if available. Use the ARGetStatus command to check if this was
         * successful. This command must be called before any other AR commands, if the
         * setup fails you may call this command again to attempt setup again. Setting
         * up AR will take control of the 3D camera, including the projection matrix, so
         * any changes you make to the camera position, rotation, FOV, will be
         * overwritten by the AR system when Render or Sync are called. However you can
         * still control the camera near and far values with SetCameraRange which will
         * persist through the AR system. When using AR and placing or sizing 3D objects
         * then the coordinate system is 1 AGK unit equals 1 meter.
         *
         * @return void
         */
        @Signature
        public native void ARSetup();

        /**
         * Sets the light estimation mode for AR, by default this is turned on. This
         * attempts to work out the ambient light in the real world so you can light
         * your virtual objects correctly.
         *
         * @param mode - 1=Turn light estimation on, 0=Turn light estimation off
         * @return void
         */
        @Signature
        public native void ARSetLightEstimationMode(int mode);

        /**
         * Cleans up the resources used during hit testing, this should be called when
         * you are done checking the hit test results. If you do not call it then it
         * will be called automatically when you perform another hit test or destroy the
         * AR session.
         *
         * @return void
         */
        @Signature
        public native void ARHitTestFinish();

        /**
         * Casts a ray into the real world scene and detects any hits with planes or
         * tracking points detected in the world. Returns the number of hits detected,
         * the hits will be ordered with the closest first. The coordinates should be in
         * screen space, for example the values returned from GetPointerX and
         * GetPointerY. When you are finished checking the results of this hit test you
         * should call ARHitTestFinish to release any used resources. If not then this
         * will be done automatically when you next call ARHitTest.
         *
         * @param screenX - The X component of the screen coordinate
         * @param screenY - The Y component of the screen coordinate
         * @return int
         */
        @Signature
        public native int ARHitTest(float screenX, float screenY);

        /**
         * Returns the current state of the AR setup process. 0=ARSetup not yet called,
         * -1=AR not available on this device, or setup failed, -2=User rejected ARCore
         * install, 1=ARCore install in progress, 2=AR setup successful.
         *
         * @return int
         */
        @Signature
        public native int ARGetStatus();

        /**
         * Cleans up any resources used in the call to ARGetPlanes, you should call this
         * when you are done checking the results. If not then it will be called
         * automatically when you next call ARGetPlanes or destroy the AR session.
         *
         * @return void
         */
        @Signature
        public native void ARGetPlanesFinish();

        /**
         * Returns the Z component of the center of the given plane. This point may
         * drift over time relative to the real world scene, so it should be checked and
         * updated regularly if you are using it to show a visible representation of the
         * plane.
         *
         * @param index - The index of the plane to check, starting with index 1
         * @return float
         */
        @Signature
        public native float ARGetPlaneZ(int index);

        /**
         * Queries the AR session for all the planes currently being tracked in the
         * world, these are detected over time if ARSetPlaneDetectionMode is turned on.
         * Returns the number of planes found. This can be used to show the detected
         * planes to the user by creating some plane objects with CreateObjectPlane and
         * placing them at the given position, with the given rotation, and size. When
         * you are done checking the results you should call ARGetPlanesFinish to clean
         * up any resources used in the check.
         *
         * @param reserved - reserved for future use, must be 0
         * @return int
         */
        @Signature
        public native int ARGetPlanes(int reserved);

        /**
         * Returns the Y component of the center of the given plane. This point may
         * drift over time relative to the real world scene, so it should be checked and
         * updated regularly if you are using it to show a visible representation of the
         * plane.
         *
         * @param index - The index of the plane to check, starting with index 1
         * @return float
         */
        @Signature
        public native float ARGetPlaneY(int index);

        /**
         * Returns the Z component of the size of the given plane. This can be used to
         * scale a 3D object to match a visual representation of the detected plane.
         *
         * @param index - The index of the plane to check, starting with index 1
         * @return float
         */
        @Signature
        public native float ARGetPlaneSizeZ(int index);

        /**
         * Returns the X component of the center of the given plane. This point may
         * drift over time relative to the real world scene, so it should be checked and
         * updated regularly if you are using it to show a visible representation of the
         * plane.
         *
         * @param index - The index of the plane to check, starting with index 1
         * @return float
         */
        @Signature
        public native float ARGetPlaneX(int index);

        /**
         * Returns the X component of the size of the given plane. This can be used to
         * scale a 3D object to match a visual representation of the detected plane.
         *
         * @param index - The index of the plane to check, starting with index 1
         * @return float
         */
        @Signature
        public native float ARGetPlaneSizeX(int index);

        /**
         * Returns the Z component of the rotation of the given plane. This can be used
         * to rotate a 3D object to match a visual representation of the detected plane.
         *
         * @param index - The index of the plane to check, starting with index 1
         * @return float
         */
        @Signature
        public native float ARGetPlaneAngleZ(int index);

        /**
         * Returns the X component of the rotation of the given plane. This can be used
         * to rotate a 3D object to match a visual representation of the detected plane.
         *
         * @param index - The index of the plane to check, starting with index 1
         * @return float
         */
        @Signature
        public native float ARGetPlaneAngleX(int index);

        /**
         * Returns the estimated light value for the current frame, this will be a value
         * between 0.0 and 1.0. The best use of this value is to set the ambient light
         * color with SetAmbientColor with a value of 1.0 corresponding to a color value
         * of 255,255,255.
         *
         * @return float
         */
        @Signature
        public native float ARGetLightEstimate();

        /**
         * Returns the Y component of the rotation of the given plane. This can be used
         * to rotate a 3D object to match a visual representation of the detected plane.
         *
         * @param index - The index of the plane to check, starting with index 1
         * @return float
         */
        @Signature
        public native float ARGetPlaneAngleY(int index);

        /**
         * Returns the Z component of the given hit test result in 3D space. Hit test
         * results are ordered with the closest first, starting at index 1. This point
         * should only be used for a short time, for example to display a particle
         * effect, as it will drift relative to the real world. If you plan to use this
         * 3D point to position a long lived object in the world then you should create
         * an anchor from this hit test result instead so that it doesn't drift.
         *
         * @param index - The index of the hit test result to check, starting with index
         *              1.
         * @return float
         */
        @Signature
        public native float ARGetHitTestZ(int index);

        /**
         * Returns the Y component of the given hit test result in 3D space. Hit test
         * results are ordered with the closest first, starting at index 1. This point
         * should only be used for a short time, for example to display a particle
         * effect, as it will drift relative to the real world. If you plan to use this
         * 3D point to position a long lived object in the world then you should create
         * an anchor from this hit test result instead so that it doesn't drift.
         *
         * @param index - The index of the hit test result to check, starting with index
         *              1.
         * @return float
         */
        @Signature
        public native float ARGetHitTestY(int index);

        /**
         * Returns the X component of the given hit test result in 3D space. Hit test
         * results are ordered with the closest first, starting at index 1. This point
         * should only be used for a short time, for example to display a particle
         * effect, as it will drift relative to the real world. If you plan to use this
         * 3D point to position a long lived object in the world then you should create
         * an anchor from this hit test result instead so that it doesn't drift.
         *
         * @param index - The index of the hit test result to check, starting with index
         *              1.
         * @return float
         */
        @Signature
        public native float ARGetHitTestX(int index);

        /**
         * Returns the type of surface detected, 1=plane, usually horizontal, 0=point,
         * usually a wall or other object, -1=unknown.
         *
         * @param index - The index of the hit test result to check, starting with index
         *              1.
         * @return int
         */
        @Signature
        public native int ARGetHitTestType(int index);

        /**
         * Returns the Z component of the normal of the given hit test result in 3D
         * space. Hit test results are ordered with the closest first, starting at index
         * 1. For planes on the ground the normal will point straight up in 3D space,
         * for points detected on walls or other objects the normal will point away from
         * the detected surface.
         *
         * @param index - The index of the hit test result to check, starting with index
         *              1.
         * @return float
         */
        @Signature
        public native float ARGetHitTestNormalZ(int index);

        /**
         * Returns the X component of the normal of the given hit test result in 3D
         * space. Hit test results are ordered with the closest first, starting at index
         * 1. For planes on the ground the normal will point straight up in 3D space,
         * for points detected on walls or other objects the normal will point away from
         * the detected surface.
         *
         * @param index - The index of the hit test result to check, starting with index
         *              1.
         * @return float
         */
        @Signature
        public native float ARGetHitTestNormalX(int index);

        /**
         * Returns the Y component of the normal of the given hit test result in 3D
         * space. Hit test results are ordered with the closest first, starting at index
         * 1. For planes on the ground the normal will point straight up in 3D space,
         * for points detected on walls or other objects the normal will point away from
         * the detected surface.
         *
         * @param index - The index of the hit test result to check, starting with index
         *              1.
         * @return float
         */
        @Signature
        public native float ARGetHitTestNormalY(int index);

        /**
         * Returns the current tracking status of the given anchor. 0=stopped, 1=paused,
         * 2=tracking, -1=don't know. Anchors can stop tracking if the camera loses
         * tracking with the world, this can happen if the camera can't see enough
         * features to work out how the scene is moving. For example by looking at a
         * blank wall. When an anchor stops or pauses tracking it maintains its current
         * position and rotation, but this no longer correlates to the world position it
         * was tracking, so the anchor may appear to be drifting relative to the world.
         * When the anchor resumes tracking it should return to its correct world
         * position.
         *
         * @param anchorID - The ID of the anchor to check
         * @return int
         */
        @Signature
        public native int ARGetAnchorStatus(int anchorID);

        /**
         * You must call this command if you want the AR camera feed to be drawn to the
         * screen. If you do not then the camera will still track as if it were moving
         * around the real world but the camera feed will not be seen inside the app.
         * This may be useful if you want to render a purely virtual reality but still
         * use the AR camera tracking functionality. The best time to call this command
         * is just before calling Render or Sync.
         *
         * @return void
         */
        @Signature
        public native void ARDrawBackground();

        /**
         * Destroys the AR session and any resources allocated during setup. After you
         * can not call any AR commands, except ARGetStatus and ARSetup. You may call
         * ARSetup to recreate an AR session. There is no limit on the number of times
         * you can create and destroy the AR session. Currently on Android this command
         * may take up to 5 seconds, apparently this will be improved ina future version
         * of Google's ARCore.
         *
         * @return void
         */
        @Signature
        public native void ARDestroy();

        /**
         * Deletes the specified anchor and frees up any resources that were being used
         * by it. If any objects were attached to the anchor when it is deleted then
         * they will return to an unattached state and be placed at world coordinates
         *
         * @param anchorID - The ID of the anchor to delete
         * @return void
         */
        @Signature
        public native void ARDeleteAnchor(int anchorID);

        /**
         * Attaches an object to an anchor in the same way that FixObjectToObject works.
         * The object's position and rotation will be added to the anchor's position and
         * rotation. So for example an object at position 0,0,0 would be directly on top
         * of the anchor's position, whereas if the object had a position of 0,2,0 then
         * the object would be placed 2 meters above the anchor's position. There is no
         * limit on the number of objects that can be attached to an anchor, and objects
         * can still be attached to the object attached to the anchor. For example
         * object 1 could be fixed to the anchor, and object 2 could be fixed to object
         * 1. To remove an object from an anchor call this command with an anchor ID of
         * 0. The object will then be placed in the world at its given position, for
         * example a position of 0,0,0 would place it at the origin of the world.
         *
         * @param objID    - The ID of the object to fix to the anchor
         * @param anchorID - The ID of the anchor to use
         * @return void
         */
        @Signature
        public native void ARFixObjectToAnchor(int objID, int anchorID);
}