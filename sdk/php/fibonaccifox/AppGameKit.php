<?php

namespace fibonaccifox;

/**
 * Класс описания методов, реализованных в AppGameKit для <b>x64</b> и <b>x86</b>
 *
 * @author FibonacciFox
 * @version 1.0.0;
 */
class AppGameKit
{
    /**
     * AppGameKit constructor.
     *
     * @param Object $Object передаем класс реализующий логику приложения
     */
    function __construct(Object $Object)
    {

    }

    /**
     * Возвращает преобразованный путь для загрузки файлов в AppGameKit
     *
     * @param string $fileName путь до файла
     * @return string  преобразованный путь для AppGameKit
     */
    function getPath(string $fileName): string
    {

    }

    /**
     * Инициализируем OpenGL и отрисовываем в стороннее окно
     *
     * @param int $hWnd дескриптор окна
     */
    function InitGL(int $hWnd)
    {
    }

    /**
     *  Инициализируем AppGameKit
     *
     * @param int $deviceWidth ширина экрана устройства.
     * @param int $deviceHeight высота экрана устройства.
     * @param bool $fullscreen на весь экран ($fullscreen=false).
     * @return void
     */
    function Init(int $deviceWidth, int $deviceHeight, bool $fullscreen)
    {
    }


    /**
     * Возвращает арккосинус значения в радианах.
     *
     * @param float $a Значение, передаваемое в функцию arccosine.
     * @return float
     */
    function ACosRad(float $a): float
    {
    }

    /**
     * Создает якорь из заданного результата теста попадания, который может быть использован для отслеживания точки в
     * реальном мире с течением времени. Якоря автоматически регулируют свое положение, чтобы попытаться оставаться
     * неподвижными в точке, обнаруженной в реальном мире, это позволяет разместить объект там, не дрейфуя слишком
     * сильно. Возвращает идентификатор, который вы можете использовать для ссылки на этот якорь позже. Результат теста
     * попадания не обязательно должен существовать после создания из него якоря, после этого вы можете безопасно
     * очистить результаты теста попадания. Якорь будет сохраняться и использовать некоторые ресурсы отслеживания до
     * тех пор, пока вы специально не удалите его с помощью ARDeleteAnchor или не уничтожите сеанс AR.
     *
     * @param int $index Индекс результата теста попадания для использования, начиная с индекса 1
     * @return int
     */
    function ARCreateAnchorFromHitTest(int $index): int
    {
    }

    /**
     * Возвращает арккосинус значения в градусах.
     *
     * @param float $a Значение, передаваемое в функцию arccosine.
     * @return float
     */
    function ACos(float $a): float
    {
    }

    /**
     * Создает якорь из центра данной плоскости, который может быть использован для отслеживания точки в реальном мире
     * с течением времени. Якоря автоматически корректируют свое положение, чтобы попытаться оставаться неподвижными в
     * точке, обнаруженной в реальном мире, это позволяет разместить объект там, не дрейфуя слишком сильно. Возвращает
     * идентификатор, который вы можете использовать для ссылки на этот якорь позже. Результат плоскости не обязательно
     * должен существовать после создания из него якоря, после этого вы можете смело вызывать ARGetPlanesFinish. Якорь
     * будет сохраняться и использовать некоторые ресурсы отслеживания до тех пор, пока вы специально не удалите его с
     * помощью ARDeleteAnchor или не уничтожите сеанс AR.
     *
     * @param int $index Индекс используемого самолета, начиная с индекса 1
     * @return int
     */
    function ARCreateAnchorFromPlane(int $index): int
    {
    }

    /**
     * Это необязательная команда, которая сбросит камеру на заданные значения AR. Это может быть полезно, если вы
     * измените положение или поворот камеры, но затем захотите узнать значения AR для этих настроек. Вам не нужно
     * вызывать эту команду, так как значения будут сброшены до значений AR при рендеринге или синхронизации в любом
     * случае.
     *
     * @return void
     */
    function ARControlCamera()
    {
    }

    /**
     * Записывает строку в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не
     * предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут прочитаны
     * с помощью ReadString2. Для создания удобочитаемых файлов используйте WriteLine Это использует другой метод от
     * WriteString, который будет быстрее для чтения AGK позже, но он не совместим с ReadString, вы должны использовать
     * ReadString2 для чтения строк, написанных с помощью WriteString2
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param string $str Строка для записи.
     * @return void
     */
    function WriteString2(int $iFileID, string $str)
    {
    }

    /**
     * Записывает завершенную строку CR(\n) в данный файл, который должен быть открыт для записи.
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param string $str Строка для записи.
     * @return void
     */
    function WriteLine($iFileID, $str)
    {
    }

    /**
     * Записывает строку с нулевым завершением в данный файл, который должен быть открыт для записи. Обратите внимание,
     * что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые
     * позже будут прочитаны с помощью ReadString. Для создания удобочитаемых файлов используйте WriteLine
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param string $str Строка для записи.
     * @return void
     */
    function WriteString($iFileID, $str)
    {
    }

    /**
     * Записывает 4-байтовый поплавок в данный файл, который должен быть открыт для записи. Обратите внимание, что эта
     * команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут
     * прочитаны с помощью ReadFloat. Для создания удобочитаемых файлов используйте WriteLine
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param float $f Поплавок, чтобы писать.
     * @return void
     */
    function WriteFloat($iFileID, $f)
    {
    }

    /**
     * Записывает 4-байтовое целое число в данный файл, который должен быть открыт для записи. Обратите внимание, что
     * эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже
     * будут прочитаны с помощью ReadInteger. Для создания удобочитаемых файлов используйте WriteLine
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param int $i Целое число для записи.
     * @return void
     */
    function WriteInteger(int $iFileID, int $i)
    {
    }

    /**
     * Записывает 1-байтовое целое число без знака (0-255) в данный файл, который должен быть открыт для записи.
     * Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для
     * файлов, которые позже будут считываться с помощью ReadByte. Для создания удобочитаемых файлов используйте
     * WriteLine
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param int $b Байт для записи.
     * @return void
     */
    function WriteByte(int $iFileID, int $b)
    {
    }

    /**
     * Преобразует мировую координату Y в координату экрана Y на основе текущего смещения вида и масштабирования. Когда
     * SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен
     * на 20 пикселей вниз, объект на уровне 0,0 в мире появится на уровне -20 (вне экрана) над экраном.
     *
     * @param float $y Мировая координата Y для преобразования.
     * @return float
     */
    function WorldToScreenY(float $y): float
    {
    }

    /**
     * Открывает данный файл во внешнем приложении, подходящем для его типа файла. Как правило, это приложение по
     * умолчанию, выбранное пользователем. Файл должен быть в вашей папке для чтения или записи, вы должны указать имя
     * файла, как если бы вы загружали файл. В настоящее время это работает только на Windows, iOS и Android.
     *
     * @param string $szFilename Путь к файлу, который нужно открыть
     * @return void
     */
    function ViewFile(string $szFilename)
    {
    }

    /**
     * Преобразует мировую координату X в координату экрана X на основе текущего смещения вида и масштабирования. Когда
     * SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен
     * на 20 пикселей вправо, объект на 0,0 в мире появится на -20 (вне экрана) слева.
     *
     * @param float $x Мировая координата X для преобразования.
     * @return float
     */
    function WorldToScreenX(float $x): float
    {
    }

    /**
     * Вибрирует устройство в течение заданного количества секунд. Работает на iOS и Android. Обратите внимание, что на
     * iOS значение длины игнорируется и происходит только короткая вибрация, это связано с ограничениями Apple.
     *
     * @param float $seconds Время в секундах для вибрации
     * @return void
     */
    function VibrateDevice(float $seconds)
    {
    }

    /**
     * Преобразует строку в целое значение. Например, Val("10") вернет значение 10.
     *
     * @param string $str Строка для преобразования в целое число.
     * @param int|null $base в которой находится строковый номер.(необязательный параметр)
     * @return int
     */
    function Val(string $str, int $base = null): int
    {
    }

    /**
     * Преобразует строку в значение с плавающей запятой. Например, ValFloat("1.045") вернет значение 1.045
     *
     * @param string $str Строка для преобразования в целое число.
     * @return float
     */
    function ValFloat(string $str): float
    {
    }

    /**
     * Начиная с версии 2.0.20 AGK имеет новую систему шрифтов, которая может отображать больше символов и отображать
     * символы более плавно, однако для сохранения обратной совместимости она по умолчанию отключена. Чтобы
     * использовать новую систему, установите для этой команды значение 1. Это влияет только на шрифт по умолчанию,
     * если вы его сами не установили.
     *
     * @param int $mode 1=использовать новые шрифты по умолчанию, 0=использовать старые шрифты по умолчанию
     * @return void
     */
    function UseNewDefaultFonts(int $mode)
    {
    }

    /**
     * Преобразует строку в символы верхнего регистра.
     *
     * @param string $strin Строка для преобразования
     * @return string
     */
    function Upper(string $strin): string
    {
    }

    /**
     * Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро
     * продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть
     * установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей
     * начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать,
     * пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже
     * запущена на данном спрайте с помощью PlayTweenSprite, иначе ничего не произойдет. Если вы начали играть много
     * подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param int $spriteID Идентификатор обновляемого спрайта
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenSprite(int $tweenID, int $spriteID, float $fTime)
    {
    }

    /**
     * Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро
     * продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть
     * установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей
     * начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать,
     * пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже
     * запущена на данном тексте с помощью PlayTweenText, иначе ничего не произойдет. Если вы начали играть много
     * подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param int $textID Идентификатор текста для обновления
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenText(int $tweenID, int $textID, float $fTime)
    {
    }

    /**
     * Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро
     * продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть
     * установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей
     * начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать,
     * пока время снова станет положительным, или ждать, пока вы остановите его вручную. Твин должен быть уже запущен
     * на данном персонаже с помощью PlayTweenChar, иначе ничего не произойдет. Если вы начали играть много подростков,
     * то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param int $textID Идентификатор текста для обновления
     * @param int $charID Индекс символа, индексы начинаются с 0, если он выходит за пределы диапазона, то будет
     * проигнорирован
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenChar(int $tweenID, int $textID, int $charID, float $fTime)
    {
    }

    /**
     * Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро
     * продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть
     * установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей
     * начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать,
     * пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже
     * запущена на данном объекте с помощью PlayTweenObject, иначе ничего не произойдет. Если вы начали играть много
     * подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param int $objectID Идентификатор объекта для обновления
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenObject(int $tweenID, int $objectID, float $fTime)
    {
    }

    /**
     * Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро
     * продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть
     * установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей
     * начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать,
     * пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже
     * запущена на данной камере с помощью PlayTweenCamera, иначе ничего не произойдет. Если вы начали играть много
     * подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param int $cameraID Идентификатор объекта для обновления
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenCamera(int $tweenID, int $cameraID, float $fTime)
    {
    }

    /**
     * Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро
     * продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть
     * установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей
     * начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать,
     * пока время снова станет положительным, или ждать, пока вы остановите его вручную. Если вы начали играть много
     * подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenCustom($tweenID, $fTime)
    {
    }

    /**
     * Обновляет заданную цепочку твинов. Значение времени позволяет вам контролировать, как быстро продвигается
     * цепочка, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено
     * отрицательным, так что цепочка и подростки, которых она содержит, будут играть в обратном порядке, пока не
     * достигнут начальной точки, однако она не перестанет играть, когда достигнет начала, и вместо этого будет ждать,
     * пока время снова станет положительным, или ждать, пока вы остановите его вручную.
     *
     * @param int $chainID Идентификатор цепочки для обновления
     * @param float $fTime Время для продвижения цепи
     * @return void
     */
    function UpdateTweenChain($chainID, $fTime)
    {
    }

    /**
     * Немедленно опережает излучатель частиц на заданное количество времени. Если вы хотите продвинуть высокочастотный
     * излучатель на большой промежуток времени, такой как 1 секунда, вы должны вызвать эту команду несколько раз с
     * небольшим значением времени, таким как 0,02, чтобы она создавала новые частицы партиями и равномерно
     * распределяла их. Вызов его один раз с большим временным значением 1 секунда создал бы огромную партию частиц
     * сразу и переместил бы их вместе как каплю вместо того, чтобы распространять их.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @param float $time Время в секундах для продвижения излучателя.
     * @return void
     */
    function UpdateParticles($ID, $time)
    {
    }

    /**
     * Если по какой-либо причине размеры устройства могут измениться (например, изменение ориентации приводит к
     * повороту видового пространства на новый размер), вызовите эту функцию для обновления внутренних значений.
     *
     * @param int $w Новая ширина
     * @param int $h Новая высота
     * @return void
     */
    function UpdateDeviceSize($w, $h)
    {
    }

    /**
     * Устанавливает новое положение соединения кирки.
     *
     * @param int $jointID Id соединения
     * @param int $positionVec3 Идентификатор вектора положения
     * @return void
     */
    function Update3DPhysicsPickJoint($jointID, $positionVec3)
    {
    }

    /**
     * Звонил автоматически. Это расширенная команда для управления процессом обновления. Обычно Update вызывает это и
     * Update2D (), чтобы обновить все в мире. Эта команда обновляет только 3D - объекты, такие как 3D-модели.
     *
     * @param float $time время в секундах, чтобы переместить все вперед. Могут быть доли секунды.
     * @return void
     */
    function Update3D($time)
    {
    }

    /**
     * Обновления всех подростков начались на отдельных предметах и цепочках. Значение времени позволяет вам
     * контролировать, как быстро продвигаются подростки, и в большинстве случаев следует использовать результат
     * GetFrameTime. Время может быть установлено отрицательным, так что любые играющие подростки будут играть в
     * обратном порядке, пока не достигнут своих начальных точек, однако они не прекратят играть, когда достигнут
     * начала, и вместо этого будут ждать, пока время снова станет положительным, или ждать, пока вы остановите их
     * вручную.
     *
     * @param float $fTime Время для продвижения подростков
     * @return void
     */
    function UpdateAllTweens($fTime)
    {
    }

    /**
     * Звонил автоматически. Это расширенная команда для управления процессом обновления. Обычно Update вызывает это и
     * Update3D (), чтобы обновить все в мире. Эта команда обновляет только 2D-объекты, такие как спрайты и текст.
     *
     * @param float $time время в секундах, чтобы переместить все вперед. Могут быть доли секунды.
     * @return void
     */
    function Update2D($time)
    {
    }

    /**
     * Использует плавную кривую для перемещения от начала до конца, это позволяет избежать внезапного старта и
     * остановки. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение
     * для этого, которое равно 1.
     *
     * @return int
     */
    function TweenSmooth1()
    {
    }

    /**
     * Использует плавную кривую для перемещения от начала до конца, похожую на TweenSmooth1, но более преувеличенную.
     * Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого,
     * которое равно 2.
     *
     * @return int
     */
    function TweenSmooth2()
    {
    }

    /**
     * Обновляет все 2D и 3D объекты в зависимости от заданного времени, анимации, физики и т. Д. Если время равно 0,
     * то для пошагового моделирования используется время последнего кадра. Если вы уже назвали StepPhysics этим
     * фреймом, он не будет вызван снова для этого фрейма. Вызываемый автоматически Sync, вы можете использовать Sync
     * или Update(), Render(), Swap() для ручной синхронизации. Если вы хотите иметь больше контроля, вы можете разбить
     * это дальше, заменив Update на Update2D, Update3D()
     *
     * @param float $time время в секундах, чтобы переместить все вперед. Могут быть доли секунды.
     * @return void
     */
    function Update($time)
    {
    }

    /**
     * Использует эластичный аффект в конце интерполяции. Это единственный метод интерполяции, который превышает
     * заданный диапазон и не подходит для цветов. Это просто вспомогательная функция, чтобы избежать необходимости
     * запоминать целочисленное значение для этого, которое равно 8.
     *
     * @return int
     */
    function TweenOvershoot()
    {
    }

    /**
     * Использует линейную интерполяцию для перемещения от начала к концу, это самая простая форма интерполяции. Это
     * просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого,
     * которое равно 0.
     *
     * @return int
     */
    function TweenLinear()
    {
    }

    /**
     * Использует плавную кривую для движения к концу, похожую на TweenEaseOut1, но более преувеличенную. Это просто
     * вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно
     * 6.
     *
     * @return int
     */
    function TweenEaseOut2()
    {
    }

    /**
     * Использует плавную кривую для перемещения с самого начала, аналогичную TweenEaseIn1, но более преувеличенную.
     * Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого,
     * которое равно 4.
     *
     * @return int
     */
    function TweenEaseIn2()
    {
    }

    /**
     * Использует плавную кривую для движения к концу, это позволяет избежать внезапной остановки, но все равно
     * начинается резко. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное
     * значение для этого, которое равно 5.
     *
     * @return int
     */
    function TweenEaseOut1()
    {
    }

    /**
     * Немедленно опережает излучатель частиц на заданное количество времени. Если вы хотите продвинуть высокочастотный
     * излучатель на большой промежуток времени, такой как 1 секунда, вы должны вызвать эту команду несколько раз с
     * небольшим значением времени, таким как 0,02, чтобы она создавала новые частицы партиями и равномерно
     * распределяла их. Вызов его один раз с большим временным значением 1 секунда создал бы огромную партию частиц
     * сразу и переместил бы их вместе как каплю вместо того, чтобы распространять их.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @param float $time Время в секундах для продвижения излучателя.
     * @return void
     */
    function Update3DParticles($ID, $time)
    {
    }

    /**
     * Использует плавную кривую для движения с самого начала, это позволяет избежать внезапного старта, но все равно
     * резко заканчивается. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное
     * значение для этого, которое равно 3.
     *
     * @return int
     */
    function TweenEaseIn1()
    {
    }

    /**
     * Возвращает строку со всеми символами, удаленными после заданного символа. Исходная строка не изменяется, и
     * возвращается новая строка с удаленными символами. Это поиск в обратном направлении от конца строки к началу и
     * при первом появлении символа удаляет его и все, что после него. Обратите внимание, что если вы вызываете эту
     * команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы закончите с ней.
     *
     * @param string $str Строка для изменения
     * @param string $character Символ, который нужно искать, должен быть одним символом
     * @return string
     */
    function TruncateString($str, $character)
    {
    }

    /**
     * Возвращает целочисленную часть значения с плавающей запятой без округления в любом случае.
     *
     * @param float $a Значение для усечения.
     * @return int
     */
    function Trunc($a)
    {
    }

    /**
     * Использует эффект отскока в конце интерполяции. Это просто вспомогательная функция, чтобы избежать необходимости
     * запоминать целочисленное значение для этого, которое равно 7.
     *
     * @return int
     */
    function TweenBounce()
    {
    }

    /**
     * Получите количество секунд и долей секунд с момента запуска приложения. Точность до миллисекунд, но из-за
     * неточностей с плавающей запятой чем дольше работает приложение, тем менее точным оно становится. Более
     * конкретно, значение времени имеет около 7 значимых цифр точности, так что по мере увеличения числа секунд
     * количество десятичных знаков уменьшается. Если вам нужно только время до ближайшей секунды, то это значение
     * будет хорошо примерно до 16 000 000 секунд.  Вызов этой команды внутренне вызовет системный вызов, чтобы
     * получить количество прошедшего времени, поэтому он будет меняться каждый раз, когда вы его вызываете.
     *
     * @return float
     */
    function Timer()
    {
    }

    /**
     * Немедленно завершает работу указанного приложения. Это следует использовать только в крайних случаях, так как
     * приложение не имеет возможности очистить или закончить то, что оно делает.
     *
     * @param int $appID Идентификатор приложения для завершения работы, возвращаемый из runApp()
     * @return void
     */
    function TerminateApp($appID)
    {
    }

    /**
     * Инициализирует механизм преобразования текста в речь на устройстве, чтобы он мог воспроизводить звук. Обратите
     * внимание, что это может быть не сразу, вы должны проверить GetTextToSpeechReady, чтобы увидеть, закончил ли он
     * настройку. Вызов других команд преобразования текста в речь, когда он не готов, будет проигнорирован.  В
     * настоящее время работает только на iOS и Android.
     *
     * @return void
     */
    function TextToSpeechSetup()
    {
    }

    /**
     * Возвращает строку со всеми символами в "символах", удаленными из концов строки. Исходная строка не изменяется, и
     * возвращается новая строка с удаленными символами. Это можно использовать для удаления лишних пробелов с концов
     * входной строки. Обратите внимание, что если вы вызываете эту команду из уровня 2, то возвращаемая строка должна
     * быть удалена, когда вы закончите с ней.
     *
     * @param string $str Строка для изменения
     * @param string $chars Символы для удаления
     * @return string
     */
    function TrimString($str, $chars)
    {
    }

    /**
     * Возвращает тангенс значения в радианах.
     *
     * @param float $a Значение, передаваемое в касательную функцию.
     * @return float
     */
    function TanRad($a)
    {
    }

    /**
     * Возвращает тангенс значения в градусах.
     *
     * @param float $a Значение, передаваемое в касательную функцию.
     * @return float
     */
    function Tan($a)
    {
    }

    /**
     * Обновляет сцену с последней информацией, рисует все спрайты, обновляет глобальные объекты и меняет местами
     * backbuffer в поле зрения. Не рисует спрайты, созданные с помощью указателей на уровне 2, вы должны нарисовать их
     * вручную, вызвав функцию рисования спрайта или назначив их менеджеру спрайтов для пакетного рисования.
     *
     * @return void
     */
    function Sync()
    {
    }

    /**
     * Выводит задний буфер на экран и очищает задний буфер для следующего кадра, обновляет глобальные временные
     * переменные. Вызываемый автоматически Sync, вы можете использовать Sync или Update, Render, Swap один за другим
     * для ручной синхронизации.
     *
     * @return void
     */
    function Swap()
    {
    }

    /**
     * Возвращает строку, из которой удалены все символы в "символах". Исходная строка не изменяется, и возвращается
     * новая строка с удаленными символами. Например, StripString("my string", "yn") вернет "m strig". Обратите
     * внимание, что если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы
     * закончите с ней.
     *
     * @param string $str Строка для изменения
     * @param string $chars Символы для удаления
     * @return string
     */
    function StripString($str, $chars)
    {
    }

    /**
     * Преобразует строку UTF-8 в строку Base64. Если вы вызываете эту команду из уровня 2, эта строка должна быть
     * удалена, когда вы закончите с ней.
     *
     * @param string $input Строка для преобразования
     * @return string
     */
    function StringToBase64($input)
    {
    }

    /**
     * Останавливает видео и удаляет его из поля зрения, используя playVideo, чтобы запустить его с самого начала.
     *
     * @return void
     */
    function StopVideo()
    {
    }

    /**
     * Останавливает данный идентификатор анимации, если он воспроизводится на данном текстовом объекте. Если анимация
     * не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если текст был в середине
     * интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @param int $textID Идентификатор текстового объекта для остановки
     * @return void
     */
    function StopTweenText(int $tweenID, int $textID)
    {
    }


    /**
     * Преобразует значение в строку, если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда
     * вы закончите с ней.
     *
     * @param float|int $value - Значение для преобразования Int либо Float
     * @param null $decimals Количество мест после десятичной точки для включения.
     * @return string
     */
    function Str( $value, $decimals = null): string
    {
    }

    /**
     * Останавливает данный идентификатор анимации, если он воспроизводится на данном спрайте. Если анимация не
     * воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если спрайт находился в середине
     * интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @param int $spriteID Идентификатор спрайта для остановки
     * @return void
     */
    function StopTweenSprite($tweenID, $spriteID)
    {
    }

    /**
     * Останавливает данный идентификатор анимации, если он воспроизводится на данном объекте. Если анимация не
     * воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если объект находился в середине
     * интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @param int $objectID Идентификатор объекта для остановки
     * @return void
     */
    function StopTweenObject($tweenID, $objectID)
    {
    }

    /**
     * Останавливает данную цепь. Если элемент находился в середине интерполяции, он останется в своем текущем
     * положении, он не будет переходить к концу или возвращаться к началу. Воспроизведение цепочки снова запустит ее с
     * самого начала.
     *
     * @param int $chainID Идентификатор цепочки для изменения
     * @return void
     */
    function StopTweenChain($chainID)
    {
    }

    /**
     * Останавливает данный пользовательский идентификатор анимации, если он воспроизводится. Если анимация не
     * воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если твин был в середине
     * интерполяции, его значения останутся на своих текущих значениях, он не будет переходить к концу или возвращаться
     * к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @return void
     */
    function StopTweenCustom($tweenID)
    {
    }

    /**
     * Останавливает данный идентификатор анимации, если он воспроизводится на заданном символе текстового объекта.
     * Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если символ
     * находился в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или
     * возвращаться к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @param int $textID Идентификатор текстового объекта, содержащего символ
     * @param int $charID Индекс символа для остановки, индексы начинаются с 0, если он выходит за пределы диапазона,
     *     то будет проигнорирован
     * @return void
     */
    function StopTweenChar($tweenID, $textID, $charID)
    {
    }

    /**
     * Останавливает данный идентификатор анимации, если он воспроизводится на данной камере. Если анимация не
     * воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если камера находилась в середине
     * интерполяции, она останется в своем текущем положении, она не будет переходить к концу или возвращаться к
     * началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @param int $cameraID Идентификатор камеры для остановки
     * @return void
     */
    function StopTweenCamera($tweenID, $cameraID)
    {
    }

    /**
     * Эта команда останавливает и скрывает любое приглашение ввода текста, ранее запущенное с помощью команды
     * StartTextInput.
     *
     * @return void
     */
    function StopTextInput()
    {
    }

    /**
     * Еще не функционирует.
     *
     * @return void
     */
    function StopSoundRecording()
    {
    }

    /**
     * Останавливает анимацию спрайта, сохраняя значения, используемые для его настройки.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, чтобы остановить анимацию.
     * @return void
     */
    function StopSprite($iSpriteIndex)
    {
    }

    /**
     * Останавливает текущий экземпляр, если он еще этого не сделал. При этом экземпляр удаляется, и его идентификатор
     * больше не может быть использован. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при
     * инициировании воспроизведения звука.
     *
     * @param int $iID Идентификатор проверяемого экземпляра
     * @return void
     */
    function StopSoundInstance($iID)
    {
    }

    /**
     * Немедленно останавливает любой произносимый текст и удаляет все элементы из очереди.  В настоящее время работает
     * только на iOS и Android.
     *
     * @return void
     */
    function StopSpeaking()
    {
    }

    /**
     * Остановите звук, воспроизводимый в данный момент на указанном звуковом номере.
     *
     * @param int $iID Звук, по-видимому, прекратился.
     * @return void
     */
    function StopSound($iID)
    {
    }

    /**
     * Останавливает любую текущую запись экрана. Если запись уже остановлена, то это не имеет никакого эффекта. В iOS
     * это предложит пользователю отредактировать и/или сохранить видео, а также отказаться от него. На Android
     * пользователь не видит никаких изменений, и видео молча сохраняется в фоновом режиме.
     *
     * @return void
     */
    function StopScreenRecording()
    {
    }

    /**
     * Останавливает любую анимацию, которая в данный момент воспроизводится на объекте, и оставляет кости в их текущем
     * положении. Если объект в данный момент находится в подростковом возрасте, то анимация также будет остановлена с
     * костями, оставленными в середине анимации.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @return void
     */
    function StopObjectAnimation($objID)
    {
    }

    /**
     * Остановите оживление скелета
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @return void
     */
    function StopSkeleton2DAnimation($iSkeleton)
    {
    }

    /**
     * Останавливает любое воспроизведение музыки, после чего музыка может быть перезапущена только вызовом PlayMusic.
     *
     * @return void
     */
    function StopMusic()
    {
    }

    /**
     * Вызовите перед командой Sync() в нижней части цикла. Это шагнет в мир физики. Сохраняет физику постоянной
     * независимо от частоты кадров. Не вызывая эту команду, вы приостановите действие физического мира.
     *
     * @return void
     */
    function Step3DPhysicsWorld()
    {
    }

    /**
     * Шагает физическое моделирование на определенное количество времени. Это значение времени выражается в секундах и
     * может включать доли секунд. Шаговое моделирование физики на большое значение времени (больше, чем, скажем, 0,1)
     * может привести к неопределенному поведению и движению физических объектов друг через друга. Не требуется, чтобы
     * вы вызывали эту команду в своем игровом цикле, если вы ее не вызываете, Sync или Update вызовут ее для вас с
     * последним временем кадра, чтобы позволить физическому моделированию догнать вас в реальном времени. Если вы
     * действительно вызываете StepPhysics, то он не будет вызван для вас синхронизацией или обновлением для этого
     * кадра, это позволяет вам сделать свой собственный физический хронометраж, если вы предпочитаете. При
     * использовании фиксированного временного шага каждый кадр ваша физика будет работать точно так же на всех
     * устройствах и во всех частотах кадров, но снижение fps приведет к тому, что физика будет идти медленнее, так как
     * она всегда будет шагать одно и то же количество времени, независимо от того, был ли кадр быстрым или медленным.
     * Использование переменного шага для каждого кадра позволит физике двигаться с одинаковой скоростью независимо от
     * частоты кадров, но она больше не будет детерминированной между устройствами и различными частотами кадров.
     * Например, если ваша игра зависит от физического объекта, падающего и подпрыгивающего на одну и ту же высоту
     * каждый раз, когда он запускается, то вы должны использовать фиксированный временной шаг. Если положение
     * физических объектов не важно для вашей игровой логики, то переменный временной шаг может быть лучшим.
     *
     * @param float $time Время шага в секундах
     * @return void
     */
    function StepPhysics($time)
    {
    }

    /**
     * Останавливает музыкальный файл и сбрасывает его положение в начало файла.
     *
     * @param int $musicID Идентификатор музыкального файла для остановки
     * @return void
     */
    function StopMusicOGG($musicID)
    {
    }

    /**
     * Останавливает обновление местоположения GPS, используйте это для экономии заряда батареи, когда вам больше не
     * нужно местоположение.
     *
     * @return void
     */
    function StopGPSTracking()
    {
    }

    /**
     * Эта команда выводит текстовое приглашение ввода над вашим приложением, в то время как ваше приложение продолжает
     * работать в фоновом режиме. Допустимыми символами являются значения ASCII в диапазоне от 32 до 126 включительно,
     * если только вы не активировали новые шрифты по умолчанию с помощью UseNewDefaultFonts, и в этом случае можно
     * использовать любые символы Unicode. Если для ввода текста на этом устройстве требуется виртуальная клавиатура,
     * то она будет отображаться поверх вашего приложения. Вы не можете предполагать, что какая-либо часть вашего
     * приложения будет видна во время ввода текста, хотя ваш код будет продолжать работать. Когда пользователь
     * закончит ввод текста, GetTextInputCompleted вернет 1, а GetTextInputCancelled сообщит вам, завершил ли он ввод
     * текста или отменил его. На клавиатурных устройствах отмена производится с помощью клавиши escape, а завершение-с
     * помощью клавиши enter. В случае успеха вы можете получить введенный текст с помощью GetTextInput.
     *
     * @param null|string $initial Начальная строка для отображения пользователю, которую он может редактировать.
     * @return void
     */
    function StartTextInput($initial = null)
    {
    }

    /**
     * Начинает запись экрана и сохранение его в файл. В настоящее время поддерживается только на iOS 9.0 и выше и
     * Android 5.0 и выше. В iOS имя файла игнорируется, так как устройство всегда сохраняет запись в фотопленке. На
     * Android параметр микрофона может быть установлен в 1 для записи звука с микрофона устройства во время записи.
     * Значение 0 приведет к созданию бесшумного видео, так как Android не поддерживает запись звука непосредственно из
     * приложения. Однако аудиовыход из приложения может быть слышен через микрофон при использовании режима 1. Запись
     * через микрофон требует, чтобы вы включили разрешение "RecordAudio" при экспорте вашего APK.  В iOS значение
     * микрофона 1 будет записывать как аудиовыход приложения, так и микрофон, а значение 0 будет записывать только
     * звук приложения. На Android 6 и ниже запись может прекратиться в любое время, например, если приложение
     * отправлено в фоновый режим или активировано другое действие, например покупка в приложении. На Android 7 и выше
     * запись будет приостановлена, когда приложение находится в фоновом режиме, и возобновлена, когда приложение
     * возобновится. На iOS запись будет продолжаться после таких перерывов до тех пор, пока не будет вызвана функция
     * StopScreenRecording.
     *
     * @param string $szFilename Путь для сохранения видео, который должен заканчиваться в формате .mp4, может быть
     *     путем к файлу "raw:".
     * @param int $microphone 1 для записи с микрофона, 0 для записи с устройства
     * @return void
     */
    function StartScreenRecording(string $szFilename, int $microphone)
    {
    }

    /**
     * Возвращает квадратный корень из значения с плавающей запятой.
     *
     * @param float $a Значение квадратного корня.
     * @return float
     */
    function Sqrt(float $a)
    {
    }

    /**
     * Бросает луч через определенный спрайт (может быть физический или не физический) и сохраняет результат любого
     * пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких
     * как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Эта
     * функция уникальна тем, что она также работает со всеми спрайтами, даже с теми, у которых не включена физика, но
     * спрайту должна быть назначена форма с помощью одной из команд sprite shape. Возвращает 1, если произошло
     * столкновение, и 0, если нет.
     *
     * @param int $sprite Идентификатор спрайта для проверки пересечения с лучом.
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function SpriteRayCastSingle(int $sprite, float $x, float $y, float $x2, float $y2): int
    {
    }

    /**
     * Бросает луч через все спрайты, которые имеют форму (включая физические спрайты), и сохраняет результат любого
     * пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких
     * как GetRayCastNormalX. Физические спрайты будут использовать только основную форму, назначенную спрайту с
     * помощью SetSpriteShape, чтобы проверить, что составные формы используют PhysicsRayCast. Если луч начинается
     * внутри фигуры, то эта фигура не будет учитываться в результатах. Спрайтам должна быть назначена форма с помощью
     * одной из команд sprite shape, иначе она не будет включена в результаты столкновения. Эта функция медленнее, чем
     * физические лучи, поскольку она не может использовать оптимизированные структуры, которые представляют, где
     * находятся спрайты в мире относительно луча. Эта функция фильтрует проверяемые спрайты, поэтому проверяются
     * только спрайты определенной группы. По умолчанию спрайты создаются в группе 0. Эта функция может отслеживать
     * только спрайты, созданные с помощью CreateSprite, если вы вручную выделили память для спрайтов, вам нужно будет
     * циклически просматривать список спрайтов с помощью SpriteRayCastSingle или использовать физическую версию.
     * Возвращает 1, если произошло столкновение, и 0, если нет.
     *
     * @param int $group Идентификатор группы, проверяемый на пересечение с лучом, может быть отрицательным.
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function SpriteRayCastGroup($group, $x, $y, $x2, $y2)
    {
    }

    /**
     * Запускает процесс получения местоположения GPS, если это возможно, на текущем устройстве. Это может вызвать
     * запрос разрешения на некоторых платформах при первом вызове. Если пользователь отказывает в разрешении, то
     * GetGPSSensorExists может вернуть 0 с этого момента. Вы должны вызывать эту команду только тогда, когда
     * пользователь выполняет действие, которое, как он знает, потребует определения местоположения, в противном случае
     * он может отклонить его и никогда больше не получить запрос (ему придется войти в настройки своего устройства,
     * чтобы включить его). Эта команда будет потреблять много энергии батареи, поэтому используйте StopGPSTracking,
     * когда вам больше не нужно местоположение. Эта команда работает на iOS, Android, Mac и Windows 7 и выше. Вызов
     * этой команды может занять некоторое время, чтобы получить точное местоположение от GetRawGPSLatitude и
     * GetRawGPSLongitude.
     *
     * @return void
     */
    function StartGPSTracking()
    {
    }

    /**
     * Бросает луч через все спрайты, имеющие форму (включая физические спрайты), и сохраняет результат любого
     * пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких
     * как GetRayCastNormalX. Физические спрайты будут использовать только основную форму, назначенную спрайту с
     * помощью SetSpriteShape, чтобы проверить, что составные формы используют PhysicsRayCast. Если луч начинается
     * внутри фигуры, то эта фигура не будет учитываться в результатах. Спрайтам должна быть назначена форма с помощью
     * одной из команд sprite shape, иначе она не будет включена в результаты столкновения. Эта функция медленнее, чем
     * физика только лучей, поскольку она не может использовать оптимизированные структуры, которые представляют, где
     * находятся спрайты в мире относительно луча. Эта функция может отслеживать только спрайты, созданные с помощью
     * CreateSprite, если вы вручную выделили память для спрайтов, вам нужно будет циклически просматривать список
     * спрайтов с помощью SpriteRayCastSingle или использовать физическую версию. Возвращает 1, если произошло
     * столкновение, и 0, если нет.
     *
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function SpriteRayCast($x, $y, $x2, $y2)
    {
    }

    /**
     * Отбрасывает форму столкновения сфер по длине луча. Возвращает 1, если указанный объект был поражен, и 0, если он
     * не был поражен.
     *
     * @param int $objID идентификатор объекта
     * @param int $rayID Идентификатор луча, который возвращается вызовом Create3DPhysicsRay().
     * @param int $fromVec3ID Идентификатор вектора, удерживающего начальную точку
     * @param int $toVec3ID Идентификатор вектора, удерживающего конечную точку
     * @param float $radius Радиус сферы
     * @return int
     */
    function SphereCast3DPhysicsObject($objID, $rayID, $fromVec3ID, $toVec3ID, $radius)
    {
    }

    /**
     * Отбрасывает форму столкновения сфер по длине луча.
     *
     * @param int $rayID Идентификатор луча, который возвращается вызовом Create3DPhysicsRay().
     * @param int $fromVec3ID Идентификатор вектора, удерживающего начальную точку
     * @param int $toVec3ID Идентификатор вектора, удерживающего конечную точку
     * @param float $radius Радиус сферы
     * @return void
     */
    function SphereCast3DPhysics($rayID, $fromVec3ID, $toVec3ID, $radius)
    {
    }

    /**
     * Ставит данный текст в очередь для произнесения. Если какой - то текст уже произносится, то данный текст будет
     * произнесен после окончания текущей речи. Эта команда может быть вызвана несколько раз в быстрой
     * последовательности, чтобы поставить в очередь много текста. Вы можете вызвать IsSpeaking, чтобы проверить, когда
     * очередь пуста и весь текст был произнесен или отменен. Обратите внимание, что при первом вызове этой команды
     * может возникнуть задержка при установке незнакомого языка с помощью SetSpeechLanguage. Например, использование
     * французского языка на устройстве, настроенном для английского языка, попытается загрузить движок французского
     * языка, прежде чем начать говорить текст.  Если приложение будет отправлено в фоновый режим, то речь остановится,
     * и весь текст будет удален из очереди.  Вы можете указать необязательную задержку в миллисекундах, чтобы
     * устройство подождало, прежде чем начать произносить текст.  В настоящее время работает только на iOS и Android.
     *
     * @param string $text Текст для выступления
     * @param null|int $delay Количество времени в миллисекундах ожидания перед запуском речевого вывода
     * @return void
     */
    function Speak(string $text, $delay = null)
    {
    }

    /**
     * Бросает луч через все спрайты, которые имеют форму (включая физические спрайты), и сохраняет результат любого
     * пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких
     * как GetRayCastNormalX. Физические спрайты будут использовать только основную форму, назначенную спрайту с
     * помощью SetSpriteShape, чтобы проверить, что составные формы используют PhysicsRayCast. Если луч начинается
     * внутри фигуры, то эта фигура не будет учитываться в результатах. Спрайтам должна быть назначена форма с помощью
     * одной из команд sprite shape, иначе она не будет включена в результаты столкновения. Эта функция медленнее, чем
     * физические лучи, поскольку она не может использовать оптимизированные структуры, которые представляют, где
     * находятся спрайты в мире относительно луча. Эта функция фильтрует проверяемые спрайты, поэтому проверяются
     * только спрайты определенных категорий. Параметр category - это побитовое поле, которое использует младшие 16
     * битов для представления каждой из возможных 16 категорий, используемых при настройке спрайта. Значение по
     * умолчанию all 1s означает, что все категории будут включены, тогда как значение all 0s означает, что никакие
     * категории не будут включены. Вы можете установить отдельные биты, чтобы установить, какие из них должны быть
     * проверены. Эта функция может отслеживать только спрайты, созданные с помощью CreateSprite, если вы вручную
     * выделили память для спрайтов, вам нужно будет циклически просматривать список спрайтов с помощью
     * SpriteRayCastSingle или использовать физическую версию. Возвращает 1, если произошло столкновение, и 0, если
     * нет.
     *
     * @param int $category Категории для проверки на пересечение с лучом, побитовое поле с использованием самых нижних
     *     16 бит.
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function SpriteRayCastCategory(int $category, float $x, float $y, float $x2, float $y2): int
    {
    }

    /**
     * Стоит контроллер
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Stand3DPhysicsCharacterController(int $objID)
    {
    }

    /**
     * Приостановите работу приложения на определенное количество миллисекунд. Не рекомендуется использовать эту
     * команду для приостановки приложения более чем на один кадр (примерно 17 миллисекунд).
     *
     * @param int $milliseconds Количество миллисекунд сна.
     * @return void
     */
    function Sleep(int $milliseconds)
    {
    }

    /**
     * Возвращает синус значения в градусах.
     *
     * @param float $a Значение, которое нужно передать в синусоидальную функцию.
     * @return float
     */
    function Sin(float $a)
    {
    }

    /**
     * Создает строку пробелов, равную переданной длине.
     *
     * @param int $length Длина строки пробелов для создания
     * @return string
     */
    function Spaces($length)
    {
    }

    /**
     * Создает полноэкранную видеорекламу вознаграждения для получения дохода с помощью Chartboost. Перед вызовом этой
     * функции вы должны установить данные своего рекламного аккаунта с помощью SetChartboostDetails. И iOS, и Android
     * используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было
     * загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается
     * загрузить объявление при следующем вызове этой команды. Для Chartboost вы должны запустить процесс кэширования
     * вручную с помощью CacheRewardAdChartboost, вам нужно только вызвать его один раз. После показа видеорекламы с
     * вознаграждением новая видеореклама будет автоматически кэширована. Сбой в загрузке объявления может быть вызван
     * тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете
     * проверить, ждет ли объявление показа с помощью GetRewardAdLoadedChartboost. Ваше приложение будет
     * приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено. Проверьте
     * GetRewardAdRewardedChartboost, чтобы узнать, завершил ли пользователь просмотр объявления о вознаграждении и
     * должен ли он быть вознагражден. Он будет установлен в 0, когда вы вызовете эту команду, а затем установлен в 1,
     * когда они закончат просмотр
     *
     * @return void
     */
    function ShowRewardAdChartboost()
    {
    }

    /**
     * Возвращает синус значения в радианах.
     *
     * @param float $a Значение, которое нужно передать в синусоидальную функцию.
     * @return float
     */
    function SinRad(float $a): float
    {
    }

    /**
     * Удаляет любые вхождения ../ or ..\ и соответствующим образом сокращает путь, удаляя папки. Также заменяет все
     * задние косые черты на передние косые черты, так как передние косые черты будут работать на любой платформе. Это
     * работает как с относительными, так и с абсолютными путями, если путь абсолютен, то все вхождения ../ будут
     * удалены, даже если их слишком много. Если путь относителен, то любые вхождения../, которые запускают путь, не
     * будут удалены. Например, относительный путь "../../MyFile.txt" не может быть упрощено далее, в то время как
     * "C:/../../MyFile.txt" будет преобразован в "C:/MyFile.txt". Путь может начинаться с префикса "raw:" или нет,
     * принимаются оба варианта. Если вы используете эту функцию в Tier 2, то вы должны удалить возвращаемую строку с
     * помощью agk::DeleteString (), когда закончите с ней.
     *
     * @param string $szPath Путь к упрощению
     * @return string
     */
    function SimplifyPath(string $szPath): string
    {
    }

    /**
     * Создает полноэкранную видеорекламу вознаграждения для получения дохода с помощью AdMob. Перед вызовом этой
     * функции вы должны установить данные своего рекламного аккаунта с помощью SetAdMobRewardAdDetails. И iOS, и
     * Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было
     * загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается
     * загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у
     * рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет
     * ли объявление показа с помощью GetRewardAdLoadedAdMob. Ваше приложение будет приостановлено, когда появится
     * объявление, и возобновится, когда оно будет отклонено. Проверьте GetRewardAdRewardedAdMob, чтобы узнать,
     * завершил ли пользователь просмотр объявления о вознаграждении и должен ли он быть вознагражден. Он будет
     * установлен в 0, когда вы вызовете эту команду, а затем установлен в 1, когда они закончат просмотр
     *
     * @return void
     */
    function ShowRewardAdAdMob()
    {
    }

    /**
     * Эта функция устарела, вместо нее используйте SetDeviceCameraToImage. Предоставляет пользователю возможность
     * сделать снимок с помощью камеры устройства, если таковая имеется. Если устройство не имеет камеры или иным
     * образом не может быть использовано, это вернет 0, и ваше приложение будет продолжать работать в обычном режиме.
     * Это не сразу захватывает изображение, в зависимости от платформы ваше приложение может продолжать работать в
     * фоновом режиме, пока пользователь делает снимок, или оно может приостановить выполнение во время съемки. В любом
     * случае вы должны предположить, что ваше приложение продолжает работать, но больше не видно, используйте
     * IsCapturingImage, чтобы проверить, когда пользователь возвращается из процесса захвата изображения, и
     * GetCapturedImage, чтобы обнаружить результат этого процесса. В настоящее время это не работает на Mac.
     *
     * @return int
     */
    function ShowImageCaptureScreen()
    {
    }

    /**
     * Создает полноэкранную (интерстициальную) рекламу для получения дохода с помощью Amazon Ads. Перед вызовом этой
     * функции вы должны установить данные своего рекламного аккаунта с помощью SetAmazonAdDetails. И iOS, и Android
     * используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было
     * загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается
     * загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у
     * рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет
     * ли объявление показа с помощью GetFullscreenAdvertLoadedAmazon. Ваше приложение будет приостановлено, когда
     * появится объявление, и возобновится, когда оно будет отклонено.
     *
     * @return void
     */
    function ShowFullscreenAdvertAmazon()
    {
    }

    /**
     * Создает полноэкранную (интерстициальную) рекламу для получения дохода с помощью Chartboost. Перед вызовом этой
     * функции вы должны установить данные своего рекламного аккаунта с помощью SetChartboostDetails. И iOS, и Android
     * используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было
     * загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается
     * загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у
     * рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет
     * ли объявление показа с помощью GetFullscreenAdvertLoadedChartboost. Ваше приложение будет приостановлено, когда
     * появится объявление, и возобновится, когда оно будет отклонено.
     *
     * @return void
     */
    function ShowFullscreenAdvertChartboost()
    {
    }

    /**
     * Создает полноэкранную (интерстициальную) рекламу для получения дохода с помощью AdMob. Перед вызовом этой
     * функции вы должны установить данные своего рекламного аккаунта с помощью SetAdMobDetails. И iOS, и Android
     * используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было
     * загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается
     * загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у
     * рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет
     * ли объявление показа с помощью GetFullscreenAdvertLoadedAdMob. Ваше приложение будет приостановлено, когда
     * появится объявление, и возобновится, когда оно будет отклонено.
     *
     * @return void
     */
    function ShowFullscreenAdvertAdMob()
    {
    }

    /**
     * Предоставляет пользователю возможность выбрать изображение, хранящееся на его текущей платформе, например
     * фотографию на телефоне или изображение, сохраненное на ПК. Это не сразу захватывает изображение, в зависимости
     * от платформы ваше приложение может продолжать работать в фоновом режиме, пока пользователь выбирает изображение,
     * или оно может приостановить выполнение, пока выбирается изображение. В любом случае вы должны предположить, что
     * ваше приложение продолжает работать, но больше не видно, использовать IsChoosingImage, чтобы проверить, когда
     * пользователь возвращается из процесса выбора изображения, и GetChosenImage, чтобы обнаружить результат этого
     * процесса. Эта функция возвращает 1, если ей удалось отобразить экран выбора, и 0 в противном случае.
     *
     * @return int
     */
    function ShowChooseImageScreen()
    {
    }

    /**
     * Отправляет данный текст в операционную систему, которая затем спросит пользователя, как он хочет поделиться этим
     * текстом, например, через Facebook, Twitter и т. Д. Это работает только на iOS и Android.
     *
     * @param string $szText Текст для обмена
     * @return void
     */
    function ShareText($szText)
    {
    }

    /**
     * Отправляет указанное изображение в приложение SnapChat на текущем устройстве вместе с дополнительным файлом
     * стикера, подписью и URL-адресом. Затем пользователь может изменить изображение с помощью приложения SnapChat и
     * решить, стоит ли делиться им с друзьями. Если у пользователя не установлено приложение SnapChat, то вместо него
     * на странице приложения SnapChat будет открыт магазин приложений. Эта команда будет работать только на Android и
     * iOS 10 или выше
     *
     * @param string $imageFile Путь к изображению, которым вы хотите поделиться
     * @param string $stickerFile Путь к изображению стикера, чтобы добавить его к изображению, может быть пустой
     *     строкой
     * @param string $caption Подпись, которую нужно добавить к изображению, может быть пустой строкой
     * @param string $url URL-адрес, который нужно добавить к изображению, может быть пустой строкой
     * @return void
     */
    function ShareSnapChatImage($imageFile, $stickerFile, $caption, $url)
    {
    }

    /**
     * Отправляет данное изображение в операционную систему, которая затем спросит пользователя, как он хочет
     * поделиться этим изображением, например, через Facebook, Twitter и т. Д. Файл должен быть в вашей папке для
     * чтения или записи, или вы можете использовать путь "raw:" для загрузки из любого места, вы должны указать имя
     * файла, как если бы вы загружали файл. Это работает только на iOS и Android.
     *
     * @param string $szFilename Имя файла изображения для совместного использования
     * @return void
     */
    function ShareImage($szFilename)
    {
    }

    /**
     * Отправляет данный файл в операционную систему, которая затем спросит пользователя, как он хочет поделиться им,
     * например, по электронной почте, NFC и т. Д. Файл может находиться в вашей папке для чтения или записи, или вы
     * можете использовать путь "raw:" для загрузки из любого места, вы должны указать имя файла, как если бы вы
     * загружали файл. Это работает только на iOS и Android.
     *
     * @param string $szFilename Путь к файлу для совместного использования
     * @return void
     */
    function ShareFile($szFilename)
    {
    }

    /**
     * Отправляет данное изображение и текст в операционную систему, которая затем спросит пользователя, как он хочет
     * поделиться текстом, например, через Facebook, Twitter и т. Д. Файл изображения должен находиться в вашей папке
     * для чтения или записи, или вы можете использовать путь "raw:" для загрузки из любого места, вы должны указать
     * имя файла, как если бы вы загружали файл. Это работает только на iOS и Android.
     *
     * @param string $szFilename Имя файла изображения для совместного использования
     * @param string $szText Текст для обмена
     * @return void
     */
    function ShareImageAndText($szFilename, $szText)
    {
    }

    /**
     * Хэширует строку с помощью алгоритма SHA512 для получения 64-символьной шестнадцатеричной строки. Это
     * односторонняя хэш-функция, которая может использоваться с солением (добавлением секретной строки) для паролей
     * или обнаружения несанкционированного доступа к параметрам, передаваемым серверу. Если вы вызываете эту функцию
     * из уровня 2, то вы должны удалить возвращаемую строку с помощью agk::DeleteString, когда закончите с ней.
     *
     * @param string $str Строка для хэширования
     * @return string
     */
    function Sha512($str)
    {
    }

    /**
     * Хэширует строку с помощью алгоритма SHA256 для получения 32-символьной шестнадцатеричной строки. Это
     * односторонняя хэш-функция, которая может использоваться с солением (добавлением секретной строки) для паролей
     * или обнаружения несанкционированного доступа к параметрам, передаваемым серверу. Если вы вызываете эту функцию
     * из уровня 2, то вы должны удалить возвращаемую строку с помощью agk::DeleteString, когда закончите с ней.
     *
     * @param string $str Строка для хэширования
     * @return string
     */
    function Sha256($str)
    {
    }

    /**
     * Хэширует строку с помощью алгоритма SHA1 для получения 40-символьной шестнадцатеричной строки. Это односторонняя
     * хэш-функция, которая может использоваться с солением (добавлением секретной строки) для паролей или обнаружения
     * несанкционированного доступа к параметрам, передаваемым серверу. Если вы вызываете эту функцию из уровня 2, то
     * вы должны удалить возвращаемую строку с помощью agk::DeleteString с помощью DeleteString (), когда закончите с
     * ней.
     *
     * @param string $str Строка для хэширования
     * @return string
     */
    function Sha1($str)
    {
    }

    /**
     * Настраивает устройство на использование облачных данных на совместимых платформах, в настоящее время эту функцию
     * поддерживают только Android и iOS. Облачные данные можно использовать для совместного использования настроек на
     * нескольких устройствах, работающих под управлением одного и того же приложения. Например, сохранение некоторых
     * настроек приложения или прогресса на одном устройстве с помощью команд облачных данных сделает их доступными
     * (через короткий промежуток времени) на всех других устройствах на той же платформе. Обратите внимание, что
     * данные не пересекаются с платформами, поэтому данные, сохраненные на iOS, недоступны на Android, а данные,
     * сохраненные на Android, недоступны на iOS.  В iOS это использует iCloud Drive для хранения данных, поэтому
     * пользователь должен войти в iCloud и включить iCloud Drive, вы можете определить, были ли они сделаны с помощью
     * GetCloudDataAllowed. Вы также должны добавить iCloud в свой профиль подготовки, но вам не нужно создавать
     * какие-либо контейнеры. Этот профиль подготовки необходимо использовать при экспорте приложения. На iOS вы
     * ограничены 1 МБ памяти.  На Android это использует Android Drive AppData, поэтому пользователь должен войти в
     * систему с учетной записью Google на устройстве. Вы также должны добавить проект Google API для вашего приложения
     * здесь https: console.developers.google.com и создайте идентификатор клиента OAuth в разделе учетные данные.
     * Скажите ему, что запрос исходит от Android, дайте ему имя по вашему выбору и назовите имя пакета вашего
     * приложения. Вам нужно будет дать ему SHA-1 fignerprint файла хранилища ключей, который вы будете использовать
     * для подписи вашего APK, это делается для того, чтобы он мог проверить, что только APKS, подписанные вами, могут
     * использовать сгенерированный идентификатор клиента OAuth. Программа "keytool" является частью Java Development
     * Kit (JDK). После создания вам не нужно ничего делать с токеном OAuth, он будет использоваться автоматически при
     * вызове команд облачных данных. На Android любые данные, которые вы храните, будут засчитываться в лимит хранения
     * Google Диска пользователя, они не могут получить доступ к файлам, хранящимся в вашем приложении, но они могут
     * очистить данные приложения в настройках своего диска.  Широковещательные приложения будут использовать хранилище
     * данных AGK Player и совместно использовать переменные во всех ваших широковещательных приложениях, поэтому
     * будьте осторожны с перезаписью значений, если два ваших приложения имеют одно и то же имя переменной. Данные,
     * которые вы храните в хранилище данных AGK Player, будут видны только вам и вашим устройствам.  Эта команда
     * должна быть вызвана перед любыми другими командами облачных данных, кроме GetCloudDataAllowed, которые могут
     * быть вызваны в любое время. На Android вы должны спросить пользователя, хочет ли он хранить данные на своем
     * диске, прежде чем вызывать setup, так как эта команда может попросить пользователя войти в свой аккаунт Google.
     *
     * @param string $reserved Зарезервировано, должно быть пустой строкой
     * @return void
     */
    function SetupCloudData($reserved)
    {
    }

    /**
     * Задает заголовок окна для тех платформ, которые работают в окне (например, Windows, Mac).
     *
     * @param string $szTitle Текст, используемый для заголовка окна.
     * @return void
     */
    function SetWindowTitle($szTitle)
    {
    }

    /**
     * Это устанавливает размер окна для платформ, которые его поддерживают, таких как Windows и Mac. Это не повлияет
     * на мобильные устройства. В полноэкранном режиме ширина и высота будут игнорироваться, а разрешение рабочего
     * стола будет использоваться. По умолчанию размер окна будет отрегулирован таким образом, чтобы он всегда
     * помещался на экране, в том числе освобождая место для панели задач в Windows. Это означает, что ваш конечный
     * размер окна может быть немного меньше, чем выбранный вами размер. Вы можете переопределить это, установив
     * параметр allowOverSized равным 1, который удалит все проверки границ и позволит вам создавать окна размером
     * больше текущего экрана. Если параметр fullscreen установлен в 1, то параметр allowOverSized не имеет никакого
     * эффекта.
     *
     * @param int $width Желаемая ширина окна в пикселях.
     * @param int $height Желаемая высота окна в пикселях.
     * @param int $fullscreen 1 для использования полноэкранного режима, 0 для обычного окна.
     * @param null|int $allowOverSized 1, чтобы размер окна превышал видимый экран, 0, чтобы уменьшить его до нужного
     *     размера(необяхательный параметр)
     * @return void
     */
    function SetWindowSize(int $width, int $height, int $fullscreen, $allowOverSized = null)
    {
    }

    /**
     * Это устанавливает положение окна для платформ, которые его поддерживают, таких как Windows и Mac. Если окно в
     * данный момент полноэкранное, то это никак не повлияет. Это не повлияет на мобильные устройства.
     *
     * @param int $x Желаемое положение X окна в пикселях.
     * @param int $y Желаемое положение Y окна в пикселях.
     * @return void
     */
    function SetWindowPosition(int $x, $y)
    {
    }

    /**
     * Подход по умолчанию для системы координат в AGK заключается в использовании процентной системы, где 0,0
     * представляет верхний левый угол, а 100,100-нижний правый. Альтернативный подход заключается в обработке
     * платформы с фиксированным разрешением, например 320 x 480. Любые платформы, которые не соответствуют этому
     * разрешению, будут масштабированы, чтобы максимально соответствовать черным границам, где это необходимо.
     *
     * @param int $iWidth количество единиц измерения, используемых по ширине области рендеринга
     * @param int $iHeight количество единиц измерения, используемых по высоте области рендеринга
     * @return void
     */
    function SetVirtualResolution($iWidth, $iHeight)
    {
    }

    /**
     * Это устанавливает окно устанавливает, разрешено ли пользователю изменять размер окна, по умолчанию это значение
     * равно 0
     *
     * @param int $mode 0-отключить изменение размера, 1-разрешить изменение размера
     * @return void
     */
    function SetWindowAllowResize($mode)
    {
    }

    /**
     * Устанавливает, виден ли джойстик на экране, это не влияет на его способность принимать ввод, используйте
     * SetVirtualJoystickActive, чтобы повлиять на то, будет ли виртуальный джойстик принимать ввод. Невидимый джойстик
     * все еще может быть активен.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param int $visible 1 для отображения джойстика, 0 для его скрытия.
     * @return void
     */
    function SetVirtualJoystickVisible($index, $visible)
    {
    }

    /**
     * Задает диаметр виртуального джойстика в экранных координатах. Изменение размера виртуального джойстика во время
     * его использования изменит текущие возвращаемые значения X и Y.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param float $size Новый диаметр джойстика в экранных координатах.
     * @return void
     */
    function SetVirtualJoystickSize($index, $size)
    {
    }

    /**
     * Задает положение виртуального джойстика в экранных координатах. Вы можете использовать GetVirtualWidth и
     * GetVirtualHeight, чтобы найти текущие границы экрана. Джойстик будет центрирован в заданном положении x и y.
     * Перемещение виртуального джойстика во время его использования изменит текущие возвращаемые значения X и Y.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param float $x Координата x новой позиции.
     * @param float $y Координата y новой позиции.
     * @return void
     */
    function SetVirtualJoystickPosition($index, $x, $y)
    {
    }

    /**
     * Устанавливает изображение, используемое внутренней (подвижной) частью джойстика. Вы можете использовать
     * идентификатор изображения 0, чтобы вернуть его к изображению по умолчанию.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param int $imageID Идентификатор изображения, используемый для этого джойстика.
     * @return void
     */
    function SetVirtualJoystickImageInner($index, $imageID)
    {
    }

    /**
     * Устанавливает мертвую зону для всех виртуальных джойстиков так, чтобы любое значение X или Y ниже заданного
     * порога возвращало 0. Это значение должно быть между 0 и 1, по умолчанию оно равно 0,15.
     *
     * @param float $threshold Значение, ниже которого будет возвращено 0.
     * @return void
     */
    function SetVirtualJoystickDeadZone($threshold)
    {
    }

    /**
     * Устанавливает изображение, используемое внешней (фиксированной) частью джойстика. Вы можете использовать
     * идентификатор изображения 0, чтобы вернуть его к изображению по умолчанию.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param int $imageID Идентификатор изображения, используемый для этого джойстика.
     * @return void
     */
    function SetVirtualJoystickImageOuter($index, $imageID)
    {
    }

    /**
     * Устанавливает прозрачность виртуального джойстика на экране. Виртуальный джойстик состоит из двух частей:
     * внутренней подвижной части и внешней статической части. Alpha1 устанавливает прозрачность внешней части в
     * диапазоне 0-255, при этом 255 полностью непрозрачны. Alpha2 устанавливает прозрачность внутренней части в
     * диапазоне 0-255.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param int $alpha1 Альфа-значение внешней части джойстика.
     * @param int $alpha2 Альфа-значение внутренней части джойстика.
     * @return void
     */
    function SetVirtualJoystickAlpha($index, $alpha1, $alpha2)
    {
    }

    /**
     * Устанавливает, будет ли джойстик захватывать события мыши и касания. Если установлено значение 0, то он не будет
     * захватывать входные данные и не будет обновлять свои значения X и Y, они вернутся к 0. Это не повлияет на
     * видимость виртуального джойстика, используйте SetVirtualJoystickVisible, чтобы изменить его видимость.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param int $active 1, чтобы разрешить ввод, 0, чтобы отключить его.
     * @return void
     */
    function SetVirtualJoystickActive($index, $active)
    {
    }

    /**
     * Устанавливает текст, отображаемый в центре кнопки.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param string $str Текст для отображения.
     * @return void
     */
    function SetVirtualButtonText($index, $str)
    {
    }

    /**
     * Устанавливает, виден ли виртуальный объект на экране, это не влияет на его способность принимать ввод,
     * используйте SetVirtualButtonActive, чтобы повлиять на то, будет ли виртуальная кнопка принимать ввод. Невидимая
     * кнопка все еще может быть активна.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $visible 1, чтобы показать кнопку, 0, чтобы скрыть ее.
     * @return void
     */
    function SetVirtualButtonVisible($index, $visible)
    {
    }

    /**
     * Задает размер виртуальной кнопки в координатах экрана. Можно передать
     * либо диаметр $size - в экранных координатах, либо - $sizeX(новый размер X
     * кнопки в координатах экрана) и дополнительно $sizeY (новый размер кнопки Y в координатах экрана)
     *
     * @param int $index идентификатор виртуальной кнопки для установки.
     * @param float $size новый диаметр кнопки в экранных координатах. либо $sizeX и $sizeY
     * либо $sizeX Новый размер кнопки в координатах экрана и $sizeY Новый размер кнопки Y в координатах экрана.
     * @param $sizeY
     * @return void
     */
    function SetVirtualButtonSize(int $index, float $size, $sizeY = null)
    {
    }



    /**
     * Устанавливает изображение, используемое кнопкой, когда она не нажата. Вы можете использовать идентификатор
     * изображения 0, чтобы вернуть его к изображению по умолчанию.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $imageID Идентификатор изображения, используемый для этой кнопки.
     * @return void
     */
    function SetVirtualButtonImageUp($index, $imageID)
    {
    }

    /**
     * Устанавливает изображение, используемое кнопкой при ее нажатии. Вы можете использовать идентификатор изображения
     * 0, чтобы вернуть его к изображению по умолчанию.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $imageID Идентификатор изображения, используемый для этой кнопки.
     * @return void
     */
    function SetVirtualButtonImageDown($index, $imageID)
    {
    }

    /**
     * Устанавливает цвет виртуальной кнопки по заданному индексу. По умолчанию кнопки имеют оттенки серого, так что
     * они могут принимать различные цвета. Цвета должны быть указаны в диапазоне 0-255.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $red Красная составляющая нового цвета.
     * @param int $green Зеленая составляющая нового цвета.
     * @param int $blue Синий компонент нового цвета.
     * @return void
     */
    function SetVirtualButtonColor($index, $red, $green, $blue)
    {
    }

    /**
     * Задает положение виртуальной кнопки в координатах экрана. Вы можете использовать GetVirtualWidth и
     * GetVirtualHeight, чтобы найти текущие границы экрана. Кнопка будет центрирована по заданным координатам x и y.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param float $x Координата x новой позиции в координатах экрана.
     * @param float $y Координата y новой позиции в координатах экрана.
     * @return void
     */
    function SetVirtualButtonPosition($index, $x, $y)
    {
    }

    /**
     * Устанавливает прозрачность виртуальной кнопки по заданному индексу. Альфа-значение должно находиться в диапазоне
     * 0-255, где 255 полностью непрозрачно.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $alpha Новое альфа-значение для этой кнопки.
     * @return void
     */
    function SetVirtualButtonAlpha($index, $alpha)
    {
    }

    /**
     * Устанавливает, будет ли виртуальный захватывать события мыши и касания. Если установлено значение 0, он не будет
     * захватывать входные данные и не будет обновлять свое нажатое состояние, он вернется к 0 (вверх). Это не повлияет
     * на видимость виртуальной кнопки, используйте SetVirtualButtonVisible, чтобы изменить ее видимость.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $active 1 для принятия ввода, 0 для его деактивации.
     * @return void
     */
    function SetVirtualButtonActive($index, $active)
    {
    }

    /**
     * Устанавливает режим масштабирования из верхнего левого угла или по центру. По умолчанию вид масштабируется из
     * левого верхнего угла, сохраняя смещение видов в мировых координатах. Например, вид со смещением 20,20 будет
     * сохранять свой верхний левый угол на уровне 20,20 в мировых координатах независимо от того, какое значение
     * масштабирования задано. Однако центрированный зум сохраняет центр вида неподвижным, одновременно масштабируя все
     * остальное вокруг него, что затрудняет оценку значения смещения. В этом режиме верхний левый угол будет
     * находиться только на уровне 20,20, когда значение масштабирования равно 1,0, для других значений масштабирования
     * верхний левый угол будет масштабирован в сторону от точки смещения. Например, предположим, что размер мира
     * составляет 100 100 единиц, уровень масштабирования-1,0, а смещение вида-0,0. Вид будет отображать мировые
     * координаты от 0,0 (в верхнем левом углу) до 100,100 (в нижнем правом углу), со значением масштабирования 2,0 и
     * верхним левым масштабированием вид теперь будет показывать мировые координаты от 0,0 до 50,50 в том же
     * пространстве, что делает все больше. При центрированном масштабировании вид вместо этого будет показывать от
     * 25,25 до 75,75, сохраняя центр вида над точкой 50,50 в мировых координатах.
     *
     * @param int $mode 0=вверху слева, 1=по центру
     * @return void
     */
    function SetViewZoomMode($mode)
    {
    }

    /**
     * Масштабирование видового экрана относительно окружающего мира, например, масштабирование вида 2.0 удвоит размер
     * всего, что в данный момент находится в поле зрения. Значение 1.0 возвращает все к нормальному размеру.
     * Использование этой команды автоматически отключит четыре физические стены, окружающие экран. Вы также можете
     * зафиксировать спрайты на экране, чтобы они не меняли размер, используя FixSpriteToScreen. Эта команда может
     * масштабироваться либо в направлении верхнего левого угла вида, либо в направлении центра вида, см.
     *
     * @param float $zoom Уровень масштабирования для прокрутки спрайтов
     * @return void
     */
    function SetViewZoom($zoom)
    {
    }

    /**
     * Устанавливает громкость видео от 0 (приглушенный звук) до 100 (полная громкость)
     *
     * @param float $volume Громкость видео в диапазоне 0-100.
     * @return void
     */
    function SetVideoVolume($volume)
    {
    }

    /**
     * Ищет видео в заданной позиции. Это не гарантирует 100% точности, устройство может выбрать поиск ближайшего
     * ключевого кадра, который может быть до 10 секунд до или после выбранного вами времени.
     *
     * @param float $seconds Позиция в видео к которой нужно стремиться
     * @return void
     */
    function SetVideoPosition($seconds)
    {
    }

    /**
     * Смещение видового экрана относительно окружающего мира, например, смещение вида 0,20 переместит экран вниз на 20
     * пикселей, показывая любой спрайт, который ранее был расположен чуть ниже нижней части экрана. Это может быть
     * полезно для прокрутки игр, где вы хотите переместить вид через уровень. Использование этой команды автоматически
     * отключит четыре физические стены, окружающие экран. Вы также можете закрепить спрайты на экране так, чтобы они
     * двигались вместе с ним, используя FixSpriteToScreen. Значения смещения вида позиционируют верхний левый угол
     * вида в мире, в то время как SetViewZoom определяет, какую часть мира может видеть вид.
     *
     * @param float $x Смещение x для вида
     * @param float $y Смещение y для вида
     * @return void
     */
    function SetViewOffset($x, $y)
    {
    }

    /**
     * Устанавливает ширину, высоту и положение видео во время его воспроизведения. Может быть вызван до или во время
     * воспроизведения. Координаты находятся в координатах экрана AGK, основанных на выбранном вами виртуальном
     * разрешении. Соотношение сторон не сохраняется и будет растянуто в соответствии с выбранными вами размерами.
     * Чтобы найти фактический размер видео в пикселях, используйте GetVideoWidth и GetVideoHeight. Исключением из
     * этого правила являются окна, которые всегда сохраняют соотношение сторон исходного видео и добавляют черные
     * границы там, где это необходимо.
     *
     * @param float $x Координата x для позиционирования верхнего левого угла видео
     * @param float $y Координата y для позиционирования верхнего левого угла видео
     * @param float $width Ширина для отображения видео
     * @param float $height Высота для отображения видео
     * @return void
     */
    function SetVideoDimensions($x, $y, $width, $height)
    {
    }

    /**
     * Заполняет указанный вектор.
     *
     * @param int $vectorID Идентификатор вектора
     * @param float $x x компонент вектора
     * @param float $y Компонент y вектора
     * @param float $z z компонент вектора
     * @return void
     */
    function SetVector3($vectorID, $x, $y, $z)
    {
    }

    /**
     * Устанавливает, следует ли включать или выключать вертикальную синхронизацию. Это предпочтительный метод
     * ограничения частоты кадров, поскольку он будет связывать частоту кадров с частотой обновления монитора и
     * избегать разрыва или заикания. Использование этой команды с режимом 1 переопределит любую заданную в данный
     * момент частоту обновления из SetSyncRate, в противном случае эти две команды будут бороться друг с другом за
     * контроль частоты кадров, вместо этого AGK будет использовать частоту обновления VSync, которая обычно составляет
     * 60 кадров в секунду, но зависит от монитора. В Linux, Mac и HTML5 вы можете использовать значение больше 1 для
     * пропуска обновлений, например, если частота обновления монитора составляет 60 Гц, то значение режима 1 ограничит
     * приложение до 60 кадров в секунду, но значение режима 2 пропустит каждое другое обновление, которое ограничит
     * приложение до 30 кадров в секунду.
     *
     * @param int $mode 1, чтобы включить vsync, 0, чтобы выключить его.
     * @return void
     */
    function SetVSync($mode)
    {
    }

    /**
     * Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров текстового
     * объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью
     * PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для текста, текст будет расположен здесь, когда начнется
     *     воспроизведение
     * @param float $endY Конечное значение Y для текста, текст будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении текста от начала к концу
     * @return void
     */
    function SetTweenTextY($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     * Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров текстового
     * объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью
     * PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для текста, текст будет расположен здесь, когда начнется
     *     воспроизведение
     * @param float $endX Конечное значение X для текста, текст будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при перемещении текста от beginX к EndX
     * @return void
     */
    function SetTweenTextX($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     * Задает параметр Размера заданного идентификатора анимации. Анимация может изменять несколько параметров
     * текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции.
     * Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с
     * помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginS Начальное значение размера текста, текст будет иметь этот размер при запуске
     *     воспроизведения
     * @param float $endS Значение конечного размера для текста, текст будет иметь этот размер, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении текста от начала к концу
     * @return void
     */
    function SetTweenTextSize($tweenID, $beginS, $endS, $interpolation)
    {
    }

    /**
     * Задает параметр Интервала для заданного идентификатора анимации. Анимация может изменять несколько параметров
     * текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции.
     * Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с
     * помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSP Начальное значение интервала для текста, текст будет иметь этот интервал при запуске
     *     воспроизведения
     * @param float $endSP Значение конечного интервала для текста, текст будет иметь этот интервал при завершении
     *     воспроизведения
     * @param int $interpolation Метод интерполяции при перемещении текста из beginSP в endSP
     * @return void
     */
    function SetTweenTextSpacing($tweenID, $beginSP, $endSP, $interpolation)
    {
    }

    /**
     * Задает красный параметр заданного идентификатора анимации. Анимация может изменять несколько параметров
     * текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции.
     * Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с
     * помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginR Начальный красный цвет для текста, текст будет этого цвета, когда начнется воспроизведение
     * @param int $endR Конец Красный цвет для текста, текст будет этот цвет, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при перемещении текста от beginR к EndR
     * @return void
     */
    function SetTweenTextRed($tweenID, $beginR, $endR, $interpolation)
    {
    }

    /**
     * Устанавливает синий параметр данного идентификатора анимации. Анимация может изменять несколько параметров
     * текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции.
     * Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с
     * помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginB Начальный синий цвет для текста, текст будет этого цвета, когда начнется воспроизведение
     * @param int $endB Конец синий цвет для текста, текст будет этот цвет, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при перемещении текста из beginB в endB
     * @return void
     */
    function SetTweenTextBlue($tweenID, $beginB, $endB, $interpolation)
    {
    }

    /**
     * Задает параметр межстрочного интервала для данного идентификатора анимации. Анимация может изменять несколько
     * параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам
     * одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(),
     * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginLSP Начальное значение межстрочного интервала для текста, текст будет иметь этот интервал при
     *     запуске воспроизведения
     * @param float $endLSP Конечное значение межстрочного интервала для текста, текст будет иметь этот интервал при
     *     завершении воспроизведения
     * @param int $interpolation Метод интерполяции при перемещении текста из beginLSP в endLSP
     * @return void
     */
    function SetTweenTextLineSpacing($tweenID, $beginLSP, $endLSP, $interpolation)
    {
    }

    /**
     * Задает зеленый параметр заданного идентификатора анимации. Анимация может изменять несколько параметров
     * текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции.
     * Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с
     * помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginG Начальный зеленый цвет для текста, текст будет этого цвета, когда начнется воспроизведение
     * @param int $endG Конец Зеленый цвет для текста, текст будет этот цвет, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении текста от начала к концу
     * @return void
     */
    function SetTweenTextGreen($tweenID, $beginG, $endG, $interpolation)
    {
    }

    /**
     * Задает параметр угла заданного идентификатора анимации. Анимация может изменять несколько параметров текстового
     * объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью
     * PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginA Начальное значение угла для текста, текст будет повернут на этот угол при начале
     *     воспроизведения
     * @param float $endA Значение конечного угла для текста, текст будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении текста от начала к концу
     * @return void
     */
    function SetTweenTextAngle($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     * Задает альфа - параметр данного идентификатора tween ID. Анимация может изменять несколько параметров текстового
     * объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью
     * PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginA Начальный альфа-цвет для текста, текст будет этого цвета, когда начнется воспроизведение
     * @param int $endA Конечный альфа-цвет для текста, текст будет этого цвета, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении текста от начала к концу
     * @return void
     */
    function SetTweenTextAlpha($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     * Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или
     * AddTweenChainSprite. Это изменяет положение спрайта, используя его точку смещения, обычно центр спрайта.
     * Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
     * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы
     * отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для спрайта, спрайт будет расположен здесь, когда начнется
     *     воспроизведение
     * @param float $endY Конечное значение Y для спрайта, спрайт будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от начала к концу
     * @return void
     */
    function SetTweenSpriteYByOffset($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     * Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или
     * AddTweenChainSprite. Это изменяет положение спрайта, используя его верхний левый угол. Доступные методы
     * интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(),
     * TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию
     * по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для спрайта, спрайт будет расположен здесь, когда начнется
     *     воспроизведение
     * @param float $endY Конечное значение Y для спрайта, спрайт будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от начала к концу
     * @return void
     */
    function SetTweenSpriteY($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     * Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или
     * AddTweenChainSprite. Это изменяет положение спрайта, используя его точку смещения, обычно центр спрайта.
     * Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(),
     * TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы
     * отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для спрайта, спрайт будет расположен здесь, когда начнется
     *     воспроизведение
     * @param float $endX Конечное значение X для спрайта, спрайт будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginX к EndX
     * @return void
     */
    function SetTweenSpriteXByOffset($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     * Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или
     * AddTweenChainSprite. Это изменяет положение спрайта, используя его верхний левый угол. Доступные методы
     * интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(),
     * TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию
     * по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для спрайта, спрайт будет расположен здесь, когда начнется
     *     воспроизведение
     * @param float $endX Конечное значение X для спрайта, спрайт будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginX к EndX
     * @return void
     */
    function SetTweenSpriteX($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     * Задает параметр sizeY для данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или
     * AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSY Начальное значение sizeY для спрайта, спрайт будет иметь этот размер при запуске игры
     * @param float $endSY Значение end sizeY для спрайта, спрайт будет иметь этот размер, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginSX к endSX
     * @return void
     */
    function SetTweenSpriteSizeY($tweenID, $beginSY, $endSY, $interpolation)
    {
    }

    /**
     * Задает красный параметр заданного идентификатора анимации. Анимация может изменять несколько параметров спрайта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Tween-это просто
     * шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с PlayTweenSprite или
     * AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginR Начальный красный цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда начнется
     *     игра
     * @param int $endR Конечный красный цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginR к EndR
     * @return void
     */
    function SetTweenSpriteRed($tweenID, $beginR, $endR, $interpolation)
    {
    }

    /**
     * Задает параметр sizeX для данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или
     * AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSX Начальное значение sizeX для спрайта, спрайт будет иметь этот размер при запуске
     *     воспроизведения
     * @param float $endSX Значение end sizeX для спрайта, спрайт будет иметь этот размер, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginSX к endSX
     * @return void
     */
    function SetTweenSpriteSizeX($tweenID, $beginSX, $endSX, $interpolation)
    {
    }

    /**
     * Задает зеленый параметр заданного идентификатора анимации. Анимация может изменять несколько параметров спрайта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или
     * AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginG Стартовый зеленый цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда начнется
     *     игра
     * @param int $endG Конечный зеленый цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от начала к концу
     * @return void
     */
    function SetTweenSpriteGreen($tweenID, $beginG, $endG, $interpolation)
    {
    }

    /**
     * Устанавливает синий параметр данного идентификатора анимации. Анимация может изменять несколько параметров
     * спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью
     * PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginB Начальный синий цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда начнется игра
     * @param int $endB Конечный синий цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginB к endB
     * @return void
     */
    function SetTweenSpriteBlue($tweenID, $beginB, $endB, $interpolation)
    {
    }

    /**
     * Задает параметр угла заданного идентификатора анимации. Анимация может изменять несколько параметров спрайта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или
     * AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginA Начальное значение угла для спрайта, спрайт будет повернут на этот угол при запуске игры
     * @param float $endA Значение конечного угла для спрайта, спрайт будет повернут на этот угол, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт вращается от начала до конца
     * @return void
     */
    function SetTweenSpriteAngle($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     * Задает альфа - параметр данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или
     * AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginA Начальный альфа-цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда начнется
     *     воспроизведение
     * @param int $endA Конечный альфа-цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от начала к концу
     * @return void
     */
    function SetTweenSpriteAlpha($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     * Задает параметр Z заданного идентификатора tween ID. Анимация может изменять несколько параметров объекта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или
     * AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginZ Начальное значение Z для объекта, объект будет расположен здесь, когда начнется
     *     воспроизведение
     * @param float $endZ Конечное значение Z для объекта, объект будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginZ к endZ
     * @return void
     */
    function SetTweenObjectZ($tweenID, $beginZ, $endZ, $interpolation)
    {
    }

    /**
     * Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров объекта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или
     * AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для объекта, объект будет расположен здесь, когда начнется
     *     воспроизведение
     * @param float $endY Конечное значение Y для объекта, объект будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от начала к концу
     * @return void
     */
    function SetTweenObjectY($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     * Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров объекта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или
     * AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для объекта, объект будет расположен здесь, когда начнется
     *     воспроизведение
     * @param float $endX Конечное значение X для объекта, объект будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginX к EndX
     * @return void
     */
    function SetTweenObjectX($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     * Задает параметр scaleZ для данного идентификатора tween ID. Шкала абсолютна, поэтому значение 1.0 будет
     * нормальным размером, в то время как 2.0 будет в два раза больше. Анимация может изменять несколько параметров
     * объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью
     * PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSZ Начальное значение масштаба для объекта, объект будет повернут на этот угол при запуске
     *     воспроизведения
     * @param float $endSZ Конечное значение масштаба для объекта, объект будет повернут на этот угол, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginSZ к endSZ
     * @return void
     */
    function SetTweenObjectScaleZ($tweenID, $beginSZ, $endSZ, $interpolation)
    {
    }

    /**
     * Задает параметр scaleY для данного идентификатора tween ID. Шкала абсолютна, поэтому значение 1.0 будет
     * нормальным размером, в то время как 2.0 будет в два раза больше. Анимация может изменять несколько параметров
     * объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью
     * PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSY Начальное значение масштаба для объекта, объект будет повернут на этот угол при запуске
     *     воспроизведения
     * @param float $endSY Конечное значение масштаба для объекта, объект будет повернут на этот угол, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции при движении объекта от начала к концу
     * @return void
     */
    function SetTweenObjectScaleY($tweenID, $beginSY, $endSY, $interpolation)
    {
    }

    /**
     * Задает параметр scaleX для данного идентификатора tween ID. Шкала абсолютна, поэтому значение 1.0 будет
     * нормальным размером, в то время как 2.0 будет в два раза больше. Анимация может изменять несколько параметров
     * объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью
     * PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSX Начальное значение scaleX для объекта, объект будет повернут на этот угол при запуске
     *     воспроизведения
     * @param float $endSX Конечное значение scaleX для объекта, объект будет повернут на этот угол, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginSX к endSX
     * @return void
     */
    function SetTweenObjectScaleX($tweenID, $beginSX, $endSX, $interpolation)
    {
    }

    /**
     * Устанавливает красный параметр данного идентификатора анимации в диапазоне от 0 до 255. Анимация может изменять
     * несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с
     * помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginR Начальный красный цвет для объекта, объект будет этого цвета, когда начнется игра
     * @param int $endR Конечный красный цвет для объекта, объект будет этого цвета, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении объекта от beginR к EndR
     * @return void
     */
    function SetTweenObjectRed($tweenID, $beginR, $endR, $interpolation)
    {
    }

    /**
     * Устанавливает зеленый параметр данного идентификатора анимации в диапазоне от 0 до 255. Анимация может изменять
     * несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с
     * помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginG Стартовый зеленый цвет для объекта, объект будет этого цвета, когда начнется игра
     * @param int $endG Конечный зеленый цвет для объекта, объект будет этого цвета, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении объекта от начала к концу
     * @return void
     */
    function SetTweenObjectGreen($tweenID, $beginG, $endG, $interpolation)
    {
    }

    /**
     * Устанавливает синий параметр данного идентификатора анимации в диапазоне от 0 до 255. Анимация может изменять
     * несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с
     * помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginB Начальный синий цвет для объекта, объект будет этого цвета, когда начнется игра
     * @param int $endB Конечный синий цвет для объекта, объект будет этого цвета, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении объекта от beginB к endB
     * @return void
     */
    function SetTweenObjectBlue($tweenID, $beginB, $endB, $interpolation)
    {
    }

    /**
     * Задает параметр Euler AngleZ заданного идентификатора tween ID. Анимация может изменять несколько параметров
     * объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью
     * PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAZ Начальное значение AngleZ для объекта, объект будет повернут на этот угол при запуске игры
     * @param float $endAZ Значение end AngleZ для объекта, объект будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginAZ к endAZ
     * @return void
     */
    function SetTweenObjectAngleZ($tweenID, $beginAZ, $endAZ, $interpolation)
    {
    }

    /**
     * Задает параметр Euler angleY данного идентификатора tween. Анимация может изменять несколько параметров объекта
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или
     * AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAY Начальное значение угла для объекта, объект будет повернут на этот угол, когда начнется
     *     игра
     * @param float $endAY Значение конечного угла для объекта, объект будет повернут на этот угол, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции при движении объекта от начала до конца
     * @return void
     */
    function SetTweenObjectAngleY($tweenID, $beginAY, $endAY, $interpolation)
    {
    }

    /**
     * Задает параметр Euler AngleX заданного идентификатора tween ID. Анимация может изменять несколько параметров
     * объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью
     * PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAX Начальное значение AngleX для объекта, объект будет повернут на этот угол при запуске игры
     * @param float $endAX Значение end AngleX для объекта, объект будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginAX к endAX
     * @return void
     */
    function SetTweenObjectAngleX($tweenID, $beginAX, $endAX, $interpolation)
    {
    }

    /**
     * Устанавливает альфа - параметр данного идентификатора tween ID в диапазоне от 0 до 255. Анимация может изменять
     * несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с
     * помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(),
     * TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginA Начальный альфа-цвет для объекта, объект будет этого цвета, когда начнется воспроизведение
     * @param int $endA Конечный альфа-цвет для объекта, объект будет этого цвета, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении объекта от начала к концу
     * @return void
     */
    function SetTweenObjectAlpha($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     * Изменяет продолжительность анимации после ее создания. Если анимация выполняется в данный момент или является
     * частью цепочки, которая выполняется в данный момент, то изменение ее продолжительности может привести к
     * неожиданным результатам.
     *
     * @param int $tweenID Идентификатор твина, который нужно изменить, может быть любым типом твина
     * @param float $duration Новая продолжительность использования в секундах
     * @return void
     */
    function SetTweenDuration($tweenID, $duration)
    {
    }

    /**
     * Задает третье целочисленное значение заданного пользовательского идентификатора анимации. Анимация может
     * изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
     * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции
     * -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $begin Отправная точка для этого значения
     * @param int $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomInteger3($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     * Задает четвертое целочисленное значение заданного пользовательского идентификатора анимации. Анимация может
     * изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
     * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции
     * -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $begin Отправная точка для этого значения
     * @param int $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomInteger4($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     * Задает второе целочисленное значение заданного пользовательского идентификатора анимации. Анимация может
     * изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
     * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции
     * -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $begin Отправная точка для этого значения
     * @param int $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomInteger2($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     * Задает первое целочисленное значение заданного пользовательского идентификатора анимации. Анимация может
     * изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
     * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции
     * -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $begin Отправная точка для этого значения
     * @param int $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomInteger1($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     * Устанавливает четвертое плавающее значение заданного пользовательского идентификатора анимации. Анимация может
     * изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
     * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции
     * -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $begin Отправная точка для этого значения
     * @param float $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomFloat4($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     * Устанавливает второе плавающее значение заданного пользовательского идентификатора анимации. Анимация может
     * изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
     * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции
     * -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $begin Отправная точка для этого значения
     * @param float $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomFloat2($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     * Устанавливает третье плавающее значение заданного пользовательского идентификатора анимации. Анимация может
     * изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
     * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции
     * -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $begin Отправная точка для этого значения
     * @param float $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomFloat3($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     * Устанавливает первое плавающее значение заданного пользовательского идентификатора анимации. Анимация может
     * изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод
     * интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
     * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции
     * -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $begin Отправная точка для этого значения
     * @param float $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomFloat1($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     * Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров персонажа
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Позиции символов ar
     * относительно родительского текстового объекта. Твин-это просто шаблон, который может быть применен ко многим
     * символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или
     * AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
     * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции
     * -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для персонажа, символ будет расположен здесь, когда начнется игра
     * @param float $endY Конечное значение Y для символа, символ будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как символ движется от начала к концу
     * @return void
     */
    function SetTweenCharY($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     * Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров персонажа
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Позиции символов ar
     * относительно родительского текстового объекта. Твин-это просто шаблон, который может быть применен ко многим
     * символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или
     * AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(),
     * TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции
     * -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для персонажа, персонаж будет расположен здесь, когда начнется игра
     * @param float $endX Конечное значение X для персонажа, персонаж будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при перемещении символа из beginX в EndX
     * @return void
     */
    function SetTweenCharX($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     * Задает зеленый параметр заданного идентификатора анимации. Анимация может изменять несколько параметров
     * персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных
     * текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(),
     * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginG Начальное зеленое значение для персонажа, персонаж будет этого цвета, когда начнется игра
     * @param int $endG Конечное зеленое значение для персонажа, персонаж будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как символ движется от начала к концу
     * @return void
     */
    function SetTweenCharGreen($tweenID, $beginG, $endG, $interpolation)
    {
    }

    /**
     * Устанавливает синий параметр данного идентификатора анимации. Анимация может изменять несколько параметров
     * персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных
     * текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(),
     * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginB Начальное синее значение для персонажа, персонаж будет этого цвета, когда начнется игра
     * @param int $endB Конечное синее значение для персонажа, персонаж будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции при перемещении символа из beginB в endB
     * @return void
     */
    function SetTweenCharBlue($tweenID, $beginB, $endB, $interpolation)
    {
    }

    /**
     * Задает красный параметр заданного идентификатора анимации. Анимация может изменять несколько параметров
     * персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных
     * текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(),
     * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginR Начальное красное значение для персонажа, персонаж будет этого цвета, когда начнется игра
     * @param int $endR Конечное красное значение для персонажа, персонаж будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции при перемещении символа из beginR в EndR
     * @return void
     */
    function SetTweenCharRed($tweenID, $beginR, $endR, $interpolation)
    {
    }

    /**
     * Задает параметр угла заданного идентификатора анимации. Анимация может изменять несколько параметров персонажа
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных
     * текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(),
     * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginA Начальное значение угла для персонажа, персонаж будет повернут на этот угол, когда начнется
     *     игра
     * @param float $endA Значение конечного угла для персонажа, персонаж будет повернут на этот угол, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции в то время как символ движется от начала к концу
     * @return void
     */
    function SetTweenCharAngle($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     * Задает альфа - параметр данного идентификатора tween ID. Анимация может изменять несколько параметров персонажа
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных
     * текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(),
     * TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(),
     * TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginA Начальное альфа-значение для персонажа, персонаж будет этого цвета, когда начнется игра
     * @param int $endA Конечное альфа-значение для персонажа, персонаж будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как символ движется от начала к концу
     * @return void
     */
    function SetTweenCharAlpha($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     * Перескакивает цепочку твинов в заданное положение в своей временной линии. Если в данный момент воспроизводится
     * цепочка твинов, то интерполяция оценит заданное значение времени и обновит необходимые объекты. Если цепочка
     * tween не воспроизводится, то эта команда не имеет никакого эффекта, так как вызов PlayTweenChain сбрасывает
     * время до 0. Если время случайно падает на задержку между подростками, то интерполяция останется неизменной до
     * тех пор, пока задержка не будет пройдена.
     *
     * @param int $chainID Идентификатор цепочки для изменения
     * @param float $time Время в секундах для перехода в цепочку tween
     * @return void
     */
    function SetTweenChainTime($chainID, $time)
    {
    }

    /**
     * Задает параметр Z заданного идентификатора tween ID. Анимация может изменять несколько параметров камеры
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или
     * AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginZ Начальное значение Z для камеры, камера будет расположена здесь, когда начнется
     *     воспроизведение
     * @param float $endZ Конечное значение Z для камеры, камера будет расположена здесь, когда воспроизведение
     *     закончится
     * @param int $interpolation Метод интерполяции при движении камеры от beginZ к endZ
     * @return void
     */
    function SetTweenCameraZ($tweenID, $beginZ, $endZ, $interpolation)
    {
    }

    /**
     * Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров камеры
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или
     * AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для камеры, камера будет расположена здесь, когда начнется
     *     воспроизведение
     * @param float $endX Конечное значение X для камеры, камера будет расположена здесь, когда воспроизведение
     *     закончится
     * @param int $interpolation Метод интерполяции при движении камеры от beginX к EndX
     * @return void
     */
    function SetTweenCameraX($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     * Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров камеры
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или
     * AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для камеры, камера будет расположена здесь, когда начнется
     *     воспроизведение
     * @param float $endY Конечное значение Y для камеры, камера будет расположена здесь, когда воспроизведение
     *     закончится
     * @param int $interpolation Метод интерполяции в то время как камера движется от начала к концу
     * @return void
     */
    function SetTweenCameraY($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     * Задает параметр Поля зрения заданного идентификатора анимации. Анимация может изменять несколько параметров
     * камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera
     * или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginF Начальное значение FOV для камеры, камера будет иметь это значение FOV при запуске
     *     воспроизведения
     * @param float $endF Конечное значение FOV для камеры, камера будет иметь это значение FOV, когда воспроизведение
     *     закончится
     * @param int $interpolation Метод интерполяции при движении камеры от beginF к endF
     * @return void
     */
    function SetTweenCameraFOV($tweenID, $beginF, $endF, $interpolation)
    {
    }

    /**
     * Задает параметр Euler AngleZ заданного идентификатора tween ID. Анимация может изменять несколько параметров
     * камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera
     * или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAZ Начальное значение угла Эйлера для камеры, камера будет повернута на этот угол при запуске
     *     воспроизведения
     * @param float $endAZ Конечное значение угла Эйлера для камеры, камера будет повернута на этот угол, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции в то время как камера движется от beginAZ к endAZ
     * @return void
     */
    function SetTweenCameraAngleZ($tweenID, $beginAZ, $endAZ, $interpolation)
    {
    }

    /**
     * Задает параметр Euler angleY данного идентификатора tween. Анимация может изменять несколько параметров камеры
     * одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто
     * шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или
     * AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAY Начальное значение угла Эйлера для камеры, камера будет повернута на этот угол, когда
     *     начнется воспроизведение
     * @param float $endAY Конечное значение угла Эйлера для камеры, камера будет повернута на этот угол, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции во время движения камеры от начала до конца
     * @return void
     */
    function SetTweenCameraAngleY($tweenID, $beginAY, $endAY, $interpolation)
    {
    }

    /**
     * Задает параметр Euler AngleX заданного идентификатора tween ID. Анимация может изменять несколько параметров
     * камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это
     * просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera
     * или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(),
     * TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте
     * метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAX Начальное значение угла Эйлера для камеры, камера будет повернута на этот угол при запуске
     *     воспроизведения
     * @param float $endAX Конечное значение угла Эйлера для камеры, камера будет повернута на этот угол, когда игра
     *     закончится
     * @param int $interpolation Метод интерполяции при движении камеры от beginAX к endAX
     * @return void
     */
    function SetTweenCameraAngleX($tweenID, $beginAX, $endAX, $interpolation)
    {
    }

    /**
     * Эта команда устарела, переходы ориентации теперь контролируются устройством.
     *
     * @param int $mode переходный режим для использования.
     * @return void
     */
    function SetTransitionMode($mode)
    {
    }

    /**
     * Обновляет положение X текстового объекта в мировых координатах, по умолчанию текст позиционируется с помощью его
     * верхнего левого угла. При использовании выравнивания по правому краю текст позиционируется с помощью его
     * верхнего правого угла. При использовании выравнивания по центру текст позиционируется с помощью точки на полпути
     * вдоль его верхнего края.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fX Новая позиция X.
     * @return void
     */
    function SetTextX($iTextIndex, $fX)
    {
    }

    /**
     * Обновляет положение Y текстового объекта в мировых координатах, по умолчанию текст позиционируется с помощью его
     * верхнего левого угла. При использовании выравнивания по правому краю текст позиционируется с помощью его
     * верхнего правого угла. При использовании выравнивания по центру текст позиционируется с помощью точки на полпути
     * вдоль его верхнего края.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fY Новая позиция Y.
     * @return void
     */
    function SetTextY($iTextIndex, $fY)
    {
    }

    /**
     * Задает, будет ли текст отрисовываться во время обновления экрана.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $bVisible 1, чтобы нарисовать этот текст, 0, чтобы скрыть его.
     * @return void
     */
    function SetTextVisible($iTextIndex, $bVisible)
    {
    }

    /**
     * Установите прозрачность текста на определенную настройку с выбором без прозрачности, альфа-прозрачности и
     * аддитивного смешивания. По умолчанию текст создается с альфа-прозрачностью.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $mode Режим прозрачности для этого текста: 0=выкл., 1=альфа-прозрачность, 2=аддитивное смешивание
     * @return void
     */
    function SetTextTransparency($iTextIndex, $mode)
    {
    }

    /**
     * Обновляет строку текстового объекта, новый текст будет отображаться при следующем обновлении экрана.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param string $string Новая строка для использования.
     * @return void
     */
    function SetTextString($iTextIndex, $string)
    {
    }

    /**
     * Устанавливает интервал между буквами. Значение 0 не создает зазора между ограничивающими буквами, положительное
     * значение увеличивает этот зазор, отрицательное значение перекрывает буквы. Если каждый символ построен с
     * некоторым пробелом по обе стороны от него в изображении шрифта, то это значение интервала по умолчанию, и эта
     * команда будет увеличивать или уменьшать расстояние от него.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fSpacing Новый интервал для использования.
     * @return void
     */
    function SetTextSpacing($iTextIndex, $fSpacing)
    {
    }

    /**
     * Устанавливает размер текстового объекта, по умолчанию 4. Это значение представляет высоту каждого символа в
     * мировых единицах. Ширина каждого символа зависит от шрифта и рассчитывается в соответствии с заданным размером.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fSize Новый размер текста.
     * @return void
     */
    function SetTextSize($iTextIndex, $fSize)
    {
    }

    /**
     * При рисовании текст привязывается к указанным мировым координатам. Используйте значения 0,0,0,0 для отключения
     * текстовых ножниц
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param float $x Координата x верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $y Координата y верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $x2 Координата x в правом нижнем углу окна для использования в качестве границы клипа.
     * @param float $y2 Координата y в правом нижнем углу окна для использования в качестве границы клипа.
     * @return void
     */
    function SetTextScissor($iTextIndex, $x, $y, $x2, $y2)
    {
    }

    /**
     * Задает максимальную ширину, которую текстовый объект будет использовать для рисования, любые символы, выходящие
     * за пределы этого значения, будут переноситься на новую строку.
     *
     * @param int $iTextIndex Идентификатор изменяемого текстового объекта
     * @param float $width Максимальная ширина, которую будет использовать текст
     * @return void
     */
    function SetTextMaxWidth($iTextIndex, $width)
    {
    }

    /**
     * Обновляет положение текстового объекта в мировых координатах, по умолчанию текст позиционируется с помощью его
     * верхнего левого угла. При использовании выравнивания по правому краю текст позиционируется с помощью его
     * верхнего правого угла. При использовании выравнивания по центру текст позиционируется с помощью точки на полпути
     * вдоль его верхнего края.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fX Новая позиция X.
     * @param float $fY Новая позиция Y.
     * @return void
     */
    function SetTextPosition($iTextIndex, $fX, $fY)
    {
    }

    /**
     * Задает интервал между строками текста. Значение 0 не создает зазора между линиями, положительное значение
     * увеличивает этот зазор, отрицательное значение перекрывает линии. Если каждый символ построен с некоторым
     * пробелом над и под ним в изображении шрифта, то это значение интервала по умолчанию, и эта команда увеличит или
     * уменьшит расстояние от него.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fSpacing Новый интервал для использования.
     * @return void
     */
    function SetTextLineSpacing($iTextIndex, $fSpacing)
    {
    }

    /**
     * Задает максимальное количество символов, которое может быть введено в полноэкранное поле редактирования.
     * Используйте 0 для неограниченного количества.
     *
     * @param int $max Максимальное количество символов.
     * @return void
     */
    function SetTextInputMaxChars($max)
    {
    }

    /**
     * Задает расширенный шрифт, используемый для этого текстового объекта. Расширенный шрифт предназначен для
     * нестандартных символов выше значения ascii 127 и может быть установлен отдельно для стандартных символов, так
     * что вы можете иметь несколько изображений для расширенного набора и базовое изображение для обычных символов
     * шрифта. AGK имеет встроенный расширенный шрифт, который он использует для текстовых объектов с символами от 128
     * до 255, эта команда позволяет переопределить его. Если вы устанавливаете все свои текстовые объекты на один и
     * тот же расширенный шрифт, вам следует использовать вместо этого SetTextDefaultExtendedFontImage, так как это
     * сэкономит некоторое время обработки. Изображение должно содержать все белые символы, окруженные прозрачным
     * альфа-каналом. Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB.
     * Изображение шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины
     * изображение шрифта должно быть выложено в сетку из 16 символов поперек и 8 символов вниз, начиная с символа
     * ascii 32 (пробел) в левом верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 127
     * (DEL) в правом нижнем углу. Ширина изображения должна быть кратна 16, а высота изображения-6. Для переменной
     * ширины изображение должно быть текстурой атласа, сопровождаемой subimages.txt файл, в котором указано
     * расположение каждого символа на изображении. AGK будет искать изображения "32" до "127" включительно в файле
     * подизображений, и любые не найденные будут по умолчанию использовать символ пробела (32). Символы переменной
     * высоты не поддерживаются, и все символы должны быть одинаковой высоты с любым необходимым заполнением,
     * включенным в изображение шрифта. Если этот текстовый объект использует шрифт TrueType, то эта команда не влияет,
     * шрифт TrueType обрабатывает как обычные, так и расширенные символы (unicode).
     *
     * @param int $iTextIndex Идентификатор изменяемого текстового объекта
     * @param int $iImageID Изображение, содержащее новый шрифт.
     * @return void
     */
    function SetTextExtendedFontImage($iTextIndex, $iImageID)
    {
    }

    /**
     * Задает шрифт TrueType, используемый для этого текстового объекта. Шрифт должен быть загружен с помощью LoadFont
     * из файла шрифтов TrueType. Это отличается от старых растровых шрифтов тем, что он поддерживает символы юникода,
     * и символы обычно появляются более четкими на экране всех размеров.  Обратите внимание, что изменение размера
     * текстового объекта, использующего шрифт TrueType, приведет к перерисовке всех символов из файла шрифта на
     * изображение для рисования, для больших размеров текста с использованием сотен различных символов юникода это
     * может быть медленным процессом, но при нормальном использовании он обычно не заметен.  Недавно использованные
     * размеры сохраняются в течение короткого периода времени, поэтому, если вы часто переключаетесь между двумя или
     * тремя размерами текста, вам не нужно будет перерисовывать его, и это будет быстрее.  Используйте идентификатор
     * шрифта 0, чтобы использовать встроенный шрифт TrueType, поддерживающий широкий диапазон символов unicode.
     *
     * @param int $iTextIndex Идентификатор изменяемого текстового объекта.
     * @param int $iFontID Идентификатор используемого шрифта.
     * @return void
     */
    function SetTextFont($iTextIndex, $iFontID)
    {
    }

    /**
     * Устанавливает шрифт, используемый для этого текстового объекта. AGK имеет встроенный шрифт, который он
     * использует для текстовых объектов, это позволяет вам переопределить его. Если вы устанавливаете все свои
     * текстовые объекты на один и тот же шрифт, вам следует использовать вместо этого SetTextDefaultFontImage, так как
     * это сэкономит некоторое время обработки. Изображение должно содержать все белые символы, окруженные прозрачным
     * альфа-каналом. Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB.
     * Изображение шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины
     * изображение шрифта должно быть выложено в сетку из 16 символов поперек и 6 символов вниз, начиная с символа
     * ascii 32 (пробел) в левом верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 127
     * (DEL) в правом нижнем углу. Ширина изображения должна быть кратна 16, а высота изображения-6. Для переменной
     * ширины изображение должно быть текстурой атласа, сопровождаемой subimages.txt файл, в котором указано
     * расположение каждого символа на изображении. AGK будет искать изображения "32" до "127" включительно в файле
     * подизображений, и любые не найденные будут по умолчанию использовать символ пробела (32). Символы переменной
     * высоты не поддерживаются, и все символы должны быть одинаковой высоты с любым необходимым заполнением,
     * включенным в изображение шрифта. Начиная с версии 2.0.20 вы можете использовать SetTextFont для использования
     * шрифтов TrueType вместо растровых шрифтов. Вы должны выбрать один или другой, установка растрового шрифта удалит
     * шрифт Truetype, а установка шрифта TrueType удалит растровый шрифт.
     *
     * @param int $iTextIndex Идентификатор изменяемого текстового объекта
     * @param int $iImageID Изображение, содержащее новый шрифт.
     * @return void
     */
    function SetTextFontImage($iTextIndex, $iImageID)
    {
    }

    /**
     * Устанавливает порядок рисования текста между 0-10000, 0 - передняя часть экрана, 10000 - задняя. Все, что больше
     * 10000, приведет к тому, что текст будет вырезан из поля зрения. По умолчанию текст установлен на глубину 9 и
     * отображается выше всех других спрайтов в сцене, установка большей глубины приведет к сортировке текста в
     * прозрачный список порядка рисования, что может снизить производительность. Используйте глубину 0 для достижения
     * наилучшей производительности.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iDepth На какой глубине должен быть нарисован этот текст.
     * @return void
     */
    function SetTextDepth($iTextIndex, $iDepth)
    {
    }

    /**
     * Устанавливает фильтр изображений для всех текстовых объектов и функций печати, использующих шрифт по умолчанию,
     * когда текстовое изображение больше занимаемого им пространства экрана. Ближайшая фильтрация выбирает ближайший
     * пиксель для отображения и может выглядеть блочной. Линейная фильтрация смешивает 4 ближайших пикселя и может
     * выглядеть размытой.
     *
     * @param int $mode Используемый режим фильтрации: 0=ближайший, 1=линейный
     * @return void
     */
    function SetTextDefaultMagFilter($mode)
    {
    }

    /**
     * Устанавливает фильтр изображения для всех текстовых объектов и функций печати, использующих шрифт по умолчанию,
     * когда текстовое изображение меньше занимаемого им пространства экрана. Ближайшая фильтрация выбирает ближайший
     * пиксель для отображения и может выглядеть блочной. Линейная фильтрация смешивает 4 ближайших пикселя и может
     * выглядеть размытой.
     *
     * @param int $mode Используемый режим фильтрации: 0=ближайший, 1=линейный
     * @return void
     */
    function SetTextDefaultMinFilter($mode)
    {
    }

    /**
     * Устанавливает расширенный шрифт по умолчанию для текстовых объектов. Расширенный шрифт предназначен для
     * нестандартных символов выше значения ascii 127 и может быть установлен отдельно для стандартных символов, так
     * что вы можете иметь несколько изображений для расширенного набора и базовое изображение для обычных символов
     * шрифта. AGK имеет встроенный расширенный шрифт для символов от 128 до 255, который он использует для текстовых
     * объектов, что позволяет переопределить его. Если вы решите переопределить его, вы должны сделать это перед
     * созданием любых текстовых объектов. Вы можете установить шрифт для каждого текста с помощью
     * Settextendedfontimage. Изображение должно содержать все белые символы, окруженные прозрачным альфа-каналом.
     * Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB. Расширенное изображение
     * шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины изображение шрифта
     * должно быть выложено в сетку из 16 символов поперек и 8 символов вниз, начиная с символа ascii 128 в левом
     * верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 255 в правом нижнем углу. Ширина
     * изображения должна быть кратна 16, а высота-8. Для переменной ширины изображение должно быть текстурой атласа,
     * сопровождаемой subimages.txt файл, в котором указано расположение каждого символа на изображении. AGK будет
     * искать изображения "128" до "255" включительно в файле подизображений, а любые не найденные будут по умолчанию
     * использовать символ пробела (32).
     *
     * @param int $iImageID Изображение, содержащее новый шрифт.
     * @return void
     */
    function SetTextDefaultExtendedFontImage($iImageID)
    {
    }

    /**
     * Устанавливает шрифт по умолчанию для текстовых объектов. AGK имеет встроенный шрифт, который он использует для
     * текстовых объектов, это позволяет вам переопределить его. Если вы решите переопределить его, вы должны сделать
     * это перед созданием любых текстовых объектов. Вы можете установить шрифт для каждого текста с помощью
     * SetTextFontImage. Изображение должно содержать все белые символы, окруженные прозрачным альфа-каналом. Полностью
     * прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB. Изображение шрифта может быть либо
     * фиксированной ширины, либо переменной ширины. Для фиксированной ширины изображение шрифта должно быть выложено в
     * сетку из 16 символов поперек и 6 символов вниз, начиная с символа ascii 32 (пробел) в левом верхнем углу и
     * продолжая слева направо, сверху вниз, заканчивая символом ascii 127 (DEL) в правом нижнем углу. Ширина
     * изображения должна быть кратна 16, а высота изображения-6. Для переменной ширины изображение должно быть
     * текстурой атласа, сопровождаемой subimages.txt файл, в котором указано расположение каждого символа на
     * изображении. AGK будет искать изображения "32" до "127" включительно в файле подизображений, и любые не
     * найденные будут по умолчанию использовать символ пробела (32).
     *
     * @param int $iImageID Изображение, содержащее новый шрифт.
     * @return void
     */
    function SetTextDefaultFontImage($iImageID)
    {
    }

    /**
     * Установите зеленый компонент цвета текста. Значение должно находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iGreen Зеленая составляющая цвета.
     * @return void
     */
    function SetTextColorGreen($iTextIndex, $iGreen)
    {
    }

    /**
     * Установите красный компонент цвета текста. Значение должно находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iRed Красная составляющая цвета.
     * @return void
     */
    function SetTextColorRed($iTextIndex, $iRed)
    {
    }

    /**
     * Установите синий компонент цвета текста. Значение должно находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iBlue Синяя составляющая цвета.
     * @return void
     */
    function SetTextColorBlue($iTextIndex, $iBlue)
    {
    }

    /**
     * Установите альфа-компонент цвета текста. Значение должно находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iAlpha Альфа-компонент цвета.
     * @return void
     */
    function SetTextColorAlpha($iTextIndex, $iAlpha)
    {
    }

    /**
     * Установите цвет текста, значения должны быть в диапазоне 0-255. Это приведет к тому, что все символы в тексте
     * будут иметь этот цвет. Вы можете установить отдельные символы с помощью SetTextCharColor.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iRed Красная составляющая цвета.
     * @param int $iGreen Зеленая составляющая цвета.
     * @param int $iBlue Синяя составляющая цвета.
     * @param int $iAlpha Альфа-компонент цвета.
     * @return void
     */
    function SetTextColor($iTextIndex, $iRed, $iGreen, $iBlue, $iAlpha)
    {
    }

    /**
     * Установите положение X отдельного символа относительно позиции текста, установленной ранее. Символ будет
     * расположен в верхнем левом углу. При вызове любой из следующих команд положение всех символов будет сброшено на
     * прямую линию: SetTextPosition, SetTextX, SetTextY, setTextSize, SetTextSpacing, SetTextAlignment.
     * Позиционирование символов внутри текстового объекта более эффективно, чем позиционирование множества небольших
     * текстовых объектов, каждый из которых содержит символ, поскольку все символы могут быть нарисованы в одном
     * вызове рисования.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iCharIndex Индекс символа для изменения, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param float $x Новая позиция X символа относительно текущей позиции текста.
     * @return void
     */
    function SetTextCharX($iTextIndex, $iCharIndex, $x)
    {
    }

    /**
     * Установите положение Y отдельного символа относительно позиции текста, установленной ранее. Символ будет
     * расположен в верхнем левом углу. При вызове любой из следующих команд положение всех символов будет сброшено на
     * прямую линию: SetTextPosition, SetTextX, SetTextY, setTextSize, SetTextSpacing, SetTextAlignment.
     * Позиционирование символов внутри текстового объекта более эффективно, чем позиционирование множества небольших
     * текстовых объектов, каждый из которых содержит символ, поскольку все символы могут быть нарисованы в одном
     * вызове рисования.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iCharIndex Индекс символа для изменения, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param float $y Новая позиция символа Y относительно текущей позиции текста.
     * @return void
     */
    function SetTextCharY($iTextIndex, $iCharIndex, $y)
    {
    }

    /**
     * Задает красный компонент заданного цвета символов. Использование команды SetTextColor переопределит это.
     * Значения должны находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param int $red Новое красное значение для использования
     * @return void
     */
    function SetTextCharColorRed($iTextIndex, $iCharIndex, $red)
    {
    }

    /**
     * Установите положение отдельного символа относительно позиции текста, заданной ранее. Символ будет расположен в
     * верхнем левом углу. При вызове любой из следующих команд положение всех символов будет сброшено на прямую линию:
     * SetTextPosition, SetTextX, SetTextY, setTextSize, SetTextSpacing, SetTextAlignment. Позиционирование символов
     * внутри текстового объекта более эффективно, чем позиционирование множества небольших текстовых объектов, каждый
     * из которых содержит символ, поскольку все символы могут быть нарисованы в одном вызове рисования.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iCharIndex Индекс символа для изменения, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param float $x Новая позиция X символа относительно текущей позиции текста.
     * @param float $y Новая позиция символа Y относительно текущей позиции текста.
     * @return void
     */
    function SetTextCharPosition($iTextIndex, $iCharIndex, $x, $y)
    {
    }

    /**
     * Устанавливает зеленый компонент цвета указанного символа. Использование команды SetTextColor переопределит это.
     * Значения должны находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param int $green Новое зеленое значение для использования
     * @return void
     */
    function SetTextCharColorGreen($iTextIndex, $iCharIndex, $green)
    {
    }

    /**
     * Устанавливает синий компонент цвета указанного символа. Использование команды SetTextColor переопределит это.
     * Значения должны находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param int $blue Новое синее значение для использования
     * @return void
     */
    function SetTextCharColorBlue($iTextIndex, $iCharIndex, $blue)
    {
    }

    /**
     * Задает цвет указанного символа. Использование команды SetTextColor переопределит это. Значения должны находиться
     * в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param int $red красная составляющая нового цвета.
     * @param int $green зеленая составляющая нового цвета.
     * @param int $blue синий компонент нового цвета.
     * @param int $alpha альфа-компонент нового цвета.
     * @return void
     */
    function SetTextCharColor($iTextIndex, $iCharIndex, $red, $green, $blue, $alpha)
    {
    }

    /**
     * Задает альфа-компонент цвета указанного символа. Использование команды SetTextColor переопределит это. Значения
     * должны находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param int $alpha Новое альфа-значение для использования
     * @return void
     */
    function SetTextCharColorAlpha($iTextIndex, $iCharIndex, $alpha)
    {
    }

    /**
     * Установите угол отдельного символа в радианах по часовой стрелке. Персонаж будет вращаться вокруг своего центра.
     * Если какая - либо из следующих команд будет вызвана, то вращение всех символов будет сброшено: SetTextPosition,
     * SetTextX, Settextty, setTextSize, SetTextSpacing, SetTextAlignment.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iCharIndex Индекс символа для изменения, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param float $angle Новый угол в радианах.
     * @return void
     */
    function SetTextCharAngleRad($iTextIndex, $iCharIndex, $angle)
    {
    }

    /**
     * Задает символу полужирный стиль. Это применимо только в том случае, если текст использует шрифт TrueType,
     * установленный с помощью SetTextFont. Если вы используете SetTextString, то этот параметр будет сброшен на 0. Вы
     * можете использовать SetTextBold, чтобы установить всю строку жирным шрифтом.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param int $bold 1, чтобы установить символ как жирный, 0, чтобы установить его как нормальный вес (по
     *     умолчанию)
     * @return void
     */
    function SetTextCharBold($iTextIndex, $iCharIndex, $bold)
    {
    }

    /**
     * Установите угол наклона отдельного символа в градусах по часовой стрелке. Персонаж будет вращаться вокруг своего
     * центра. Если какая - либо из следующих команд будет вызвана, то вращение всех символов будет сброшено:
     * SetTextPosition, SetTextX, Settextty, setTextSize, SetTextSpacing, SetTextAlignment.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iCharIndex Индекс символа для изменения, индексы начинаются с 0, если индекс находится вне
     *     диапазона, он будет проигнорирован.
     * @param float $angle Новый угол в градусах.
     * @return void
     */
    function SetTextCharAngle($iTextIndex, $iCharIndex, $angle)
    {
    }

    /**
     * Обновляет угол наклона текста. Если текст выровнен по левому краю, то он будет вращаться вокруг своего верхнего
     * левого угла. При использовании выравнивания по центру он будет вращаться вокруг точки на полпути вдоль своего
     * верхнего края. При использовании правого выравнивания он будет вращаться вокруг своего верхнего восьмого угла.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fAngleRad Новый угол в радианах.
     * @return void
     */
    function SetTextAngleRad($iTextIndex, $fAngleRad)
    {
    }

    /**
     * Устанавливает все символы в тексте полужирным шрифтом независимо от текущего состояния SetTextCharBold. Этот
     * параметр будет оставаться активным до тех пор, пока он не будет изменен, установка новой текстовой строки не
     * изменит его.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $bold 1
     * @return void
     */
    function SetTextBold($iTextIndex, $bold)
    {
    }

    /**
     * Обновляет угол наклона текста. Если текст выровнен по левому краю, то он будет вращаться вокруг своего верхнего
     * левого угла. При использовании выравнивания по центру он будет вращаться вокруг точки на полпути вдоль своего
     * верхнего края. При использовании правого выравнивания он будет вращаться вокруг своего верхнего восьмого угла.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fAngle Новый угол в градусах.
     * @return void
     */
    function SetTextAngle($iTextIndex, $fAngle)
    {
    }

    /**
     * Устанавливает, как текст должен быть расположен на экране. Выравнивание по левому краю позиционирует текст,
     * используя его верхний левый угол, выравнивание по правому краю позиционирует его, используя его верхний правый
     * угол, а центр позиционирует его, используя точку на полпути вдоль его верхнего края.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param int $iMode Режим выравнивания для использования. 0=слева, 1=в центре, 2=справа
     * @return void
     */
    function SetTextAlignment($iTextIndex, $iMode)
    {
    }

    /**
     * Устанавливает желаемую скорость, с которой кадры будут выводиться на экран, в кадрах в секунду (fps). Кроме
     * того, есть два режима на выбор, которые могут ограничить процессор, первый (mode=0) спит приложение между
     * кадрами, чтобы сэкономить процессор и время автономной работы, где это возможно. Второй (mode=1) использует
     * непрерывный цикл для проверки времени перед следующим кадром, который может быть более точным, но перегружает
     * процессор. Предпочтительным методом ограничения частоты кадров является SetVSync (), который устанавливает
     * частоту обновления на частоту обновления монитора и предотвращает разрыв экрана или заикание. Использование
     * SetSyncRate автоматически отключит VSync, так как две команды будут бороться друг с другом за контроль частоты
     * кадров. Используйте fps 0, чтобы удалить все ограничения и нарисовать кадры как можно быстрее. Это может быть до
     * тысячи кадров в секунду на самых мощных видеокартах. Обратите внимание, что в HTML5 использование SetSyncRate
     * крайне не рекомендуется, так как он использует функцию Javascript setTimeout для синхронизации, что может
     * привести к неточной частоте кадров и заиканию. В HTML5 предпочтительным методом управления частотой кадров
     * является SetVSync.
     *
     * @param float $fps Желаемая частота кадров в кадрах в секунду, 0 для неограниченного числа.
     * @param int $mode 1 для использования, возможно, более точного, но интенсивного метода работы с процессором, 0
     *     (по умолчанию) для экономии процессора и батареи.
     * @return void
     */
    function SetSyncRate($fps, $mode)
    {
    }

    /**
     * Устанавливает новый цвет для глобального направленного света. Значения должны находиться в диапазоне 0-255, но
     * не ограничиваться им. Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать
     * свет.
     *
     * @param int $red Красная составляющая нового цвета.
     * @param int $green Зеленая составляющая нового цвета.
     * @param int $blue Синий компонент нового цвета.
     * @return void
     */
    function SetSunColor(int $red, int $green, int $blue)
    {
    }

    /**
     * Задает направление для глобального направленного света.
     *
     * @param float $vx X-компонент нового направления.
     * @param float $vy Y-компонент нового направления.
     * @param float $vz Z-компонент нового направления.
     * @return void
     */
    function SetSunDirection(float $vx, float $vy, float $vz)
    {
    }

    /**
     * Устанавливает, светит ли глобальный направленный свет или нет.
     *
     * @param int $active 1, чтобы активировать его, 0, чтобы деактивировать
     * @return void
     */
    function SetSunActive($active)
    {
    }

    /**
     * Немедленно позиционирует указанный спрайт в заданные мировые координаты Y. Мировая система координат по
     * умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно
     * изменить с помощью SetVirtualResolution). Эта команда позиционирует спрайт в верхнем левом углу.
     *
     * @param int $iSpriteIndex Идентификатор спрайта в позиции
     * @param float $fY Координата Y для позиционирования спрайта может использовать десятичные значения.
     * @return void
     */
    function SetSpriteY($iSpriteIndex, $fY)
    {
    }

    /**
     * Немедленно помещает указанный спрайт в заданные мировые координаты X. Мировая система координат по умолчанию
     * имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно изменить с
     * помощью SetVirtualResolution). Эта команда позиционирует спрайт в верхнем левом углу.
     *
     * @param int $iSpriteIndex Идентификатор спрайта в позиции
     * @param float $fX Координата X для позиционирования спрайта может использовать десятичные значения.
     * @return void
     */
    function SetSpriteX($iSpriteIndex, $fX)
    {
    }

    /**
     * Масштабирует УФ-координаты спрайтов на заданную величину. Спрайт с УФ-масштабированием на 2 сделает его текстуру
     * вдвое больше обычной. УФ-шкала не влияет на УФ-смещение, выбранное с помощью SetSpriteUVOffset, так что смещение
     * 0,5 в направлении U всегда будет начинать выборку на полпути по текстуре, шкала определяет, как далеко спрайт
     * продолжает выборку. Таким образом, при смещении 0,5 шкала 2 сделает выборку спрайта от 0,5 до 1 вместо 0,5 до
     * 1,5. По умолчанию спрайт настроен на использование УФ-координат от 0,0 до 1,1, используя полное доступное ему
     * изображение. Однако есть несколько случаев, когда это изменяется AGK, чтобы скрыть определенные ограничения.
     * Если текстура, назначенная спрайту, не имеет степени 2 ширины или высоты, изображение увеличивается в размере до
     * тех пор, пока оно не станет степенью 2 размера, а УФ-координаты для спрайта уменьшаются так, что спрайт
     * использует только ту часть текстуры, которая содержит исходное изображение. Это происходит потому, что
     * большинство мобильных платформ не поддерживают текстуры, которые не являются силой 2 ширины или высоты. Поэтому
     * смещение УФ-координат спрайта в этом случае сместит использование спрайтом текстуры в неопределенную часть,
     * которая используется в качестве отступа. Кроме того, если спрайт использует изображение, принадлежащее текстуре
     * атласа, УФ-координаты спрайта будут установлены таким образом, чтобы он использовал только ту часть текстуры,
     * которая содержит назначенное ему изображение. Смещение УФ-координат в этом случае сместит использование спрайтом
     * текстуры на другие изображения, которые являются частью текстуры атласа. То же самое можно сказать и о спрайтах,
     * использующих анимацию, содержащуюся в одной текстуре, используя SetSpriteAnimation. Из-за этих возможностей
     * рекомендуется изменять УФ-координаты только на спрайтах, использующих целые изображения (а не текстуры атласа) и
     * имеющих степень 2 размера как по ширине, так и по высоте. С этими ограничениями можно использовать УФ-значения
     * вне 0-1 для успешного зажима или повторения текстуры.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения
     * @param float $scaleU Сумма для масштабирования в направлении U.
     * @param float $scaleV Сумма для масштабирования в направлении V.
     * @return void
     */
    function SetSpriteUVScale($iSpriteIndex, $scaleU, $scaleV)
    {
    }

    /**
     * Задает, виден ли этот спрайт во время рисования. Он все еще может обновлять свою анимацию и физику, которые
     * управляются SetSpriteActive.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $bVisible Видимость этого спрайта, 1 для видимого, 0 для невидимого.
     * @return void
     */
    function SetSpriteVisible($iSpriteIndex, $bVisible)
    {
    }

    /**
     * Смещает УФ - координаты спрайтов на заданную величину. Например, смещение на 0,5 в направлении U заставит спрайт
     * начать выборку текстуры посередине верхней части текстуры, а не в верхнем левом углу, как обычно. Значения UV
     * вне диапазона 0,0 (вверху слева) и 1,1 (внизу справа) могут либо обернуть, либо зажать текстуру, что
     * определяется изображением, назначенным спрайту с помощью SetImageWrapU и SetImageWrapV. Зажим или обертывание не
     * могут быть установлены на основе каждого спрайта. По умолчанию спрайт настроен на использование УФ-координат от
     * 0,0 до 1,1, используя полное доступное ему изображение. Однако есть несколько случаев, когда это изменяется AGK,
     * чтобы скрыть определенные ограничения. Если текстура, назначенная спрайту, не имеет степени 2 ширины или высоты,
     * изображение увеличивается в размере до тех пор, пока оно не станет степенью 2 размера, а УФ-координаты для
     * спрайта уменьшаются так, что спрайт использует только ту часть текстуры, которая содержит исходное изображение.
     * Это происходит потому, что большинство мобильных платформ не поддерживают текстуры, которые не являются силой 2
     * ширины или высоты. Поэтому смещение УФ-координат спрайта в этом случае сместит использование спрайтом текстуры в
     * неопределенную часть, которая используется в качестве отступа. Кроме того, если спрайт использует изображение,
     * принадлежащее текстуре атласа, УФ-координаты спрайта будут установлены таким образом, чтобы он использовал
     * только ту часть текстуры, которая содержит назначенное ему изображение. Смещение УФ-координат в этом случае
     * сместит использование спрайтом текстуры на другие изображения, которые являются частью текстуры атласа. То же
     * самое можно сказать и о спрайтах, использующих анимацию, содержащуюся в одной текстуре, используя
     * SetSpriteAnimation. Из-за этих возможностей рекомендуется изменять УФ-координаты только на спрайтах,
     * использующих целые изображения (а не текстуры атласа) и имеющих степень 2 размера как по ширине, так и по
     * высоте. С этими ограничениями можно использовать УФ-значения вне 0-1 для успешного зажима или повторения
     * текстуры.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения
     * @param float $u Величина смещения UV-координат в направлении U.
     * @param float $v Величина смещения UV-координат в направлении V.
     * @return void
     */
    function SetSpriteUVOffset($iSpriteIndex, $u, $v)
    {
    }

    /**
     * Настраивает УФ-координаты спрайта для создания границы, которая перемещает край спрайта внутрь, подальше от края
     * примененного к нему изображения. Это может быть полезно для субизображений, загруженных из текстуры атласа, где
     * изображения могут быть упакованы очень близко друг к другу. Использование границы гарантирует, что спрайт
     * случайно не возьмет образец из соседнего изображения, вы также можете исправить это, добавив пространство между
     * изображениями в текстуре атласа. По умолчанию спрайт использует границу в 0,5 пикселя, когда его изображение
     * является субизображением, и границу в 0 пикселей, когда оно имеет нормальное изображение. Если вы сами
     * компенсировали это, добавив интервал к изображению атласа, то установка границы на 0 удаляет смещение по
     * умолчанию и создает пиксельное идеальное воспроизведение субизображения. Вы также можете увеличить эту границу,
     * установив границу больше 0,5 пикселя.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $border 0=нет границы, 0,5=смещение на половину пикселя, 1=смещение на один пиксель и т. Д.
     * @return void
     */
    function SetSpriteUVBorder($iSpriteIndex, $border)
    {
    }

    /**
     * Эта команда переопределяет обычные УФ-вычисления спрайтов и позволяет устанавливать их непосредственно для
     * каждой вершины. Обратите внимание, что анимация с использованием листов спрайта или текстур атласа не будет
     * работать при использовании этой команды, а функции УФ-смещения и масштабирования не будут иметь никакого
     * эффекта. У вас есть полный контроль над УФ-координатами. Чтобы отменить это, используйте ResetSpriteUV для
     * возврата к вычисленным UV-координатам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $u1 U-координата верхней левой вершины.
     * @param float $v1 V-координата верхней левой вершины.
     * @param float $u2 U-координата нижней левой вершины.
     * @param float $v2 V-координата нижней левой вершины.
     * @param float $u3 U-координата верхней правой вершины.
     * @param float $v3 V-координата верхней правой вершины.
     * @param float $u4 U-координата нижней правой вершины.
     * @param float $v4 V-координата нижней правой вершины.
     * @return void
     */
    function SetSpriteUV($iSpriteIndex, $u1, $v1, $u2, $v2, $u3, $v3, $u4, $v4)
    {
    }

    /**
     * Устанавливает анимацию спрайта на заданную скорость, может использоваться во время работы анимации. Можно
     * установить значение 0, чтобы временно приостановить анимацию.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $fFps скорость, с которой спрайт должен обновляться, кадры спрайта будут пропущены, если частота
     *     кадров спрайта слишком высока по сравнению с частотой кадров игры.
     * @return void
     */
    function SetSpriteSpeed($iSpriteIndex, $fFps)
    {
    }

    /**
     * Устанавливает спрайту новую ширину и высоту. В системе координат по умолчанию ширина и высота 100 100 будут
     * заполнять весь рисуемый экран (это можно изменить с помощью SetVirtualResolution). Если задано значение width
     * или height, а другое значение равно -1, то значение -1 будет пересчитано для поддержания соотношения сторон
     * изображения, чтобы оно не выглядело растянутым. Если и ширина, и высота равны -1, то спрайт возьмет ширину
     * назначенного изображения и вычислит его высоту, чтобы оно не растягивалось. Эта функция пересчитывает форму
     * столкновения спрайта, что может быть дорогостоящим процессом для круговых и полигональных фигур. Более
     * эффективный способ изменить размер спрайта - масштабировать его с помощью функции SetSpriteScale. Эта функция
     * сбрасывает масштаб спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения.
     * @param float $width ширина, используемая для спрайта, используйте минус 1, чтобы вычислить это значение.
     * @param float $height высота, используемая для спрайта, используйте минус 1, чтобы вычислить это значение.
     * @return void
     */
    function SetSpriteSize($iSpriteIndex, $width, $height)
    {
    }

    /**
     * Включает специальный режим рендеринга, который удерживает спрайт только на целых пикселях, чтобы он не рисовал
     * себя через границы пикселей, что может вызвать мерцание при перемещении спрайта по экрану. Как следствие, это
     * может привести к тому, что спрайт будет прыгать с одного пикселя на другой, а не плавно перемещаться по экрану.
     * Если спрайт имеет альфа-смешанные пиксели вдоль своего края, то привязка не требуется и может быть отключена. По
     * умолчанию эта функция отключена.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $snap 1, чтобы включить привязку, 0, чтобы выключить ее
     * @return void
     */
    function SetSpriteSnap($iSpriteIndex, $snap)
    {
    }

    /**
     * Установите прозрачность спрайта на определенную настройку с выбором без прозрачности, альфа-прозрачности и
     * аддитивного смешивания. По умолчанию спрайты создаются с альфа-прозрачностью, но если вам это не нужно,
     * рекомендуется отключить прозрачность для повышения производительности.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $mode Режим прозрачности для этого спрайта: 0=выкл., 1=альфа-прозрачность, 2=аддитивное смешивание
     * @return void
     */
    function SetSpriteTransparency($iSpriteIndex, $mode)
    {
    }

    /**
     * Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений,
     * тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты
     * настроены на использование формы коробки, которая является самой быстрой для настройки. Полигон определяется
     * набором точек (от 2 до 12) относительно смещения текущего спрайта. Например, точка 0,0 будет центрирована на
     * точке смещения спрайта, любое другое значение будет смещено от этой точки. Точки определяются по одной за раз,
     * вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен numPoints-1, фигура
     * будет создана с использованием ранее определенных точек. Как только вы начнете определять точки, вы должны
     * завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой фигуры. По
     * умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете
     * установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой
     * фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда
     * изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете
     * добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $numPoints Количество точек, используемых в полигоне, не менее 2, не более 12.
     * @param int $index Индекс точки для установки, если он равен numPoints-1, то будет создана фигура
     * @param float $x X координата добавляемого полигона
     * @param float $y Y координата добавляемого полигона
     * @param int $shapeID Идентификатор изменяемой фигуры, первая фигура-ID 1, 0=удалить существующие фигуры и
     * заменить их этой новой(необязательный параметр)
     * @return void
     */
    function SetSpriteShapePolygon(int $iSpriteIndex, int $numPoints, int $index, float $x, float $y, $shapeID = null)
    {
    }

    /**
     * Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений,
     * тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты
     * настроены на использование формы коробки, которая является самой быстрой для настройки. Окружность определяется
     * путем указания ее центральной точки относительно текущего смещения спрайта и радиуса. Например, если круг должен
     * быть центрирован в точке смещения спрайта, он будет указан в позиции 0,0. Любое другое значение будет смещать
     * круг от спрайта. Радиус определяется в координатах x, поскольку мировые координаты не обязательно представляют
     * размер элементов на экране (например, 10 единиц в X могут быть не такими же видимыми размерами, как 10 единиц в
     * Y). По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете
     * установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой
     * фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда
     * изменяет только существующие фигуры, вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Координата X центра окружности в спрайтовом пространстве.
     * @param float $y Координата Y центра окружности в спрайтовом пространстве.
     * @param float $radius Радиус окружности.
     * @param null|int $shapeID Идентификатор изменяемой фигуры, первая фигура-ID 1, 0=удалить существующие фигуры и
     *     заменить их этой новой (необязательный параметр)
     * @return void
     */
    function SetSpriteShapeCircle(int $iSpriteIndex, float $x, float $y, float $radius, $shapeID =null)
    {
    }

    /**
     * Переопределяет текущую автоматически сгенерированную форму для использования в физике. Обычное тестирование
     * столкновений и попаданий спрайтов не работает с формой цепи, это только для физики. Форма может быть установлена
     * без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является
     * самой быстрой для настройки. Цепочка определяется набором точек (не менее 2) относительно смещения текущего
     * спрайта. Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено
     * от этой точки. Цепи являются жесткими и могут быть использованы для создания полых вогнутых полигонов или
     * 2D-ландшафтов. Установите параметр loop равным 1, чтобы соединить два конца цепочки вместе, создав полый
     * многоугольник. Точки определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с
     * 0. Как только индекс равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как
     * только вы начнете определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем
     * определять точки для любой другой фигуры. Использование shapeID 0 удаляет все другие фигуры, назначенные
     * спрайту, и заменяет его этим. Вы можете установить фигуры по отдельности, указав shapeID больше 0.
     * Идентификаторы фигур начинаются с 1 для первой фигуры. Эта команда изменяет только существующие фигуры, по
     * умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с
     * помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $numPoints Количество точек для использования в цепочке, мин 2, не более.
     * @param int $index Индекс точки для установки, если он равен numPoints-1, то будет создана фигура
     * @param int $loop 1, чтобы соединить два конца цепи вместе, 0, чтобы оставить их несвязанными
     * @param float $x X координата добавляемого полигона
     * @param float $y Y координата добавляемого полигона
     * @param int $shapeID Идентификатор изменяемой фигуры, первая фигура-ID 1, 0=удалить существующие фигуры и
     *     заменить их этой новой
     * @return void
     */
    function SetSpriteShapeChain(int $iSpriteIndex, int $numPoints, int $index, int $loop, float $x, float $y, int $shapeID)
    {
    }

    /**
     * Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений,
     * тестировании ударов и физике. Фигуру можно задать без включения физики, и по умолчанию все спрайты настроены на
     * использование формы коробки, которая является самой быстрой для настройки. Поле определяется путем указания его
     * верхних левых и нижних правых координат в пространстве спрайта относительно смещения спрайта, по умолчанию это
     * центр спрайта. Например, если текущее смещение спрайта равно 0,0, то верхний левый угол коробки будет равен 0,0,
     * но если смещение спрайта равно середине спрайта (по умолчанию), то верхний левый угол будет
     * равен-width/2,-height/2. Вы также можете указать угол смещения коробки относительно текущего поворота спрайта.
     * По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете
     * установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой
     * фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда
     * изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете
     * добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата X верхнего левого угла нового окна в пространстве спрайтов.
     * @param float $y Координата Y верхнего левого угла нового окна в пространстве спрайтов.
     * @param float $x2 Координата X в правом нижнем углу нового окна в пространстве спрайтов.
     * @param float $y2 Координата Y в правом нижнем углу нового окна в пространстве спрайтов.
     * @param float $angle Угол коробки в радианах.
     * @param int|null $shapeID Идентификатор изменяемой фигуры, первая фигура-ID 1, 0=удалить существующие фигуры и
     *     заменить их этой новой
     * @return void
     */
    function SetSpriteShapeBox(int $iSpriteIndex, float $x, float $y, float $x2, float $y2, float $angle, int $shapeID = null)
    {
    }


    /**
     * Задает текущую форму для использования в обнаружении столкновений, тестировании ударов и физике. Форма может
     * быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки,
     * которая является самой быстрой для настройки. Если вы выберете no shape (0), то любая существующая фигура будет
     * удалена, а при тестировании хита вместо нее будут использоваться размеры спрайта. Команды, требующие формы,
     * такие как GetspriteCollision, будут генерировать прямоугольную форму для спрайта, если она не существует.
     * Параметр shape позволяет определить, какой тип ограничительной рамки должна использовать система для обнаружения
     * коллизий. Круг создаст идеальный круг, центрированный в точке вращения спрайта и достаточно большой, чтобы
     * охватить видимые пиксели спрайта. Box создаст прямоугольник по краям спрайта, независимо от того, видны пиксели
     * или нет. Полигон создаст плотно прилегающий выпуклый полигон вокруг видимых пикселей спрайта, причем видимый
     * пиксель будет определен как один с альфа-значением больше 128. Эта функция не будет работать с фиктивными
     * спрайтами, так как при вычислении фигуры нет изображения, в этих случаях фигуры должны быть заданы вручную с
     * помощью SetSpriteShapeBox, SetSpriteShapeCircle или SetSpriteShapePolygon. По умолчанию установка фигуры удаляет
     * все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав
     * shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих
     * фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, по умолчанию
     * все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд
     * AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $shape Форма, используемая для этого спрайта, 0=нет формы, 1=круг, 2=коробка, 3=многоугольник
     * @param int|null $shapeID Идентификатор изменяемой фигуры, первая фигура-ID 1, 0=удалить существующие фигуры и
     * заменить их этой новой(необязательный параметр)
     * @return void
     */
    function SetSpriteShape(int $iSpriteIndex, int $shape, int $shapeID = null)
    {
    }


    /**
     * Устанавливает шейдер, используемый для рисования этого спрайта, загруженный с помощью LoadSpriteShader или
     * LoadShader. По умолчанию спрайтам присваивается внутренний шейдер, который может обрабатывать 1 текстуру и цвет.
     * Если вы используете идентификатор шейдера 0, спрайту присваивается внутренний шейдер.
     *
     * @param int $spriteID Идентификатор спрайта для изменения.
     * @param int $shaderID Идентификатор используемого шейдера.
     * @return void
     */
    function SetSpriteShader($spriteID, $shaderID)
    {
    }

    /**
     * Устанавливает масштаб спрайта как абсолютное кратное его исходному размеру. Например, значение масштаба 2 удвоит
     * размер спрайта, в то время как значение 1 вернет его к исходному размеру. Эта функция масштабируется от центра
     * вращения спрайта (его текущей точки смещения), поэтому любое увеличение размера будет держать точку смещения
     * неподвижной, в то время как все четыре стороны расширяются от нее. Для масштабирования из верхнего левого угла
     * используйте SetSpriteScale.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Значение для масштабирования спрайта в направлении X.
     * @param float $y Значение для масштабирования спрайта в направлении Y.
     * @return void
     */
    function SetSpriteScaleByOffset($iSpriteIndex, $x, $y)
    {
    }

    /**
     * При рисовании спрайт привязывается к указанным мировым координатам. Используйте значения 0,0,0,0, чтобы
     * отключить ножницы спрайта
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Координата x верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $y Координата y верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $x2 Координата x в правом нижнем углу окна для использования в качестве границы клипа.
     * @param float $y2 Координата y в правом нижнем углу окна для использования в качестве границы клипа.
     * @return void
     */
    function SetSpriteScissor($iSpriteIndex, $x, $y, $x2, $y2)
    {
    }

    /**
     * Устанавливает масштаб спрайта как абсолютное кратное его исходному размеру. Например, значение масштаба 2 удвоит
     * размер спрайта, в то время как значение 1 вернет его к исходному размеру. Эта функция масштабируется из верхнего
     * левого угла, поэтому любое увеличение размера будет держать верхнюю и левую стороны неподвижными, в то время как
     * нижняя и правая стороны движутся. Центр вращения спрайтов (его текущая точка смещения) будет масштабироваться
     * вместе со спрайтом. Для масштабирования от точки смещения используйте SetSpriteScaleByOffset.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Значение для масштабирования спрайта в направлении X.
     * @param float $y Значение для масштабирования спрайта в направлении Y.
     * @return void
     */
    function SetSpriteScale($iSpriteIndex, $x, $y)
    {
    }

    /**
     * Сразу же позиционирует указанный спрайт в заданные мировые координаты X,Y. Мировая система координат по
     * умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно
     * изменить с помощью SetVirtualResolution). Эта функция всегда позиционирует спрайт, используя его текущее
     * смещение. Например, если текущее смещение является центром спрайта, эта команда поместит центр спрайта в
     * заданные координаты.
     *
     * @param int $iSpriteIndex Идентификатор спрайта в позиции
     * @param float $fX Координата X для позиционирования спрайта может использовать десятичные значения.
     * @param float $fY координата Y для позиционирования спрайта может использовать десятичные значения.
     * @return void
     */
    function SetSpritePositionByOffset($iSpriteIndex, $fX, $fY)
    {
    }

    /**
     * Сразу же позиционирует указанный спрайт в заданные мировые координаты X,Y. Мировая система координат по
     * умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно
     * изменить с помощью SetVirtualResolution). Эта функция всегда позиционирует спрайт, используя его верхний левый
     * угол, независимо от текущего смещения спрайта. Верхний левый угол, используемый для позиционирования спрайта, не
     * вращается вместе со спрайтом, например, когда спрайт вращается вокруг своего центра, воображаемый верхний левый
     * угол остается фиксированным, и значение положения спрайта не меняется.
     *
     * @param int $iSpriteIndex Идентификатор спрайта в позиции
     * @param float $fX Координата X для позиционирования спрайта может использовать десятичные значения.
     * @param float $fY координата Y для позиционирования спрайта может использовать десятичные значения.
     * @return void
     */
    function SetSpritePosition($iSpriteIndex, $fX, $fY)
    {
    }

    /**
     * Немедленно устанавливает скорость спрайта в заданном направлении. Это резкое изменение, которое может показаться
     * неправильным во время физического моделирования, силы и импульсы являются предпочтительным подходом к влиянию на
     * скорость.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $vx x-компонент новой скорости.
     * @param float $vy y-составляющая новой скорости.
     * @return void
     */
    function SetSpritePhysicsVelocity($iSpriteIndex, $vx, $vy)
    {
    }

    /**
     * Прикладывает крутящий момент к вращению спрайта, подобно тому, как прикладывает силу к его движению. Если спрайт
     * ограничен окружающими объектами, он не может вращаться, если крутящий момент не достаточно велик, чтобы
     * переместить и эти объекты. Крутящий момент будет длиться только для этого кадра, чтобы продолжать применять этот
     * крутящий момент, вы должны продолжать вызывать эту функцию. Реакция на крутящий момент зависит от размера
     * объекта, большие объекты будут вращаться медленнее, чем маленькие объекты при том же крутящем моменте.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $torque Размер силы, приложенной к вращению спрайта. может быть отрицательным.
     * @return void
     */
    function SetSpritePhysicsTorque($iSpriteIndex, $torque)
    {
    }


    /**
     * Устанавливает значение реституции (bounciness), которое будет использоваться для этого спрайта во время
     * физических вычислений. Должно быть в диапазоне от 0 до 1. Значения больше 1 приведут к тому, что спрайт наберет
     * энергию от столкновений, которые могут привести к нестабильному результату. По умолчанию это устанавливает все
     * фигуры, назначенные этому спрайту, в одно и то же значение, вместо этого вы можете установить его для каждой
     * фигуры, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает, что они
     * применяются ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $restitution Новая реституционная стоимость.
     * @param int|null $shapeID Идентификатор изменяемой фигуры, 0 для применения значения ко всем фигурам
     * (необязательный параметр)
     * @return void
     */
    function SetSpritePhysicsRestitution(int $iSpriteIndex, float $restitution, int $shapeID)
    {
    }

    /**
     * Настраивает спрайт на автоматическое столкновение с помощью встроенной физической системы. После того как вы
     * настроили спрайт на управление физикой, вы должны использовать SetSpritePosition и SetSpriteAngle экономно, так
     * как они будут прерывать физическое движение спрайта. Вы также можете использовать SetSpritePhysicsVelocity и
     * SetSpritePhysicsAngularVelocity для изменения скорости и направления спрайта, но опять же они будут мешать
     * физическому движению спрайта. Если вы хотите повлиять на положение или вращение физического спрайта, вы должны
     * использовать функции силы и крутящего момента (вращательной силы) там, где это возможно, они будут поддерживать
     * плавное физическое движение. Параметр mode позволяет выбрать, как спрайт должен вести себя в физическом мире.
     * Статическое означает, что он никогда не будет двигаться или вращаться, динамическое означает, что он будет
     * реагировать на все столкновения и силы, с которыми он сталкивается, включая гравитацию и столкновения со
     * статическими объектами. Кинематика-это особый случай, который можно рассматривать как движущееся статическое
     * тело, оно не будет реагировать на столкновения или силы и будет продолжать двигаться с заданной скоростью вечно,
     * но динамические элементы будут реагировать на него и эффективно выталкиваться с пути. Используемая физическая
     * форма определяется командой SetSpriteShape, которая должна быть вызвана перед этой командой и дорого изменяется
     * для круговых и полигональных форм, поскольку они восстанавливают форму из пикселей изображения спрайта. После
     * того как вы вызвали эту команду для определения режима спрайта, дальнейшие вызовы будут игнорировать значения
     * режима и она будет только повторно активировать спрайт, который был выключен, так как режим не может быть
     * изменен, пока спрайт находится в физической системе. Если вы хотите изменить режим спрайта, вызовите
     * SetSpritePhysicsDelete, который удалит все его физические настройки, а затем вызовите SetSpritePhysicsOn с новым
     * режимом. Но делать это слишком часто будет замедлять работу системы. Все физические спрайты должны быть мировыми
     * спрайтами (не фиксированными на экране), если только SetViewOffset не установлен на 0,0, и в этом случае это не
     * имеет значения. В противном случае отладочные фигуры не будут выстраиваться в линию, а спрайты из разных
     * пространств просмотра не будут взаимодействовать должным образом.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $mode Физический режим, используемый для этого спрайта, 1=статический, 2=динамический,
     *     3=кинематический
     * @return void
     */
    function SetSpritePhysicsOn($iSpriteIndex, $mode)
    {
    }

    /**
     * Эта команда переопределяет вычисленную массу для этого спрайта и устанавливает ее в выбранное вами значение в
     * килограммах. Установка этого значения слишком низко или слишком высоко может привести к нестабильной симуляции,
     * особенно если очень легкий объект встречается с очень тяжелым. Диапазон значений, который вы должны
     * использовать, зависит от выбранной вами шкалы физики. Внутренне масса по умолчанию для каждого объекта
     * вычисляется на основе его размера. Коробка размером 1 х 1 м будет весить 1 кг, поэтому из-за стандартной шкалы
     * физики 5 коробка размером 5 х 5 в виртуальных единицах весит 1 кг.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $mass Новое массовое значение.
     * @return void
     */
    function SetSpritePhysicsMass($iSpriteIndex, $mass)
    {
    }

    /**
     * Временно отключив физику для этого спрайта, он больше не будет двигаться и реагировать на столкновения или силы.
     * Используйте SetSpritePhysicsOn для реактивации спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @return void
     */
    function SetSpritePhysicsOff($iSpriteIndex)
    {
    }

    /**
     * Установите это значение в true, если спрайт, скорее всего, будет двигаться очень быстро, как пуля, так как затем
     * он будет более тщательно проверяться на столкновение с другими динамическими спрайтами, использование которых
     * без необходимости повлияет на производительность. Это называется непрерывным обнаружением столкновений (CCD) и
     * автоматически применяется к проверке столкновений между этим спрайтом и статическими объектами. Эта команда
     * включает CCD для проверки коллизий между этим спрайтом и динамическими объектами. Это не сработает, если global
     * CCD будет отключен с помощью SetPhysicsCCD.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $bullet 1, чтобы установить этот спрайт в качестве пули, 0, чтобы выключить его.
     * @return void
     */
    function SetSpritePhysicsIsBullet($iSpriteIndex, $bullet)
    {
    }

    /**
     * Установите это значение равным 1, чтобы сделать спрайт сенсорным объектом. Физические датчики обнаруживают
     * столкновения и контакты, но не реагируют на них, они также не влияют ни на что, что попадает в них. Их
     * единственная цель-обнаружение столкновений. Если вы примените это к динамическому телу, оно ни с чем не
     * столкнется и, скорее всего, провалится сквозь пол и будет падать вечно, на него все еще действуют силы. По
     * умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой
     * фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0
     * означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $sensor 1, чтобы установить этот спрайт в качестве датчика, 0, чтобы сделать его нормальным
     *     физическим объектом.
     * @param int|null $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * (необязательный параметр)
     * @return void
     */
    function SetSpritePhysicsIsSensor(int $iSpriteIndex, int $sensor, int $shapeID = null)
    {
    }

    /**
     * Похоже на силу, но применяется только один раз. В то время как силы прилагаются непрерывно в течение долгого
     * времени, постепенно влияя на скорость спрайта, импульс имитирует внезапное попадание спрайта и немедленно
     * изменяет скорость с эквивалентной силой аналогичной силы, приложенной в течение 1 секунды. Импульс состоит из
     * точки в мировых координатах и направления, если точка и направление не совпадают с точкой смещения спрайта, то
     * это приведет к вращению спрайта по мере его перемещения импульсом. Длина вектора импульса определяет его силу.
     * Если спрайт ограничен окружающими объектами, он передаст импульс этим объектам и не сможет двигаться сам.
     * Импульсы придают ускорение объекту относительно его массы, тяжелые объекты будут двигаться меньше, чем легкие
     * объекты с тем же импульсом, приложенным к ним.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Координата X положения импульса в мировых координатах.
     * @param float $y Координата Y положения импульса в мировых координатах.
     * @param float $vx X-составляющая направления импульса.
     * @param float $vy Y-составляющая направления импульса.
     * @return void
     */
    function SetSpritePhysicsImpulse($iSpriteIndex, $x, $y, $vx, $vy)
    {
    }



    /**
     * Устанавливает значение трения, которое будет использоваться для этого спрайта во время физических вычислений.
     * Должно быть в диапазоне от 0 до 1. По умолчанию это устанавливает все фигуры, назначенные этому спрайту, в одно
     * и то же значение, вместо этого вы можете установить его для каждой фигуры, указав shapeID больше 0.
     * Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает, что они применяются ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $friction Новое значение трения.
     * @param int|null $shapeID Идентификатор изменяемой фигуры, 0 для применения значения ко всем фигурам
     * (необязательный параметр)
     * @return void
     */
    function SetSpritePhysicsFriction(int $iSpriteIndex, float $friction, int $shapeID = null)
    {
    }

    /**
     * Применяет силу к спрайту, которая будет длиться только для этого кадра, чтобы продолжать применять эту силу, вы
     * должны продолжать вызывать эту функцию. Сила состоит из точки в мировых координатах и направления, если точка и
     * направление не совпадают с точкой смещения спрайта, то это приведет к вращению спрайта при его перемещении
     * силой. Длина вектора силы определяет его силу. Если спрайт ограничен окружающими объектами, он не может
     * двигаться, если сила не достаточно велика, чтобы переместить и эти объекты. Силы прилагают ускорение к объекту
     * относительно его массы, тяжелые объекты будут двигаться меньше, чем легкие объекты с той же силой, приложенной к
     * ним.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата X положения силы в мировых координатах.
     * @param float $y Координата Y положения силы в мировых координатах.
     * @param float $vx X-составляющая направления силы.
     * @param float $vy Y-составляющая направления силы.
     * @return void
     */
    function SetSpritePhysicsForce($iSpriteIndex, $x, $y, $vx, $vy)
    {
    }

    /**
     * Отключает физику для этого спрайта и удаляет все связанные с ним физические настройки для этого спрайта. Вы
     * можете использовать это для изменения режима или формы спрайта, но регулярное выполнение этого может повлиять на
     * производительность приложения.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @return void
     */
    function SetSpritePhysicsDelete($iSpriteIndex)
    {
    }

    /**
     * Задает значение плотности, которое будет использоваться для данной формы спрайта во время физических вычислений.
     * Значение по умолчанию равно 1.0. Это влияет на расчет массы для данного размера спрайта. Эта команда пересчитает
     * массу и центр масс для этого спрайта. Используйте shapeID 0, чтобы применить эту плотность ко всем фигурам, или
     * укажите идентификатор фигуры больше 0, чтобы применить ее только к этой фигуре. Идентификаторы фигур начинаются
     * с 1 для первой фигуры.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения
     * @param float $density Новое значение плотности по умолчанию равно 1.0
     * @param int $shapeID Идентификатор изменяемой фигуры, 0 для применения значения ко всем фигурам
     * @return void
     */
    function SetSpritePhysicsDensity($iSpriteIndex, $density, $shapeID)
    {
    }

    /**
     * Устанавливает некоторое демпфирование линейного движения спрайта, которое может имитировать что-то вроде
     * сопротивления ветру. Значение 0 означает отсутствие демпфирования, значение 0,75 будет уменьшать вектор скорости
     * наполовину каждую секунду при работе со скоростью 60 кадров в секунду. Более высокие значения приведут к более
     * быстрому снижению скорости.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $damp Новое значение демпфирования.
     * @return void
     */
    function SetSpritePhysicsDamping($iSpriteIndex, $damp)
    {
    }

    /**
     * Задает, разрешено ли физическому моделированию вращать спрайт.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $rotate 1, чтобы разрешить вращение, 0, чтобы предотвратить его.
     * @return void
     */
    function SetSpritePhysicsCanRotate($iSpriteIndex, $rotate)
    {
    }

    /**
     * Устанавливает центр масс (COM) относительно смещения спрайта. По умолчанию AGK вычисляет наилучшее
     * местоположение для COM на основе размера и расположения всех фигур, прикрепленных к спрайту. Установка его на
     * 0,0 поставит COM на точку смещения спрайта (и центр вращения). Если COM сильно отличается от точки смещения,
     * спрайт может показаться нестабильным, так как он будет вести себя как несбалансированный волчок.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата x центра масс.
     * @param float $y Координата y центра масс.
     * @return void
     */
    function SetSpritePhysicsCOM($iSpriteIndex, $x, $y)
    {
    }

    /**
     * Аналогично силе крутящего момента, но приложенной только один раз. В то время как силы прилагаются непрерывно в
     * течение долгого времени, постепенно влияя на скорость спрайта, импульс имитирует внезапное попадание спрайта и
     * немедленно изменяет угловую скорость с эквивалентной мощностью аналогичной силы крутящего момента, приложенной в
     * течение 1 секунды. Если спрайт ограничен окружающими объектами, он не может вращаться, если импульс не
     * достаточно велик, чтобы переместить и эти объекты.  Реакция на импульс зависит от размера объекта, большие
     * объекты будут вращаться медленнее, чем маленькие объекты, получившие тот же импульс.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $impulse Размер силы, приложенной к вращению спрайта. может быть отрицательным.
     * @return void
     */
    function SetSpritePhysicsAngularImpulse($iSpriteIndex, $impulse)
    {
    }

    /**
     * Немедленно устанавливает скорость вращения спрайта в заданном направлении. Это резкое изменение, которое может
     * показаться неправильным во время физического моделирования, крутящий момент и угловые импульсы являются
     * предпочтительным подходом к влиянию на угловую скорость.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $va Новая угловая скорость.
     * @return void
     */
    function SetSpritePhysicsAngularVelocity($iSpriteIndex, $va)
    {
    }

    /**
     * Устанавливает некоторое демпфирование углового движения спрайта, которое может имитировать что-то вроде
     * сопротивления ветру. Значение 0 означает отсутствие демпфирования, значение 0,75 будет уменьшать вектор угловой
     * скорости наполовину каждую секунду при работе со скоростью 60 кадров в секунду. Более высокие значения уменьшат
     * вращение быстрее.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $damp Новое значение демпфирования.
     * @return void
     */
    function SetSpritePhysicsAngularDamping($iSpriteIndex, $damp)
    {
    }

    /**
     * Точка смещения-это точка, вокруг которой будет вращаться спрайт,причем (0,0) - верхний левый угол, а (ширина,
     * высота) - нижний правый угол. Смещение также можно использовать для позиционирования спрайта с помощью
     * SetSpritePositionByOffset, в то время как SetSpritePosition всегда будет позиционировать спрайт с помощью его
     * верхнего левого угла. Если спрайт масштабируется, не забудьте принять во внимание масштаб,спрайт, созданный как
     * 10 на 10 единиц в ширину, масштабированный на 0,5, будет иметь нижний правый угол на уровне 5,5, поэтому
     * расположить смещение в центре означало бы поместить его на 2,5, 2,5, когда спрайт масштабируется обратно, точка
     * смещения будет масштабироваться вместе с ним, чтобы сохранить свое относительное положение. Эта команда вызывает
     * пересчет формы спрайта из-за новой центральной точки, дополнительные формы не пересчитываются, поэтому будут
     * искажены от их первоначального определения. Не рекомендуется вызывать эту команду на спрайте, уже настроенном
     * для физики. Измените смещение перед применением физики или дополнительных фигур.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Расстояние X от верхнего левого угла для смещения точки вращения.
     * @param float $y Расстояние Y от верхнего левого угла до смещения точки поворота.
     * @return void
     */
    function SetSpriteOffset($iSpriteIndex, $x, $y)
    {
    }

    /**
     * Измените изображение спрайта на новое загруженное изображение. Если новое изображение имеет другой размер или
     * форму, чем старое, спрайт может выглядеть искаженным в результате, вы можете исправить это, сбросив размеры
     * спрайта с помощью SetSpriteSize. Если спрайт анимирован, вам также может потребоваться снова вызвать
     * SetSpriteAnimation. В случае круговых и полигональных спрайтов вы можете установить, использует ли спрайт это
     * новое изображение для изменения своей формы столкновения. На форму коробки изменения изображения не влияют.
     * Использование этой команды очистит все анимационные кадры, которые вы установили с помощью любой из команд
     * sprite animation.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iImageIndex Идентификатор изображения, которое будет использоваться для этого спрайта.
     * @param int|null $bUpdateShape Задает, следует ли изменить форму столкновения этого спрайта в соответствии с новым
     * изображением. ( 1 или 0 ) (не обязательный параметр)
     * @return void
     */
    function SetSpriteImage(int $iSpriteIndex, int $iImageIndex, int $bUpdateShape = null)
    {
    }

    /**
     * Назначает этот спрайт группе для фильтрации коллизий (физических или нефизических). В физике спрайты с одним и
     * тем же положительным идентификатором группы всегда будут сталкиваться, в то время как те, которые имеют один и
     * тот же отрицательный идентификатор группы, никогда не будут сталкиваться. Те, у кого идентификатор группы равен
     * нулю (по умолчанию), или отличающиеся идентификаторы групп переходят к проверке фильтра категорий. Если спрайт
     * не настроен на физику, этот тест будет применяться только к базовой фигуре в shapeID 1. По умолчанию это
     * устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав
     * значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить
     * его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $group Идентификатор группы, назначаемый этому спрайту.
     * @param int|null $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * (не обязательный параметр)
     * @return void
     */
    function SetSpriteGroup(int $iSpriteIndex, int $group, int
    $shapeID = null)
    {
    }


    /**
     * Устанавливает спрайт на определенный кадр, кадры начинаются с 1 и заканчиваются на GetSpriteFrameCount
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iFrame Идентификатор кадра, на который должен измениться этот спрайт, имеет немедленный эффект.
     * @return void
     */
    function SetSpriteFrame($iSpriteIndex, $iFrame)
    {
    }

    /**
     * Переворачивает спрайт либо по горизонтали, либо по вертикали (или и то, и другое). Это просто изменяет
     * УФ-координаты так, чтобы спрайт выглядел перевернутым, он не регулирует значения положения или угла. Обратите
     * внимание, что переворачивание как в горизонтальном, так и в вертикальном направлениях одновременно дает
     * видимость поворота на 180 градусов.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $horz 1, чтобы перевернуть спрайт горизонтально слева направо, 0, чтобы сохранить спрайт нормальным.
     * @param int $vert 1, чтобы перевернуть спрайт вертикально сверху вниз, 0, чтобы сохранить спрайт нормальным.
     * @return void
     */
    function SetSpriteFlip($iSpriteIndex, $horz, $vert)
    {
    }

    /**
     * Устанавливает порядок рисования спрайта между 0-10000, 0 - передняя часть экрана, 10000 - задняя. Все, что выше
     * 10000, приведет к тому, что спрайт будет вырезан из поля зрения. По умолчанию спрайты находятся на глубине 10.
     * Если два спрайта занимают одну и ту же глубину, то порядок их рисования не определен, если только SetSortCreated
     * не используется в значении true, и в этом случае спрайты на одной и той же глубине будут нарисованы в том
     * порядке, в котором они были созданы. Для максимальной производительности рекомендуется, чтобы каждый спрайт имел
     * свое собственное значение глубины, если только порядок их рисования не имеет значения, например, физические
     * спрайты, которые обычно не перекрываются. Обратите внимание, что если вы не используете КАКИЕ-либо 3D-объекты и
     * используете глубину спрайта больше 5000, вы должны использовать SetGlobal3DDepth до 10000 для повышения
     * производительности (по существу, выводя все спрайты на переднюю панель 3D-рендера).
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iDepth Глубина, на которой должен быть нарисован этот спрайт.
     * @return void
     */
    function SetSpriteDepth($iSpriteIndex, $iDepth)
    {
    }

    /**
     * Установите синий компонент спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $iBlue Синяя составляющая цвета. Допустимый диапазон-от 0 до 255.
     * @return void
     */
    function SetSpriteColorBlue($iSpriteIndex, $iBlue)
    {
    }

    /**
     * Установите зеленый компонент спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iGreen Зеленая составляющая цвета. Допустимый диапазон-от 0 до 255.
     * @return void
     */
    function SetSpriteColorGreen($iSpriteIndex, $iGreen)
    {
    }

    /**
     * Установите красный компонент спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iRed Красная составляющая цвета. Допустимый диапазон-от 0 до 255.
     * @return void
     */
    function SetSpriteColorRed($iSpriteIndex, $iRed)
    {
    }

    /**
     * Установите альфа-компонент спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iAlpha Альфа-компонент цвета. Допустимый диапазон-от 0 до 255. При использовании значения 0 спрайт
     *     будет невидим. При использовании значения 255 спрайт будет полностью непрозрачным.
     * @return void
     */
    function SetSpriteColorAlpha($iSpriteIndex, $iAlpha)
    {
    }

    /**
     * Установите цвет спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iRed Красная составляющая цвета.
     * @param int $iGreen Зеленая составляющая цвета.
     * @param int $iBlue Синяя составляющая цвета.
     * @param int $iAlpha Альфа-компонент цвета. Допустимый диапазон-от 0 до 255. При использовании значения 0 спрайт
     *     будет невидим. При использовании значения 255 спрайт будет полностью непрозрачным.
     * @return void
     */
    function SetSpriteColor($iSpriteIndex, $iRed, $iGreen, $iBlue, $iAlpha)
    {
    }


    /**
     * Использует побитовую маску, чтобы определить, с какими категориями спрайтов этот спрайт может столкнуться.
     * Спрайты назначаются категориям с помощью SetSpriteCategoryBits. Существует 16 категорий, каждая из которых
     * представлена одним битом в параметре "маска", значение 1 для бита означает, что этот спрайт столкнется со
     * спрайтами из этой категории, и 0-что он не столкнется с этой категорией, независимо от того, к какой категории
     * принадлежит сам этот спрайт. По умолчанию все спрайты принадлежат к категории 1 (0x0001 самый правый бит) и
     * сталкиваются со всеми категориями (0xffff). Если спрайт не настроен на физику, этот тест будет применяться
     * только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же значение, вы
     * можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур
     * начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $mask Побитовая маска категорий, с которой этот спрайт может столкнуться во время физических
     *     вычислений.
     * @param int|null $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * (не обязательный параметр)
     * @return void
     */
    function SetSpriteCollideBits(int $iSpriteIndex, int $mask, int $shapeID = null)
    {
    }

    /**
     * Присваивает спрайту ноль или более категорий для фильтрации столкновений (физические и нефизические). Существует
     * 16 категорий, каждая из которых представлена одним битом в параметре "категории", значение 1 для бита означает,
     * что этот спрайт является частью этой категории, а 0-что он не принадлежит к этой категории. Затем спрайты могут
     * быть настроены на столкновение с определенными категориями с помощью SetSpriteCollideBits независимо от того, к
     * каким категориям они сами принадлежат. По умолчанию все спрайты относятся к категории 1 (0x0001 самый правый
     * бит) и сталкиваются со всеми категориями (0xffff). Если спрайт не настроен на физику, этот тест будет
     * применяться только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же
     * значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы
     * фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $categories Побитовое поле категорий, назначаемое этому спрайту.
     * @param int|null $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * (не обязательный параметр)
     * @return void
     */
    function SetSpriteCategoryBits(int $iSpriteIndex, int $categories, int $shapeID = null)
    {
    }


    /**
     * Устанавливает или удаляет категорию, с которой может столкнуться этот спрайт. Спрайтам присваиваются категории с
     * помощью SetSpriteCategoryBit. Существует 16 категорий, значение 1 для этой категории означает, что этот спрайт
     * столкнется со спрайтами из этой категории, а 0-что он не столкнется с этой категорией, независимо от того, к
     * какой категории принадлежит сам этот спрайт. По умолчанию все спрайты относятся к категории 1 и сталкиваются со
     * всеми категориями. Эта команда похожа на SetSpriteCategoryBits, за исключением того, что эта команда
     * устанавливает одну категорию за раз, в то время как эта команда устанавливает их все сразу, используя битовую
     * маску. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для
     * каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а
     * shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $category Категория, включающая или выключающая столкновение для этого спрайта, должна быть от 1 до
     *     16 включительно.
     * @param int $flag 1, чтобы включить столкновение, 0, чтобы выключить его для этого спрайта.
     * @param int|null $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * (не обзяательный параметр)
     * @return void
     */
    function SetSpriteCollideBit(int $iSpriteIndex, int $category, int $flag, int $shapeID = null)
    {
    }

    /**
     * Назначает или удаляет спрайт из определенной категории. Существует 16 категорий, к которым может принадлежать
     * спрайт, и спрайт может принадлежать к любому числу сразу. Эта команда похожа на SetSpriteCategoryBits, за
     * исключением того, что эта команда устанавливает одну категорию за раз, в то время как эта команда устанавливает
     * их все сразу, используя битовую маску. По умолчанию это устанавливает все фигуры в одно и то же значение, вы
     * можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур
     * начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $category Категория, которую нужно изменить, должна быть от 1 до 16 включительно.
     * @param int $flag 1, чтобы сделать спрайт частью этой категории, 0, чтобы удалить его.
     * @param int|null $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * (не обязательный параметр)
     * @return void
     */
    function SetSpriteCategoryBit(int $iSpriteIndex, int $category, int $flag, int $shapeID = null)
    {
    }

    /**
     * Инициализирует анимацию спрайта кадрами из назначенного ему изображения на основе ширины и высоты кадра. Спрайт
     * будет использовать ширину и высоту кадра для извлечения изображений этого размера из назначенного ему
     * изображения, начиная с верхнего левого угла и перемещаясь слева направо. Когда он достигнет правой части
     * изображения, он снова начнет двигаться на одну строку вниз, снова двигаясь слева направо, пока не будет
     * достигнуто количество кадров или не закончится место на изображении для поиска кадров. Поддерживается сохранение
     * анимационного изображения на текстуре атласа. Эта функция является предпочтительным методом назначения анимации
     * спрайту, поскольку она позволяет избежать дорогостоящих изменений изображения во время рендеринга. Однако если
     * все ваши анимационные кадры являются отдельными изображениями, вы можете использовать AddSpriteAnimationFrame
     * для добавления кадров из изображений по отдельности. Использование SetSpriteImage очистит все анимационные
     * кадры, которые вы установили здесь.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно установить для анимации.
     * @param int $iFrameWidth Ширина кадров в пикселях на изображении.
     * @param int $iFrameHeight Высота кадров в пикселях на изображении.
     * @param int $iFrameCount Количество кадров, которые спрайт должен попытаться извлечь из изображения.
     * @return void
     */
    function SetSpriteAnimation($iSpriteIndex, $iFrameWidth, $iFrameHeight, $iFrameCount)
    {
    }

    /**
     * Немедленно поворачивает указанный спрайт на заданный угол в радианах. По умолчанию спрайты вращаются вокруг
     * своего центра, см. SetSpriteOffset, чтобы изменить это.
     *
     * @param int $iSpriteIndex Идентификатор вращаемого спрайта.
     * @param float $fAng Угол установки спрайта в радианах.
     * @return void
     */
    function SetSpriteAngleRad($iSpriteIndex, $fAng)
    {
    }

    /**
     * Немедленно поворачивает указанный спрайт на заданный угол в градусах. По умолчанию спрайты вращаются вокруг
     * своего центра, см. SetSpriteOffset, чтобы изменить это.
     *
     * @param int $iSpriteIndex Идентификатор вращаемого спрайта.
     * @param float $fAng Угол установки спрайта в градусах.
     * @return void
     */
    function SetSpriteAngle($iSpriteIndex, $fAng)
    {
    }

    /**
     * Добавляет в спрайт дополнительные изображения, которые можно использовать с шейдерами. Набор изображений с
     * помощью SetSpriteImage используется в качестве этапа текстуры 0, и эта команда позволит вам установить этапы от
     * 1 до 7. Эти дополнительные изображения не играют никакой роли в анимации или вычислениях формы. Обратите
     * внимание, что спрайт будет иметь одинаковые УФ-координаты для каждой текстуры, поэтому рекомендуется, чтобы
     * изображения имели одинаковые размеры или использовали мощность 2 изображений, чтобы избежать УФ-преобразования
     * на мобильных устройствах, где изображения могут быть масштабированы.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iImageIndex Идентификатор изображения, которое будет использоваться для этого спрайта.
     * @param int $iStage Индекс используемой стадии текстуры находится в диапазоне от 1 до 7.
     * @return void
     */
    function SetSpriteAdditionalImage($iSpriteIndex, $iImageIndex, $iStage)
    {
    }

    /**
     * Устанавливает, обновляет ли этот спрайт свою анимацию и физику каждый кадр, спрайт может быть видимым или нет,
     * что контролируется SetSpriteVisible.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $bActive Установите значение 1, если этот спрайт должен быть обновлен, и 0, если нет.
     * @return void
     */
    function SetSpriteActive($iSpriteIndex, $bActive)
    {
    }

    /**
     * Устанавливает скорость речи, где 1.0-нормальная скорость, 2.0-двойная скорость, 0.5-половинная скорость и так
     * далее.  В настоящее время работает только на iOS и Android.
     *
     * @param float $rate Скорость произнесения текста по умолчанию равна 1,0
     * @return void
     */
    function SetSpeechRate($rate)
    {
    }

    /**
     * Задает язык, используемый при произнесении текста по голосовому идентификатору. Идентификатор можно найти с
     * помощью GetSpeechVoiceID и необходим, когда несколько голосов имеют один и тот же язык, но с разными акцентами.
     *
     * @param string $sID Язык, используемый для произнесения текста, по умолчанию является текущим языком устройства.
     * @return void
     */
    function SetSpeechLanguageByID($sID)
    {
    }

    /**
     * Задает язык, используемый при произнесении текста, например "en_GB" для британского английского, "en_US" для
     * американского английского, "fr_FR" для французского и т. Д. Если языковой движок в данный момент не находится на
     * устройстве, то устройство попытается загрузить его при следующем вызове Speak, что может привести к задержке
     * перед произнесением этого текста. Если загрузка завершится неудачно или подключение к Интернету будет
     * недоступно, то будет использоваться языковой движок по умолчанию для текущего устройства.  В настоящее время
     * работает только на iOS и Android.
     *
     * @param string $lang Язык, используемый для произнесения текста, по умолчанию является текущим языком устройства.
     * @return void
     */
    function SetSpeechLanguage($lang)
    {
    }

    /**
     * Устанавливает основную громкость звука для всех звуков. Отдельные объемы звука останутся нетронутыми, но все
     * объемы умножаются на основную громкость звука, позволяя использовать такие функции, как затухание.
     *
     * @param int $iVol Основная громкость звука для всех звуков.
     * @return void
     */
    function SetSoundSystemVolume($iVol)
    {
    }

    /**
     * Устанавливает текущий объем указанного экземпляра в диапазоне от 0 до 100. Идентификатор экземпляра - это
     * значение, возвращаемое из PlaySound при инициировании воспроизведения звука.
     *
     * @param int $iID Идентификатор экземпляра для изменения
     * @param int $vol Новый том экземпляра, от 0 до 100
     * @return void
     */
    function SetSoundInstanceVolume($iID, $vol)
    {
    }

    /**
     * Устанавливает текущую скорость воспроизведения указанного экземпляра, где 1.0-нормальная скорость, 2.0 - двойная
     * скорость и так далее. Не все устройства гарантированно поддерживают изменение скорости воспроизведения.
     * Используйте GetSoundMaxRate и GetSoundMinRate для проверки допустимых диапазонов для текущего устройства, любые
     * значения вне этого диапазона будут зажаты. Идентификатор экземпляра - это значение, возвращаемое из PlaySound
     * при инициировании воспроизведения звука.
     *
     * @param int $iID Идентификатор экземпляра для изменения
     * @param float $rate Новая скорость воспроизведения экземпляра
     * @return void
     */
    function SetSoundInstanceRate($iID, $rate)
    {
    }

    /**
     * Устанавливает текущий баланс указанного экземпляра, при этом 0 находится по центру, -1.0-все на левом динамике,
     * а 1.0-все на правом динамике, любые значения вне этого диапазона будут зажаты. Это лучше всего работает с
     * моно-звуками, но может быть применено и к стереозвукам. Идентификатор экземпляра - это значение, возвращаемое из
     * PlaySound при инициировании воспроизведения звука.
     *
     * @param int $iID Идентификатор экземпляра для изменения
     * @param float $balance Новый баланс экземпляра
     * @return void
     */
    function SetSoundInstanceBalance($iID, $balance)
    {
    }

    /**
     * Устанавливает, будет ли приложение разрешать фоновую музыку из других приложений продолжать воспроизведение
     * (режим=0) или отключать другие приложения, пока это приложение активно (режим=1). Обратите внимание, что в
     * режиме 0 устройство считает звук вашего приложения несущественным, поэтому будет отключено, если звонок
     * устройства установлен в бесшумное состояние. Это работает только на iOS.
     *
     * @param int $mode Используемый звуковой режим (по умолчанию=0)
     * @return void
     */
    function SetSoundDeviceMode($mode)
    {
    }

    /**
     * Задает, должен ли AGK сортировать прозрачные спрайты по глубине при рисовании. Это сначала рисует спрайты в
     * задней части экрана, чтобы достичь правильного результата смешивания, когда прозрачные спрайты перекрываются. Он
     * включен по умолчанию, но если ваши прозрачные спрайты гарантированно не перекрываются, вы можете отключить его,
     * чтобы повысить производительность. Эта команда устарела, сортировка теперь обрабатывается автоматически.
     *
     * @param int $sort Установите значение 1 для сортировки прозрачных спрайтов по глубине, 0-для отключения
     *     прозрачной сортировки.
     * @return void
     */
    function SetSortTransparentDepth($sort)
    {
    }

    /**
     * Задает, должен ли AGK сортировать спрайты по текстуре при рисовании, чтобы ограничить количество изменений
     * текстуры. Это улучшит производительность на устройствах, которые плохо справляются с частыми изменениями
     * состояния, но может снизить производительность, если текстуры на спрайтах часто меняются. По умолчанию он
     * выключен, но если вы не меняете текстуры спрайтов или используете текстуры атласа, рекомендуется включить его.
     * Эта команда устарела, сортировка теперь обрабатывается автоматически.
     *
     * @param int $sort Установите значение 1 для сортировки спрайтов по текстуре. по умолчанию=0
     * @return void
     */
    function SetSortTextures($sort)
    {
    }

    /**
     * Задает, должен ли AGK сортировать непрозрачные спрайты по глубине при рисовании. Это сначала рисует спрайты в
     * передней части экрана, которые заполняют буфер глубины, так что более поздние спрайты позади могут быть
     * пропущены. Это улучшит производительность на устройствах с ограниченной скоростью заполнения, где вы рисуете
     * много перекрывающихся непрозрачных спрайтов. По умолчанию он выключен, но если вы не часто меняете глубину
     * спрайта, рекомендуется включить его. Это не относится к прозрачным спрайтам, которые имеют свои собственные
     * требования к сортировке. Эта команда устарела, сортировка теперь обрабатывается автоматически.
     *
     * @param int $sort Установите значение 1 для сортировки непрозрачных спрайтов по глубине. по умолчанию=0
     * @return void
     */
    function SetSortDepth($sort)
    {
    }

    /**
     * Если два спрайта занимают одну и ту же глубину, то порядок их рисования не определен, если только эта функция не
     * установлена в 1, и в этом случае спрайты на одной и той же глубине будут нарисованы в том порядке, в котором они
     * были созданы. Для максимальной производительности рекомендуется, чтобы каждый спрайт имел свое собственное
     * значение глубины с этой командой, установленной в 0. Если порядок их рисования не важен, например, физические
     * спрайты, которые обычно не перекрываются, то вы можете использовать спрайты на одной и той же глубине, не
     * устанавливая эту команду в 1.
     *
     * @param int $sort Установите значение 1, чтобы отсортировать спрайты с одинаковой глубиной по порядку их
     *     создания, и 0, чтобы отключить его.
     * @return void
     */
    function SetSortCreated($sort)
    {
    }

    /**
     * Устанавливает, должно ли устройство спать, когда ваше приложение находится в режиме ожидания. По умолчанию он
     * выключен, но если он активирован, то будет использовать настройки устройства, чтобы определить, как долго оно
     * должно простаивать перед сном.
     *
     * @param int $mode 1 для включения спящего режима, 0 для его выключения (по умолчанию)
     * @return void
     */
    function SetSleepMode($mode)
    {
    }

    /**
     * Задает свойства для любых изображений наклеек, добавляемых в будущие вызовы ShareSnapChatImage. Параметры X и Y
     * должны находиться в диапазоне от 0.0 до 1.0, например, в направлении X 1.0-это крайняя правая часть изображения,
     * а 0.0-крайняя левая часть изображения.
     *
     * @param float $x Положение X наклейки, по умолчанию 0,5
     * @param float $y Положение наклейки Y, по умолчанию 0,5
     * @param int $width Ширина наклейки, по умолчанию 250
     * @param int $height Высота наклейки, по умолчанию 250
     * @param float $angle Угол наклона наклейки, по умолчанию 0
     * @return void
     */
    function SetSnapChatStickerSettings($x, $y, $width, $height, $angle)
    {
    }

    /**
     * Устанавливает, виден ли объект sky box или нет. По умолчанию он не виден. Поле неба всегда будет появляться
     * позади всех других 3D-объектов и будет нарисовано в максимальном видимом диапазоне обзора, который задается с
     * помощью SetCameraRange. В поле sky есть дополнительное солнце, которое будет нарисовано в соответствии с текущим
     * направлением света, установленным с помощью SetSunDirection. Однако он не будет использовать направленный
     * световой цвет, поэтому вы можете иметь направленный свет как один цвет, а небо и солнце-как другой цвет.
     *
     * @param int $active 1, чтобы показать скайбокс, 0, чтобы скрыть его
     * @return void
     */
    function SetSkyBoxVisible($active)
    {
    }

    /**
     * Устанавливает, будет ли небесная коробка рисовать солнце в месте текущего направленного света. Его положение
     * можно установить с помощью SetSunDirection, но он не будет использовать направленный светлый цвет, вы можете
     * установить его отдельно с помощью SetSkyBoxSunColor. Обратите внимание, что установка видимого солнца изменяет
     * расчеты чертежа небесного ящика, делая их более сложными, что может повлиять на производительность.
     *
     * @param int $visible 1, чтобы нарисовать солнце, 0, чтобы скрыть его
     * @return void
     */
    function SetSkyBoxSunVisible($visible)
    {
    }

    /**
     * Устанавливает размер солнца и его ореола, если он виден. Значения размера не относятся ни к каким мировым
     * единицам измерения и должны находиться в диапазоне от 1,0 до 100,0. Значения по умолчанию-5,0 для солнца и 50,0
     * для гало.
     *
     * @param float $sun Размер солнца
     * @param float $halo Размер гало вокруг солнца
     * @return void
     */
    function SetSkyBoxSunSize($sun, $halo)
    {
    }

    /**
     * Устанавливает цвет солнца, если он виден. По умолчанию это 255,230,179. Цвета должны находиться в диапазоне от 0
     * до 255, хотя это не ограничено и значения за пределами этого диапазона будут приниматься, включая отрицательные
     * значения. Обратите внимание, что из-за того, как цвет солнца добавляется к цвету неба, цвета солнца темнее, чем
     * цвет неба, могут привести к неожиданному цвету солнца, когда один или несколько цветовых компонентов полностью
     * отсутствуют. Если это произойдет, то масштабирование цвета солнца, поднимаясь выше 255, если это необходимо,
     * удалит его. Цвет солнца оказывает некоторое влияние на размер солнца в дополнение к SetSkyBoxSunSize, причем
     * более яркие цвета делают его больше.
     *
     * @param int $red Красная составляющая цвета неба
     * @param int $green Зеленая составляющая цвета неба
     * @param int $blue Голубая составляющая цвета неба
     * @return void
     */
    function SetSkyBoxSunColor($red, $green, $blue)
    {
    }

    /**
     * Задает цвет, который заполнит большую часть неба. По умолчанию это 161 183 209. Цвета должны находиться в
     * диапазоне от 0 до 255, хотя это не ограничено и значения за пределами этого диапазона будут приниматься, включая
     * отрицательные значения.
     *
     * @param int $red Красная составляющая цвета неба
     * @param int $green Зеленая составляющая цвета неба
     * @param int $blue Голубая составляющая цвета неба
     * @return void
     */
    function SetSkyBoxSkyColor($red, $green, $blue)
    {
    }

    /**
     * Устанавливает размер и высоту горизонта. По умолчанию размер равен 4.0, а высота-0.0. Это влияет на то, как
     * высоко простирается цвет горизонта, прежде чем стать цветом неба. Значение высоты находится в мировых
     * координатах, и все, что находится на этой высоте или ниже нее, будет иметь цвет горизонта. Выше этой высоты
     * горизонт сливается с цветом неба, пока в какой-то момент не остается только цвет неба. Горизонт всегда будет
     * находиться на заданной высоте в мире, даже если камера движется вверх и вниз. Значение размера не относится ни к
     * каким мировым единицам и должно быть установлено по вашему вкусу, тогда эффективный диапазон составляет от 0,1
     * до примерно 50,0, но может быть установлен и выше. Если диапазон обзора мал, то значение высоты будет иметь
     * больший эффект, поскольку небесный ящик приближается к камере ближе, чем если бы диапазон обзора был больше.
     * Например, высота горизонта 100 с небольшим диапазоном обзора будет казаться очень высокой, но когда диапазон
     * обзора больше, камера просматривает горизонт с гораздо большего расстояния, поэтому изменение высоты на 100
     * единиц будет иметь меньший эффект.
     *
     * @param float $size Размер горизонта над высотой горизонта
     * @param float $height Высота, с которой начинается горизонт
     * @return void
     */
    function SetSkyBoxHorizonSize($size, $height)
    {
    }

    /**
     * Задает цвет, который будет отображаться на горизонте. По умолчанию это 255,255,255. Цвета должны находиться в
     * диапазоне от 0 до 255, хотя это не ограничено и значения за пределами этого диапазона будут приниматься, включая
     * отрицательные значения.
     *
     * @param int $red Красная составляющая цвета неба
     * @param int $green Зеленая составляющая цвета неба
     * @param int $blue Голубая составляющая цвета неба
     * @return void
     */
    function SetSkyBoxHorizonColor($red, $green, $blue)
    {
    }

    /**
     * Устанавливает, является ли указанный скелет видимым или нет. AGK автоматически скроет скелет, когда он
     * переместится за пределы экрана, чтобы повысить производительность, поэтому вам нужно сделать это только в том
     * случае, если вы хотите скрыть его, пока он находится на экране. Когда скелет спрятан, он все равно оживет.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $mode 1, чтобы сделать его видимым, 0, чтобы скрыть его
     * @return void
     */
    function SetSkeleton2DVisible($iSkeleton, $mode)
    {
    }

    /**
     * Устанавливает угол корня скелета, углы костей будут относительно этого угла.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param float $r Угол использования в градусах
     * @return void
     */
    function SetSkeleton2DRotation($iSkeleton, $r)
    {
    }

    /**
     * Устанавливает положение корня скелета, положение костей будет относительно этого места. Это может быть
     * использовано для перемещения скелета во время его анимации, чтобы сделать его похожим на ходьбу.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param float $x Положение X скелета
     * @param float $y Положение Y скелета
     * @return void
     */
    function SetSkeleton2DPosition($iSkeleton, $x, $y)
    {
    }

    /**
     * Устанавливает горизонтальный и вертикальный режим переворота скелета, это будет переворачивать все кости и
     * спрайты вдоль горизонтальной или вертикальной оси (или и то, и другое).
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $flipH 1-перевернуть скелет по горизонтальной оси, 0-не перевернуть.
     * @param int $flipV 1-перевернуть скелет по вертикальной оси, 0-не перевернуть.
     * @return void
     */
    function SetSkeleton2DFlip($iSkeleton, $flipH, $flipV)
    {
    }

    /**
     * Устанавливает глубину этого скелета в диапазоне 0-10000 с 0 - вершиной.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $depth Значение глубины для использования
     * @return void
     */
    function SetSkeleton2DDepth($iSkeleton, $depth)
    {
    }

    /**
     * Установите исходную шкалу кости. Анимация переопределит это значение.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $bone Идентификатор кости для модификации
     * @param float $sx Новое значение шкалы X для использования
     * @param float $sy Новое значение шкалы Y для использования
     * @return void
     */
    function SetSkeleton2DBoneScale($iSkeleton, $bone, $sx, $sy)
    {
    }

    /**
     * Установка исходного положения кости относительно ее родителя также известна как установочная поза. Вся анимация
     * будет находиться относительно этой позиции, она может быть изменена во время воспроизведения анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $bone Идентификатор кости для изменения
     * @param float $x Новая позиция X для использования
     * @param float $y Новая позиция Y для использования
     * @return void
     */
    function SetSkeleton2DBonePosition($iSkeleton, $bone, $x, $y)
    {
    }

    /**
     * Устанавливает, может ли кость оживать или она остается неподвижной. Вы все еще можете изменить положение кости,
     * угол наклона и масштаб вручную.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $bone Идентификатор кости для модификации
     * @param int $mode 1, чтобы позволить кости оживать, 0, чтобы остановить ее
     * @return void
     */
    function SetSkeleton2DBoneMode($iSkeleton, $bone, $mode)
    {
    }

    /**
     * Устанавливает скорость анимации (по умолчанию 1.0), отрицательные значения разрешены для реверса анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param float $speed Скорость анимации с 1.0 является нормальной скоростью
     * @return void
     */
    function SetSkeleton2DAnimationSpeed($iSkeleton, $speed)
    {
    }

    /**
     * Установите исходный угол кости относительно ее родителя. Вся анимация будет относительно этого угла, он может
     * быть изменен во время воспроизведения анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $bone Идентификатор кости для модификации
     * @param float $r Новый угол для использования
     * @return void
     */
    function SetSkeleton2DBoneAngle($iSkeleton, $bone, $r)
    {
    }

    /**
     * Устанавливает скелет в определенную точку анимации в зависимости от времени, с дополнительным временем
     * твиннинга. Время анимации будет плавно интерполировать скелет из его текущего состояния в выбранный кадр
     * указанной анимации, чтобы не было резкого перехода.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param string $anim Имя используемой анимации
     * @param float $time Смещение времени, используемое для установки каркаса скелета
     * @param float $tweentime Количество секунд для перехода из текущего состояния в заданный кадр
     * @return void
     */
    function SetSkeleton2DAnimationFrame($iSkeleton, $anim, $time, $tweentime)
    {
    }

    /**
     * Только для iOS. Сообщает AGK, какую группу приложений вы используете для обмена данными между приложениями.
     * Например, group.com.mycompany.mygroup.myvariables создается на портале разработчиков Apple и должен быть
     * добавлен к каждому идентификатору приложения, к которому вы хотите получить доступ к этим переменным. Вам нужно
     * будет заново создать профиль подготовки для каждого приложения после добавления группы приложений к его
     * идентификатору приложения.
     *
     * @param string $group Имя, используемое для идентификации этой переменной
     * @return void
     */
    function SetSharedVariableAppGroup($group)
    {
    }

    /**
     * Включает или выключает отображение теней, по умолчанию это выключено. Тени генерируются только глобальным
     * направленным светом, которым можно управлять с помощью команды SetSunDirection. Обратите внимание, что это не
     * гарантировано поддерживается на всех устройствах, вы можете проверить наличие текущего устройства, вызвав
     * GetShadowMappingSupported. В настоящее время существует три режима теней, которые можно использовать, режим 1
     * использует равномерное отображение теней, которое имеет более низкое, но стабильное качество. Режим 2 использует
     * Light Space Perspective shadow mapping (LiPSM), который в большинстве случаев имеет более высокое качество, но
     * если камера смотрит в том же направлении, что и свет, то это не лучше, чем Равномерное теневое отображение.
     * Перспектива светлого пространства также страдает от мерцания теней при движении камеры, в то время как
     * Равномерность более стабильна. Оба имеют примерно одинаковую производительность. Режим 3 использует каскадное
     * теневое отображение, которое использует несколько теневых карт для поддержания высокого качества вблизи камеры,
     * в то же время позволяя более низкие качественные тени на расстоянии. Этот метод имеет гораздо более низкую
     * производительность, чем предыдущие два метода, но во всех случаях приводит к более качественным теням. Обратите
     * внимание, что при использовании режимов 1 и 2 этап текстуры 7 на всех объектах, получающих тень, зарезервирован
     * для карты теней. При использовании теневого режима 3 (каскадные тени) для теневых карт зарезервированы этапы
     * текстуры 4, 5, 6 и 7.
     *
     * @param int $mode 0, чтобы выключить его, 1, чтобы использовать Равномерные тени, 2, чтобы использовать тени
     *     LiPSM, 3, чтобы использовать каскадные тени
     * @return void
     */
    function SetShadowMappingMode($mode)
    {
    }

    /**
     * Устанавливает режим сглаживания для теневой карты. Режим 0 отключает сглаживание и приводит к самым быстрым
     * теням, но создает жесткие края. Режим 1 немного медленнее, но создает более мягкие тени, многократно пробуя
     * карту теней. Режим 2 использует случайную мультисэмплировку, чтобы избежать полос, создаваемых режимом 1, но еще
     * медленнее.
     *
     * @param int $mode 0
     * @return void
     */
    function SetShadowSmoothing($mode)
    {
    }

    /**
     * Задает разрешение теневой карты в пикселях. Хорошие значения-512x512 или 1024x1024, это не обязательно должна
     * быть степень двух по размеру. Чем выше разрешение, тем лучше качество теней, хотя производительность будет ниже
     * при более высоком разрешении теневых карт.
     *
     * @param int $width Ширина в пикселях, используемая для теневой карты
     * @param int $height Высота в пикселях, используемая для теневой карты
     * @return void
     */
    function SetShadowMapSize($width, $height)
    {
    }

    /**
     * Устанавливает диапазон от камеры, в котором будут нарисованы тени. В идеале это должно быть установлено на
     * дальний диапазон камеры от SetCameraRange, но рисование теней до самой дальней плоскости может отнять некоторое
     * качество у тех теней, которые находятся ближе к камере. Поэтому установка диапазона теней ниже, чем дальний
     * диапазон камеры, может улучшить качество теней за счет удаленных объектов, не имеющих теней. Фактический
     * диапазон теней будет меньшим значением дальнего диапазона камеры и этого диапазона теней, поэтому вы можете
     * безопасно установить его больше, чем дальний диапазон камеры, без какого-либо влияния на качество. Если позже вы
     * отрегулируете дальний диапазон камеры, то диапазон теней не изменится соответствующим образом, вы должны
     * установить его отдельно. Используйте значение -1, чтобы игнорировать это значение, и всегда используйте дальний
     * диапазон камеры для теней. По умолчанию это значение равно -1.
     *
     * @param float $range Расстояние, чтобы остановить рисование теней, -1, чтобы вместо этого использовать дальний
     *     диапазон камеры
     * @return void
     */
    function SetShadowRange($range)
    {
    }

    /**
     * Устанавливает смещение для смещения теней так, чтобы поверхности объектов не затеняли сами себя, по умолчанию
     * значение равно 0,001. Это может помочь предотвратить появление теневых артефактов на поверхностях, которые
     * находятся на свету, но также отбрасывают тень позади себя.
     *
     * @param float $bias Расстояние до сдвига теней
     * @return void
     */
    function SetShadowBias($bias)
    {
    }

    /**
     * Ограничивает угол направленного света шагами заданного размера, а не непрерывным значением. Это может
     * предотвратить мерцание тени, если направленный свет медленно меняет свой угол, например, солнце движется по
     * небу. По умолчанию это значение равно 0, что отключает размер шага и сохраняет угол как непрерывное значение.
     * Значения в диапазоне от 0,1 до 2,0, по-видимому, работают лучше всего. Это применимо только в том случае, если
     * SetShadowMappingMode имеет значение Uniform.
     *
     * @param float $step Размер шага угла освещения в градусах
     * @return void
     */
    function SetShadowLightStepSize($step)
    {
    }

    /**
     * При использовании cascade shadow maps (SetShadowMappingMode 3) эта команда устанавливает диапазон, который будет
     * охватывать каждая каскадная карта. Всего существует 4 каскадных теневых карты, четвертая всегда охватывает всю
     * затененную область (cascade4 = 1.0), по умолчанию третий каскад охватывает половину затененной области (cascade3
     * = 0.5), второй каскад охватывает четверть затененной области (cascade2 = 0.25), а первый каскад охватывает одну
     * восьмую затененной области (cascade1 = 0.125). Поскольку все каскадные теневые карты используют одинаковое
     * разрешение, чем меньше площадь, которую они покрывают, тем больше деталей тени будет в этой области. Каскадные
     * теневые карты упорядочены таким образом, что самая маленькая из них находится ближе всего к камере, а самая
     * большая-дальше всего. Таким образом, тени вблизи камеры должны иметь высокую детализацию, в то время как самые
     * дальние, которые менее заметны, будут иметь более низкую детализацию. Обратите внимание, что, хотя использование
     * меньшей площади для конкретного каскада увеличит качество тени, это уменьшит площадь, которую этот каскад
     * покрывает, поэтому качество тени упадет на следующий уровень раньше, чем расстояние от камеры увеличится.
     * Каскадные уровни должны находиться в диапазоне от 0.0 до 1.0, и каждый уровень должен быть больше предыдущего
     * уровня, то есть каскад2 должен быть больше каскада1 и так далее. Если эти правила нарушены, то эта команда
     * ничего не сделает.
     *
     * @param float $cascade1 Наименьший уровень каскада, должен быть меньше, чем cascade2, должен быть больше, чем 0.0
     * @param float $cascade2 Второй каскадный уровень, должен быть меньше, чем cascade3
     * @param float $cascade3 Третий каскадный уровень, должен быть меньше 1,0
     * @return void
     */
    function SetShadowCascadeValues($cascade1, $cascade2, $cascade3)
    {
    }

    /**
     * Задает индекс массива констант шейдера по имени, константа должна быть помечена как "однородная" в источнике
     * шейдера. Индексы массива начинаются с 0, если индекс массива находится за пределами границ, то он будет
     * проигнорирован и никакие изменения не будут внесены. Это повлияет на все объекты, нарисованные с помощью этого
     * шейдера. Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4 значения и отбрасывает все,
     * которые не используются именованной переменной.
     *
     * @param int $shaderID Идентификатор шейдера для изменения.
     * @param string $szName Имя изменяемой константы, как определено в исходном файле шейдера.
     * @param int $arrayIndex Индекс элемента в массиве для изменения.
     * @param float $value1 Компонент X или R нового значения, это значение всегда будет использоваться.
     * @param float $value2 Компонент Y или G нового значения, если константа использует только 1 компонент, это
     *     значение отбрасывается.
     * @param float $value3 Компонент Z или B нового значения, если константа использует только 2 компонента, это
     *     значение отбрасывается.
     * @param float $value4 W или компонент нового значения, если константа использует только 3 компонента, это
     *     значение отбрасывается.
     * @return void
     */
    function SetShaderConstantArrayByName($shaderID, $szName, $arrayIndex, $value1, $value2, $value3, $value4)
    {
    }

    /**
     * Задает константу шейдера по имени, константа должна быть помечена как "однородная" в источнике шейдера. Это
     * повлияет на все объекты, нарисованные с помощью этого шейдера. Все значения шейдера имеют от 1 до 4 компонентов,
     * эта команда принимает 4 значения и отбрасывает все, которые не используются именованной переменной.
     *
     * @param int $shaderID Идентификатор шейдера для изменения.
     * @param string $szName Имя изменяемой константы, как определено в исходном файле шейдера.
     * @param float $value1 Компонент X или R нового значения, это значение всегда будет использоваться.
     * @param float $value2 Компонент Y или G нового значения, если константа использует только 1 компонент, это
     *     значение отбрасывается.
     * @param float $value3 Компонент Z или B нового значения, если константа использует только 2 компонента, это
     *     значение отбрасывается.
     * @param float $value4 W или компонент нового значения, если константа использует только 3 компонента, это
     *     значение отбрасывается.
     * @return void
     */
    function SetShaderConstantByName($shaderID, $szName, $value1, $value2, $value3, $value4)
    {
    }

    /**
     * Устанавливает разрешение заднего буфера там, где это возможно. Если выбранное вами разрешение больше, чем может
     * отображать устройство, чем устройство будет использовать свое максимально возможное разрешение, вы можете
     * использовать GetDeviceWidth и GetDeviceHeight, чтобы узнать, что было использовано. На мобильных устройствах
     * использование разрешения экрана с другим соотношением сторон, чем на устройстве, приведет к растяжению. Вы
     * можете проверить соотношение сторон устройства с помощью GetMaxDeviceWidth и GetMaxDeviceHeight. Не
     * рекомендуется разрешать как портретную, так и альбомную ориентацию при использовании этой команды, так как AGK
     * не может предотвратить растяжение без отмены желаемого разрешения экрана, поэтому он этого не сделает. Если вы
     * хотите, чтобы все ориентации были без растяжения, вам нужно будет следить за изменениями GetMaxDeviceWidth и
     * GetMaxDeviceHeight и установить соответствующее разрешение замены с помощью SetScreenResolution, чтобы оно
     * соответствовало новому соотношению сторон. Использование разрешения 0 в любом направлении приведет к сбросу
     * разрешения экрана до максимального разрешения, поддерживаемого на устройстве. Обратите внимание, что в Windows и
     * Mac размер backbuffer изменяется путем изменения размера окна, поэтому он будет перезаписывать любые настройки
     * из SetWindowSize. Это может быть не так в будущем, и AGK может иметь отдельные размеры окон и размеры backbuffer
     * в будущей версии.
     *
     * @param int $width Желаемая ширина экрана в пикселях.
     * @param int $height Желаемая высота экрана в пикселях.
     * @return void
     */
    function SetScreenResolution($width, $height)
    {
    }

    /**
     * Эта функция задает область экрана, которая будет отображаться в последующих командах Sync() или Render ().
     * Область определяется двумя точками, представляющими верхний левый и нижний правый углы прямоугольника, который
     * будет новой областью рисования. По умолчанию это значение равно вашему виртуальному разрешению, поэтому все, что
     * находится за пределами этого разрешения, не будет видно. Использование SetScissor(0,0,0,0) - это особый случай,
     * который отключит все отсечения и сделает весь экран пригодным для отображения вещей. Это может быть полезно при
     * создании приложения, которое работает с различными соотношениями сторон. Например, использование виртуального
     * разрешения 1024х768 на устройстве с экраном 1280х800 будет соответствовать области 1024х768 как можно ближе в
     * центре экрана, с черными границами по обе стороны. SetScissor(0,0,0,0) помещает область 1024x768 в одно и то же
     * место, но там нет черных границ, поэтому размещение чего-то в отрицательном положении X все равно будет видно до
     * тех пор, пока экран все еще может поместиться. В то время как размещение чего-то в отрицательном положении на
     * устройстве с экраном 1024x768 (который идеально подходит для вашего виртуального разрешения) приведет к тому,
     * что этот элемент исчезнет с края экрана. Вы можете использовать это с помощью команд GetScreenBoundsLeft,
     * GetScreenBoundsRight, GetScreenBoundsTop и GetScreenBoundsBottom, чтобы найти фактический край экрана в
     * выбранном вами разрешении. Это позволяет размещать элементы по краю экрана на всех устройствах независимо от его
     * соотношения сторон.
     *
     * @param float $x x-компонент первой координаты.
     * @param float $y Компонент y первой координаты.
     * @param float $x2 x-компонент второй координаты.
     * @param float $y2 Компонент y второй координаты.
     * @return void
     */
    function SetScissor($x, $y, $x2, $y2)
    {
    }

    /**
     * Некоторые платформы имеют экраны с высоким разрешением, такие как iPad, эта функция определяет, как эти
     * платформы отображают свой контент. У вас есть выбор mode=1, который будет использовать буфер кадров полного
     * разрешения, который будет выглядеть лучше, или mode=0, который будет использовать буфер кадров меньшего
     * разрешения (обычно половинного размера), который затем масштабируется по размеру экрана и будет работать
     * быстрее. Это не влияет на устройства с низким разрешением, которые всегда будут использовать буфер кадров с
     * низким разрешением.
     *
     * @param int $mode 1 для использования высокого (собственного) разрешения, 0 для использования низкого
     *     (масштабированного) разрешения
     * @return void
     */
    function SetResolutionMode($mode)
    {
    }

    /**
     * Эта команда устанавливает конвейер рендеринга для вывода любых будущих вызовов рисования на экран. Это режим по
     * умолчанию, поэтому вам нужно вызвать его только в том случае, если вы ранее перенаправили рисунок на изображение
     * с помощью SetRenderToImage.
     *
     * @return void
     */
    function SetRenderToScreen()
    {
    }

    /**
     * Перенаправляет все будущие вызовы рисования на изображение, а не на экран. Затем указанное изображение может
     * быть применено к объекту или спрайту. Будьте осторожны, чтобы не применять к объекту или спрайту одновременно с
     * его рисованием, так как это может привести к ошибке. Вы также можете выбрать визуализацию информации о глубине
     * для изображения, которое вы можете использовать позже, или визуализацию без буфера глубины, если ваша сцена в
     * нем не нуждается. Вы также можете использовать идентификатор изображения глубины, равный -1, для рендеринга
     * буфера глубины без захвата его в изображение. Обратите внимание, что некоторые устройства (особенно Android) не
     * поддерживают рендеринг глубины изображения, в этих случаях единственными допустимыми значениями идентификатора
     * глубины являются 0 и -1. Вы можете проверить, поддерживает ли текущее устройство текстуры глубины, используя
     * IsSupportedDepthTexture. Рендеринг изображений может быть любого размера, и не обязательно должен быть в степени
     * 2 по ширине или высоте. Для более подробного объяснения, когда вы визуализируете изображение, оно будет рисовать
     * на изображении именно то, что оно нарисовало бы на экране. Например, если ваше виртуальное разрешение составляет
     * 1024x768 и требует границ, то оно будет рисовать границы на изображении рендеринга. Это означает, что если вы
     * посмотрите на полученное изображение рендеринга в его родной форме, например 1024x1024, оно будет выглядеть так,
     * как будто вы взяли окно 1024х768 и растянули его вертикально в квадрат. В результате, если вы возьмете это
     * квадратное изображение и растянете его обратно в 1024х768, текстурируя спрайт или квадроцикл размером 1024х768,
     * то оно снова будет выглядеть нормально. Это означает, что вы можете визуализировать окно 1024x768 в изображение
     * любого размера, скажем 64x512, и растянуть его до 1024x768, и оно должно выглядеть правильно с точки зрения
     * соотношения сторон, конечно, в нем будут отсутствовать некоторые детали. Затем вы можете получить более
     * продвинутый результат, изменив виртуальное разрешение после установки изображения рендеринга и изменив его
     * обратно при рендеринге на экран, или используя SetCameraAspect для изменения соотношения сторон 3D, если
     * изображение рендеринга будет использоваться для чего-то другого, чем представление экрана 1:1. При рендеринге
     * изображения очень важно, чтобы изображение было очищено с помощью ClearScreen (), прежде чем рисовать на нем
     * новую сцену. Это делается для того, чтобы графический процессор знал, что он может отбросить предыдущее
     * содержимое. Если изображение не очищается и вещи продолжают притягиваться к нему, то производительность
     * некоторых графических процессоров со временем ухудшится.
     *
     * @param int $colorImage Идентификатор изображения, которое будет использоваться в качестве цветового буфера, 0,
     *     чтобы не отображать цвет
     * @param int $depthImage Идентификатор изображения, используемого в качестве буфера глубины, 0-чтобы не отображать
     *     глубину, -1-чтобы использовать буфер глубины без изображения
     * @return void
     */
    function SetRenderToImage($colorImage, $depthImage)
    {
    }

    /**
     * Задает папку, в которой будут храниться файлы, созданные AGK. Это никак не влияет на iOS, так как она не может
     * писать вне своей папки приложения. Вы можете установить его на любой абсолютный путь на устройстве, однако
     * некоторые места, такие как папка Program Files в Windows, потребуют прав администратора для записи в них.
     * Некоторые места будут защищены операционной системой, SetRawWritePath позволит вам установить путь к этим
     * местам, но любая попытка записи в них потерпит неудачу. Вы можете использовать GetDocumentsPath, чтобы получить
     * системную папку документов для текущего пользователя или папку sdcard на Android, которая гарантированно
     * разрешит доступ на запись. Эта команда теперь устарела. Предпочтительным способом доступа к файлам за пределами
     * обычной папки записи является использование команд OpenRawFolder и путей к файлам "raw:".
     *
     * @param string $str Путь для использования в качестве папки записи
     * @return void
     */
    function SetRawWritePath($str)
    {
    }

    /**
     * Задает расстояние, на которое должно переместиться событие касания, прежде чем оно будет классифицировано как
     * событие перетаскивания. По умолчанию это значение равно 6.
     *
     * @param int $distance Расстояние, на которое событие касания должно переместиться в виртуальных координатах
     * @return void
     */
    function SetRawTouchMoveSensitivity($distance)
    {
    }

    /**
     * Пытается скрыть или показать любой указатель мыши, используемый на этой платформе. Не гарантируется работа на
     * всех платформах.
     *
     * @param int $visible 1, чтобы сделать его видимым, 0, чтобы скрыть его.
     * @return void
     */
    function SetRawMouseVisible($visible)
    {
    }

    /**
     * Позволяет вам установить некоторые пользовательские данные для хранения в этом событии, которые вы можете
     * получить позже. Это может быть значение или указатель.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @param int $value Значение для хранения с этим событием.
     * @return void
     */
    function SetRawTouchValue($iIndex, $value)
    {
    }

    /**
     * Пытается расположить любой указатель мыши, используемый на этой платформе. Не гарантируется работа на всех
     * платформах. Будет работать только тогда, когда окно вашего приложения имеет фокус.
     *
     * @param float $x Компонент X новой позиции мыши.
     * @param float $y Компонент Y новой позиции мыши.
     * @return void
     */
    function SetRawMousePosition($x, $y)
    {
    }

    /**
     * Устанавливает мертвую зону для всех реальных джойстиков так, чтобы любое значение X или Y ниже заданного порога
     * возвращало 0. Это значение должно быть между 0 и 1, по умолчанию оно равно 0,15.
     *
     * @param float $threshold Значение, ниже которого будет возвращено 0.
     * @return void
     */
    function SetRawJoystickDeadZone($threshold)
    {
    }

    /**
     * Задает начальное значение для генератора случайных чисел. Два приложения AGK, использующие одно и то же
     * начальное значение, будут генерировать одну и ту же последовательность случайных чисел. По умолчанию начальное
     * значение устанавливается на текущее время при запуске, так что каждый запуск приложения будет генерировать
     * другую последовательность чисел.
     *
     * @param int $seed Начальное значение, между 1 и 2^32
     * @return void
     */
    function SetRandomSeed2($seed)
    {
    }

    /**
     * Задает начальное значение для генератора случайных чисел. Два приложения AGK, использующие одно и то же
     * начальное значение, будут генерировать одну и ту же последовательность случайных чисел. По умолчанию начальное
     * значение устанавливается на текущее время при запуске, так что каждый запуск приложения будет генерировать
     * другую последовательность чисел.
     *
     * @param int $seed Начальное значение, между 1 и 2^32
     * @return void
     */
    function SetRandomSeed($seed)
    {
    }

    /**
     * Эта команда используется на Android для установки SenderID, используемого проектом Firebase. В настоящее время
     * keyName должно быть установлено в "SenderID" (с учетом регистра), а KeyValue должно быть установлено в значение
     * SenderID, которое можно найти в настройках проекта Firebase на вкладке Облачные сообщения.
     *
     * @param string $keyName Ключ к набору
     * @param string $keyValue Ключевое значение
     * @return void
     */
    function SetPushNotificationKeys($keyName, $keyValue)
    {
    }

    /**
     * Устанавливает интервал между буквами. Значение 0 не создает зазора между ограничивающими буквами, положительное
     * значение увеличивает этот зазор, отрицательное значение перекрывает буквы. Это глобальная команда, которая будет
     * влиять на весь печатный текст при следующем вызове синхронизации. Для управления интервалом на основе каждой
     * строки используйте текстовые команды.
     *
     * @param float $fSpacing Интервал между буквами для использования.
     * @return void
     */
    function SetPrintSpacing($fSpacing)
    {
    }

    /**
     * Задает размер печатного текста, который будет отображаться на экране. Это глобальная команда, которая будет
     * влиять на весь печатный текст при следующем вызове синхронизации. Для управления размером на основе каждой
     * строки используйте текстовые команды.
     *
     * @param float $fSize Размер текста в пикселях виртуального разрешения.
     * @return void
     */
    function SetPrintSize($fSize)
    {
    }

    /**
     * Устанавливает шрифт для использования для всего печатного текста, шрифт должен быть предварительно загружен с
     * помощью LoadFont. Используйте идентификатор шрифта 0, чтобы использовать шрифт AGK по умолчанию.
     *
     * @param int $fontID Идентификатор шрифта, используемый для печати текста
     * @return void
     */
    function SetPrintFont($fontID)
    {
    }


    /**
     * Задает цвет печатного текста. Это глобальная команда, которая будет влиять на весь печатный текст при следующем
     * вызове синхронизации. Для управления цветом на основе каждой строки используйте текстовые команды. Эта версия
     * устанавливает альфа-код на 255, полностью непрозрачный.
     *
     * @param int $iRed Красная составляющая цвета.
     * @param int $iGreen Зеленая составляющая цвета.
     * @param int $iBlue Синяя составляющая цвета.
     * @param int|null $iAlpha Альфа-компонент цвета. (не обязательный параметр)
     * @return void
     */
    function SetPrintColor(int $iRed, int $iGreen, int $iBlue, int $iAlpha = 255)
    {
    }

    /**
     * Изменяет точечный свет на новый радиус воздействия. Объекты, находящиеся на большем расстоянии от источника
     * света, будут получать от него нулевой свет.
     *
     * @param int $lightID Идентификатор света для изменения.
     * @param float $radius Расстояние, на которое может повлиять свет.
     * @return void
     */
    function SetPointLightRadius($lightID, $radius)
    {
    }

    /**
     * Помещает точечный свет в новое положение.
     *
     * @param int $lightID Идентификатор света для изменения.
     * @param float $x X-компонент новой позиции.
     * @param float $y Y-компонент новой позиции.
     * @param float $z Z-компонент новой позиции.
     * @return void
     */
    function SetPointLightPosition($lightID, $x, $y, $z)
    {
    }

    /**
     * Устанавливает точечный свет в режим вершины или пикселя. Вершинный режим быстрее, но пиксельный режим имеет
     * лучшее качество. По умолчанию огни создаются в режиме вершин. Сетка может быть освещена до 8 вершинными огнями и
     * 4 пиксельными огнями одновременно, если вы добавите больше огней, чем это, то самые близкие огни будут
     * использоваться сеткой.
     *
     * @param int $lightID Идентификатор света для изменения.
     * @param int $mode 0 для вершины, 1 для пиксельного режима.
     * @return void
     */
    function SetPointLightMode($lightID, $mode)
    {
    }

    /**
     * Меняет точечный свет на новый цвет. Значения должны находиться в диапазоне 0-255, но не ограничиваться им.
     * Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать свет.
     *
     * @param int $lightID Идентификатор света для изменения.
     * @param int $red Красная составляющая светлого цвета.
     * @param int $green Зеленая составляющая светлого цвета.
     * @param int $blue Синяя составляющая светлого цвета.
     * @return void
     */
    function SetPointLightColor($lightID, $red, $green, $blue)
    {
    }

    /**
     * Переключает существование физической стены в верхней части экрана, чтобы физические объекты не покидали экран в
     * этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны
     * отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с
     * ним, они фиксированы к миру, поэтому они будут отключены автоматически.
     *
     * @param int $mode 0=выкл., 1=вкл.
     * @return void
     */
    function SetPhysicsWallTop($mode)
    {
    }

    /**
     * Переключает существование физической стены справа от экрана, чтобы физические объекты не покидали экран в этом
     * направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны
     * отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с
     * ним, они фиксированы к миру, поэтому они будут отключены автоматически.
     *
     * @param int $mode 0=выкл., 1=вкл.
     * @return void
     */
    function SetPhysicsWallRight($mode)
    {
    }

    /**
     * Переключает существование физической стены в левой части экрана, чтобы физические объекты не покидали экран в
     * этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны
     * отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с
     * ним, они фиксированы к миру, поэтому они будут отключены автоматически.
     *
     * @param int $mode 0=выкл., 1=вкл.
     * @return void
     */
    function SetPhysicsWallLeft($mode)
    {
    }

    /**
     * Задает количество потоков для использования во время физики. Значение 0 или 1 отключает многопоточность,
     * значение минус 1 выбирает значение, соответствующее количеству процессоров в устройстве для лучшей
     * производительности. Использование значения, превышающего количество процессоров в устройстве, скорее всего,
     * повредит производительности. По умолчанию-минус 1.
     *
     * @param int $threads Количество используемых нитей минус 1 для автоматического выбора числа, подходящего для
     *     данного устройства
     * @return void
     */
    function SetPhysicsThreading($threads)
    {
    }

    /**
     * Переключает существование физической стены в нижней части экрана, чтобы физические объекты не покидали экран в
     * этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны
     * отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с
     * ним, они фиксированы к миру, поэтому они будут отключены автоматически.
     *
     * @param int $mode 0=выкл., 1=вкл.
     * @return void
     */
    function SetPhysicsWallBottom($mode)
    {
    }

    /**
     * Устанавливает шкалу, используемую физической системой, по сравнению с мировыми координатами. По замыслу
     * физическая система настроена на использование 1 единицы измерения, равной 1 метру, что в случае стандартных
     * мировых координат (100 100) означало бы, что экран в физическом моделировании равен 100 на 100 метров. Однако по
     * своей конструкции физическая система предназначена для лучшей работы с динамическими объектами размером от 0,1
     * метра до 10 метров и со статическими объектами размером до 50 метров, поэтому экран масштабируется при отправке
     * в физическую систему, по умолчанию масштаб равен 0,2, поэтому в физическом мире экран составляет 20 метров на 20
     * метров. Это делается исключительно для того, чтобы позволить физической системе работать в своем разработанном
     * масштабе, позволяя использовать мировые координаты в качестве параметров, а AGK выполняет все необходимое
     * масштабирование за кулисами. Эта функция позволяет вам изменить масштабный коэффициент, если ваше виртуальное
     * разрешение будет отличаться от 100,100. Эта функция должна вызываться перед любыми другими физическими функциями
     * и не должна вызываться после запуска физической системы.
     *
     * @param float $scale Новое значение шкалы для использования для всех значений экрана к физике и наоборот.
     * @return void
     */
    function SetPhysicsScale($scale)
    {
    }

    /**
     * Устанавливает способность динамических тел спать, когда они не двигаются, это значительно улучшает
     * производительность, когда динамические тела расположились в своих конечных положениях. Выключение его полезно
     * только для бенчмаркинга, когда вы хотите, чтобы процессор постоянно обрабатывал все тела. По умолчанию включено.
     *
     * @param int $mode 0, чтобы отключить спящий режим, 1, чтобы включить его
     * @return void
     */
    function SetPhysicsSleeping($mode)
    {
    }

    /**
     * Задает максимальное количество точек, которые будут сгенерированы в будущих полигональных физических фигурах, не
     * влияет на уже сгенерированные фигуры, может вызываться несколько раз. Влияет только на формы, генерируемые AGK
     * через SetSpriteShape. Должно быть от 2 до 12. Значение по умолчанию-8.
     *
     * @param int $points Максимальное количество точек, разрешенных в новых многоугольниках.
     * @return void
     */
    function SetPhysicsMaxPolygonPoints($points)
    {
    }

    /**
     * Задает вектор гравитации для всех спрайтов с помощью физики. Значения x и y будут масштабироваться в физическом
     * пространстве, поэтому будут представлять только метры в секунду в квадрате, когда масштаб = 1,0, в мировом
     * пространстве значения представляют пиксели в секунду в квадрате. Например, в шкале по умолчанию 0,2 значение
     * SetPhysicsGravity 0,50 будет представлять 10 метров в секунду в квадрате. Гравитация-это постоянное ускорение,
     * приложенное ко всем физическим объектам одинаково, независимо от массы. В то время как сила прилагает ускорение,
     * пропорциональное массе объектов. Чтобы противодействовать гравитации с помощью силы, потребуется учет массы.
     *
     * @param float $x X-компонент вектора силы тяжести.
     * @param float $y Y-компонент вектора силы тяжести.
     * @return void
     */
    function SetPhysicsGravity($x, $y)
    {
    }

    /**
     * Изменяет диапазон действия глобальной силы. Спрайты, находящиеся на большем расстоянии от положения силы, не
     * почувствуют ее воздействия. Диапазон меньше нуля равен бесконечному диапазону.
     *
     * @param int $iForceIndex Идентификатор силы для изменения.
     * @param float $range Новый диапазон силы.
     * @return void
     */
    function SetPhysicsForceRange($iForceIndex, $range)
    {
    }

    /**
     * Изменяет положение глобальной силы в мировых координатах.
     *
     * @param int $iForceIndex Идентификатор силы для изменения.
     * @param float $x x-компонент новой позиции.
     * @param float $y y-компонент новой позиции.
     * @return void
     */
    function SetPhysicsForcePosition($iForceIndex, $x, $y)
    {
    }

    /**
     * Изменяет силу глобальной силы. Для сил, которые исчезают, это будет сила в 1 единице от положения силы. Эта сила
     * выражена в Ньютонах и по своим размерам похожа на гравитацию, за исключением того, что на нее влияет масса
     * объекта. Например, для объекта массой 1 кг и силой 10 ньютонов будет воздействовать на объект так же, как
     * гравитация, установленная на 10 м/с^2. Для массы 2 кг двигаться труднее, поэтому сила в 10 Ньютонов будет вдвое
     * эффективнее при перемещении объекта, чем сила тяжести при 10 м/с^2.
     *
     * @param int $iForceIndex Идентификатор силы для изменения.
     * @param float $power Новая сила силы.
     * @return void
     */
    function SetPhysicsForcePower($iForceIndex, $power)
    {
    }

    /**
     * Позволяет рисовать внутренние физические фигуры на экране. Если вы установили значение viewoffset на что-то
     * отличное от 0,0, убедитесь, что ни один из ваших физических спрайтов не закреплен на экране с помощью
     * FixSpriteToScreen, иначе отладочные фигуры не выстроятся в линию. Отладочные контуры рисуются как мировые
     * спрайты. Отладочный вывод будет рисовать форму каждого набора физических спрайтов с помощью SetSpritePhysicsOn и
     * всех нефизических спрайтов, которым назначена форма для команд столкновения нефизических спрайтов. Фигуры будут
     * нарисованы в следующих цветах: Кремовый=Динамический физический объект, Зеленый=Статический физический объект,
     * Темно-синий=Кинематический физический объект, Светло-Голубой=нефизический объект. Серый=Спящий динамический
     * физический объект. Кроме того, физические объекты будут нарисованы как затененные контуром, нефизические объекты
     * будут только контуром.
     *
     * @return void
     */
    function SetPhysicsDebugOn()
    {
    }

    /**
     * Включает и выключает непрерывное обнаружение столкновений. Это предотвращает туннелирование быстро движущихся
     * объектов через статические тела. Чтобы предотвратить прохождение быстро движущихся объектов друг через друга,
     * используйте SetSpritePhysicsIsBullet, когда у вас есть большое количество динамических тел, которые могут быть
     * узким местом в физическом движке, особенно когда резьба включена, так как эта часть в настоящее время не имеет
     * резьбы. По умолчанию он выключен.
     *
     * @param int $mode 0, чтобы отключить CCD, 1, чтобы включить его
     * @return void
     */
    function SetPhysicsCCD($mode)
    {
    }

    /**
     * Отключает рисование внутренних физических фигур на экране.
     *
     * @return void
     */
    function SetPhysicsDebugOff()
    {
    }

    /**
     * Устанавливает, рисуются ли испускаемые частицы. Установите значение 1, чтобы показать частицы, и 0, чтобы скрыть
     * их. Частицы все равно будут обновляться, пока они скрыты, вы можете остановить обновление частиц с помощью
     * SetParticlesActive
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $visible 1=показать, 0=скрыть
     * @return void
     */
    function SetParticlesVisible($ID, $visible)
    {
    }

    /**
     * Устанавливает минимальный и максимальный множитель, который будет влиять на испускаемые частицы. Это может быть
     * использовано для того, чтобы гарантировать, что при испускании частиц будут наблюдаться некоторые изменения.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $v1 Минимальный множитель скорости.
     * @param float $v2 Множитель максимальной скорости.
     * @return void
     */
    function SetParticlesVelocityRange($ID, $v1, $v2)
    {
    }

    /**
     * Установите прозрачность частиц на определенную настройку с выбором без прозрачности, альфа-прозрачности и
     * аддитивного смешивания. По умолчанию частицы создаются с альфа-прозрачностью.
     *
     * @param int $ID Идентификатор излучателя частиц для изменения.
     * @param int $mode Режим прозрачности для этих частиц: 0=выкл., 1=альфа-прозрачность, 2=аддитивное смешивание
     * @return void
     */
    function SetParticlesTransparency($ID, $mode)
    {
    }

    /**
     * Задает область вокруг излучателя, в которой могут появиться новые частицы. Эти значения относятся к положению
     * эмиттера, например, зона 0,0,0,0 будет означать, что все частицы начинаются в точке положения эмиттера. Зона -10
     * в x и +10 x, где y равно 0 (-10,0,10,0), создаст линию, центрированную на положении излучателя, вдоль которой
     * будут случайным образом появляться частицы. Зона коробки, где и x, и y имеют ненулевые размеры, означала бы, что
     * частицы могут начинаться в любой точке внутри коробки.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x1 Координата x верхнего левого угла стартовой зоны.
     * @param float $y1 Координата y верхнего левого угла стартовой зоны.
     * @param float $x2 Координата x в правом нижнем углу стартовой зоны.
     * @param float $y2 Координата y в правом нижнем углу стартовой зоны.
     * @return void
     */
    function SetParticlesStartZone($ID, $x1, $y1, $x2, $y2)
    {
    }

    /**
     * Задает размер всех частиц в мировых координатах. Установка большого количества частиц на большой размер будет
     * плохо работать на мобильных устройствах с низкой скоростью заполнения (количество пикселей, которые он может
     * нарисовать в секунду).
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $size Размер частиц
     * @return void
     */
    function SetParticlesSize($ID, $size)
    {
    }

    /**
     * Задает диапазон вращения в радианах, который частица может иметь в течение своей жизни. Когда частица создается,
     * она начинается под углом 0 и выбирает случайную скорость вращения между углом 1 и углом 2. Затем частица будет
     * вращаться с выбранной скоростью в течение всей своей жизни. Используйте отрицательные значения для вращения
     * против часовой стрелки и положительные для вращения по часовой стрелке.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $angle1 Минимальный угол дальности в радианах в секунду.
     * @param float $angle2 Максимальный угол дальности в радианах в секунду.
     * @return void
     */
    function SetParticlesRotationRangeRad($ID, $angle1, $angle2)
    {
    }

    /**
     * Задает диапазон вращения в радианах, который частица может иметь в течение своей жизни. Когда частица создается,
     * она начинается под углом 0 и выбирает случайную скорость вращения между углом 1 и углом 2. Затем частица будет
     * вращаться с выбранной скоростью в течение всей своей жизни. Используйте отрицательные значения для вращения
     * против часовой стрелки и положительные для вращения по часовой стрелке.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $angle1 Минимальный угол диапазона в градусах в секунду.
     * @param float $angle2 Максимальный угол диапазона в градусах в секунду.
     * @return void
     */
    function SetParticlesRotationRange($ID, $angle1, $angle2)
    {
    }

    /**
     * Устанавливает положение излучателя частиц. Это положение, из которого будут появляться новые частицы, и не
     * влияет на частицы, которые уже видны.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x Новая координата x для излучателя в мировых координатах.
     * @param float $y Новая координата y для излучателя в мировых координатах.
     * @return void
     */
    function SetParticlesPosition($ID, $x, $y)
    {
    }

    /**
     * Устанавливает максимальное количество частиц, которые будут испускаться. Если это значение равно -1, то число
     * бесконечно. Излучатель будет вести подсчет количества частиц, которые он испускает, и остановится, когда будет
     * достигнут предел. Чтобы проверить, достиг ли излучатель своего предела, используйте GetParticlesMaxReached.
     * Чтобы сбросить счетчик и заставить его снова начать излучать, используйте ResetParticleCount.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $max Максимальное количество испускаемых частиц
     * @return void
     */
    function SetParticlesMax($ID, $max)
    {
    }

    /**
     * Задает время жизни частиц после их испускания в секундах. После того, как частицы будут живы в течение заданного
     * количества секунд, они исчезнут. Это одно из двух значений, влияющих на количество генерируемых частиц,
     * другое-SetParticlesFrequency. Максимальное количество частиц, которое может быть на экране в любой момент
     * времени, - это freq*life, причем freq-это количество частиц, испускаемых в секунду. Это значение не зависит от
     * частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время в секундах, в течение которого частица видна.
     * @return void
     */
    function SetParticlesLife($ID, $time)
    {
    }

    /**
     * Устанавливает изображение, которое будет использоваться для каждой частицы. Начиная с 1083 изображений, которые
     * могут быть загружены из субизображений, содержащихся в текстурах атласа.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $imageID Идентификатор изображения, используемого для испускаемых частиц.
     * @return void
     */
    function SetParticlesImage($ID, $imageID)
    {
    }

    /**
     * Задает частоту генерации новых частиц. Значение freq указывает, сколько частиц должно быть произведено в
     * секунду, это не зависит от частоты кадров. Это одно из двух значений, влияющих на количество генерируемых
     * частиц, другое-SetParticlesLife. Максимальное количество частиц, которое может быть на экране в любой момент
     * времени, - это freq*life, причем жизнь-это количество секунд, в течение которых частица живет, прежде чем
     * исчезнуть. Это значение не зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $freq Скорость образования новых частиц в частицах в секунду.
     * @return void
     */
    function SetParticlesFrequency($ID, $freq)
    {
    }

    /**
     * Позволяет частицам вращаться в том направлении, в котором они движутся. Это переопределяет любое использование
     * SetParticlesRotationRange для изменения скорости вращения частиц. Вместо этого частицы всегда будут вращаться
     * лицом к направлению своего движения.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $mode 1, чтобы заставить частицы вращаться в том направлении, в котором они движутся, 0, чтобы
     *     использовать нормальное вращение.
     * @return void
     */
    function SetParticlesFaceDirection($ID, $mode)
    {
    }

    /**
     * Задает начальное направление новых частиц, когда они выходят из излучателя. Это можно использовать вместе с
     * командой SetParticlesAngle, чтобы установить диапазон изменения от этого начального направления, которое могут
     * выбрать новые частицы. Это также устанавливает начальную скорость частиц, принимая длину вектора за единицы в
     * секунду. Например, если начальное направление vx=10, vy=-15, частицы начнут двигаться вправо со скоростью 10
     * единиц в секунду и вверх со скоростью 15 единиц в секунду и будут продолжать эту скорость движения в течение
     * всей своей жизни, если на них не будут влиять силы, добавленные с помощью AddParticlesForce.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $vx Направление x, в котором частицы будут двигаться изначально.
     * @param float $vy Направление y, в котором частицы будут двигаться изначально.
     * @return void
     */
    function SetParticlesDirection($ID, $vx, $vy)
    {
    }

    /**
     * Задает глубину излучателя частиц. Это касается всех частиц, даже тех, которые уже видны. Все частицы рисуются на
     * той же глубине, что и излучатель, так что AGK может сгруппировать их в один вызов рисования для более быстрого
     * рисования. Глубина должна быть между 0 и 10000, причем 0-это передняя часть экрана.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $depth Новое значение глубины частиц.
     * @return void
     */
    function SetParticlesDepth($ID, $depth)
    {
    }

    /**
     * Устанавливает режим интерполяции для изменения цвета. Цвета могут быть установлены в определенные моменты жизни
     * частицы с помощью AddParticlesColorKeyFrame, и частица либо смешается между этими цветами, либо быстро
     * изменится, когда достигнет следующего изменения цвета.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $mode 1=плавная интерполяция, 0=отсутствие интерполяции
     * @return void
     */
    function SetParticlesColorInterpolation($ID, $mode)
    {
    }

    /**
     * Задает диапазон направления в радианах, который частица может выбрать при первом запуске. Это берет базовое
     * направление, заданное с помощью SetParticlesDirection, и регулирует его на случайную величину от 0 до угла/2
     * радиана. Например, угол 0 будет означать, что все новые частицы следуют точно в указанном ранее направлении.
     * Угол 2*PI будет означать, что частицы могут появиться, двигаясь в любом направлении, а угол PI/2 будет означать,
     * что частицы будут двигаться наружу в конусе радианов PI/2 от их начального положения с центром конуса в данном
     * направлении.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $angle Диапазон изменения, который частица может выбрать из направления излучателя.
     * @return void
     */
    function SetParticlesAngleRad($ID, $angle)
    {
    }

    /**
     * Задает диапазон направления в градусах, который частица может выбрать при первом запуске. Это берет базовое
     * направление, заданное с помощью SetParticlesDirection, и регулирует его на случайную величину между 0 и углом/2
     * градуса. Например, угол 0 будет означать, что все новые частицы следуют точно в указанном ранее направлении.
     * Угол 360 будет означать, что частицы могут появиться, двигаясь в любом направлении, а угол 90 будет означать,
     * что частицы будут двигаться наружу в конусе 90 градусов от их начального положения с центром конуса в данном
     * направлении.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $angle Диапазон изменения, который частица может выбрать из направления излучателя.
     * @return void
     */
    function SetParticlesAngle($ID, $angle)
    {
    }

    /**
     * Устанавливает, обновляются ли испускаемые частицы каждый кадр. Установите значение 1, чтобы обновить частицы как
     * обычно, и 0, чтобы приостановить их. Частицы будут продолжать быть видимыми, когда остановятся. Чтобы скрыть
     * частицы, используйте SetParticlesVisible.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $active 1=нормально, 0=пауза
     * @return void
     */
    function SetParticlesActive($ID, $active)
    {
    }

    /**
     * Устанавливает, в какую ориентацию AGK позволит вращаться приложению. Есть две портретные и две пейзажные
     * ориентации, одна для правильного пути вверх, а другая для перевернутого. На платформах, которые не могут
     * вращаться, таких как Windows или Mac, эта команда не имеет никакого эффекта, и приложение всегда будет
     * нарисовано правильно. Значение 1 для каждой ориентации будет определять, будет ли приложение вращаться, когда
     * устройство удерживается в этой ориентации. Значение 0 сохранит приложение в его последней допустимой ориентации.
     * Обратите внимание, что если устройство в данный момент находится в запрещенной ориентации, то AGK попытается
     * повернуть устройство в разрешенную ориентацию, однако это не гарантируется немедленно. Так, например, если вам
     * нужно, чтобы устройство находилось в ландшафтном режиме, и вы вызываете эту команду с разрешенным только
     * ландшафтным режимом, вам следует дождаться, пока GetDeviceWidth вернет больше, чем GetDeviceHeight, что будет
     * сигнализировать о том, что устройство теперь находится в ландшафтном режиме.
     *
     * @param int $portrait Ориентация устройства по умолчанию.
     * @param int $portrait2 Перевернутая портретная ориентация.
     * @param int $landscape Альбомная ориентация при повороте устройства влево от его положения по умолчанию.
     * @param int $landscape2 Альбомная ориентация при повороте устройства вправо от его положения по умолчанию.
     * @return void
     */
    function SetOrientationAllowed($portrait, $portrait2, $landscape, $landscape2)
    {
    }

    /**
     * Устанавливает, является ли этот объект видимым или нет. Он по-прежнему будет участвовать в столкновениях и
     * других невизуальных взаимодействиях.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 1, чтобы сделать этот объект видимым, 0, чтобы скрыть его.
     * @return void
     */
    function SetObjectVisible($objID, $mode)
    {
    }

    /**
     * Изменяет все сетки в объекте для использования указанного УФ-масштаба, см. SetObjectMeshUVScale для получения
     * дополнительной информации.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $textureStage Текстурная стадия UVS для модификации находится в диапазоне от 0 до 7
     * @param float $scaleU Шкала, используемая в направлении U, по умолчанию равна 1
     * @param float $scaleV Шкала, используемая в направлении V, по умолчанию равна 1
     * @return void
     */
    function SetObjectUVScale($objID, $textureStage, $scaleU, $scaleV)
    {
    }

    /**
     * Изменяет все сетки в объекте для использования указанного смещения UV, дополнительные сведения см. в разделе
     * SetObjectMeshUVOffset.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $textureStage Текстурная стадия UVS для модификации находится в диапазоне от 0 до 7
     * @param float $offsetU Смещение, используемое в направлении U, по умолчанию равно 0
     * @param float $offsetV Смещение, используемое в направлении V, по умолчанию равно 0
     * @return void
     */
    function SetObjectUVOffset($objID, $textureStage, $offsetU, $offsetV)
    {
    }

    /**
     * Устанавливает режим прозрачности для этого объекта, 0-непрозрачный, 1-альфа-смешанный, 2-аддитивный смешанный,
     * 3-пользовательский смешанный. Использование значения прозрачности больше 0 замедлит рендеринг, он также не
     * записывает прозрачные объекты в Z-буфер, поэтому может вызвать некоторые проблемы с упорядочением глубины.
     * Существует альтернативная форма прозрачности, называемая альфа-маскировкой, которая полезна, если вам нужны
     * только полностью прозрачные или полностью непрозрачные пиксели, но нет смешивания между ними. Более подробную
     * информацию см. в разделе SetObjectAlphaMask. При использовании режима 3 (custom) значения смешивания должны быть
     * заданы с помощью SetObjectBlendModes, иначе объект не будет прозрачным.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode Режим прозрачности, используемый для этого объекта.
     * @return void
     */
    function SetObjectTransparency($objID, $mode)
    {
    }

    /**
     * Устанавливает форму столкновения объектов в статическую треугольную сетку на основе размера объекта. Объект
     * становится статическим объектом треугольная сетчатая форма не может быть динамической. Сначала вы должны создать
     * физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function SetObjectShapeStaticPolygon($objID)
    {
    }


    /**
     * Задает форму столкновения в виде сферы в зависимости от размера объекта. Сначала вы должны создать физическое
     * тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @param float|null $diameter размер сферы (не обязательный параметр)
     * @return void
     */
    function SetObjectShapeSphere(int $objID, float $diameter = null)
    {
    }


    /**
     * Задает форму столкновения в виде цилиндра в зависимости от размера объекта. Сначала вы должны создать физическое
     * тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 =Ось X, 1 =ось Y, 2 = ориентация оси Z
     * @param float|null $height высота по оси y (не оябзательный параметр)
     * @param float|null $diameter диаметр на x и z (не оябзательный параметр)
     * @return void
     */
    function SetObjectShapeCylinder(int $objID, int $axis, float $height = null, float $diameter = null)
    {
    }

    /**
     * Устанавливает форму столкновения объектов на выпуклую оболочку в зависимости от размера объекта. Сначала вы
     * должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function SetObjectShapeConvexHull($objID)
    {
    }

    /**
     * Устанавливает форму столкновения в виде конуса на основе переданного размера. Сначала вы должны создать
     * физическое тело для объекта, иначе эта команда не будет выполнена. Возвращает идентификатор фигуры.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 =Ось X, 1 =ось Y, 2 = ориентация оси Z
     * @param float|null $height высота по оси y (не обязательный параметр)
     * @param float|null $diameter диаметр на x и z (не обязательный параметр)
     * @return void
     */
    function SetObjectShapeCone(int $objID, int $axis, float $height = null, float $diameter = null)
    {
    }


    /**
     * Устанавливает форму столкновения объектов в составную форму, готовую к добавлению новых фигур. Объект должен
     * быть динамическим.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function SetObjectShapeCompound(int $objID)
    {
    }

    /**
     * Устанавливает форму столкновения в капсулу на основе переданного размера. Сначала вы должны создать физическое
     * тело для объекта, иначе эта команда не будет выполнена.
     *
     *
     * Пример вызова:
     *
     * void SetObjectShapeCapsule($objID, int $axis);
     *
     * void SetObjectShapeCapsule($objID, $axis, $vectorID);
     *
     * void SetObjectShapeCapsule(int $objID, int $axis, float $sizeX, float $sizeY, float $sizeZ);
     * @param int $objID идентификатор объекта
     * @param int $axis 0 =Ось X, 1 =ось Y, 2 = ориентация оси Z
     * @param int $vectorID Идентификатор вектора измерения.
     * @param float $sizeX размер по оси x
     * @param float $sizeY размер по оси Y
     * @param float $sizeZ размер по оси Z
     * @return void
     */
    function SetObjectShapeCapsule(mixed...$args)
    {
    }

    /**
     * Устанавливает форму столкновения в поле на основе переданного размера. Сначала вы должны создать физическое тело
     * для объекта, иначе эта команда не будет выполнена.
     *
     * Пример вызова:
     *
     * void SetObjectShapeBox($objID);
     *
     * void SetObjectShapeBox($objID,$vectorID);
     *
     * void SetObjectShapeBox($objID, $sizeX, $sizeY, $sizeZ);
     * @param int $objID идентификатор объекта
     * @param int $vectorID Идентификатор вектора измерения
     * @param float $sizeX размер по оси x
     * @param float $sizeY размер по оси Y
     * @param float $sizeZ размер по оси Z
     * @return void
     */
    function SetObjectShapeBox(mixed...$args)
    {
    }

    /**
     * Останавливает объект, устанавливающий заданное имя константы в его шейдерах, и с этого момента использует
     * значение шейдера по умолчанию.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param string $szName Имя константы, чтобы перестать меняться.
     * @return void
     */
    function SetObjectShaderConstantDefault($objID, $szName)
    {
    }

    /**
     * Задает константу шейдера для объекта по имени, константа должна быть помечена как "однородная" в источнике
     * шейдера. Объект установит указанную константу в это значение для любого шейдера, к которому он будет применен.
     * Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4 значения и отбрасывает все, которые не
     * используются именованной переменной.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param string $szName Имя изменяемой константы, как определено в исходном файле шейдера.
     * @param float $value1 Компонент X или R нового значения, это значение всегда будет использоваться.
     * @param float $value2 Компонент Y или G нового значения, если константа использует только 1 компонент, это
     *     значение отбрасывается.
     * @param float $value3 Компонент Z или B нового значения, если константа использует только 2 компонента, это
     *     значение отбрасывается.
     * @param float $value4 W или компонент нового значения, если константа использует только 3 компонента, это
     *     значение отбрасывается.
     * @return void
     */
    function SetObjectShaderConstantByName($objID, $szName, $value1, $value2, $value3, $value4)
    {
    }

    /**
     * Задает константу шейдера для объекта по имени, константа должна быть помечена как "однородная" в источнике
     * шейдера. Объект установит указанную константу в это значение для любого шейдера, к которому он будет применен.
     * Индексы массива начинаются с 0, если индекс массива находится за пределами границ, то он будет проигнорирован и
     * никакие изменения не будут внесены. Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4
     * значения и отбрасывает все, которые не используются именованной переменной.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param string $szName Имя изменяемой константы, как определено в исходном файле шейдера.
     * @param int $arrayIndex Индекс элемента в массиве для изменения.
     * @param float $value1 Компонент X или R нового значения, это значение всегда будет использоваться.
     * @param float $value2 Компонент Y или G нового значения, если константа использует только 1 компонент, это
     *     значение отбрасывается.
     * @param float $value3 Компонент Z или B нового значения, если константа использует только 2 компонента, это
     *     значение отбрасывается.
     * @param float $value4 W или компонент нового значения, если константа использует только 3 компонента, это
     *     значение отбрасывается.
     * @return void
     */
    function SetObjectShaderConstantArrayByName($objID, $szName, $arrayIndex, $value1, $value2, $value3, $value4)
    {
    }

    /**
     * Устанавливает шейдер, используемый для рисования сеток в этом объекте, каждая сетка может иметь свой собственный
     * набор шейдеров с помощью SetObjectMeshShader, эта команда устанавливает все сетки в этом объекте для
     * использования указанного шейдера. Шейдер, должно быть, был загружен LoadShader. Шейдер похож на сценарий,
     * отправленный в графический процессор, чтобы рассказать ему, как объединить полигональные и текстурные данные для
     * отображения их на экране. По умолчанию сеткам присваивается внутренний шейдер, который будет обрабатывать
     * освещение и текстурирование. Если вы используете идентификатор шейдера 0, сеткам присваивается внутренний
     * шейдер.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $shaderID Идентификатор используемого шейдера.
     * @return void
     */
    function SetObjectShader($objID, $shaderID)
    {
    }

    /**
     * Устанавливает, будет ли объект отбракован при его перемещении за пределы экрана. По умолчанию AGK попытается
     * определить, когда объект переместился за пределы экрана, и объекты, которые больше не находятся на экране,
     * больше не будут отправляться в конвейер рендеринга. Если вершинный шейдер изменяет вершины из их нормальных
     * положений, то это должно быть отключено, так как AGK не может заранее знать, где будет нарисован объект.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 0 для отключения отбраковки экрана, 1 для его включения (по умолчанию).
     * @return void
     */
    function SetObjectScreenCulling($objID, $mode)
    {
    }

    /**
     * Изменяет размер объекта в направлениях X, Y и Z. Это изменяет вершины объекта, что делает это постоянное
     * изменение более медленным, чем SetObjectScale. Эта команда не считывает и не влияет на значения,заданные с
     * помощью SetObjectScale,поэтому использование SetObjectScale(ID,2, 2, 2), а затем установка постоянного масштаба
     * 3,3,3 все равно нарисует объект в 2 раза больше обычного, что означает в 6 раз больше, чем при запуске. Эта
     * команда не влияет ни на какие дочерние объекты, которые могли быть загружены вместе с ней, ни на какие объекты,
     * прикрепленные к ней с помощью FixObjectToObject. Эта команда будет работать с костяными анимированными объектами
     * до тех пор, пока масштаб однороден, то есть значения шкалы X, Y и Z одинаковы.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $x Величина для масштабирования объекта по оси X.
     * @param float $y Величина для масштабирования объекта по оси Y.
     * @param float $z Величина для масштабирования объекта по оси Z.
     * @return void
     */
    function SetObjectScalePermanent($objID, $x, $y, $z)
    {
    }

    /**
     * Изменяет размер объекта в направлениях X, Y и Z. Значение масштаба 1,1,1 возвращает объект к его первоначальному
     * размеру, значение масштаба 2 делает объект вдвое больше, 0,5 - вдвое меньше и так далее. Эта команда не
     * складывается, поэтому вызов ее дважды со значением 2 не сделает ее в 4 раза больше, она останется в 2 раза
     * больше. Обратите внимание, что использование различных значений для направлений X, Y и Z, таких как so 1,2,1,
     * называется неоднородной шкалой, в то время как 1.5,1.5,1.5 будет однородной шкалой. Неравномерное
     * масштабирование требует, чтобы любой шейдер, используемый этим объектом, использовал матрицу agk_WorldNormal для
     * любых нормальных преобразований, чтобы выглядеть правильно. Если этот объект был загружен командой
     * LoadObjectWithChildren и имеет дочерние объекты или имеет объекты, прикрепленные к нему с помощью
     * FixObjectToObject, то они также будут масштабироваться на эту величину в дополнение к их собственному
     * масштабированию. Обратите внимание, что это не будет корректно работать с костяными анимированными объектами,
     * вместо этого используйте SetObjectScalePermanent.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $x Величина для масштабирования объекта по оси X.
     * @param float $y Величина для масштабирования объекта по оси Y.
     * @param float $z Величина для масштабирования объекта по оси Z.
     * @return void
     */
    function SetObjectScale($objID, $x, $y, $z)
    {
    }

    /**
     * Задает вращение указанного объекта с помощью кватерниона. В качестве альтернативы вы можете использовать
     * SetObjectRotation для использования углов Эйлера. По умолчанию объекты создаются с кватернионом 1,0,0,0 в
     * порядке w,x,y,z. Кватернион-это 4-мерное представление трехмерного вращения со свойством w^2+x^2+y^2+z^2 = 1,
     * которое позволяет легко интерполировать между двумя вращениями путем линейной интерполяции двух кватернионов и
     * их нормализации. Каждое 3D-вращение представлено ровно 2 кватернионами, w,x,y,z и -w,-x,-y,-z, поэтому любая
     * версия может быть возвращена командами GetObjectQuat. Кватернионы и углы Эйлера могут использоваться
     * одновременно. Например, установка вращения кватерниона будет генерировать эквивалентные значения Эйлера, которые
     * могут быть получены с помощью GetObjectAngleX, GetObjectAngleX и GetObjectAngleZ.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $w W-компонент кватерниона.
     * @param float $x X-компонент кватерниона.
     * @param float $y Y-компонент кватерниона.
     * @param float $z Z-компонент кватерниона.
     * @return void
     */
    function SetObjectRotationQuat($objID, $w, $x, $y, $z)
    {
    }

    /**
     * Задает поворот указанного объекта с помощью углов Эйлера в градусах. В качестве альтернативы вы можете
     * использовать SetObjectRotationQuat для использования кватерниона. По умолчанию объекты создаются с углами 0,0,0
     * в порядке YXZ. Углы Эйлера-это составные углы, где объект начинается с 0,0,0 и затем поворачивается на заданный
     * угол Y, затем на заданный угол X, а затем катится на заданный угол Z. Каждое 3D-вращение может быть представлено
     * 2 комбинациями углов Эйлера, Y,X,Z и Y-180,X-180,Z-180, поэтому любая версия может быть возвращена командами
     * GetObjectAngle. Кватернионы и углы Эйлера могут использоваться одновременно. Например, установка вращения
     * кватерниона будет генерировать эквивалентные значения Эйлера, которые могут быть получены с помощью
     * GetObjectAngleX, GetObjectAngleX и GetObjectAngleZ.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $angx X-компонент вращения Эйлера.
     * @param float $angy Y-компонент вращения Эйлера.
     * @param float $angz Z-компонент вращения Эйлера.
     * @return void
     */
    function SetObjectRotation($objID, $angx, $angy, $angz)
    {
    }

    /**
     * Задает объект для получения теней от других объектов. По умолчанию это значение равно 1. Объект может быть
     * настроен как на отбрасывание, так и на получение теней.
     *
     * @param int $objID Идентификатор объекта для получения теней
     * @param int $mode 1, чтобы заставить этот объект получать тени, 0, чтобы остановить его получение теней
     * @return void
     */
    function SetObjectReceiveShadow($objID, $mode)
    {
    }

    /**
     * Задает положение указанного объекта. По умолчанию объекты располагаются на уровне 0,0,0
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $x X-компонент позиции.
     * @param float $y Y-компонент позиции.
     * @param float $z Z-компонент позиции.
     * @return void
     */
    function SetObjectPosition($objID, $x, $y, $z)
    {
    }

    /**
     * Масштабирует нормальные координаты карты UV на заданную величину. Это не влияет ни на какую другую текстуру, но
     * накладывается поверх УФ-смещения и масштаба объекта. Значение масштаба 1.0 будет использовать немодифицированный
     * UVS, значение масштаба 2.0 удвоит значение UV и так далее.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $scaleU Сумма для масштабирования карты нормалей в направлении U
     * @param float $scaleV Величина для масштабирования карты нормалей в направлении V
     * @return void
     */
    function SetObjectNormalMapScale($objID, $scaleU, $scaleV)
    {
    }

    /**
     * Устанавливает все сетки в этом объекте для использования указанного изображения в качестве карты нормалей. Вы
     * можете установить нормальную карту для одной сетки с помощью SetObjectMeshNormalMap. Нормальная карта будет
     * помещена в текстурную стадию 2, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который сочетает
     * ее с любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете свой собственный
     * шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму карту нормалей, так как AGK не
     * будет изменять ваш шейдер таким образом. Нормальная карта будет использовать второй набор УФ-координат, если
     * таковой имеется, в противном случае она будет использовать те же УФ-координаты, что и базовая текстура. Если
     * есть также изображение на стадии текстуры 1 (например, световая карта), то нормальная карта всегда будет
     * использовать базовый UVS.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $imageID Идентификатор изображения, которое будет использоваться в качестве обычной карты.
     * @return void
     */
    function SetObjectNormalMap($objID, $imageID)
    {
    }

    /**
     * Изменяет UVS сетки, чтобы масштабировать их на заданную величину. Это может вытолкнуть УФ-координаты за пределы
     * диапазона от 0.0 до 1.0, и в этом случае режим обертывания изображения будет использоваться либо для зажима,
     * либо для повторения текстуры. Используйте SetImageWrapU и SetImageWrapV для установки режима обертывания.
     * Значение масштаба 1 оставит UV-координаты со значениями по умолчанию, в то время как значение масштаба 2.0
     * удвоит количество раз, когда текстура появляется на сетке (при условии, что режим обертывания установлен на
     * повторение). Обратите внимание, что изображение должно быть размером в 2 степени, чтобы использовать режим
     * повтора.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения.
     * @param int $textureStage Текстурная стадия UVS для модификации находится в диапазоне от 0 до 7
     * @param float $scaleU Шкала, используемая в направлении U, по умолчанию равна 1
     * @param float $scaleV Шкала, используемая в направлении V, по умолчанию равна 1
     * @return void
     */
    function SetObjectMeshUVScale($objID, $meshIndex, $textureStage, $scaleU, $scaleV)
    {
    }

    /**
     * Устанавливает, является ли эта сетка объектов видимой или нет.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для проверки, первая сетка находится в индексе 1.
     * @param int $mode 1, чтобы установить эту сетку объектов как видимую, 0, чтобы скрыть ее.
     * @return void
     */
    function SetObjectMeshVisible($objID, $meshIndex, $mode)
    {
    }

    /**
     * Изменяет UVS сетки, чтобы сдвинуть их на заданное смещение. Это может вытолкнуть УФ-координаты за пределы
     * диапазона от 0.0 до 1.0, и в этом случае режим переноса изображения будет использоваться либо для зажима, либо
     * для повторения текстуры. Используйте SetImageWrapU и SetImageWrapV для установки режима обертывания. Обратите
     * внимание, что изображение должно быть размером в 2 степени, чтобы использовать режим повтора.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения.
     * @param int $textureStage Текстурная стадия UVS для модификации находится в диапазоне от 0 до 7
     * @param float $offsetU Смещение, используемое в направлении U, по умолчанию равно 0
     * @param float $offsetV Смещение, используемое в направлении V, по умолчанию равно 0
     * @return void
     */
    function SetObjectMeshUVOffset($objID, $meshIndex, $textureStage, $offsetU, $offsetV)
    {
    }

    /**
     * Устанавливает шейдер, используемый для рисования этой сетки, шейдер должен быть загружен LoadShader. Шейдер
     * похож на сценарий, отправленный в графический процессор, чтобы рассказать ему, как объединить полигональные и
     * текстурные данные для отображения их на экране. По умолчанию сеткам присваивается внутренний шейдер, который
     * будет обрабатывать освещение и текстурирование. Если вы используете идентификатор шейдера 0, сетке присваивается
     * внутренний шейдер. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения, первая сетка находится в индексе 1.
     * @param int $shaderID Идентификатор используемого шейдера.
     * @return void
     */
    function SetObjectMeshShader($objID, $meshIndex, $shaderID)
    {
    }

    /**
     * Масштабирует нормальные координаты карты UV на заданную величину. Это не влияет ни на какую другую текстуру, но
     * накладывается поверх УФ-смещения и масштаба объекта. Значение масштаба 1.0 будет использовать немодифицированный
     * UVS, значение масштаба 2.0 удвоит значение UV и так далее.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения, первая сетка находится в индексе 1.
     * @param float $scaleU Сумма для масштабирования карты нормалей в направлении U
     * @param float $scaleV Величина для масштабирования карты нормалей в направлении V
     * @return void
     */
    function SetObjectMeshNormalMapScale($objID, $meshIndex, $scaleU, $scaleV)
    {
    }

    /**
     * Устанавливает сетку объекта для использования указанного изображения в качестве карты нормалей. Нормальная карта
     * будет помещена в текстурную стадию 2, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который
     * сочетает ее с любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете свой
     * собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму карту нормалей, так
     * как AGK не будет изменять ваш шейдер таким образом. Индексы сетки находятся в диапазоне от 1 до
     * GetObjectNumMeshes
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения, первая сетка находится в индексе 1.
     * @param int $imageID Идентификатор изображения, которое будет использоваться в качестве обычной карты.
     * @return void
     */
    function SetObjectMeshNormalMap($objID, $meshIndex, $imageID)
    {
    }

    /**
     * Устанавливает сетку объекта для использования указанного изображения в качестве световой карты. Световая карта
     * будет помещена в текстурную стадию 1, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который
     * объединит ее с текстурной стадией 0 и любым динамическим освещением, чтобы правильно осветить объект. Если вы
     * устанавливаете свой собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму
     * световую карту, так как AGK не будет изменять ваш шейдер таким образом. Индексы сетки находятся в диапазоне от 1
     * до GetObjectNumMeshes
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения, первая сетка находится в индексе 1.
     * @param int $imageID Идентификатор изображения, которое будет использоваться в качестве световой карты.
     * @return void
     */
    function SetObjectMeshLightMap($objID, $meshIndex, $imageID)
    {
    }

    /**
     * Устанавливает сетку объекта для использования этого изображения при рендеринге. Сетка может иметь до 8
     * изображений, назначенных ей на этапах текстуры от 0 до 7. Если вы не уверены, какой этап текстуры использовать,
     * поместите изображение в этап 0. Стадии текстуры можно использовать для назначения нескольких изображений сетке,
     * например, вы можете поместить базовую (диффузную) текстуру в стадию 0, нормальную карту в стадию 1 и световую
     * карту в стадию 2. Шейдер, используемый для рисования этого объекта, может затем объединить различные текстуры в
     * пиксельное значение для отображения на экране. Использование значения изображения 0 для определенного этапа
     * текстуры удаляет любое назначенное изображение с этого этапа. Индексы сетки находятся в диапазоне от 1 до
     * GetObjectNumMeshes
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения, первая сетка находится в индексе 1.
     * @param int $imageID Идентификатор изображения, назначаемого этому объекту.
     * @param int $textureStage Этап текстуры, используемый для этого изображения.
     * @return void
     */
    function SetObjectMeshImage($objID, $meshIndex, $imageID, $textureStage)
    {
    }

    /**
     * Изменяет сетку объекта на основе предоставленного memblock. Мемблок не обязательно должен иметь такое же
     * количество атрибутов или вершин, как исходная сетка, но он улучшит производительность, если это произойдет.
     * Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов
     * в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие
     * вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой
     * многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0
     * ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например,
     * позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3
     * атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют
     * размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта
     * смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала
     * индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные
     * атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют
     * нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1
     * байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет
     * равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых
     * байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например,
     * позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите
     * внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не
     * используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в
     * диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов
     * цвета и 0 для всего остального. Байт длины строки всегда должен быть кратен 4 по соображениям выравнивания, сама
     * строка может иметь немного меньше символов, но всегда округляется до ближайшего кратного 4 для значения длины
     * строки. например, строка длины 5 должна иметь значение длины строки 8. Обратите внимание, что строка из 4
     * символов имеет нулевой терминатор на конце, что делает ее длиной 5, поэтому, даже если она уже имеет кратное 4
     * символам значение длины, она должна использовать значение длины 8 из-за нулевого терминатора. Строка имени
     * атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, -
     * "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы
     * можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же
     * именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта,
     * то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные
     * вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X,
     * 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута,
     * указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности
     * 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам,
     * используя размер вершины, указанный выше, и индекс вершины, например so
     * offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый
     * индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три
     * индекса представляют собой многоугольник. Если вы планируете регулярно вносить изменения в сетку, вы должны
     * сохранить memblock после использования SetObjectMeshFromMemblock вместо того, чтобы регенерировать его из
     * объекта каждый раз, когда вы хотите внести изменения. Затем снова вызовите SetObjectMeshFromMemblock, когда вы
     * хотите перенести свои новые изменения на объект.
     *
     * @param int $objID Идентификатор объекта для изменения
     * @param int $meshIndex Индекс сетки для изменения
     * @param int $memID Индекс memblock, используемый для изменения сетки
     * @return void
     */
    function SetObjectMeshFromMemblock($objID, $meshIndex, $memID)
    {
    }

    /**
     * Включает или выключает обнаружение столкновений для одной сетки в объекте.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения режима Коллисона, первая сетка находится в индексе 1.
     * @param int $mode 0, чтобы выключить столкновение, 1, чтобы включить его.
     * @return void
     */
    function SetObjectMeshCollisionMode($objID, $meshIndex, $mode)
    {
    }

    /**
     * Вращает объект, чтобы посмотреть на определенную точку в пространстве с дополнительным значением крена.
     * "смотреть" определяется как выравнивание локальной оси Z объекта, чтобы указать его положительную сторону в
     * данной точке. Это может быть достигнуто с помощью только углов Y и X в эйлеровой нотации, поэтому вы можете
     * указать дополнительный угол Z в градусах, чтобы перевернуть объект слева направо, всегда глядя на одно и то же
     * место.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $x X-компонент позиции, на которую нужно смотреть.
     * @param float $y Y-компонент позиции, на которую нужно смотреть.
     * @param float $z Z-компонент позиции, на которую нужно смотреть.
     * @param float $roll Угол Z для поворота объекта при взгляде на заданное положение отрицательный-по часовой
     *     стрелке.
     * @return void
     */
    function SetObjectLookAt($objID, $x, $y, $z, $roll)
    {
    }

    /**
     * Включает или выключает освещение при рисовании этого объекта.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 0 для выключения освещения, 1 для его включения.
     * @return void
     */
    function SetObjectLightMode($objID, $mode)
    {
    }

    /**
     * Устанавливает все сетки в этом объекте для использования этого изображения при рендеринге. Вы можете установить
     * текстуры отдельно для каждой сетки с помощью SetObjectMeshImage. Каждая сетка может иметь до 8 изображений,
     * назначенных ей на этапах текстуры от 0 до 7. Если вы не уверены, какой этап текстуры использовать, поместите
     * изображение в этап 0. Стадии текстуры можно использовать для назначения нескольких изображений сетке, например,
     * вы можете поместить базовую (диффузную) текстуру в стадию 0, нормальную карту в стадию 1 и световую карту в
     * стадию 2. Шейдер, используемый для рисования этого объекта, может затем объединить различные текстуры в
     * пиксельное значение для отображения на экране. Использование значения изображения 0 для определенного этапа
     * текстуры удаляет любое назначенное изображение с этого этапа.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $imageID Идентификатор изображения, назначаемого этому объекту.
     * @param int $texStage Этап текстуры, используемый для этого изображения.
     * @return void
     */
    function SetObjectImage($objID, $imageID, $texStage)
    {
    }

    /**
     * Устанавливает все сетки в этом объекте для использования указанного изображения в качестве световой карты. Вы
     * можете установить световую карту для одной сетки с помощью SetObjectMeshLightMap. Световая карта будет помещена
     * в текстурную стадию 1, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который объединит ее с
     * текстурной стадией 0 и любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете
     * свой собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму световую карту,
     * так как AGK не будет изменять ваш шейдер таким образом. Световая карта будет использовать второй набор
     * УФ-координат, если он доступен, в противном случае она будет использовать те же УФ-координаты, что и базовая
     * текстура.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $imageID Идентификатор изображения, которое будет использоваться в качестве световой карты.
     * @return void
     */
    function SetObjectLightMap($objID, $imageID)
    {
    }

    /**
     * Включает или выключает туман при рисовании этого объекта. По умолчанию все объекты получают туман, когда он
     * включен с помощью SetFogMode
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 0, чтобы выключить туман, 1, чтобы включить его.
     * @return void
     */
    function SetObjectFogMode($objID, $mode)
    {
    }

    /**
     * Устанавливает режим записи глубины при рисовании этого объекта на экране. Если он проходит тест глубины, объект
     * записывает свое значение глубины в буфер глубины, чтобы остановить что-либо еще позади от прохождения их тестов
     * глубины. По умолчанию только объекты, которые находятся ближе (меньше) текущего значения глубины, будут
     * перезаписывать текущее содержимое экрана. Вы можете отключить эту запись в буфер глубины для этого объекта, это
     * может быть полезно для прозрачных объектов, которые не должны блокировать рисование позади себя. По умолчанию
     * для всех непрозрачных объектов включена запись глубины, а для всех прозрачных объектов-выключена запись глубины.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 0, чтобы отключить списание глубины для этого объекта, 1, чтобы включить его.
     * @return void
     */
    function SetObjectDepthWrite($objID, $mode)
    {
    }

    /**
     * Устанавливает режим чтения глубины при рисовании этого объекта на экране. Объект должен пройти тест глубины,
     * чтобы быть видимым. Доступные варианты: 0=никогда не проходите, 1=меньше, 2=равно, 3=меньше или равно, 4=больше,
     * 5=не равно, 6=больше или равно, 7=всегда проходите. По умолчанию все объекты используют режим 1 (меньше), что
     * означает, что они должны быть ближе, чем любые уже нарисованные объекты, чтобы быть видимыми.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode Режим глубины, используемый для этого объекта.
     * @return void
     */
    function SetObjectDepthReadMode($objID, $mode)
    {
    }

    /**
     * Устанавливает смещение глубины при рисовании этого объекта на экране. Если два объекта находятся очень близко
     * друг к другу, один перед другим, они могут вызвать Z-бой, где они, кажется, мерцают между одним объектом и
     * другим, отображаемым друг перед другом. Например, наклейка на поверхность другого объекта. Смещение Z
     * предназначено для предотвращения этого мерцания, заставляя (смещая) один объект всегда находиться впереди или
     * позади другого. Величина смещения должна быть положительной, чтобы приблизить этот объект к камере, и
     * отрицательной, чтобы отодвинуть его назад. На самом деле это не влияет на положение объекта, только на его
     * воспринимаемое положение, когда система рендеринга проверяет, должен ли объект быть нарисован или нет. Если
     * объект проходит этот тест на смещенную глубину, то он рисуется в исходном положении. Значение смещения кратно
     * наименьшему значению буфера z, поэтому рекомендуемым значением является значение смещения 1. Значения меньше
     * этого вряд ли будут иметь какой-либо эффект, значения больше этого можно попробовать, если значение 1 не
     * работает, попробуйте 1.5, 2.0 и т. Д.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $bias Величина смещения, равная 0, чтобы отключить смещение глубины для этого объекта.
     * @return void
     */
    function SetObjectDepthBias($objID, $bias)
    {
    }

    /**
     * Задает диапазон значений глубины, с которыми сопоставляется этот объект. По умолчанию это от 0 до 1, где 0 -
     * ближняя плоскость, а 1-дальняя. Например, установка диапазона глубины 1,1 приведет к тому, что каждый пиксель в
     * этом объекте будет иметь значение глубины 1 при сравнении и записи в буфер глубины. Значения будут зажаты в
     * диапазоне от 0 до 1, объекты за пределами ближней или дальней плоскостей все равно будут обрезаны. Обратные
     * сопоставления разрешаются установкой near больше, чем far.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $zNear Начало диапазона глубин для этого объекта
     * @param float $zFar Конец диапазона глубин для этого объекта
     * @return void
     */
    function SetObjectDepthRange($objID, $zNear, $zFar)
    {
    }

    /**
     * Задает, должен ли этот объект рисовать свои задние грани при рендеринге. Используйте режим 0=как передние, так и
     * задние нарисованные, 1=только передние грани, 2=только задние грани. По умолчанию рисуются только лицевые грани
     * (режим 1).
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode Режим отбраковки, используемый для этого объекта.
     * @return void
     */
    function SetObjectCullMode($objID, $mode)
    {
    }

    /**
     * Задает эмиссионный цвет, используемый при рисовании этого объекта. Значения должны находиться в диапазоне 0-255,
     * но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать объект, а значения меньше 0 будут отнимать
     * свет. Излучающий цвет имитирует свет, генерируемый объектом, поэтому он получит этот цвет, даже если он ничем не
     * освещается. Это не влияет ни на какие окружающие предметы.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $red Красная составляющая цвета.
     * @param int $green Зеленая составляющая цвета.
     * @param int $blue Синяя составляющая цвета.
     * @return void
     */
    function SetObjectColorEmissive($objID, $red, $green, $blue)
    {
    }

    /**
     * Задает диффузный цвет, используемый при рисовании этого объекта. Значения должны находиться в диапазоне 0-255,
     * но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать объект, а значения меньше 0 будут отнимать
     * свет.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $red Красная составляющая цвета.
     * @param int $green Зеленая составляющая цвета.
     * @param int $blue Синяя составляющая цвета.
     * @param int $alpha Альфа-компонент цвета.
     * @return void
     */
    function SetObjectColor($objID, $red, $green, $blue, $alpha)
    {
    }

    /**
     * Включает или выключает обнаружение столкновений для этого объекта.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 0, чтобы выключить столкновение, 1, чтобы включить его.
     * @return void
     */
    function SetObjectCollisionMode($objID, $mode)
    {
    }

    /**
     * Задает объект для отбрасывания теней на другие объекты. По умолчанию это значение равно 0. Объект может быть
     * настроен как на отбрасывание, так и на получение теней.
     *
     * @param int $objID Идентификатор объекта для отбрасывания теней
     * @param int $mode 1, чтобы заставить этот объект отбрасывать тени, 0, чтобы остановить его отбрасывание теней
     * @return void
     */
    function SetObjectCastShadow($objID, $mode)
    {
    }

    /**
     * Задает вращение указанной кости относительно ее родителя в виде кватерниона.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param float $w W-компонент вращения.
     * @param float $x X-составляющая вращения.
     * @param float $y Y-составляющая вращения.
     * @param float $z Z-составляющая вращения.
     * @return void
     */
    function SetObjectBoneRotationQuat($objID, $boneIndex, $w, $x, $y, $z)
    {
    }

    /**
     * Задает поворот указанной кости с помощью углов Эйлера в градусах. В качестве альтернативы вы можете использовать
     * SetObjectBoneRotationQuat для использования кватерниона.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости для изменения
     * @param float $angx X-составляющая вращения.
     * @param float $angy Y-составляющая вращения.
     * @param float $angz Z-составляющая вращения.
     * @return void
     */
    function SetObjectBoneRotation($objID, $boneIndex, $angx, $angy, $angz)
    {
    }

    /**
     * Вращает кость, чтобы посмотреть на определенную точку в мировом пространстве с дополнительным значением крена.
     * "смотреть" определяется как выравнивание локальной оси Z кости, чтобы указать ее положительную сторону в данной
     * точке. Это может быть достигнуто с помощью только углов Y и X в эйлеровой нотации, поэтому вы можете указать
     * дополнительный угол Z в градусах, чтобы катить кость слева направо, всегда глядя на одно и то же место.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param float $x X-компонент позиции, на которую нужно смотреть.
     * @param float $y Y-компонент позиции, на которую нужно смотреть.
     * @param float $z Z-компонент позиции, на которую нужно смотреть.
     * @param float $roll Угол Z для перекатывания кости при взгляде на заданное положение отрицательный-по часовой
     *     стрелке.
     * @return void
     */
    function SetObjectBoneLookAt($objID, $boneIndex, $x, $y, $z, $roll)
    {
    }

    /**
     * Устанавливает положение указанной кости относительно ее родителя.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости для изменения
     * @param float $x X-компонент позиции.
     * @param float $y Y-компонент позиции.
     * @param float $z Z-компонент позиции.
     * @return void
     */
    function SetObjectBonePosition($objID, $boneIndex, $x, $y, $z)
    {
    }

    /**
     * Задает, управляется ли указанная кость анимацией или управляется вручную. При управлении анимацией ни одна из
     * команд SetObjectBonePosition или аналогичных команд не будет иметь никакого эффекта. При ручном управлении кость
     * будет сохранять свое текущее положение, если вы не измените его.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param int $animate 1, чтобы позволить анимации воздействовать на эту кость, 0, чтобы разрешить ручное
     *     управление.
     * @return void
     */
    function SetObjectBoneCanAnimate($objID, $boneIndex, $animate)
    {
    }

    /**
     * Если SetObjectTransparency имеет значение 3, то исходные и целевые значения смешивания можно задать вручную с
     * помощью этой команды. Доступны следующие режимы наложения: 0 = 0 1 = 1 2 = Исходный пиксель Альфа 3 = 1 -
     * Исходный Пиксель Альфа 4 = Целевой Пиксель Альфа 5 = 1 - Целевой Пиксель Альфа 6 = Исходный Пиксель Цвет
     * (действителен только для режима назначения) 7 = 1 - Исходный пиксель Цвет (действителен только для режима
     * назначения) 8 = Целевой пиксель Цвет (действителен только для режима источника) 9 = 1 - Целевой пиксель Цвет
     * (действителен только для режима источника) 10 = Альфа Насыщение (действителен только для режима источника)
     * Исходный пиксель будет умножен на исходный режим, а целевой пиксель будет умножен на целевой режим. Затем они
     * будут сложены вместе, чтобы получить окончательный цвет пикселя. Исходный пиксель-это пиксель, принадлежащий
     * рисуемому объекту, в то время как конечный пиксель-это цвет пикселя, уже находящегося на экране, над которым
     * рисуется текущий объект.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $src Режим наложения, используемый для источника наложения.
     * @param int $dst Режим наложения, используемый для назначения наложения.
     * @return void
     */
    function SetObjectBlendModes($objID, $src, $dst)
    {
    }

    /**
     * Устанавливает скорость анимации для данного объекта как кратную времени по умолчанию, то есть 1.0 будет
     * использовать время из ключевых кадров анимации, 2.0 будет воспроизводить их в два раза быстрее, 0.5-в два раза
     * медленнее и так далее. Вы также можете использовать отрицательные значения для воспроизведения анимации в
     * обратном порядке или 0 для ее приостановки.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $speed Новая скорость анимации, используемая для этого объекта, по умолчанию 1.0
     * @return void
     */
    function SetObjectAnimationSpeed($objID, $speed)
    {
    }

    /**
     * Устанавливает положение костей объекта в соответствии с заданным временем в анимации. Только объекты,
     * загруженные с помощью LoadObjectWithChildren, будут иметь назначенные им анимации. Имена анимаций определяются
     * программой моделирования при создании анимаций вы можете узнать, что это за имена, используя
     * GetObjectAnimationName. Если заданное время попадает между ключевыми кадрами, то позиции костей будут
     * интерполированы между ними. Параметр tweentime можно использовать для интерполяции между текущими позициями
     * костей и заданным временем анимации, чтобы не было резкого скачка в позициях костей. Обратите внимание, что как
     * только эта команда будет вызвана, кости будут управляться анимацией и не могут быть перемещены с помощью
     * SetObjectBonePosition или аналогичных команд. Вы можете восстановить ручное управление отдельными костями,
     * используя SetObjectBoneCanAnimate на нем. Вы можете восстановить контроль над всей костной структурой с помощью
     * ResetObjectAnimation.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param string $animName Название воспроизводимой анимации, определяемое программой моделирования
     * @param float $time Точка в анимации для считывания положения костей, в секундах
     * @param float $tweentime Время в секундах для перехода от текущего состояния объектов к заданному кадру
     * @return void
     */
    function SetObjectAnimationFrame($objID, $animName, $time, $tweentime)
    {
    }

    /**
     * Включает или выключает альфа-маскировку для этого объекта. Это похоже на прозрачность, но производит только
     * полностью прозрачные или полностью непрозрачные пиксели, нет смешанных или полупрозрачных пикселей. Если пиксель
     * имеет альфа - значение меньше 128, он будет проигнорирован, если он больше или равен 128, то он будет нарисован.
     * Это имеет меньше проблем с упорядочением глубины, чем при использовании SetObjectTransparency, но в некоторых
     * случаях может быть немного медленнее. Вы не должны использовать как прозрачность, так и альфа-маскировку на
     * одном и том же объекте одновременно, используйте только одну или другую.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 1=использовать альфа-маскировку, 0=отключить альфа-маскировку.
     * @return void
     */
    function SetObjectAlphaMask($objID, $mode)
    {
    }

    /**
     * Устанавливает пороги спящего режима 3d-физики для объекта.
     *
     * @param int $objID идентификатор объекта
     * @param float $angular угловая скорость
     * @param float $linear линейная скорость
     * @return void
     */
    function SetObject3DPhysicsSleepingThreshold($objID, $angular, $linear)
    {
    }

    /**
     * Задает значение альфа-сигнала, которое будет использоваться при рисовании этого объекта. Это то же самое
     * альфа-значение, которое можно установить в SetObjectColor. Значения должны находиться в диапазоне 0-255, но не
     * ограничиваться им.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $alpha Альфа-компонент цвета.
     * @return void
     */
    function SetObjectAlpha($objID, $alpha)
    {
    }

    /**
     * Это установит максимальную линейную скорость для динамического объекта. Это предотвратит движение объектов
     * слишком быстро, чтобы их можно было увидеть на экране.
     *
     * @param int $objID идентификатор объекта
     * @param float $maxLinearVelocity максимальная скорость, которую может достичь объект.
     * @return void
     */
    function SetObject3DPhysicsMaxLinearVelocity($objID, $maxLinearVelocity)
    {
    }

    /**
     * Это установит трение качения для статических и динамических объектов.
     *
     * @param int $objID идентификатор объекта
     * @param float $friction величина трения качения в виде поплавка
     * @return void
     */
    function SetObject3DPhysicsRollingFriction($objID, $friction)
    {
    }

    /**
     * Задает вектор линейной скорости объекта. Вектор направления автоматически нормализуется.
     *
     * Пример вызова:
     *
     * void SetObject3DPhysicsLinearVelocity($objID, $vectorID, $initialSpeed);
     *
     * void SetObject3DPhysicsLinearVelocity($objID, $dirX, $dirY, $dirZ, $initialSpeed);
     * @param int $objID идентификатор объекта
     * @param int $vectorID Идентификатор вектора направления
     * @param float $dirX X компонент вектора направления
     * @param float $dirY компонент Y вектора направления
     * @param float $dirZ Z-составляющая вектора направления
     * @param float $initialSpeed начальная скорость.
     * @return void
     */
    function SetObject3DPhysicsLinearVelocity(mixed...$args)
    {
    }

    /**
     * Задает массу объекта
     *
     * @param int $objID идентификатор объекта
     * @param float $mass масса объекта
     * @return void
     */
    function SetObject3DPhysicsMass($objID, $mass)
    {
    }

    /**
     * Устанавливает группу столкновений объектов и маску. По умолчанию все физические объекты находятся в одной группе
     * и не маскируются. Если вы используете группы столкновений и маски, вы должны использовать их для всех физических
     * объектов в мире.
     *
     * @param int $objID идентификатор объекта
     * @param int $group группа столкновений, к которой принадлежит и этот физический объект.
     * @param int $mask группы столкновений, которые вы хотите замаскировать от столкновения.
     * @return void
     */
    function SetObject3DPhysicsGroupAndMask($objID, $group, $mask)
    {
    }

    /**
     * Это установит трение для динамических и статических объектов
     *
     * @param int $objID идентификатор объекта
     * @param float $friction значение трения в виде поплавка
     * @return void
     */
    function SetObject3DPhysicsFriction($objID, $friction)
    {
    }

    /**
     * Устанавливает линейное и угловое демпфирование для объекта
     *
     * @param int $objID идентификатор объекта
     * @param float $linearDamp Величина линейного демпфирования, приложенного к объекту.
     * @param float $angularDamp Величина углового демпфирования, приложенного к объекту.
     * @return void
     */
    function SetObject3DPhysicsDamping($objID, $linearDamp, $angularDamp)
    {
    }

    /**
     * Это позволит установить тип анизотропного трения.
     *
     * @param int $objID идентификатор объекта
     * @param int $type DISABLED = 0, FRICTION = 1, ROLLING_FRICTION = 2
     * @return void
     */
    function SetObject3DPhysicsAnisotropicFriction($objID, $type)
    {
    }

    /**
     * Устанавливает реституционное трение для объекта. Вы можете установить Реституцию для динамических и статических
     * объектов.
     *
     * @param int $objID идентификатор объекта
     * @param float $friction Величина трения, приложенного к объекту.
     * @return void
     */
    function SetObject3DPhysicsRestitution($objID, $friction)
    {
    }

    /**
     * Устанавливает время деактивации физического объекта. Это количество времени, которое физический объект ждет,
     * когда он придет в состояние покоя, прежде чем он станет деактивированным.
     *
     * @param int $objID идентификатор объекта
     * @param $time
     * @return void
     */
    function SetObject3DPhysicsDeactivationTime(int $objID, $time)
    {
    }

    /**
     * Все динамические объекты автоматически переводятся в состояние покоя. Это остановит автоматическое погружение
     * динамического объекта в спящий режим.
     *
     * @param int $objID идентификатор объекта.
     * @param int $canSleep 1 = true , 0 = false.
     * @return void
     */
    function SetObject3DPhysicsCanSleep(int $objID, int $canSleep)
    {
    }

    /**
     * Задает локальную целочисленную переменную для этого клиента по имени. Затем другие клиенты могут прочитать эту
     * переменную, используя то же имя при запросе ее значения. Параметр mode указывает, как должна вести себя эта
     * переменная, со значением 1, означающим, что эта переменная будет сброшена до 0 при чтении. Например, если вы
     * хотите отправить уведомление о щелчке, вы можете установить значение 1, чтобы обозначить щелчок со значением
     * режима 1. Когда каждый клиент читает переменную, каждый увидит значение 1, но если он попытается прочитать ее
     * снова, то получит значение 0. Каждый клиент сбрасывает только свою собственную копию переменной. Значение режима
     * 0 означает, что это нормальная переменная, которая не изменится при чтении. Если переменная с таким именем не
     * существует, она создается. Как только переменная создается в обычном или сброшенном режиме, она не может быть
     * изменена, и параметр mode игнорируется.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param string $name Имя этой переменной.
     * @param int $i Значение для установки этой переменной.
     * @param int|null $mode Тип этой переменной: 0=нормальный, 1=сброс
     * @return void
     */
    function SetNetworkLocalInteger(int $iNetID, string $name, int $i, int $mode = null)
    {
    }


    /**
     * Задает угловую скорость объекта. Вектор угла автоматически нормализуется.
     *
     *
     * Пример вызова:
     *
     * void SetObject3DPhysicsAngularVelocity($objID, $vectorID, $initialSpeed);
     *
     * void SetObject3DPhysicsAngularVelocity($objID, $angX, $angY, $angZ, $initialSpeed);
     * @param int $objID идентификатор объекта
     * @param int $vectorID Идентификатор вектора направления.
     * @param float $angX X компонент вектора угла
     * @param float $angY компонент Y вектора угла
     * @param float $angZ Z-составляющая вектора угла
     * @param float $initialSpeed начальная скорость.
     * @return void
     */
    function SetObject3DPhysicsAngularVelocity(mixed...$args)
    {
    }


    /**
     * Задает локальную переменную float для этого клиента по имени. Затем другие клиенты могут прочитать эту
     * переменную, используя то же имя при запросе ее значения. Переменная с плавающей точкой может не иметь того же
     * имени, что и целочисленная переменная. Если переменная с таким именем не существует, она создается.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param string $name Имя этой переменной.
     * @param float $f Значение для установки этой переменной.
     * @param int|null $mode Тип этой переменной: 0=нормальный, 1=сброс
     * @return void
     */
    function SetNetworkLocalFloat(int $iNetID, string $name, float $f, int $mode = null)
    {
    }

    /**
     * Останавливает больше клиентов от подключения к этой сети, применимо только в том случае, если вы размещаете эту
     * сеть. Также прекращается вещание сети в локальную сеть, поэтому она больше не будет отображаться для тех
     * приложений, которые слушают трансляции.
     *
     * @param int $iNetID Идентификатор сети для изменения.
     * @return void
     */
    function SetNetworkNoMoreClients($iNetID)
    {
    }

    /**
     * Присваивает локальное значение одному из 5 слотов данных в клиенте, которые можно использовать для отслеживания
     * элементов, принадлежащих этому клиенту. Например, если вы создаете спрайт для представления клиента в вашей
     * игре, вы можете назначить идентификатор спрайта одному из этих слотов данных, чтобы при просмотре списка
     * клиентов вы могли определить, какой спрайт вы использовали для каждого клиента. Это также позволяет очистить
     * спрайт, если обнаружится, что клиент отключился. Это значение является полностью локальным и не передается по
     * сети.
     *
     * @param int $iNetID Идентификатор сети для хранения значения.
     * @param int $client Идентификатор клиента в сети для хранения значения.
     * @param int $index Индекс (от 0 до 4) устанавливаемого слота данных.
     * @param int $value Целочисленное значение для установки.
     * @return void
     */
    function SetNetworkClientUserData($iNetID, $client, $index, $value)
    {
    }

    /**
     * Устанавливает, как часто сеть отправляет обновления и проверяет наличие обновлений переменных от других клиентов
     * в миллисекундах. Чем ниже это значение, тем чаще этот клиент будет отправлять и получать обновления, что
     * означает, что общие переменные с большей вероятностью будут обновляться, но это увеличит сетевой трафик. В
     * случае соединений через Интернет это особенно важно, так как большое количество переменных, которые часто
     * обновляются, означает, что может не хватить пропускной способности. Значение по умолчанию составляет 15
     * миллисекунд, что переводится примерно в 67 обновлений каждую секунду, чтобы точно соответствовать частоте кадров
     * игры 60 кадров в секунду. Если вы обновляете большое количество переменных через интернет-соединение,
     * рекомендуется увеличить это значение до 50 миллисекунд, что приведет к 20 обновлениям в секунду или более.
     *
     * @param int $iNetID Идентификатор сети, от которой требуется отключиться.
     * @param int $latency Задержка использования в миллисекундах
     * @return void
     */
    function SetNetworkLatency($iNetID, $latency)
    {
    }

    /**
     * Устанавливает основную громкость для всех музыкальных файлов OGG. Это умножается на объем файла, так что если
     * системный том установлен на 100, а объем файла установлен на 0, то файл все равно будет иметь объем 0.
     *
     * @param int $vol Основной объем для использования, от 0 до 100
     * @return void
     */
    function SetMusicSystemVolumeOGG($vol)
    {
    }

    /**
     * Перезапуск прослушивания новых клиентских подключений, применимый только в том случае, если вы размещаете сеть.
     * Также перезапускается вещание сети в локальную сеть, так что она будет отображаться для тех приложений, которые
     * слушают трансляции. Это нужно сделать только в том случае, если вы ранее вызывали SetNetworkNoMoreClients и
     * теперь хотите снова разрешить соединения.
     *
     * @param int $iNetID Идентификатор сети для изменения.
     * @return void
     */
    function SetNetworkAllowClients($iNetID)
    {
    }

    /**
     * Устанавливает объем для каждого файла. По умолчанию файлы воспроизводятся на томе 100. Уровень громкости должен
     * быть между 0 и 100.
     *
     * @param int $musicID Идентификатор музыкального файла для изменения.
     * @param int $vol Том, который будет использоваться для этого файла.
     * @return void
     */
    function SetMusicVolumeOGG($musicID, $vol)
    {
    }

    /**
     * Устанавливает основную громкость музыкального проигрывателя в диапазоне от 0 до 100.
     *
     * @param int $iVol Новое значение объема для использования.
     * @return void
     */
    function SetMusicSystemVolume($iVol)
    {
    }

    /**
     * Устанавливает время начала и окончания музыкального цикла. Когда PlayMusicOGG используется с параметром loop, он
     * по умолчанию останавливается в конце файла и возвращается к началу файла. Эта команда изменит его на цикл,
     * начинающийся и заканчивающийся в определенное время в музыкальном файле. Использование времени начала -1
     * приведет к возврату в начало файла, использование и время окончания -1 остановится в конце файла, они
     * соответствуют поведению по умолчанию. Если время начала больше текущего времени воспроизведения, то музыкальный
     * файл будет продолжать воспроизводиться до тех пор, пока не достигнет конечного времени, а затем вернется к
     * выбранному времени начала.
     *
     * @param int $musicID Идентификатор музыкального файла для изменения
     * @param float $startTime Время в секундах для возврата в начало цикла
     * @param float $endTime Время в секундах, чтобы закончить цикл и вернуться к началу
     * @return void
     */
    function SetMusicLoopTimesOGG($musicID, $startTime, $endTime)
    {
    }

    /**
     * Изменяет количество циклов воспроизведения музыкального файла, может быть установлено во время его
     * воспроизведения. Используйте значение 0 для воспроизведения до конца файла или текущего времени окончания цикла,
     * а затем остановитесь. Значение цикла, равное 1, будет циклическим навсегда, значение, большее 1, будет
     * циклическим для этого числа раз. Эта команда сбрасывает команду GetMusicLoopCountOGG и снова начинает отсчет с
     * 0.
     *
     * @param int $musicID Идентификатор музыкального файла для изменения
     * @param int $loop Количество циклов, 0 для остановки цикла.
     * @return void
     */
    function SetMusicLoopCountOGG($musicID, $loop)
    {
    }

    /**
     * Устанавливает громкость на основе каждого файла, этот уровень громкости объединяется с громкостью музыкальной
     * системы для создания окончательной громкости. По умолчанию файлы воспроизводятся на томе 100. Уровень громкости
     * должен быть между 0 и 100.
     *
     * @param int $ID Музыкальный номер для установки.
     * @param int $vol Том, который будет использоваться для этого файла.
     * @return void
     */
    function SetMusicFileVolume($ID, $vol)
    {
    }

    /**
     * Обеспечивает быстрый способ изменения УФ-значений вершины внутри мемблока сетки. Он использует атрибутивные
     * данные из начала мемблока для определения смещения вершин и изменения значений UV. Вершины начинаются с индекса
     * 0.
     *
     * @param int $memID Идентификатор изменяемого мемблока
     * @param int $vertexIndex Индекс вершины для изменения
     * @param float $u Новое значение U для этой вершины
     * @param float $v Новое значение V для этой вершины
     * @return void
     */
    function SetMeshMemblockVertexUV($memID, $vertexIndex, $u, $v)
    {
    }

    /**
     * Обеспечивает быстрый способ изменения положения вершины внутри мемблока сетки. Он использует атрибутивные данные
     * из начала мемблока для определения смещения вершины и изменения значений позиции. Вершины начинаются с индекса
     * 0.
     *
     * @param int $memID Идентификатор изменяемого мемблока
     * @param int $vertexIndex Индекс вершины для изменения
     * @param float $x Новая позиция X для этой вершины
     * @param float $y Новая позиция Y для этой вершины
     * @param float $z Новая позиция Z для этой вершины
     * @return void
     */
    function SetMeshMemblockVertexPosition($memID, $vertexIndex, $x, $y, $z)
    {
    }

    /**
     * Обеспечивает быстрый способ изменения нормали вершины внутри мемблока сетки. Он использует атрибутивные данные
     * из начала мемблока для определения смещения вершин и изменения нормальных значений. Вершины начинаются с индекса
     * 0.
     *
     * @param int $memID Идентификатор изменяемого мемблока
     * @param int $vertexIndex Индекс вершины для изменения
     * @param float $x X компонент новой нормали для этой вершины
     * @param float $y Компонент Y новой нормали для этой вершины
     * @param float $z Z компонент новой нормали для этой вершины
     * @return void
     */
    function SetMeshMemblockVertexNormal($memID, $vertexIndex, $x, $y, $z)
    {
    }

    /**
     * Записывает строку в memblock в виде необработанных байтов. Первый найденный нулевой терминатор завершит строку,
     * и один нулевой терминатор будет записан в данные memblock. Чтобы снова прочитать строку из memblock, вам нужно
     * будет знать ее длину, поэтому рекомендуется также записать значение длины строки перед строковыми данными, чтобы
     * помочь прочитать строку обратно позже. Смещение плюс длина строки, плюс 1 для нулевого терминатора, должно быть
     * меньше размера memblock.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param string $value Строка для записи.
     * @return void
     */
    function SetMemblockString($memID, $offset, $value)
    {
    }

    /**
     * Записывает короткое (2 байта) значение с заданным смещением. Смещение должно быть меньше размера мемблока.
     * Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 2,
     * поскольку запись коротких значений, не выровненных по 2-байтовым границам, влечет за собой снижение
     * производительности оборудования. Короткие значения хранятся в формате little endian, поэтому запись короткого
     * числа 23 со смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, а байт со
     * смещением 1 как 0. Данное значение будет усечено до диапазона -32768 и 32767.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param int $value Значение для записи.
     * @return void
     */
    function SetMemblockShort($memID, $offset, $value)
    {
    }

    /**
     * Записывает значение int (4 байта) с заданным смещением. Смещение должно быть меньше размера мемблока. Первое
     * значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку
     * запись целочисленных значений, не выровненных по 4-байтовым границам, влечет за собой снижение
     * производительности оборудования. Значения Int хранятся в формате little endian, поэтому запись int 23 со
     * смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, байт со смещением 1 как 0,
     * байт со смещением 2 как 0 и байт со смещением 3 как 0.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param int $value Значение для записи.
     * @return void
     */
    function SetMemblockInt($memID, $offset, $value)
    {
    }

    /**
     * Запишите значение float (4 байта) с заданным смещением. Смещение должно быть меньше размера мемблока. Первое
     * значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку
     * запись значений с плавающей запятой, не выровненных по 4-байтовым границам, влечет за собой снижение
     * производительности оборудования. Значения Float хранятся в формате IEEE 754, поэтому запись float и последующее
     * чтение его обратно в байтах вернут различные компоненты формата float.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param float $value Значение для записи.
     * @return void
     */
    function SetMemblockFloat($memID, $offset, $value)
    {
    }

    /**
     * Обеспечивает быстрый способ изменения значений цвета вершины внутри мемблока сетки. Он использует атрибутивные
     * данные из начала memblock для определения смещения вершин и изменения значений цвета. Вершины начинаются с
     * индекса 0. Значения цвета должны быть в диапазоне от 0 до 255.
     *
     * @param int $memID Идентификатор изменяемого мемблока
     * @param int $vertexIndex Индекс вершины для изменения
     * @param int $red Новое красное значение для этой вершины
     * @param int $green Новое зеленое значение для этой вершины
     * @param int $blue Новое синее значение для этой вершины
     * @param int $alpha Новое альфа
     * @return void
     */
    function SetMeshMemblockVertexColor($memID, $vertexIndex, $red, $green, $blue, $alpha)
    {
    }

    /**
     * Записывает однобайтовое значение с заданным смещением. Смещение должно быть меньше размера мемблока. Первое
     * значение имеет смещение 0. Данное значение будет усечено до диапазона -128 и 127.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param int $value Значение для записи.
     * @return void
     */
    function SetMemblockByteSigned($memID, $offset, $value)
    {
    }

    /**
     * Записывает однобайтовое значение с заданным смещением. Смещение должно быть меньше размера мемблока. Первое
     * значение имеет смещение 0. Данное значение будет усечено до диапазона 0 и 255.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param int $value Значение для записи.
     * @return void
     */
    function SetMemblockByte($memID, $offset, $value)
    {
    }

    /**
     * Создает локальное уведомление, которое появится в какой-то момент в будущем. Уведомления ссылаются на
     * идентификатор и могут быть перезаписаны путем создания нового уведомления с тем же идентификатором, что и
     * уведомление, которое вы хотите перезаписать. Если уведомление срабатывает во время работы приложения, то оно не
     * появляется и бесшумно исчезает из списка запланированных уведомлений. Если приложение не открыто, то
     * пользователю будет показано уведомление, и нажатие на него откроет ваше приложение. Если вы установите параметр
     * deeplink, то этот URL-адрес будет отправлен в приложение при нажатии уведомления. URL-адрес можно получить с
     * помощью команды GetURLSchemeText. Параметр datetime должен быть указан в unix time, который измеряется в
     * секундах с 1 января 1970 года, вы можете использовать команду GetUnixTime для возврата текущей даты и времени, а
     * затем изменить ее по мере необходимости. Если дата и время находятся в прошлом, то уведомление будет
     * проигнорировано, оно не будет перезаписывать ни одно существующее уведомление. Идентификатор должен находиться в
     * диапазоне от 1 до 100 включительно.
     *
     * @param int $iID Идентификатор, который будет использоваться для ссылки на это уведомление в будущем
     * @param int $datetime Дата и время отображения этого уведомления в unix time
     * @param string $szMessage Сообщение для отображения в уведомлении
     * @param string|null $szDeepLink URL-адрес для отправки в приложение, если уведомление прослушивается
     * @return void
     */
    function SetLocalNotification(int $iID, int $datetime, string $szMessage, string $szDeepLink = null)
    {
    }

    /**
     * Джойстик AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания ввода
     * в стиле джойстика в диапазоне от -1 до 1. Эта команда позиционирует виртуальный джойстик на экране только в том
     * случае, если необходимо эмулировать этот ввод. Например, если имеется реальный джойстик или клавиатура, то эта
     * команда не имеет заметного эффекта. Рекомендуется всегда вызывать эту команду в любом случае, если вы
     * собираетесь использовать GetJoystickX или GetJoystickY, просто если вам нужен виртуальный джойстик. Любой
     * виртуальный джойстик будет центрирован в заданном положении X и Y.
     *
     * @param float $x Координата X новой позиции в координатах экрана.
     * @param float $y Координата Y новой позиции в координатах экрана.
     * @param float $size Диаметр джойстика в экранных координатах.
     * @return void
     */
    function SetJoystickScreenPosition(float $x, float $y, float $size)
    {
    }

    /**
     * Устанавливает мертвую зону для универсальных джойстиков так, чтобы любое значение X или Y ниже заданного порога
     * возвращало 0. Это значение должно быть между 0 и 1, по умолчанию оно равно 0,15.
     *
     * @param float $threshold Значение, ниже которого будет возвращено 0.
     * @return void
     */
    function SetJoystickDeadZone($threshold)
    {
    }

    /**
     * Задает целевую точку в мировых координатах, к которой мышиный сустав будет пытаться переместить прикрепленное
     * тело. Работает только на мышиных суставах.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @param float $x Координата x новой цели.
     * @param float $y Координата y новой цели.
     * @return void
     */
    function SetJointMouseTarget($iJointIndex, $x, $y)
    {
    }

    /**
     * Устанавливает максимальное усилие, которое может быть использовано суставом мыши для перемещения объекта. По
     * умолчанию это значение равно 0
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @param float $maxForce Максимальное усилие, чтобы позволить.
     * @return void
     */
    function SetJointMouseMaxForce($iJointIndex, $maxForce)
    {
    }

    /**
     * Включает двигатель для соединения так, чтобы оно двигалось непрерывно, пока не будет предотвращено столкновение.
     * Работает на линейных/колесных соединениях, призматических соединениях и вращающихся соединениях. Двигатели
     * работают, прикладывая усилие для достижения заданной скорости, и если они встречают сопротивление, то
     * увеличивают усилие до тех пор, пока двигатель не будет двигаться с желаемой скоростью или не будет достигнута
     * максимальная заданная сила, после чего двигатель остановится, продолжая прикладывать максимальную силу. В случае
     * линейных соединений двигатель работает в одном направлении и либо толкает прикрепленные спрайты вместе, либо
     * раздвигает.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @param float $speed Желаемая скорость двигателя.
     * @param float $maxForce Максимальная сила, которую он может использовать для достижения скорости.
     * @return void
     */
    function SetJointMotorOn($iJointIndex, $speed, $maxForce)
    {
    }

    /**
     * Выключает двигатель, ранее приложенный к шарниру, который его поддерживает. Работает на линейных соединениях,
     * призматических соединениях и револьверных соединениях.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @return void
     */
    function SetJointMotorOff($iJointIndex)
    {
    }

    /**
     * Отключает ограничения для суставов, которые их поддерживают. Работает на призматических и револьверных
     * соединениях.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @return void
     */
    function SetJointLimitOff($iJointIndex)
    {
    }

    /**
     * Демпфирование можно использовать, чтобы сделать сустав мягким, как пружина. Частота задается в герцах и обычно
     * должна быть меньше половины частоты шага физики. Например, если fps равен 60, то частота должна быть меньше 30.
     * Коэффициент демпфирования должен быть между 0 и 1, но может быть и больше. Это можно использовать только на
     * дистанционных соединениях, сварных соединениях, соединениях линии/колеса и соединениях мыши. По умолчанию
     * расстояние и сварные соединения имеют коэффициент демпфирования и частоту 0, что делает соединение жестким. По
     * умолчанию суставы мыши имеют частоту 5 и коэффициент демпфирования 0,7. По умолчанию линейные/колесные
     * соединения имеют частоту 2 и коэффициент демпфирования 0,7.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @param float $dampingRatio Коэффициент демпфирования для использования, как правило, находится в диапазоне от 0
     *     до 1
     * @param float $frequency Частота колебаний, должна быть меньше половины частоты кадров
     * @return void
     */
    function SetJointDamping($iJointIndex, $dampingRatio, $frequency)
    {
    }

    /**
     * Работает на призматических и револьверных соединениях. Устанавливает предел, которого этот сустав может достичь
     * до остановки, для вращающихся суставов это основано на углах, для других-на длине. По умолчанию сустав не имеет
     * ограничений.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @param float $lowerLimit Наименьшая степень, до которой может дотянуться сустав.
     * @param float $upperLimit Наибольшей степени, которую может достичь сустав.
     * @return void
     */
    function SetJointLimitOn($iJointIndex, $lowerLimit, $upperLimit)
    {
    }

    /**
     * Устанавливает размер устройства, для которого вы разработали все свои произведения искусства, это позволяет AGK
     * уменьшить размер изображений, чтобы сэкономить память на устройствах с более низким разрешением. Обратите
     * внимание, что такие команды, как SetSpriteAnimation, которые могут предполагать размеры изображений, должны
     * учитывать уменьшенные изображения. Например, загрузка изображения 512x512 и использование
     * SetSpriteAnimation(spr,128,128,16) должны вместо этого использовать
     * SetSpriteAnimation(spr,GetImageWidth(img)/4,GetImageHeight(img)/4,16) в случае, если изображение больше не имеет
     * размера 512. Эта команда устарела, и вы должны использовать LoadImageResized для настройки размеров изображений
     * в зависимости от разрешения устройства, вы можете проверить разрешение устройства с помощью GetDeviceWidth и
     * GetDeviceHeight.
     *
     * @param int $width Предполагаемая ширина
     * @param int $height Предполагаемая высота
     * @return void
     */
    function SetIntendedDeviceSize($width, $height)
    {
    }

    /**
     * Устанавливает данные вашей учетной записи Inneractive для использования CreateAdvert. Не все платформы
     * поддерживают всех поставщиков рекламы, поэтому установка как можно большего количества реквизитов учетной записи
     * позволит AGK выбрать подходящее объявление для этой платформы. В настоящее время Inneractive поддерживается iOS,
     * Android, Windows и Mac.
     *
     * @param string $szCode Код вашей учетной записи предоставлен компанией Inneractive.
     * @return void
     */
    function SetInneractiveDetails($szCode)
    {
    }

    /**
     * Удаляет все экранные элементы управления, которые могли быть размещены на экране операционной системой, например
     * кнопки "Домой" и "Назад", позволяя вашему приложению использовать весь экран. Ваше приложение может быть
     * изменено после вызова этой команды, поэтому, если вы использовали GetDeviceWidth или GetDeviceHeight, вам
     * следует подождать несколько кадров, а затем вызвать их снова, чтобы получить новые значения. Значения могут
     * измениться не сразу после вызова этой команды, так как для изменения навигационной панели требуется некоторое
     * время. Иногда ОС отключает иммерсивный режим без предупреждения, например, при нажатии кнопок регулировки
     * громкости. Когда это произойдет, ваше приложение вернется к своему размеру без погружения в режим, чтобы
     * предотвратить скрытие любой части приложения навигационной панелью, что может сделать некоторые части приложения
     * недоступными для сенсорных событий. Вы можете обнаружить это изменение, регулярно проверяя GetDeviceWidth и
     * GetDeviceHeight, и снова использовать SetImmersiveMode, чтобы запросить возврат в режим погружения. В настоящее
     * время это относится только к устройствам Android под управлением версии 4.4 (API 19) или выше. На других
     * платформах эта команда ничего не делает.
     *
     * @param int $mode 1, чтобы включить иммерсивный режим, 0, чтобы выключить его
     * @return void
     */
    function SetImmersiveMode($mode)
    {
    }

    /**
     * Устанавливает режим УФ-обертывания изображения, когда U-координата выходит за пределы диапазона 0-1. По
     * умолчанию используется режим 0, который фиксирует значение пикселя до последнего допустимого пикселя, режим 1
     * повторяет текстуру, начиная с противоположной стороны. Чтобы успешно использовать значения UV за пределами 0-1
     * на всех платформах, рассматриваемое изображение должно иметь степень 2 по ширине и высоте и не быть частью
     * текстуры атласа. Это относится как к зажиму, так и к повторению.
     *
     * @param int $iImageIndex Идентификатор изображения для изменения.
     * @param int $mode Режим обертывания для использования, 0=зажим, 1=повторение
     * @return void
     */
    function SetImageWrapU($iImageIndex, $mode)
    {
    }

    /**
     * Устанавливает режим УФ-обертывания изображения, когда координата V выходит за пределы диапазона 0-1. По
     * умолчанию используется режим 0, который фиксирует значение пикселя до последнего допустимого пикселя, режим 1
     * повторяет текстуру, начиная с противоположной стороны. Чтобы успешно использовать УФ-значения за пределами 0-1
     * на всех платформах, рассматриваемое изображение должно иметь степень 2 по ширине и высоте и не быть частью
     * текстуры атласа. Это относится как к зажиму, так и к повторению.
     *
     * @param int $iImageIndex Идентификатор изображения для изменения.
     * @param int $mode Режим обертывания для использования, 0=зажим, 1=повторение
     * @return void
     */
    function SetImageWrapV($iImageIndex, $mode)
    {
    }

    /**
     * Делает определенный цвет полностью прозрачным в выбранном изображении. Это медленная команда, и ее не следует
     * вызывать каждый кадр.
     *
     * @param int $iImage Идентификатор изображения для изменения.
     * @param int $r Красный компонент цвета устанавливается как прозрачный
     * @param int $g Красный компонент цвета устанавливается как прозрачный
     * @param int $b Красный компонент цвета устанавливается как прозрачный
     * @return void
     */
    function SetImageTransparentColor($iImage, $r, $g, $b)
    {
    }

    /**
     * Задает данные подизображения для изображения атласа, которое представляет собой расположение каждого
     * подизображения внутри изображения атласа. Обычно это загружается автоматически из subimages.txt файл при
     * загрузке изображения, но если это невозможно, то эта команда может быть использована для установки этих данных.
     * Файл должен быть действительным subimages.txt файл в том же формате что и указанный в LoadSubImage В отличие от
     * обычной команды load image файл не нуждается в имени subimages.txt, он может иметь любое имя и путь
     *
     * @param int $iImageIndex Идентификатор изображения для изменения
     * @param string $sSubImageFile Путь к файлу вложенных изображений
     * @return void
     */
    function SetImageSubImages($iImageIndex, $sSubImageFile)
    {
    }

    /**
     * Устанавливает фильтр для текстур, когда текстура меньше пространства экрана, в котором она отображается. Вы
     * можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть блочным, или 1, чтобы
     * использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно совпадает с
     * пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница, ближайший имеет
     * тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей.
     *
     * @param int $iImageIndex Идентификатор изображения для изменения.
     * @param int $mode Используемый режим фильтра: 0=ближайший, 1=линейный
     * @return void
     */
    function SetImageMinFilter($iImageIndex, $mode)
    {
    }

    /**
     * Устанавливает фильтр для текстур, когда текстура больше, чем пространство экрана, в котором она отображается. Вы
     * можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть блочным, или 1, чтобы
     * использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно совпадает с
     * пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница, ближайший имеет
     * тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей.
     *
     * @param int $iImageIndex Идентификатор изображения для изменения.
     * @param int $mode Используемый режим фильтра: 0=ближайший, 1=линейный
     * @return void
     */
    function SetImageMagFilter($iImageIndex, $mode)
    {
    }

    /**
     * Копирует цветовой канал с одного изображения на другое. Вы можете указать исходный и конечный каналы, используя
     * значения 1,2,3,4 для представления красного, зеленого, синего и альфа-каналов соответственно. Это медленная
     * команда, и ее не следует вызывать каждый кадр. Значения смещения x,y позволяют смещать исходное изображение на
     * целевом изображении, поэтому небольшое исходное изображение можно использовать для маскировки любой части
     * большого изображения. Любая часть большого изображения за пределами размера маленького изображения останется
     * неизменной. отрицательные значения смещения поддерживаются для смещения исходного изображения от верхнего левого
     * края целевого изображения. Если вы добавляете несколько прозрачных пикселей к изображению, которое в настоящее
     * время не имеет ни одного, и используете изображение на спрайте, то обязательно используйте
     * SetSpriteTransparency, чтобы сделать спрайт прозрачным.
     *
     * @param int $iDstImage Идентификатор изображения для изменения.
     * @param int $iSrcImage Идентификатор изображения, которое будет использоваться в качестве источника.
     * @param int $dst Идентификатор цветового канала, используемого в качестве пункта назначения, 1-4 для RGBA,
     * @param int $src Идентификатор цветового канала, используемого в качестве источника, 1-4 для RGBA,
     * @param int $x Смещение x для исходного изображения на целевом изображении,
     * @param int $y Смещение y для исходного изображения на целевом изображении.
     * @return void
     */
    function SetImageMask($iDstImage, $iSrcImage, $dst, $src, $x, $y)
    {
    }

    /**
     * Устанавливает, должно ли устройство проверять SSL-сертификат при создании защищенного соединения. Если сервер, к
     * которому вы подключаетесь, использует самозаверяющий сертификат, вам нужно будет установить его равным 0, иначе
     * соединение не удастся. Во всех остальных случаях вы должны оставить это значение равным 1, чтобы обеспечить
     * безопасное соединение с сервером. Отключение проверки отключит защиту от атак man in the middle на
     * SSL-соединения.
     *
     * @param int $iHTTP Идентификатор устанавливаемого соединения.
     * @param int $mode 1 для проверки, 0 для не проверки.
     * @return void
     */
    function SetHTTPVerifyCertificate($iHTTP, $mode)
    {
    }

    /**
     * Устанавливает время в миллисекундах, в течение которого AGK будет ждать установления соединения, прежде чем
     * отказаться от него.
     *
     * @param int $iHTTP Идентификатор устанавливаемого соединения.
     * @param int $milliseconds Время ожидания в миллисекундах.
     * @return void
     */
    function SetHTTPTimeout($iHTTP, $milliseconds)
    {
    }

    /**
     * Задает домен хоста, к которому вы хотите подключиться, например для доступа www.thegamecreators.com/index.php вы
     * бы использовали значение хоста www.thegamecreators.com, не включайте http:, который обычно идет перед ним.
     * Обратите внимание, что попытка использовать определенный порт с www.thegamecreators.com:8080 на некоторых
     * платформах это может быть проигнорировано, и в этих случаях будет использоваться порт 80. При экспорте в HTML5
     * обратите внимание, что веб-браузеры ограничивают количество серверов, к которым вы можете подключиться. По
     * умолчанию вы ограничены файлами, размещенными на том же сервере, что и ваше приложение. Однако если сервер
     * отправляет заголовок Access-Control-Allow-Origin в своем ответе, который разрешает сервер вашего приложения, то
     * браузер позволит вам подключиться к нему.
     *
     * @param int $iHTTP Идентификатор устанавливаемого соединения.
     * @param string $szHost Домен для подключения.
     * @param int $iSecure Установите значение 1, чтобы использовать защищенное соединение HTTPS, и 0, чтобы
     *     использовать стандартное соединение HTTP.
     * @param string|null $szUser Имя пользователя для отправки на сервер.
     * @param string|null $szPass Пароль для отправки на сервер.
     * @return int
     */
    function SetHTTPHost(int $iHTTP, string $szHost, int $iSecure, string $szUser = null, string $szPass = null): int
    {
    }

    /**
     * Задает положение всех 3D-объектов относительно 2D-объектов. Например, использование глобальной 3D-глубины 100
     * будет означать, что все спрайты на глубине меньше или равной 100 будут появляться над любыми 3D-объектами, в то
     * время как спрайты на глубине больше 100 будут появляться под любыми 3D-объектами.
     *
     * @param int $depth Глубина спрайта для рендеринга 3D.
     * @return void
     */
    function SetGlobal3DDepth($depth)
    {
    }

    /**
     * Устанавливает, генерируются ли и используются ли загруженные изображения с mip-картами. Должен быть вызван до
     * того, как будут загружены какие-либо изображения. Может быть изменено до загрузки другого изображения, чтобы
     * некоторые использовали mip-карты, а другие-нет.
     *
     * @param int $generate Установите значение 1 для создания mip-карт (по умолчанию 0)
     * @return void
     */
    function SetGenerateMipmaps($generate)
    {
    }

    /**
     * При обычном использовании вашему приложению AGK доступны только две папки: папка чтения и папка записи. Папка
     * чтения - это расположение исполняемого файла, включающее папку мультимедиа. Папка записи (которая также имеет
     * разрешение на чтение) находится в безопасном месте платформы и отличается в зависимости от устройства. Например,
     * в Windows по умолчанию используется следующее место записи: C:\Users\username\AppData\AGKApps\appName (По
     * умолчанию это скрытая папка в Windows, и вам, возможно, придется показать скрытые файлы, чтобы увидеть ее). Это
     * ваши корневые папки. Любые файлы, созданные/записанные с помощью OpenToWrite, будут сохранены в папке записи.
     * Для простоты AGK объединяет эти две папки чтения и записи в один набор команд. Это означает, что при попытке
     * открыть или загрузить файл AGK сначала будет искать в папке записи, а затем в папке чтения. При использовании
     * SetFolder его поведение соответствует тому, что вы ожидаете от команды CD в консоли Windows или Linux; Он
     * работает из текущего каталога. Например, если текущая папка чтения C:\games\myApp\ затем SetFolder("images")
     * поместит вас в C:\games\myApp\images. Вызов команды во второй раз с помощью SetFolder("backgrounds") приведет
     * вас в C:\games\myApp\images\backgrounds\. Есть два способа вернуться на базовый путь. Первый-вызвать SetFolder
     * (""), используя пустую строку. Другой способ-предварить свой путь прямой косой чертой, SetFolder("/stuff"). Это
     * также относится и к загрузке ваших файлов с помощью других команд. Предположим, что вы все еще находитесь в
     * папках images\backgrounds и хотите загрузить файл bk.png, расположенный в основании папки read. Вы можете просто
     * сказать LoadImage("/bk.png"), который будет загружаться C:\games\myApp\bk.png. Установка пути к несуществующей
     * папке и использование OpenToWrite создаст эту папку в пути записи. SetFolder не проверяет, существует ли папка,
     * он просто устанавливает внутренний путь, который будет использоваться в следующей команде file. По умолчанию AGK
     * первым делом вызывает SetFolder("media"). Эта команда возвращает 1 при успешном выполнении или 0, если вы
     * используете недопустимый путь, такой как SetFolder("C:\"). Примечание: При настройке путей важно помнить, что
     * всегда следует использовать косую черту вперед, а не обратную. AGK преобразует их в соответствующий файловый
     * разделитель для данной платформы. Если вы хотите получить доступ к файлам вне папок чтения и записи, вы можете
     * использовать обычные файловые команды, такие как OpenToRead с путем к файлу "raw:", см. Эту команду для
     * получения более подробной информации. Для доступа к папкам вне папок чтения и записи можно использовать команды
     * OpenRawFolder.
     *
     * @param string $str Путь к папке для установки
     * @return int
     */
    function SetFolder($str)
    {
    }

    /**
     * Устанавливает диапазон действия 3D-тумана. На минимальном расстоянии не будет возникать тумана, после чего туман
     * начнет действовать. Максимальное расстояние не является пределом и является лишь приблизительным руководством
     * для того, как далеко вы хотите видеть в своей сцене. Туман увеличивается экспоненциально, чтобы имитировать
     * реальность, то есть сначала он быстро увеличивается, затем затихает и постепенно достигает полной интенсивности
     * на максимальном расстоянии.
     *
     * @param float $minDist Минимальное расстояние для тумана, никакой туман не повлияет на пиксели в пределах этого
     *     расстояния от камеры.
     * @param float $maxDist Максимальное расстояние для тумана, туман достигнет полной интенсивности вокруг этого
     *     расстояния.
     * @return void
     */
    function SetFogRange($minDist, $maxDist)
    {
    }

    /**
     * Устанавливает цвет солнца 3D тумана. Это используется вместо обычного цвета тумана, когда камера обращена к
     * солнцу, как определено командой SetSunDirection. Это может быть использовано для имитации эффектов рассеяния
     * света, чтобы воздух казался туманным. Цвет туманного солнца должен быть близок к цвету солнца для лучшего
     * эффекта, но это не обязательно. Обратите внимание, что вызов этой команды изменяет расчет тумана на более
     * сложную версию, что приведет к снижению производительности на мобильных устройствах. Чтобы вернуться к более
     * быстрому методу расчета тумана, сделайте цвет солнца тумана равным нормальному цвету тумана.
     *
     * @param int $red Красная составляющая цвета.
     * @param int $green Зеленая составляющая цвета.
     * @param int $blue Синяя составляющая цвета.
     * @return void
     */
    function SetFogSunColor($red, $green, $blue)
    {
    }

    /**
     * Устанавливает цвет 3D тумана. Объекты будут постепенно исчезать до этого цвета по мере удаления от камеры.
     * Цветовые значения должны находиться в диапазоне от 0 до 255, но этим они не ограничиваются и система будет
     * принимать значения вне диапазона, в том числе и отрицательные.
     *
     * @param int $red Красная составляющая цвета.
     * @param int $green Зеленая составляющая цвета.
     * @param int $blue Синяя составляющая цвета.
     * @return void
     */
    function SetFogColor($red, $green, $blue)
    {
    }

    /**
     * Устанавливает 3D туман включенным или выключенным, это может быть использовано для создания атмосферной дымки
     * или выцветания объектов до цвета фона, чтобы имитировать уменьшенную видимость. Туман будет автоматически
     * применен ко всем 3D-объектам, если они используют шейдер по умолчанию. Если вы применили свой собственный шейдер
     * с помощью SetObjectShader, то объявите функцию mediump vec3 ApplyFog( mediump vec3 color, highp vec3 pointPos );
     * в пиксельном шейдере, который AGK заполнит для вас во время выполнения. pointPos-это положение пикселя в мировых
     * координатах, которое вам нужно будет передать из вершинного шейдера.
     *
     * @param int $mode 1, чтобы включить туман, 0, чтобы выключить его.
     * @return void
     */
    function SetFogMode($mode)
    {
    }

    /**
     * Задает текущую позицию чтения в файле
     *
     * @param int $iFileID Идентификатор файла для проверки.
     * @param int $pos Новая позиция для продолжения чтения
     * @return void
     */
    function SetFilePos($iFileID, $pos)
    {
    }

    /**
     * Задает номер версии для использования в других командах расширения файла. В настоящее время применимо только к
     * Android. Номер версии файла расширения определяется номером версии APK, который был загружен вместе с ним.
     * Например, APK может быть обновлен до нового номера версии, но файл расширения все равно может быть исходным
     * номером версии.
     *
     * @param int $version Номер версии, используемый при проверке и загрузке файла расширения.
     * @return void
     */
    function SetExpansionFileVersion($version)
    {
    }

    /**
     * Задает открытый ключ для использования в других командах расширения файла. В настоящее время применимо только к
     * Android. Открытый ключ можно найти в консоли разработчика Google Play и он отличается для каждого приложения.
     * Нажмите на приложение, а затем нажмите на раздел Служб и API, это длинная строка, которая начинается MIIB.
     *
     * @param string $key Открытый ключ, используемый при проверке и загрузке файла расширения.
     * @return void
     */
    function SetExpansionFileKey($key)
    {
    }

    /**
     * Устанавливает режим ошибки для команд AGK from ignore, report или stop from AGK, например, идентификатор спрайта
     * не существует в команде, которая принимает идентификатор спрайта. Игнорирование заставит AGK попытаться
     * продолжить, игнорируя всю команду, если это необходимо. Отчет заставит AGK сообщить об ошибке в соответствующую
     * консоль отладки и продолжить работу. Stop заставит AGK сообщить об ошибке, как и раньше, а затем остановится,
     * вызвав исключение, которое должно быть поймано, иначе приложение завершится. В случае уровня 1 исключение
     * перехватывается интерпретатором и при отладке отображается в IDE.
     *
     * @param int $mode 0=игнорировать, 1=сообщить, 2=остановить
     * @return void
     */
    function SetErrorMode($mode)
    {
    }

    /**
     * Если SetEditBoxMultiLine имеет значение 0, эта команда устанавливает, будет ли одна строка текста прокручиваться
     * вправо или переноситься на новую строку, когда она перетекает по ширине поля редактирования. Использование
     * по-прежнему не будет разрешено вводить новые символы строки самостоятельно.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $mode 0 для прокрутки вправо (по умолчанию), 1 для переноса на новую строку.
     * @return void
     */
    function SetEditBoxWrapMode($index, $mode)
    {
    }

    /**
     * Переключает видимое состояние этого поля редактирования, когда видимое установлено в 1, поле редактирования
     * можно щелкнуть, получить фокус и изменить, когда установлено в 0, поле редактирования не отображается, не может
     * быть изменено или получить фокус.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $visible Новое состояние поля редактирования, 1 для видимого, 0 для невидимого.
     * @return void
     */
    function SetEditBoxVisible($index, $visible)
    {
    }

    /**
     * Задает, будет ли поле редактирования использовать альтернативный метод ввода текста, если поле редактирования
     * будет скрыто виртуальной клавиатурой. Это относится только к мобильным платформам, таким как iOS и Android, и
     * альтернативный метод ввода обычно представляет собой меньшее поле редактирования, расположенное чуть выше
     * клавиатуры. Поле редактирования по-прежнему будет обновляться в режиме реального времени, как если бы оно
     * вводилось непосредственно, но поскольку оно закрыто клавиатурой, пользователь его не увидит. По умолчанию он
     * включен. Если вы хотите, вы можете отключить его и переместить поле редактирования в поле зрения, когда
     * GetEditBoxHasFocus возвращает 1, обязательно переместите его обратно, когда GetEditBoxHasFocus возвращает 0.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $mode 1 для использования альтернативного ввода (по умолчанию), 0 для использования обычного ввода.
     * @return void
     */
    function SetEditBoxUseAlternateInput($index, $mode)
    {
    }

    /**
     * Задает высоту в мировых координатах текста в этом поле редактирования. По умолчанию он установлен на высоту поля
     * редактирования минус 2.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $size Новый размер шрифта для использования.
     * @return void
     */
    function SetEditBoxTextSize($index, $size)
    {
    }

    /**
     * Задает цвет вводимого текста.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $red Красная составляющая цвета (от 0 до 255).
     * @param int $green Зеленая составляющая цвета (от 0 до 255).
     * @param int $blue Синяя составляющая цвета (от 0 до 255).
     * @return void
     */
    function SetEditBoxTextColor($index, $red, $green, $blue)
    {
    }

    /**
     * Задает текст, который в данный момент отображается в поле редактирования.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param string $str Новый текст для отображения.
     * @return void
     */
    function SetEditBoxText($index, $str)
    {
    }

    /**
     * Задает размер поля редактирования в мировых координатах. При этом устанавливается размер фактического поля ввода
     * текста, его граница будет выходить за пределы этих значений.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $width Ширина нового размера.
     * @param float $height Высота нового размера.
     * @return void
     */
    function SetEditBoxSize($index, $width, $height)
    {
    }

    /**
     * При рисовании поле редактирования привязывается к указанным мировым координатам.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $x Координата x верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $y Координата y верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $x2 Координата x в правом нижнем углу окна для использования в качестве границы клипа.
     * @param float $y2 Координата y в правом нижнем углу окна для использования в качестве границы клипа.
     * @return void
     */
    function SetEditBoxScissor($index, $x, $y, $x2, $y2)
    {
    }

    /**
     * Устанавливает положение в мировых координатах поля редактирования, используя его верхний левый угол. Это
     * устанавливает положение фактического поля ввода текста, его граница будет расширяться влево и выше этой точки.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $x Значение X позиции.
     * @param float $y Значение Y позиции.
     * @return void
     */
    function SetEditBoxPosition($index, $x, $y)
    {
    }

    /**
     * Задает, будут ли в поле редактирования отображаться звезды вместо ввода текста. Использование GetEditBoxText
     * по-прежнему будет возвращать фактические символы, введенные пользователем.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $mode 1 для отображения звезд, 0 для отображения нормального ввода.
     * @return void
     */
    function SetEditBoxPasswordMode($index, $mode)
    {
    }

    /**
     * Задает, будет ли поле редактирования переносить текст в новую строку, когда он достигнет края поля
     * редактирования. По умолчанию многострочный текст равен 0, поэтому текст представляет собой одну непрерывную
     * строку в поле.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $multiline 1 для включения многострочного режима, 0 для отключения.
     * @return void
     */
    function SetEditBoxMultiLine($index, $multiline)
    {
    }

    /**
     * Задает максимальное количество строк, которые могут быть введены в это многострочное поле редактирования.
     * Используйте 0 для неограниченного количества.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $max Максимальное количество строк.
     * @return void
     */
    function SetEditBoxMaxLines($index, $max)
    {
    }

    /**
     * Задает максимальное количество символов, которое может быть введено в это поле редактирования. Используйте 0 для
     * неограниченного количества.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $max Максимальное количество символов.
     * @return void
     */
    function SetEditBoxMaxChars($index, $max)
    {
    }

    /**
     * Задает тип клавиатуры, которая будет отображаться на мобильных устройствах при редактировании этого поля
     * редактирования. Там, где это возможно, будет отображаться клавиатура такого типа, например клавиатура только с
     * цифрами.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $inputType 0 для обычного текста, 1 только для чисел.
     * @return void
     */
    function SetEditBoxInputType($index, $inputType)
    {
    }

    /**
     * Устанавливает изображение шрифта, которое будет использоваться для этого поля редактирования, должно быть ранее
     * загружено с помощью LoadImage(). Используйте 0, чтобы вернуть поле редактирования к шрифту по умолчанию.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $image Идентификатор используемого изображения-0 для шрифта по умолчанию.
     * @return void
     */
    function SetEditBoxFontImage($index, $image)
    {
    }

    /**
     * Переключает состояние фокуса этого поля редактирования, когда фокус установлен на 1, курсор начинает мигать, и
     * любое нажатие клавиши добавит текст в поле редактирования. При установке значения 0 курсор исчезает, и текст не
     * добавляется.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $focus Новое состояние поля редактирования, 1 для активного, 0 для неактивного.
     * @return void
     */
    function SetEditBoxFocus($index, $focus)
    {
    }

    /**
     * Устанавливает шрифт, используемый для этого поля редактирования, который должен быть ранее загружен с помощью
     * LoadFont. Используйте 0, чтобы вернуть поле редактирования к шрифту по умолчанию.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $fontID Идентификатор используемого шрифта-0 для шрифта по умолчанию.
     * @return void
     */
    function SetEditBoxFont($index, $fontID)
    {
    }

    /**
     * Устанавливает расширенное изображение шрифта, используемое для этого поля редактирования, должно быть ранее
     * загружено с помощью LoadImage(). Используйте 0, чтобы удалить расширенное изображение шрифта. Если вы не
     * установите это изображение, поле редактирования не будет принимать расширенные символы, такие как £ é á и т. Д.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $image Идентификатор изображения для использования, 0 для использования без изображения.
     * @return void
     */
    function SetEditBoxExtendedFontImage($index, $image)
    {
    }

    /**
     * Устанавливает глубину поля редактирования таким образом, чтобы оно могло появляться позади или перед другими
     * спрайтами и текстовыми объектами.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $depth Глубина в диапазоне от 0 (спереди) до 10000 (сзади).
     * @return void
     */
    function SetEditBoxDepth($index, $depth)
    {
    }

    /**
     * Устанавливает ширину в мировых координатах курсора ввода текста, по умолчанию это значение равно 1,5 Обратите
     * внимание, что функции, изменяющие размер текста или размер поля редактирования, могут перезаписать это значение.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $width Новая ширина курсора.
     * @return void
     */
    function SetEditBoxCursorWidth($index, $width)
    {
    }

    /**
     * Задает время в секундах между видимым и невидимым курсором в поле ввода текста.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $time Время в секундах.
     * @return void
     */
    function SetEditBoxCursorBlinkTime($index, $time)
    {
    }

    /**
     * Задает цвет мигающего курсора в этом поле редактирования.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $red Красная составляющая цвета (от 0 до 255).
     * @param int $green Зеленая составляющая цвета (от 0 до 255).
     * @param int $blue Синяя составляющая цвета (от 0 до 255).
     * @return void
     */
    function SetEditBoxCursorColor($index, $red, $green, $blue)
    {
    }

    /**
     * Устанавливает курсор в заданную позицию в тексте, т. е. позиция 0 находится слева от первого символа, позиция
     * 1-слева от второго символа и т. Д. Если значение позиции находится вне диапазона, оно будет зажато до ближайшего
     * символа. Текущая позиция курсора гарантированно находится в поле зрения пользователя, поэтому ее можно
     * использовать для выравнивания текста влево или вправо, установив курсор в крайнем левом или правом углу текста.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $pos Новое положение курсора
     * @return void
     */
    function SetEditBoxCursorPosition($index, $pos)
    {
    }

    /**
     * Задает размер границы в мировых координатах, которая будет окружать поле ввода текста. Например, значение 2
     * добавит границу в 2 пикселя вокруг поля ввода.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $size Размер границы.
     * @return void
     */
    function SetEditBoxBorderSize($index, $size)
    {
    }

    /**
     * Устанавливает изображение для использования в качестве границы, это может быть использовано вместе с цветом
     * границы. Используйте 0, чтобы удалить изображение границы.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $image Идентификатор используемого изображения.
     * @return void
     */
    function SetEditBoxBorderImage($index, $image)
    {
    }

    /**
     * Задает цвет любой присутствующей границы. Вы также можете использовать изображение с помощью
     * SetEditBoxBorderImage().
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $red Красная составляющая цвета (от 0 до 255).
     * @param int $green Зеленая составляющая цвета (от 0 до 255).
     * @param int $blue Синяя составляющая цвета (от 0 до 255).
     * @param int $alpha Альфа-компонент цвета (от 0 до 255). 255 полностью непрозрачен.
     * @return void
     */
    function SetEditBoxBorderColor($index, $red, $green, $blue, $alpha)
    {
    }

    /**
     * Задает цвет основного поля ввода текста.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $red Красная составляющая цвета (от 0 до 255).
     * @param int $green Зеленая составляющая цвета (от 0 до 255).
     * @param int $blue Синяя составляющая цвета (от 0 до 255).
     * @param int $alpha Альфа-компонент цвета (от 0 до 255). 255 полностью непрозрачен.
     * @return void
     */
    function SetEditBoxBackgroundColor($index, $red, $green, $blue, $alpha)
    {
    }

    /**
     * Устанавливает изображение для использования в качестве фона, это может быть использовано вместе с цветом фона.
     * Используйте 0, чтобы удалить фоновое изображение.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $image Идентификатор используемого изображения.
     * @return void
     */
    function SetEditBoxBackgroundImage($index, $image)
    {
    }

    /**
     * Эта команда используется в сочетании с системой позиционирования по умолчанию на основе процентов в AGK. При
     * использовании этого подхода вам нужно будет указать аспект отображения, чтобы AGK знал, как правильно отображать
     * объекты на экране. Если бы ваше произведение изначально было рассчитано на разрешение 1024 x 768, это привело бы
     * к соотношению сторон 4:3, что также равносильно утверждению 1024 / 768 = 1.33, поэтому вы бы вызвали
     * SetDisplayAspect и передали бы значение 1.33 в качестве вашего соотношения сторон. На платформах, где разрешение
     * было другим, AGK позаботится о том, чтобы ваше приложение все еще поддерживало это соотношение сторон и
     * выглядело правильно. Альтернативный подход заключается в вызове SetVirtualResolution для управления системой
     * координат и размещения спрайтов с использованием экранных координат вместо использования процентов, и в этом
     * случае вы не должны вызывать эту команду. Если спрайты уже существуют, когда это называется, они будут искажены.
     * Если заданное соотношение сторон не подходит точно на текущем устройстве, черные границы будут нарисованы вокруг
     * области рендеринга, чтобы центрировать ее на экране. Используйте соотношение сторон 0, чтобы использовать
     * текущую систему координат в качестве соотношения сторон. Используйте соотношение сторон -1 для использования
     * соотношения сторон устройства (заполняет весь экран без черных границ, но вызовет растяжение и будет выглядеть
     * по-разному на каждом устройстве) Альтернативным методом заполнения экрана, который позволяет избежать этой
     * проблемы, является использование SetScissor со значениями 0,0,0,0.
     *
     * @param float $aspect соотношение сторон, которое будет использоваться с этого момента, в виде ширины/высоты.
     * @return void
     */
    function SetDisplayAspect($aspect)
    {
    }

    /**
     * Использование идентификатора изображения, большего нуля, приведет к потоковой передаче камеры устройства на
     * выбранное изображение. Изображение в данный момент не должно существовать, оно будет создано этой командой.
     * Используйте ImageID 0, чтобы остановить потоковую передачу, это также приведет к удалению изображения. Параметр
     * cameraID используется, когда устройство имеет несколько камер, например фронтальную и заднюю. Обычно 0 относится
     * к камере, обращенной назад. Используйте GetNumDeviceCameras, чтобы узнать, сколько камер имеет это устройство, и
     * GetDeviceCameraType, чтобы проверить, обращено ли оно спереди или сзади. Этот параметр игнорируется, если
     * ImageID равен 0. У вас может быть активна только одна камера устройства одновременно, поэтому для переключения с
     * задней камеры на фронтальную вы должны сначала вызвать эту команду с ImageID, установленным в 0, чтобы
     * остановить захват, а затем запустить его снова с новым cameraID. Возвращает 1, если она была успешной, 0, если
     * возникла проблема или текущая платформа не поддерживает эту команду. В настоящее время это поддерживается на
     * iOS, Android 4.0.3 и выше, а также Windows.
     *
     * @param int $cameraID Идентификатор камеры устройства, которую вы хотите использовать, может быть задней или
     *     фронтальной камерой
     * @param int $imageID ImageID, который вы хотите использовать для этого изображения, не должен существовать
     * @return int
     */
    function SetDeviceCameraToImage($cameraID, $imageID)
    {
    }

    /**
     * Устанавливает текстурное обертывание по умолчанию для изображений, где координаты UV выходят за пределы
     * диапазона от 0 до 1 в направлении V.
     *
     * @param int $mode Режим обертывания для использования 0=зажим, 1=повторение
     * @return void
     */
    function SetDefaultWrapV($mode)
    {
    }

    /**
     * Устанавливает текстурное обертывание по умолчанию для изображений, где координаты UV выходят за пределы
     * диапазона от 0 до 1 в направлении U.
     *
     * @param int $mode Режим обертывания для использования 0=зажим, 1=повторение
     * @return void
     */
    function SetDefaultWrapU($mode)
    {
    }

    /**
     * Переключает активное состояние этого поля редактирования, когда активное установлено в 1, поле редактирования
     * можно щелкнуть, получить фокус и изменить, когда установлено в 0, поле редактирования нельзя ни изменить, ни
     * получить фокус.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $active Новое состояние поля редактирования, 1 для активного, 0 для неактивного.
     * @return void
     */
    function SetEditBoxActive($index, $active)
    {
    }

    /**
     * Устанавливает фильтр минификации по умолчанию для текстур, когда текстура меньше пространства экрана, в котором
     * она отображается. Вы можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть
     * блочным, или 1, чтобы использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно
     * совпадает с пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница,
     * ближайший имеет тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей. Вы можете
     * установить это значение для каждого изображения с помощью SetImageMinFilter.
     *
     * @param int $filter Режим фильтра для использования 0=ближайший, 1=линейный
     * @return void
     */
    function SetDefaultMinFilter($filter)
    {
    }

    /**
     * Устанавливает фильтр увеличения по умолчанию для текстур, когда текстура больше, чем пространство экрана, в
     * котором она отображается. Вы можете использовать режим 0, чтобы использовать ближайший пиксель, который будет
     * выглядеть блочным, или 1, чтобы использовать линейный фильтр, который будет выглядеть размытым. Когда
     * изображение точно совпадает с пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть
     * небольшая разница, ближайший имеет тенденцию быть более резким, но может мерцать, когда он меняет выбор
     * пикселей. Вы можете установить это значение для каждого изображения с помощью SetImageMagFilter.
     *
     * @param int $filter Режим фильтра для использования 0=ближайший, 1=линейный
     * @return void
     */
    function SetDefaultMagFilter($filter)
    {
    }

    /**
     * Устанавливает время в секундах между появлением и исчезновением курсора в полноэкранном окне редактирования
     *
     * @param float $seconds Время в секундах.
     * @return void
     */
    function SetCursorBlinkTime($seconds)
    {
    }

    /**
     * Эта команда устарела и была заменена на SetFolder.
     *
     * @param string $szPath Каталог, который будет использоваться в качестве нового текущего каталога.
     * @return int
     */
    function SetCurrentDir($szPath)
    {
    }

    /**
     * Устанавливает переменную облачных данных в заданное значение. Если несколько устройств записывают значение
     * одновременно, то облачный провайдер выбирает одно из них и отправляет его всем устройствам. Имя переменной
     * должно быть меньше 64 байт, один символ UTF8 может быть несколько байт, но обычно 1 символ равен 1 байту.
     * Рекомендуется, чтобы имена переменных включали имя приложения, например "myapp.myvariablename", поскольку при
     * трансляции ваших приложений все они будут совместно использовать одно хранилище данных в приложении AGK PLayer.
     * Изменяемые данные хранятся локально, поэтому GetCloudDataVariable немедленно вернет новое значение, однако
     * синхронизация с облаком выполняется в фоновом режиме и может занять несколько минут. Если устройство не имеет
     * подключения к Интернету, то данные будут синхронизированы при следующей доступной возможности. В iOS вы
     * ограничены 1024 переменными с общим объемом памяти 1 МБ. На Android любые данные, которые вы храните,
     * засчитываются в лимит хранения Google Диска пользователя, пользователь может очистить данные вашего приложения,
     * чтобы освободить место, но он не может прочитать данные, которые вы храните.  Вы не должны хранить
     * конфиденциальную информацию, такую как пароли, в виде обычного текста с помощью этих команд.
     *
     * @param string $varName Имя переменной, которую нужно изменить, должно быть меньше 64 байт
     * @param string $varValue Значение для установки переменной
     * @return void
     */
    function SetCloudDataVariable($varName, $varValue)
    {
    }

    /**
     * Устанавливает буфер обмена устройства на указанный текст, при этом перезаписывается все, что ранее было в буфере
     * обмена устройства. Буфер обмена такой же, как и тот, который используется функцией копирования/вставки
     * устройства.
     *
     * @param string $szText Текст для копирования
     * @return void
     */
    function SetClipboardText($szText)
    {
    }

    /**
     * Устанавливает четкий цвет, используемый при очистке заднего буфера.
     *
     * @param int $red Красный компонент ясного цвета
     * @param int $green Зеленая составляющая прозрачного цвета
     * @param int $blue Синий компонент прозрачного цвета
     * @return void
     */
    function SetClearColor($red, $green, $blue)
    {
    }

    /**
     * Устанавливает данные вашей учетной записи Chartboost для использования в интерстициальной (полноэкранной)
     * рекламе и видеорекламе вознаграждений. После вызова этой команды будет предпринята попытка кэшировать
     * интерстициал, чтобы вы могли сразу же отобразить его позже. Вы можете проверить ход выполнения этой задачи с
     * помощью GetFullscreenAdvertLoadedChartboost. Обратите внимание, что эта команда не будет автоматически
     * кэшировать видеорекламу с вознаграждением, вы должны сделать это вручную с помощью CacheRewardAdChartboost.
     * Реклама Chartboost в настоящее время поддерживается Android и iOS.
     *
     * @param string $szKey1 Идентификатор приложения
     * @param string $szKey2 Подпись приложения
     * @return void
     */
    function SetChartboostDetails($szKey1, $szKey2)
    {
    }

    /**
     * Устанавливает вращение указанной камеры с помощью кватерниона. В качестве альтернативы вы можете использовать
     * SetCameraRotation для использования углов Эйлера. По умолчанию камеры создаются с кватернионом 1,0,0,0 в порядке
     * w,x,y,z. Кватернион-это 4-мерное представление трехмерного вращения со свойством w^2+x^2+y^2+z^2 = 1, которое
     * позволяет легко интерполировать между двумя вращениями путем линейной интерполяции двух кватернионов и их
     * нормализации. Каждое 3D-вращение представлено ровно 2 кватернионами, w,x,y,z и -w,-x,-y,-z, поэтому любая версия
     * может быть возвращена командами GetCameraQuat. Кватернионы и углы Эйлера могут использоваться одновременно.
     * Например, установка вращения кватерниона создаст представление Эйлера, которое можно получить с помощью
     * GetCameraAngleX и т. Д.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $w W-компонент кватерниона.
     * @param float $x X-компонент кватерниона.
     * @param float $y Y-компонент кватерниона.
     * @param float $z Z-компонент кватерниона.
     * @return void
     */
    function SetCameraRotationQuat($cameraID, $w, $x, $y, $z)
    {
    }

    /**
     * Задает поворот указанной камеры с помощью углов Эйлера в градусах. В качестве альтернативы вы можете
     * использовать SetCameraRotationQuat для использования кватерниона. По умолчанию камеры создаются с углами 0,0,0 в
     * порядке YXZ. Углы Эйлера-это составные углы, где камера начинается с 0,0,0 и затем поворачивается на заданный
     * угол Y, затем на заданный угол X, а затем катится на заданный угол Z. Каждое 3D-вращение может быть представлено
     * 2 комбинациями углов Эйлера, Y,X,Z и Y-180,X-180,Z-180, поэтому любая версия может быть возвращена командами
     * GetCameraAngle. Кватернионы и углы Эйлера могут использоваться одновременно. Например, установка угла поворота
     * Эйлера создаст представление кватерниона, которое можно получить с помощью GetCameraQuatX и т. Д.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $angx X-компонент вращения Эйлера.
     * @param float $angy Y-компонент вращения Эйлера.
     * @param float $angz Z-компонент вращения Эйлера.
     * @return void
     */
    function SetCameraRotation($cameraID, $angx, $angy, $angz)
    {
    }

    /**
     * Устанавливает ближнюю и дальнюю плоскости камеры. Из-за ограничений рендеринга не все перед камерой может быть
     * рендерено, поэтому они должны быть ограничены видимым диапазоном. Все, что находится за пределами этого
     * диапазона, отсекается системой рендеринга и остается невидимым. Ближняя плоскость-это самое близкое, что объект
     * может быть к камере и все еще визуализироваться, она должна быть больше 0. Обратите внимание, что использование
     * очень малых значений для ближней плоскости повлияет на точность буфера глубины при рендеринге объектов вдали,
     * что может вызвать мерцание на удаленных объектах. Это происходит потому, что буфер глубины не является линейным,
     * вместо этого он смещен в сторону ближней плоскости, и чем ближе к 0 становится ближняя плоскость, тем меньше
     * буфера глубины доступно для дальних объектов. Дальняя плоскость-это максимальное расстояние, на котором объект
     * может находиться от камеры и все еще визуализироваться, его максимальное значение равно бесконечности, но опять
     * же, чем дальше вы пытаетесь визуализировать объект от ближней плоскости, тем менее точной становится буферизация
     * глубины. Если объект пересекает ближнюю или дальнюю плоскость так, что часть его находится с одной стороны, а
     * часть-с другой, то объект будет разрезан плоскостью, и будет видна только часть в пределах диапазона обзора.
     * Диапазон по умолчанию-near=1, far=1000.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $fNear Самое близкое, что объект будет визуализирован.
     * @param float $fFar Самое дальнее, что объект будет визуализирован.
     * @return void
     */
    function SetCameraRange($cameraID, $fNear, $fFar)
    {
    }

    /**
     * Устанавливает положение указанной камеры. По умолчанию камеры расположены на уровне 0,0,0, основная камера-ID 1.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $x X-компонент позиции.
     * @param float $y Y-компонент позиции.
     * @param float $z Z-компонент позиции.
     * @return void
     */
    function SetCameraPosition($cameraID, $x, $y, $z)
    {
    }

    /**
     * Устанавливает камеру на использование смещенной от центра проекционной матрицы. Вы должны установить значения
     * матрицы проекции с помощью SetCameraBounds и SetCameraRange.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param int $mode 1 для использования матрицы проекции вне центра, 0 для использования нормальной матрицы,
     *     значение по умолчанию равно 0.
     * @return void
     */
    function SetCameraOffCenter($cameraID, $mode)
    {
    }

    /**
     * Если FOV камеры установлен в 0, то это будет определять ширину ортогонального вида, значение по умолчанию равно
     * 40. Значение высоты будет вычислено из него на основе соотношения сторон камеры. При использовании ортогональной
     * проекции все остается одного и того же размера независимо от того, насколько близко или далеко оно находится к
     * камере, поэтому при использовании значения ширины по умолчанию куб размером 80 единиц всегда будет заполнять вид
     * камеры, когда камера смотрит на него, так как 40 измеряется от центра экрана до края. Эта команда перезапишет
     * все значения, заданные с помощью SetCameraBounds.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $width Ширина вида в мировых координатах.
     * @return void
     */
    function SetCameraOrthoWidth($cameraID, $width)
    {
    }

    /**
     * Поворачивает камеру, чтобы посмотреть на определенную точку в пространстве с дополнительным значением крена.
     * "смотреть" определяется как выравнивание локальной оси Z камеры, чтобы указать ее положительную сторону в данной
     * точке. Это может быть достигнуто с помощью только углов Y и X в эйлеровой нотации, поэтому вы можете указать
     * дополнительный угол Z в градусах, чтобы повернуть камеру влево или вправо, всегда глядя на одно и то же место.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $x X-компонент позиции, на которую нужно смотреть.
     * @param float $y Y-компонент позиции, на которую нужно смотреть.
     * @param float $z Z-компонент позиции, на которую нужно смотреть.
     * @param float $roll Угол Z для поворота камеры при взгляде на заданное положение отрицательный-по часовой
     *     стрелке.
     * @return void
     */
    function SetCameraLookAt($cameraID, $x, $y, $z, $roll)
    {
    }

    /**
     * Устанавливает горизонтальное поле зрения камеры (FOV). Это определяет угол между левой и правой сторонами обзора
     * камеры, по умолчанию равный 70, и обеспечивает реалистичную 3D-проекцию. Использование меньших значений будет
     * выглядеть так, как будто камера увеличивает масштаб сцены, фактически не двигаясь. Это иногда используется для
     * драматического эффекта в фильмах, где FOV масштабируется в одну сторону, в то время как камера движется в
     * другую. Использование значения FOV 0-это особый случай, который будет генерировать ортогональную матрицу вместо
     * проекционной матрицы, это заставит все оставаться одного и того же размера независимо от того, насколько близко
     * или далеко оно находится к камере. Ортогональная матрица будет иметь ширину 40 мировых единиц с высотой,
     * определяемой соотношением сторон камеры.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $fov Поле зрения в градусах.
     * @return void
     */
    function SetCameraFOV($cameraID, $fov)
    {
    }

    /**
     * Задает параметры для матрицы проекции вне центра. Ближние и дальние значения задаются отдельно с помощью
     * SetCameraRange. Чтобы использовать матрицу проекции вне центра, вы должны активировать ее с помощью
     * SetCameraOffCenter.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $left Левая составляющая проекционной матрицы.
     * @param float $right Правая составляющая проекционной матрицы.
     * @param float $top Верхний компонент проекционной матрицы.
     * @param float $bottom Нижняя составляющая проекционной матрицы.
     * @return void
     */
    function SetCameraBounds($cameraID, $left, $right, $top, $bottom)
    {
    }

    /**
     * Устанавливает соотношение сторон камеры при рендеринге 3D. По умолчанию используется
     * GetDeviceWidth()/GetDeviceHeight() и обеспечивает реалистичную 3D-проекцию. Если размер backbuffer устройства
     * изменяется, например, если устройство меняет ориентацию, или размер окна изменяется, или вызывается
     * SetScreenResolution, то это значение будет сброшено до значения по умолчанию.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $aspect Новое соотношение сторон для использования.
     * @return void
     */
    function SetCameraAspect($cameraID, $aspect)
    {
    }

    /**
     * Эта функция позиционирует виртуальную кнопку в заданном положении только в том случае, если это необходимо для
     * данного устройства, например, если присутствует реальный джойстик или клавиатура, то эта команда не будет иметь
     * заметного эффекта. Рекомендуется вызвать эту команду в любом случае, просто на случай, если потребуется
     * виртуальная кнопка. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства
     * для создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут использоваться для
     * команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет
     * использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5
     * соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая появится на
     * экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа
     * гарантированно имеет способ активации кнопок AGK. Если виртуальная кнопка создана,она будет центрирована на
     * заданной позиции X, Y.
     *
     * @param int $index Идентификатор кнопки, которую нужно расположить, должен находиться в диапазоне от 1 до 5
     *     включительно.
     * @param float $x Координата X положения кнопки в координатах экрана.
     * @param float $y Координата Y положения кнопки в координатах экрана.
     * @param float $size Диаметр положения кнопки в координатах экрана.
     * @return void
     */
    function SetButtonScreenPosition($index, $x, $y, $size)
    {
    }

    /**
     * Устанавливает цвет или любые границы, используемые, когда дисплей не точно соответствует соотношению сторон.
     * Если этот цвет отличается от цвета clear, то выполняется дополнительная операция clear, которая может повлиять
     * на производительность, если скорость заполнения является проблемой.
     *
     * @param int $red Красная составляющая цвета границы
     * @param int $green Зеленая составляющая цвета границы
     * @param int $blue Синий компонент цвета границы
     * @return void
     */
    function SetBorderColor($red, $green, $blue)
    {
    }

    /**
     * Задает, должно ли устройство использовать сглаживание при рендеринге в задний буфер. В настоящее время это
     * относится только к Windows, Mac и Linux, и доступна только 4-кратная множественная выборка. Это не относится ни
     * к каким объектам, нарисованным на изображении с помощью SetRenderToImage, только задний буфер сглажен.
     *
     * @param int $mode 0=выкл., 1=4xMSAA
     * @return void
     */
    function SetAntialiasMode($mode)
    {
    }

    /**
     * Задает новый цвет для глобального окружающего света. Значения должны находиться в диапазоне 0-255, но не
     * ограничиваться им. Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать свет.
     * Цвет окружающей среды по умолчанию-76,76,76.
     *
     * @param int $red Красная составляющая нового цвета.
     * @param int $green Зеленая составляющая нового цвета.
     * @param int $blue Синий компонент нового цвета.
     * @return void
     */
    function SetAmbientColor($red, $green, $blue)
    {
    }

    /**
     * Определяет, будут ли объявления Amazon тестовыми или платными. Это должно быть вызвано перед SetAmazonAdDetails,
     * чтобы убедиться, что все объявления являются тестовыми. По умолчанию будет показываться платная реклама.
     *
     * @param int $mode 0=показывать платную рекламу, 1=показывать тестовую рекламу
     * @return void
     */
    function SetAmazonAdTesting($mode)
    {
    }

    /**
     * Устанавливает данные учетной записи Amazon Ads для использования в интерстициальной (полноэкранной) рекламе.
     * После вызова этой команды будет предпринята попытка кэшировать интерстициал, чтобы вы могли сразу же отобразить
     * его позже. Вы можете проверить ход этого процесса с помощью GetFullscreenAdvertLoadedAmazon. В настоящее время
     * Amazon ads поддерживается iOS и Android.
     *
     * @param string $szKey Идентификатор рекламного блока, предоставленный Amazon.
     * @return void
     */
    function SetAmazonAdDetails($szKey)
    {
    }

    /**
     * Установите видимость любого объявления.
     *
     * @param int $iVisible 1 покажет рекламу, а 0 скроет ее.
     * @return void
     */
    function SetAdvertVisible($iVisible)
    {
    }

    /**
     * Размещает рекламу, созданную с помощью CreateAdvert, где-то на экране и пытается масштабировать ее до
     * определенной ширины. Поскольку реклама будет иметь свое собственное соотношение сторон, высота будет
     * рассчитываться исходя из ширины. Это не гарантирует работу со всеми поставщиками рекламы, в настоящее время
     * только Inneractive может масштабировать и перемещать рекламу в абсолютное положение.
     *
     * @param float $x Положение x в верхнем левом углу объявления
     * @param float $y Положение y в верхнем левом углу объявления
     * @param float $width Желаемая ширина объявления, она будет масштабирована до этой ширины
     * @return void
     */
    function SetAdvertPosition($x, $y, $width)
    {
    }

    /**
     * Размещает рекламу, созданную с помощью CreateAdvert, где-то на экране и пытается масштабировать ее до
     * определенной ширины. Поскольку реклама будет иметь свое собственное соотношение сторон, высота будет
     * рассчитываться исходя из ширины. Это обеспечивает грубое позиционирование, позволяя вам выбирать между левым,
     * центрированным или правым выравниванием для горизонтального и вертикального положений. Это не гарантирует работу
     * со всеми поставщиками рекламы, в настоящее время только Inneractive может масштабировать рекламу до определенной
     * ширины.
     *
     * @param int $horz Горизонтальное положение объявления, 0=слева, 1=в центре, 2=справа
     * @param int $vert Вертикальное положение объявления, 0=верх, 1=центр, 2=низ
     * @param float $width Желаемая ширина объявления, она будет масштабирована до этой ширины
     * @return void
     */
    function SetAdvertLocation($horz, $vert, $width)
    {
    }

    /**
     * Устанавливает данные вашей учетной записи AdMob для использования в видеообъявлениях с вознаграждением. После
     * вызова этой команды будет предпринята попытка кэшировать видео награды, чтобы вы могли сразу же отобразить его
     * позже. Вы можете проверить ход выполнения этой задачи с помощью GetRewardAdLoadedAdMob. Видео AdMob reward в
     * настоящее время поддерживаются iOS и Android.
     *
     * @param string $szID Идентификатор рекламного блока, предоставленный AdMob (не идентификатор приложения).
     * @return void
     */
    function SetAdMobRewardAdDetails($szID)
    {
    }

    /**
     * Размещает рекламу, созданную с помощью CreateAdvert, где-то на экране и пытается масштабировать ее до
     * определенной ширины. Поскольку реклама будет иметь свое собственное соотношение сторон, высота будет
     * рассчитываться исходя из ширины. Это обеспечивает грубое позиционирование, позволяя вам выбирать между левым,
     * центрированным или правым выравниванием для горизонтального и вертикального положений. Это не гарантирует работу
     * со всеми поставщиками рекламы, в настоящее время только Inneractive может масштабировать рекламу до определенной
     * ширины.
     *
     * @param int $horz Горизонтальное положение объявления: 0=слева, 1=в центре, 2=справа
     * @param int $vert Вертикальное положение объявления, 0=верх, 1=центр, 2=низ
     * @param float $offsetx когда horz равен 0 или 2 это значение смещает объявление от указанного края
     * @param float $offsety когда vert равен 0 или 2 это значение смещает объявление от указанного края
     * @param float $width Желаемая ширина объявления, она будет масштабирована до этой ширины
     * @return void
     */
    function SetAdvertLocationEx($horz, $vert, $offsetx, $offsety, $width)
    {
    }

    /**
     * Определяет, будут ли объявления AdMob тестовыми или платными. Это должно быть вызвано перед SetAdMobDetails,
     * чтобы убедиться, что все объявления являются тестовыми. По умолчанию будет показываться платная реклама.
     * Обратите внимание, что если вы показываете платные объявления во время тестирования, вы не должны нажимать на
     * них, иначе ваша учетная запись AdMob может быть приостановлена.
     *
     * @param int $mode 0 = показывать платные объявления, 1 = показывать тестовые объявления
     * @return void
     */
    function SetAdMobTesting($mode)
    {
    }

    /**
     * Устанавливает данные учетной записи AdMob для использования в баннерной рекламе и интерстициальной
     * (полноэкранной) рекламе. Обратите внимание, что это поддерживает только одно или другое, вы можете установить
     * либо ИДЕНТИФИКАТОР рекламного блока баннера, либо идентификатор интерстициального рекламного блока, но не оба
     * одновременно. После вызова этой команды будет предпринята попытка кэшировать интерстициал, чтобы вы могли сразу
     * же отобразить его позже. Вы можете проверить ход выполнения этой задачи с помощью
     * GetFullscreenAdvertLoadedAdMob. Реклама AdMob в настоящее время поддерживается iOS и Android.
     *
     * @param string $szID Идентификатор рекламного блока, предоставленный AdMob.
     * @return void
     */
    function SetAdMobDetails($szID)
    {
    }

    /**
     * Устанавливает рейтинг контента для рекламы AdMob, если ваше приложение ориентировано на детей. Это должно быть
     * вызвано перед SetAdMobDetails
     *
     * @param int $rating 0 = нормальная реклама, 1 = безопасная для детей реклама
     * @return void
     */
    function SetAdMobChildRating($rating)
    {
    }

    /**
     * Установите целевую скорость для твист-соединения. Должен быть вызван в цикле. Сначала включите соединение с
     * Set3DPhysicsTwistJointMotorIsEnabled()
     *
     * @param int $jointID Id соединения
     * @param int $rotationVec3ID Идентификатор вектора, который имеет цель вращения для двигателя твист-сустава.
     * @return void
     */
    function Set3DPhysicsTwistJointMotorRotationTarget($jointID, $rotationVec3ID)
    {
    }

    /**
     * Устанавливает статику тряпичной куклы, изменяя массу всех костей тряпичной куклы на ноль.
     *
     * @param int $objID идентификатор объекта
     * @param int $isStatic 1 = истина, 0 = ложь
     * @return void
     */
    function Set3DphysicsRagdollStatic($objID, $isStatic)
    {
    }

    /**
     * Включает двигатель с твист-соединением.
     *
     * @param int $jointID идентификатор СОЕДИНЕНИЯ
     * @param int $isEnabled 1 = истина , 0 = ложь
     * @return void
     */
    function Set3DPhysicsTwistJointMotorIsEnabled($jointID, $isEnabled)
    {
    }

    /**
     * Устанавливает максимальное значение импульса двигателя для Твист-соединения. Сначала включите соединение с
     * Set3DPhysicsTwistJointMotorIsEnabled()
     *
     * @param int $jointID Id соединения
     * @param float $maxImpulse Максимальный импульс, который должен быть приложен к двигателю сустава.
     * @return void
     */
    function Set3DPhysicsTwistJointMaxMotorImpulse($jointID, $maxImpulse)
    {
    }

    /**
     * Задает вращение статической плоскости
     *
     * @param int $planeID статический идентификатор плоскости
     * @param float $angX Угол вращения мира X.
     * @param float $angY Угол поворота мира Y.
     * @param float $angZ Угол поворота мира Z.
     * @return void
     */
    function Set3DPhysicsStaticPlaneRotation($planeID, $angX, $angY, $angZ)
    {
    }

    /**
     * Устанавливает целевую линейную скорость двигателя для физического ползункового соединения.
     *
     * @param int $jointID Id соединения
     * @param float $linearMotorVelocity Линейная скорость, которая должна быть приложена к совместному двигателю.
     * @return void
     */
    function Set3DPhysicsSliderJointTargetLinearMotorVelocity($jointID, $linearMotorVelocity)
    {
    }

    /**
     * Установите линейный двигатель с приводом от ползунковых соединений в положение включено.
     *
     * @param int $jointID Id соединения
     * @param int $isEnabled 1 = истина, 0 = ложь
     * @return void
     */
    function Set3DPhysicsSliderJointPoweredLinearMotorIsEnabled($jointID, $isEnabled)
    {
    }

    /**
     * Устанавливает двигатель шарниров на максимальное линейное усилие.
     *
     * @param int $jointID Id соединения
     * @param float $maxLinearForce Максимальная линейная сила, приложенная к шарнирному двигателю.
     * @return void
     */
    function Set3DPhysicsSliderJointMaxLinearMotorForce($jointID, $maxLinearForce)
    {
    }

    /**
     * Устанавливает пороги сна для создаваемой тряпичной куклы. Значения по умолчанию должны быть хороши для
     * большинства ситуаций. Звоните только в том случае, если вы хотите изменить эти значения. Должен быть вызван до
     * Finalize3DPhysicsRagDoll()
     *
     * @param float $linear Значение по умолчанию-1.8
     * @param float $angular Значение по умолчанию-2.8
     * @return void
     */
    function Set3DPhysicsRagdollSleepingThresholds($linear, $angular)
    {
    }

    /**
     * Устанавливает время деактивации создаваемой тряпичной куклы. Значения по умолчанию должны быть хороши для
     * большинства ситуаций. Звоните только в том случае, если вы хотите изменить эти значения. Должен быть вызван
     * перед Finalize3DPhysicsRagDoll()
     *
     * @param float $time Значение по умолчанию-0.8
     * @return void
     */
    function Set3DPhysicsRagdollDeactivationTime($time)
    {
    }

    /**
     * Задает положение статической плоскости
     *
     * @param int $planeID статический идентификатор плоскости
     * @param float $posX Положение мира X.
     * @param float $posY Положение в мире Y.
     * @param float $posZ Положение мира Z.
     * @return void
     */
    function Set3DPhysicsStaticPlanePosition($planeID, $posX, $posY, $posZ)
    {
    }

    /**
     * Поддерживает физическую тряпичную куклу в активном состоянии. Не допускает автоматической деактивации, когда
     * рэгдолл приходит в состояние покоя.
     *
     * @param int $objID идентификатор объекта
     * @param int $isDisabled 1 = истина, 0 = ложь
     * @return void
     */
    function Set3DPhysicsRagdollDeactivation($objID, $isDisabled)
    {
    }

    /**
     * Устанавливает демпфирование для создаваемой тряпичной куклы. Значения по умолчанию должны быть хороши для
     * большинства ситуаций. Звоните только в том случае, если вы хотите изменить эти значения. Должен быть вызван
     * перед Finalize3DPhysicsRagDoll()
     *
     * @param float $linear Значение по умолчанию-0,08
     * @param float $angular Значение по умолчанию-0.95
     * @return void
     */
    function Set3DPhysicsRagdollDamping($linear, $angular)
    {
    }

    /**
     * Показывает объекты кости тряпичной куклы и скрывает объект.
     *
     * @param int $objID идентификатор объекта
     * @param int $isVisible 1 = истина, 0 = ложь
     * @return void
     */
    function Set3DPhysicsRagdollBonesVisible($objID, $isVisible)
    {
    }

    /**
     * Устанавливает линейные пределы для ползункового соединения. Чтобы разблокировать соединение, установите нижний
     * предел больше верхнего.
     *
     * @param int $jointID Id соединения
     * @param float $lowerLimit Нижний предел
     * @param float $upperLimit Верхний предел
     * @return void
     */
    function Set3DPhysicsJointSliderLinearLimits($jointID, $lowerLimit, $upperLimit)
    {
    }

    /**
     * Устанавливает угловые пределы для ползункового соединения. Чтобы разблокировать соединение, установите нижний
     * предел больше верхнего.
     *
     * @param int $jointID Id соединения
     * @param float $lowerLimit Нижний предел в градусах
     * @param float $upperLimit Верхний предел в градусах
     * @return void
     */
    function Set3DPhysicsJointSliderAngularLimits($jointID, $lowerLimit, $upperLimit)
    {
    }

    /**
     * Устанавливает угловые пределы для шарнирного соединения в градусах. Чтобы разблокировать соединение, установите
     * нижний предел больше верхнего.
     *
     * @param int $jointID Id соединения
     * @param float $minAng Минимальный угол в градусах.
     * @param float $maxAng Максимальный угол в градусах.
     * @return void
     */
    function Set3DPhysicsJointHingeLimits($jointID, $minAng, $maxAng)
    {
    }

    /**
     * Устанавливает порог разрушения соединения.
     *
     * @param int $jointID Id соединения
     * @param int $isEnabled 0 отключит соединение
     * @return void
     */
    function Set3DPhysicsJointEnabled($jointID, $isEnabled)
    {
    }

    /**
     * Устанавливает угловые пределы для соединения закрутки конуса в градусах. Чтобы разблокировать определенное
     * значение установите его на 360
     *
     * @param int $jointID Id соединения
     * @param float $swingSpan1 угол в градусах
     * @param float $swingSpan2 угол в градусах
     * @param float $twistSpan угол в градусах
     * @return void
     */
    function Set3DPhysicsJointConeTwistLimits($jointID, $swingSpan1, $swingSpan2, $twistSpan)
    {
    }

    /**
     * Установите целевую скорость для шарнирного соединения. Должен быть вызван в цикле. Сначала включите соединение с
     * Set3DPhysicsHingeJointMotorIsEnabled()
     *
     * @param int $jointID Id соединения
     * @param float $targetVelocity Целевая скорость, которую нужно использовать.
     * @return void
     */
    function Set3DPhysicsHingeJointMotorVelocity($jointID, $targetVelocity)
    {
    }

    /**
     * Включает мотор шарнирного соединения.
     *
     * @param int $jointID Id соединения
     * @param int $isEnabled 1 = истина , 0 = ложь
     * @return void
     */
    function Set3DPhysicsHingeJointMotorIsEnabled($jointID, $isEnabled)
    {
    }

    /**
     * Устанавливает порог разрушения соединения.
     *
     * @param int $jointID Id соединения
     * @param float $breakThreshold пороговое значение разрыва
     * @return void
     */
    function Set3DPhysicsJointBreakingThreshold($jointID, $breakThreshold)
    {
    }

    /**
     * Устанавливает максимальное значение импульса двигателя для шарнирного соединения. Сначала включите соединение с
     * Set3DPhysicsHingeJointMotorIsEnabled()
     *
     * @param int $jointID Id соединения
     * @param float $maxImpulse Максимальное значение импульса, которое должно быть приложено к совместному двигателю.
     * @return void
     */
    function Set3DPhysicsHingeJointMaxMotorImpulse($jointID, $maxImpulse)
    {
    }

    /**
     * Устанавливает высоту, на которую контроллер может подниматься и опускаться.
     *
     * @param int $objID идентификатор объекта.
     * @param float $stepHeight Высота шага в мировых ценностях.
     * @return void
     */
    function Set3DPhysicsCharacterControllerStepHeight($objID, $stepHeight)
    {
    }

    /**
     * Устанавливает гравитацию мира физики, гравитация измеряется в метрах в секунду. По умолчанию гравитация
     * установлена на ( 0.0, -10.0, 0.0 ). Вам нужно только вызвать эту команду, если вам нужно изменить настройки по
     * умолчанию.
     *
     * Пример вызова:
     *
     * void Set3DPhysicsGravity($vectorID);
     *
     * void Set3DPhysicsGravity($x, $y, $z);
     * @param int $vectorID Идентификатор вектора для использования.
     * @param float $x Величина силы тяжести по оси Х в метрах в секунду.
     * @param float $y Величина силы тяжести по оси Y в метрах в секунду.
     * @param float $z Величина силы тяжести по оси Z в метрах в секунду.
     * @return void
     */
    function Set3DPhysicsGravity(mixed...$args)
    {
    }

    /**
     * Перемещает Контроллер в новые переданные координаты. Не размещайте контроллер внутри другого физического объекта.
     *
     * @param int $objID идентификатор объекта.
     * @param float $posX Новая координата X.
     * @param float $posY Новая координата Y.
     * @param float $posZ Новая координата Z.
     * @return void
     */
    function Set3DPhysicsCharacterControllerPosition($objID, $posX, $posY, $posZ)
    {
    }

    /**
     * установите максимальный наклон в угловых градусах, на которые может подняться контроллер.
     *
     * @param int $objID идентификатор объекта
     * @param float $maxSlopeDegress Значение по умолчанию-45,0 градуса.
     * @return void
     */
    function Set3DPhysicsCharacterControllerMaxSlope($objID, $maxSlopeDegress)
    {
    }

    /**
     * Установите скорость, с которой контроллер перемещается вверх при вызове прыжка.
     *
     * @param int $objID идентификатор объекта
     * @param float $jumpSpeed Значение по умолчанию-10.0
     * @return void
     */
    function Set3DPhysicsCharacterControllerJumpSpeed($objID, $jumpSpeed)
    {
    }

    /**
     * Устанавливает гравитацию для контроллера символов. Эта гравитация не то же самое, что физическая мировая
     * гравитация. и влияет только на индивидуальный характер контроллера.
     *
     * @param int $objID идентификатор объекта
     * @param float $gravity Значение по умолчанию равно (9,8 * 3)
     * @return void
     */
    function Set3DPhysicsCharacterControllerGravity($objID, $gravity)
    {
    }

    /**
     * Устанавливает скорость, с которой контроллер будет падать.
     *
     * @param int $objID идентификатор объекта
     * @param float $fallSpeed Значение по умолчанию-55,0, что является конечной скоростью скай-дайвера в метрах в
     *     секунду.
     * @return void
     */
    function Set3DPhysicsCharacterControllerFallSpeed($objID, $fallSpeed)
    {
    }

    /**
     * Устанавливает, рисуются ли испускаемые частицы. Установите значение 1, чтобы показать частицы, и 0, чтобы скрыть
     * их. Частицы все равно будут обновляться, пока они скрыты, вы можете остановить обновление частиц с помощью
     * Set3DParticlesActive
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $visible 1=показать, 0=скрыть
     * @return void
     */
    function Set3DParticlesVisible($ID, $visible)
    {
    }

    /**
     * Устанавливает минимальный и максимальный множитель, который будет влиять на испускаемые частицы. Это может быть
     * использовано для обеспечения некоторого изменения скорости при испускании частиц.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $v1 Минимальный множитель скорости.
     * @param float $v2 Множитель максимальной скорости.
     * @return void
     */
    function Set3DParticlesVelocityRange($ID, $v1, $v2)
    {
    }

    /**
     * Установите прозрачность частиц на определенную настройку с выбором без прозрачности, альфа-прозрачности и
     * аддитивного смешивания. По умолчанию частицы создаются с альфа-прозрачностью.
     *
     * @param int $ID Идентификатор излучателя частиц для изменения.
     * @param int $mode Режим прозрачности для этих частиц: 0=выкл., 1=альфа-прозрачность, 2=аддитивное смешивание
     * @return void
     */
    function Set3DParticlesTransparency($ID, $mode)
    {
    }

    /**
     * Задает область вокруг излучателя, в которой могут появиться новые частицы. Эти значения относятся к положению
     * эмиттера, например, зона 0,0,0,0 будет означать, что все частицы начинаются в точке положения эмиттера. Зона -10
     * в x и +10 x, где y и z равны 0 (-10,0,0,10,0,0), создаст линию, центрированную на положении излучателя, вдоль
     * которой будут случайным образом появляться частицы. Зона коробки, где x, y и z не равны нулю, означала бы, что
     * частицы могут начинаться в любой точке внутри коробки.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x1 Координата x верхнего левого угла стартовой зоны.
     * @param float $y1 Координата y верхнего левого угла стартовой зоны.
     * @param float $z1 z-координата верхнего левого угла стартовой зоны.
     * @param float $x2 Координата x в правом нижнем углу стартовой зоны.
     * @param float $y2 Координата y в правом нижнем углу стартовой зоны.
     * @param float $z2 Координата z в правом нижнем углу стартовой зоны.
     * @return void
     */
    function Set3DParticlesStartZone($ID, $x1, $y1, $z1, $x2, $y2, $z2)
    {
    }

    /**
     * Задает размер всех частиц в мировых координатах. Установка большого количества частиц на большой размер будет
     * плохо работать на мобильных устройствах с низкой скоростью заполнения (количество пикселей, которые он может
     * нарисовать в секунду).
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $size Размер частиц
     * @return void
     */
    function Set3DParticlesSize($ID, $size)
    {
    }

    /**
     * Устанавливает положение 3D-излучателя частиц. Это положение, из которого будут появляться новые частицы, и не
     * влияет на частицы, которые уже видны.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x Новая координата x для излучателя в мировых координатах.
     * @param float $y Новая координата y для излучателя в мировых координатах.
     * @param float $z Новая координата z для излучателя в мировых координатах.
     * @return void
     */
    function Set3DParticlesPosition($ID, $x, $y, $z)
    {
    }

    /**
     * Устанавливает максимальное количество частиц, которые будут испускаться. Если это значение равно -1, то число
     * бесконечно. Излучатель будет вести подсчет общего количества частиц, которые он испускает, и остановится, когда
     * будет достигнут предел. Чтобы проверить, достиг ли излучатель своего предела, используйте
     * Get3DParticlesMaxReached. Чтобы сбросить счетчик и заставить его снова начать излучать, используйте
     * Reset3DParticleCount.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $max Максимальное количество испускаемых частиц
     * @return void
     */
    function Set3DParticlesMax($ID, $max)
    {
    }

    /**
     * Устанавливает время жизни частиц в секундах после их испускания. После того, как частицы будут живы в течение
     * заданного количества секунд, они исчезнут. Это одно из двух значений, влияющих на количество генерируемых
     * частиц, другое-Set3DParticlesFrequency. Максимальное количество частиц, которое может быть на экране в любой
     * момент времени, - это freq*life, причем freq-это количество частиц, испускаемых в секунду. Это значение не
     * зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время в секундах, в течение которого частица видна.
     * @return void
     */
    function Set3DParticlesLife($ID, $time)
    {
    }

    /**
     * Устанавливает изображение, которое будет использоваться для каждой частицы.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $imageID Идентификатор изображения, используемого для испускаемых частиц.
     * @return void
     */
    function Set3DParticlesImage($ID, $imageID)
    {
    }

    /**
     * Задает частоту генерации новых частиц. Значение freq указывает, сколько частиц должно быть произведено в
     * секунду, это не зависит от частоты кадров. Это одно из двух значений, влияющих на количество генерируемых
     * частиц, другое-SetParticlesLife. Максимальное количество частиц, которое может быть на экране в любой момент
     * времени, - это freq*life, причем жизнь-это количество секунд, в течение которых частица живет, прежде чем
     * исчезнуть.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $freq Скорость образования новых частиц в частицах в секунду.
     * @return void
     */
    function Set3DParticlesFrequency($ID, $freq)
    {
    }

    /**
     * Задает диапазон направления в градусах, который частица может выбрать при первом запуске. Это берет базовое
     * направление, заданное с помощью Set3DParticlesDirection, и регулирует его на случайную величину между 0 и углом
     * 1/2 градуса в одном направлении и углом 2/2 градуса в перпендикулярном направлении. Например, угол 1, равный 0,
     * и угол 2, равный 0, означают, что все новые частицы следуют точно в указанном ранее направлении. Угол 1, равный
     * 360, и угол 2, равный 0, означали бы, что частицы могут двигаться в любом направлении по плоскому кругу, в то
     * время как угол 1, равный 360, и угол 2, равный 180, означали бы, что частицы будут двигаться в любом направлении
     * по сфере. Углы образуют пирамиду, выровненную с направлением излучателя частиц, указанным ранее. Угол 1 должен
     * быть между 0 и 360, угол 2 должен быть между 0 и 180.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $angle1 Диапазон изменения, который частица может выбрать из направления излучателя.
     * @param float $angle2 Перпендикулярный диапазон изменения, который частица может выбрать из направления
     *     излучателя.
     * @return void
     */
    function Set3DParticlesDirectionRange($ID, $angle1, $angle2)
    {
    }

    /**
     * Задает начальное направление новых частиц, когда они выходят из излучателя. Это можно использовать вместе с
     * командой Set3DParticlesDirectionRange, чтобы установить диапазон отклонения от этого начального направления,
     * которое могут выбрать новые частицы. Это также устанавливает начальную скорость частиц, принимая длину вектора
     * за единицы в секунду. Например, если начальное направление vx=10, vy=-15, vz=0, частицы начнут двигаться в
     * направлении X со скоростью 10 единиц в секунду и в направлении Y со скоростью 15 единиц в секунду и будут
     * продолжать эту скорость движения в течение всей своей жизни, если на них не будут влиять силы, добавленные с
     * помощью Add3DParticlesForce.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $vx Направление x, в котором частицы будут двигаться изначально.
     * @param float $vy Направление y, в котором частицы будут двигаться изначально.
     * @param float $vz Направление z, в котором частицы будут двигаться изначально.
     * @param float $roll Угол поворота излучателя в заданном направлении
     * @return void
     */
    function Set3DParticlesDirection($ID, $vx, $vy, $vz, $roll)
    {
    }

    /**
     * Устанавливает режим интерполяции для изменения цвета. Цвета могут быть установлены в определенные моменты жизни
     * частицы с помощью Add3DParticlesColorKeyFrame, и частица либо смешается между этими цветами (плавная
     * интерполяция), либо быстро изменится, когда достигнет следующего изменения цвета (без интерполяции).
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $mode 1=плавная интерполяция, 0=отсутствие интерполяции
     * @return void
     */
    function Set3DParticlesColorInterpolation($ID, $mode)
    {
    }

    /**
     * Устанавливает, обновляются ли испускаемые частицы каждый кадр. Установите значение 1, чтобы обновить частицы как
     * обычно, и 0, чтобы приостановить их. Частицы будут продолжать быть видимыми, когда остановятся. Чтобы скрыть
     * частицы, используйте Set3DParticlesVisible.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $active 1=нормально, 0=пауза
     * @return void
     */
    function Set3DParticlesActive($ID, $active)
    {
    }

    /**
     * Отправит строку на удаленное соединение. Обратите внимание, что данные отправляются не сразу, для их отправки
     * необходимо вызвать FlushSocket. Если вы отправляете строку в приложение, не являющееся AGK, то строка строится
     * из значения длины 4 байта, за которым следует X байт строковых данных, где X-значение длины. Строка не
     * завершается нулем. Возвращает 1, если строка была успешно записана в буфер, 0, если сокет отключен.
     *
     * @param int $socketID Идентификатор сокета для записи
     * @param string $value Значение для отправки
     * @return int
     */
    function SendSocketString($socketID, $value)
    {
    }

    /**
     * Отправляет сетевое сообщение, созданное с помощью CreateNetworkMessage, на указанный удаленный IP-адрес и порт.
     * Вы должны указать прослушиватель UDP для использования в качестве исходного IP-адреса и порта. Эта функция
     * удалит указанный идентификатор сообщения.
     *
     * @param int $listenerID Идентификатор прослушивателя для использования в качестве исходного IP-адреса и порта
     * @param int $messageID Идентификатор отправляемого сетевого сообщения
     * @param string $toIP IP-адрес для отправки сообщения
     * @param int $toPort Порт для отправки сообщения
     * @return void
     */
    function SendUDPNetworkMessage($listenerID, $messageID, $toIP, $toPort)
    {
    }

    /**
     * Отправит 4-байтовое целое число на удаленное соединение. Обратите внимание, что данные отправляются не сразу,
     * для их отправки необходимо вызвать FlushSocket. Возвращает 1, если целое число было успешно записано в буфер, 0,
     * если сокет отключен.
     *
     * @param int $socketID Идентификатор сокета для записи
     * @param int $value Значение для отправки
     * @return int
     */
    function SendSocketInteger($socketID, $value)
    {
    }

    /**
     * Отправит 4-байтовый поплавок на удаленное соединение. Обратите внимание, что данные отправляются не сразу, для
     * их отправки необходимо вызвать FlushSocket. Возвращает 1, если float был успешно записан в буфер, 0, если сокет
     * отключен.
     *
     * @param int $socketID Идентификатор сокета для записи
     * @param float $value Значение для отправки
     * @return int
     */
    function SendSocketFloat($socketID, $value)
    {
    }

    /**
     * Отправка данных на смарт-часы в фоновом режиме, если приложение watch в данный момент не открыто, сообщение
     * будет поставлено в очередь и получено приложением watch при следующем открытии. Сообщение должно быть в виде
     * строки JSON, например "{"label":"my message"}". Вы также можете использовать тип с функцией .toJSON() для
     * создания строки JSON. Приложение watch получит его как NSDictionary с метками в качестве ключей.  В настоящее
     * время работает только на iOS.
     *
     * @param string $szJson Строка JSON, содержащая сообщение для отправки в приложение watch.
     * @return void
     */
    function SendSmartWatchData($szJson)
    {
    }

    /**
     * Отправит один байт в диапазоне от -128 до 127 на удаленное соединение. Обратите внимание, что данные
     * отправляются не сразу, для их отправки необходимо вызвать FlushSocket. Возвращает 1, если байт был успешно
     * записан в буфер, 0, если сокет отключен.
     *
     * @param int $socketID Идентификатор сокета для записи
     * @param int $value Значение для отправки
     * @return int
     */
    function SendSocketByte($socketID, $value)
    {
    }

    /**
     * Отправляет созданное сетевое сообщение данному клиенту в данной сети. Используйте идентификатор клиента 0 для
     * отправки всем подключенным клиентам (кроме отправителя), в противном случае, если идентификатор клиента не
     * существует, будет сгенерирована ошибка. Эта функция удалит указанный идентификатор сообщения.
     *
     * @param int $iNetID Идентификатор сети, по которой будет отправлено сообщение.
     * @param int $toClient Идентификатор клиента, которому нужно отправить сообщение, 0 для отправки всем.
     * @param int $iMsgID Идентификатор отправляемого сообщения.
     * @return void
     */
    function SendNetworkMessage($iNetID, $toClient, $iMsgID)
    {
    }

    /**
     * Отправьте запрос на сервер, указанный в SetHTTPHost, например, если запрашивается http:
     * www.thegamecreators.com/index.php szServerFile должен быть "index.php". Эта команда немедленно возвращается и
     * ждет ответа сервера в фоновом режиме. Вы можете проверить статус ответа с помощью GetHTTPResponseReady и, когда
     * он будет готов, получить ответ с помощью GetHTTPResponse.
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после
     *     доменной части URL-адреса.
     * @param string|null $szPostData Необработанные данные post для отправки на сервер обратите внимание, что & и =
     * @return int
     */
    function SendHTTPRequestASync(int $iHTTP, string $szServerFile, string $szPostData = null): int
    {
    }

    /**
     * Отправьте запрос на сервер, указанный в SetHTTPHost (), например, если запрашивается http:
     * www.thegamecreators.com/index.php szServerFile должен быть "index.php". Эта команда ожидает ответа сервера и
     * возвращает ответ сервера. Если вы используете уровень 2, вы должны удалить этот ответ, когда закончите с ним. Не
     * работает при экспорте в HTML5
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после
     *     доменной части URL-адреса.
     * @param string|null $szPostData Необработанные данные post для отправки на сервер обратите внимание, что & и =
     * @return string
     */
    function SendHTTPRequest(int $iHTTP, string $szServerFile, string $szPostData = null): string
    {
    }

    /**
     * Отправьте файл на сервер, указанный в SetHTTPHost, например, если запрашивается http:
     * www.thegamecreators.com/index.php szServerFile должен быть "index.php". Также позволяет отправлять POST-данные
     * на сервер, которые могут включать переменные или файловые данные, например "myvar=5&var2=test". Эта команда
     * немедленно возвращается и ждет ответа сервера в фоновом режиме. Вы можете проверить статус ответа с помощью
     * GetHTTPResponseReady и, когда он будет готов, получить ответ с помощью GetHTTPResponse. Вы можете проверить ход
     * загрузки с помощью GetHTTPFileProgress. Не работает при экспорте в HTML5
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после
     *     доменной части URL-адреса.
     * @param string $szPostData Необработанные данные post для отправки на сервер обратите внимание, что & и =
     * @param string $szLocalFile Имя файла, который вы хотите отправить на сервер.
     * @return int
     */
    function SendHTTPFile($iHTTP, $szServerFile, $szPostData, $szLocalFile)
    {
    }

    /**
     * Стремится к заданному значению времени, если файл воспроизводится в данный момент, то он немедленно продолжит
     * воспроизведение оттуда. Если файл в данный момент не воспроизводится, то он вступит в силу после следующего
     * вызова PlayMusicOGG. Параметр mode позволяет выбрать, следует ли искать на основе абсолютного или относительного
     * значения времени. Абсолют будет стремиться к этой позиции в файле, в то время как относительный будет искать
     * относительно текущей позиции.
     *
     * @param int $musicID Идентификатор музыкального файла для поиска
     * @param float $seconds Время в секундах, чтобы стремиться к
     * @param int $mode 0 для абсолютного поиска, 1 для относительного поиска
     * @return void
     */
    function SeekMusicOGG($musicID, $seconds, $mode)
    {
    }

    /**
     * Ищет воспроизводимую в данный момент музыку в заданном количестве секунд, либо относительно текущей позиции,
     * либо в абсолютном положении. Например, если музыкальная дорожка имеет длину 60 секунд и в настоящее время
     * находится в положении 10 секунд (она воспроизводила 10 секунд музыки), поиск абсолютного значения 3 секунды
     * вернет ее обратно к 3 секундам после начала музыкальной дорожки. Используя относительное значение 3, вы добавите
     * 3 секунды к текущей позиции, взяв ее до 13.
     *
     * @param float $seconds Количество секунд для поиска.
     * @param int $mode 0 для использования абсолютного положения, 1 для использования относительного положения
     * @return void
     */
    function SeekMusic($seconds, $mode)
    {
    }

    /**
     * Преобразует координату Y экрана в мировую координату Y на основе текущего смещения и масштабирования вида. Когда
     * SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен
     * на 20 пикселей вниз, ввод при 0,0 на экране будет выглядеть 0,20 в мире.
     *
     * @param float $y Экран Y-координата для преобразования.
     * @return float
     */
    function ScreenToWorldY($y)
    {
    }

    /**
     * Преобразует координату X экрана в мировую координату X на основе текущего смещения и масштабирования вида. Когда
     * SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен
     * на 20 пикселей вправо, ввод при 0,0 на экране появится 20,0 в мире.
     *
     * @param float $x Экран X координата для преобразования.
     * @return float
     */
    function ScreenToWorldX($x)
    {
    }

    /**
     * Возвращает среднее значение кадров в секунду на основе времени рендеринга последних нескольких кадров. Чтобы
     * получить точное время, затраченное на последний кадр, вы можете вызвать GetFrameTime.
     *
     * @return float
     */
    function ScreenFPS()
    {
    }

    /**
     * Сохраняет звуковой файл в папку записи приложения.
     *
     * @param int $iID Идентификатор звука для сохранения.
     * @param string $sFilename Имя файла, которое будет использоваться для звукового файла, рекомендуется заканчивать
     *     на .wav.
     * @return void
     */
    function SaveSound($iID, $sFilename)
    {
    }

    /**
     * Сохраняет форму столкновения объектов в файл .bcs (Bullet Collision Shape). Возвращает true, если это удалось.
     *
     * @param int $objID идентификатор объекта
     * @param string $fileName имя файла в виде строки.
     * @return int
     */
    function SaveObjectShape($objID, $fileName)
    {
    }

    /**
     * Сохраняет переменную, чтобы к ней можно было получить доступ из других приложений. Это работает только на
     * платформах iOS, Android 10 и ниже, а также HTML5. Приложения могут совместно использовать переменную только в
     * том случае, если они отвечают определенным требованиям, основанным на платформе. В iOS приложения должны быть
     * созданы одной и той же учетной записью разработчика Apple и иметь одну и ту же группу приложений, добавленную к
     * их идентификаторам приложений на портале разработчиков Apple. После этого вам нужно будет заново создать профиль
     * подготовки. В iOS вы должны сообщить AGK, что такое группа приложений, используя SetSharedVariableAppGroup. На
     * Android 10 и ниже приложения должны иметь разрешение WRITE_EXTERNAL_STORAGE и иметь одно и то же имя пакета до
     * последней точки. Например, com.mycompany.mygroup.myapp1 и com.mycompany.mygroup.myapp2 смогут совместно
     * использовать переменные. На Android общие переменные записываются в доступное пользователю место, поэтому имейте
     * в виду, что пользователи могут читать и/или редактировать сохраненные вами переменные. На Android 11 или выше
     * эта команда не будет работать, так как приложения ограничены в записи в общие места. В HTML приложения должны
     * размещаться в одном домене, значения хранятся в виде файлов cookie. Переменные идентифицируются по имени,
     * поэтому использование SaveSharedVariable("username", "Alice") установит переменную с именем "username" в
     * значение "Alice". Затем это может быть прочитано другими приложениями с помощью LoadSharedVariable(
     * "username",""), Если два приложения сохраняют разные значения в одном и том же имени переменной, то значение
     * будет перезаписано и будет доступно только самое последнее значение. Значения переменных будут сохраняться даже
     * в том случае, если приложение будет удалено и повторно установлено. Вы не должны использовать эту команду для
     * хранения любой конфиденциальной информации, такой как пароли, в виде обычного текста. В iOS длина имени
     * переменной плюс длина идентификатора вашего приложения до последней точки (например, com.mycompany.mygroup)
     * должна быть меньше 58.
     *
     * @param string $varName Имя, используемое для идентификации этой переменной
     * @param string $varValue Значение, которое нужно сохранить в этой переменной
     * @return void
     */
    function SaveSharedVariable($varName, $varValue)
    {
    }

    /**
     * Еще не функционирует.
     *
     * @param int $objID Идентификатор объекта для сохранения.
     * @param string $szFilename Имя файла, которое будет использоваться для нового файла.
     * @return void
     */
    function SaveObject($objID, $szFilename)
    {
    }

    /**
     * Сохраняет изображение с заданным идентификатором в указанное имя файла. Файл будет помещен в папку записи
     * приложения в том месте, которое в данный момент указано SetFolder. Кроме того, вы можете указать путь,
     * начинающийся с прямой косой черты, чтобы выбрать местоположение из корня папки записи, игнорируя любую папку
     * SetFolder. Рекомендуется использовать расширение ".png" в конце имени файла для сохранения в формате PNG.
     * Некоторые платформы могут поддерживать дополнительные расширения, такие как ".jpg", но это не гарантирует работу
     * на всех платформах.
     *
     * @param int $iImageIndex Идентификатор изображения для изменения.
     * @param string $filename Имя файла сохраненного изображения
     * @return void
     */
    function SaveImage($iImageIndex, $filename)
    {
    }

    /**
     * Округляет поплавок до ближайшего целого числа (положительного или отрицательного).
     *
     * @param float $a Значение округлить.
     * @return int
     */
    function Round($a)
    {
    }

    /**
     * Вращает указанный объект вокруг своей локальной оси Z, то есть если бы объект был самолетом, эта команда
     * заставила бы его сделать бочкообразный крен независимо от того, в каком направлении он был обращен.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота по локальной оси Z в градусах, положительные крены против часовой стрелки,
     *     отрицательные крены по часовой стрелке.
     * @return void
     */
    function RotateObjectLocalZ($objID, $amount)
    {
    }

    /**
     * Запускает внешний исполняемый файл, который не зависит от этого приложения. Он вернет идентификатор, который вы
     * можете использовать, чтобы проверить, работает ли приложение по-прежнему или, в крайнем случае, завершить его
     * работу. Если это не удастся, он вернет 0. В настоящее время работает только на Windows, Mac, Linux и Raspberry
     * Pi.
     *
     * @param string $szFilename Имя файла нового приложения, доступ к которому осуществляется так же, как и к любому
     *     другому файлу в AGK
     * @param string $szParameters Необязательные параметры командной строки для передачи в приложение или пустая
     *     строка
     * @return int
     */
    function RunApp($szFilename, $szParameters)
    {
    }

    /**
     * Вращает указанный объект вокруг его локальной оси Y, то есть если бы объект был самолетом, эта команда заставила
     * бы его поворачиваться влево и вправо независимо от того, в каком направлении он находится.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота по локальной оси Y в градусах, положительный поворот вправо, отрицательный
     *     поворот влево.
     * @return void
     */
    function RotateObjectLocalY($objID, $amount)
    {
    }

    /**
     * Вращает указанный объект вокруг глобальной оси Z. Представьте себе, что камера смотрит вниз по оси Z на объект
     * со случайным вращением. Эта команда будет вращать объект влево и вправо относительно камеры независимо от того,
     * в какую сторону он обращен.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота по глобальной оси Z в градусах, положительные крены против часовой стрелки,
     *     отрицательные крены по часовой стрелке.
     * @return void
     */
    function RotateObjectGlobalZ($objID, $amount)
    {
    }

    /**
     * Вращает указанный объект вокруг его локальной оси X, то есть, если бы объект был самолетом, эта команда
     * заставила бы его наклоняться вверх и вниз независимо от того, в каком направлении он обращен.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота по локальной оси X в градусах, положительный смотрит вниз, отрицательный
     *     смотрит вверх.
     * @return void
     */
    function RotateObjectLocalX($objID, $amount)
    {
    }

    /**
     * Вращает указанный объект вокруг глобальной оси Y. Представьте себе, что камера смотрит вниз по оси Z на объект
     * со случайным вращением. Эта команда повернет объект влево и вправо относительно камеры независимо от того, в
     * какую сторону он обращен.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота по глобальной оси Y в градусах, положительный поворот вправо, отрицательный
     *     поворот влево.
     * @return void
     */
    function RotateObjectGlobalY($objID, $amount)
    {
    }

    /**
     * Вращает указанный объект вокруг глобальной оси X. Представьте себе, что камера смотрит вниз по оси Z на объект
     * со случайным вращением. Эта команда будет наклонять объект вверх и вниз относительно камеры независимо от того,
     * в какую сторону он обращен.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота на глобальной оси X в градусах, положительный шаг вниз, отрицательный шаг
     *     вверх.
     * @return void
     */
    function RotateObjectGlobalX($objID, $amount)
    {
    }

    /**
     * Катит указанную кость вокруг своей локальной оси Z, то есть если бы кость была самолетом, эта команда заставила
     * бы ее сделать бочкообразный крен независимо от того, в каком направлении она обращена.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param float $amount Угол поворота по локальной оси Z в градусах, положительные крены против часовой стрелки,
     *     отрицательные крены по часовой стрелке.
     * @return void
     */
    function RotateObjectBoneLocalZ($objID, $boneIndex, $amount)
    {
    }

    /**
     * Вращает указанную кость вокруг ее локальной оси X, то есть, если бы кость была самолетом, эта команда заставила
     * бы ее наклоняться вверх и вниз независимо от того, в каком направлении она обращена.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param float $amount Угол поворота по локальной оси X в градусах, положительный смотрит вниз, отрицательный
     *     смотрит вверх.
     * @return void
     */
    function RotateObjectBoneLocalX($objID, $boneIndex, $amount)
    {
    }

    /**
     * Вращает указанную кость вокруг ее локальной оси Y, то есть, если бы кость была самолетом, эта команда заставила
     * бы ее поворачиваться влево и вправо независимо от того, в каком направлении она обращена.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param float $amount Угол поворота по локальной оси Y в градусах, положительный поворот вправо, отрицательный
     *     поворот влево.
     * @return void
     */
    function RotateObjectBoneLocalY($objID, $boneIndex, $amount)
    {
    }

    /**
     * Вращает указанную камеру вокруг своей локальной оси Z, то есть если бы камера была самолетом, эта команда
     * заставила бы ее катиться влево и вправо независимо от того, в каком направлении она была обращена.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота по локальной оси Z в градусах, отрицательный-по часовой стрелке.
     * @return void
     */
    function RotateCameraLocalZ($cameraID, $amount)
    {
    }

    /**
     * Вращает указанную камеру вокруг своей локальной оси Y, то есть если бы камера была самолетом, эта команда
     * заставила бы ее поворачиваться влево и вправо независимо от того, в каком направлении она обращена.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота по локальной оси Y в градусах, положительный поворот вправо, отрицательный
     *     поворот влево.
     * @return void
     */
    function RotateCameraLocalY($cameraID, $amount)
    {
    }

    /**
     * Вращает указанную камеру вокруг своей локальной оси X, то есть если бы камера была самолетом, эта команда
     * заставила бы ее наклоняться вверх и вниз независимо от того, в каком направлении она обращена.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота по локальной оси X в градусах, положительный смотрит вниз, отрицательный
     *     смотрит вверх.
     * @return void
     */
    function RotateCameraLocalX($cameraID, $amount)
    {
    }

    /**
     * Вращает указанную камеру вокруг глобальной оси Z. Представьте себе, что вы смотрите на камеру, как если бы это
     * был объект, расположенный на 0,0,0 и смотрящий в случайном направлении. Эта команда будет вращать его вокруг
     * фиксированной оси Z, которая используется для определения положения всего в мире.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота на глобальной оси Z в градусах, отрицательный-по часовой стрелке.
     * @return void
     */
    function RotateCameraGlobalZ($cameraID, $amount)
    {
    }

    /**
     * Вращает указанную камеру вокруг глобальной оси Y. Представьте себе, что вы смотрите на камеру, как если бы это
     * был объект, расположенный на 0,0,0 и смотрящий в случайном направлении. Эта команда повернет его вокруг
     * неподвижной оси Y, той, которая используется для определения положения всего в мире.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота по глобальной оси Y в градусах, положительный поворот вправо, отрицательный
     *     поворот влево.
     * @return void
     */
    function RotateCameraGlobalY($cameraID, $amount)
    {
    }

    /**
     * Вращает указанную камеру вокруг глобальной оси X. Представьте себе, что вы смотрите на камеру, как если бы это
     * был объект, расположенный на 0,0,0 и смотрящий в случайном направлении. Эта команда будет вращать его вокруг
     * фиксированной оси X, которая используется для определения положения всего в мире.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота на глобальной оси X в градусах, положительный шаг вниз, отрицательный шаг
     *     вверх.
     * @return void
     */
    function RotateCameraGlobalX($cameraID, $amount)
    {
    }

    /**
     * Вращает контроллер.
     *
     * @param int $objID идентификатор объекта
     * @param float $angle количество в градусах
     * @return void
     */
    function Rotate3DPhysicsCharacterController($objID, $angle)
    {
    }

    /**
     * Обрезает заданную строку, сохраняя наибольшее количество символов справа до заданного значения счетчика.
     *
     * @param string $strin Строка, которую нужно обрезать
     * @param int $count Количество символов, которые нужно сохранить
     * @return string
     */
    function Right($strin, $count)
    {
    }

    /**
     * Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenText. Если анимация уже
     * возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @param int $textID ИДЕНТИФИКАТОР текста для возобновления
     * @return void
     */
    function ResumeTweenText($tweenID, $textID)
    {
    }

    /**
     * Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenSprite. Если анимация
     * уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @param int $spriteID Идентификатор спрайта для возобновления
     * @return void
     */
    function ResumeTweenSprite($tweenID, $spriteID)
    {
    }

    /**
     * Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenCustom. Если анимация
     * уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @return void
     */
    function ResumeTweenCustom($tweenID)
    {
    }

    /**
     * Возобновляет заданный интервал с того момента, когда он был приостановлен с помощью PauseTweenChar. Если
     * анимация уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @param int $textID ИДЕНТИФИКАТОР текста для возобновления
     * @param int $charID Индекс персонажа для возобновления
     * @return void
     */
    function ResumeTweenChar($tweenID, $textID, $charID)
    {
    }

    /**
     * Возобновляет заданную анимацию с того момента, когда она была приостановлена с помощью PauseTweenObject. Если
     * анимация уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @param int $objectID ИДЕНТИФИКАТОР объекта для возобновления
     * @return void
     */
    function ResumeTweenObject($tweenID, $objectID)
    {
    }

    /**
     * Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenCamera. Если анимация
     * уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @param int $cameraID Идентификатор камеры для возобновления работы
     * @return void
     */
    function ResumeTweenCamera($tweenID, $cameraID)
    {
    }

    /**
     * Возобновляет воспроизведение музыкального файла, если он был приостановлен.
     *
     * @param int $musicID Идентификатор музыкального файла для приостановки
     * @return void
     */
    function ResumeMusicOGG($musicID)
    {
    }

    /**
     * Продолжает анимацию спрайта, используя значения, используемые для его настройки. Продолжается с текущего кадра,
     * а не начинается снова с первого кадра.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для возобновления анимации.
     * @return void
     */
    function ResumeSprite($iSpriteIndex)
    {
    }

    /**
     * Возобновляет прерванную музыку с того места, где она остановилась.
     *
     * @return void
     */
    function ResumeMusic()
    {
    }

    /**
     * Восстанавливает приложение из свернутого состояния в нормальное окно.
     *
     * @return void
     */
    function RestoreApp()
    {
    }

    /**
     * Изменяет размер изображения на новую ширину и высоту. Если изображение является изображением атласа, то его
     * subimages.txt значения также будут изменены таким образом, чтобы LoadSubImage все еще работал. Обратите
     * внимание, что если вы ранее использовали LoadSubImage на этом изображении, то изменение его размера приведет к
     * неправильному отображению этих субизображений. Эта команда не будет работать с самими субизображениями.
     *
     * @param int $imageID Идентификатор изображения для изменения размера
     * @param int $width Новая ширина изображения
     * @param int $height Новая высота изображения
     * @return void
     */
    function ResizeImage($imageID, $width, $height)
    {
    }

    /**
     * Эта команда восстанавливает нормальную функциональность UV-координат после вызова SetSpriteUV.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @return void
     */
    function ResetSpriteUV($iSpriteIndex)
    {
    }

    /**
     * Сбрасывает время, возвращенное таймером, на 0. Это позволяет восстановить полную точность после того, как ваше
     * приложение работает в течение некоторого времени. Это также сбрасывает значения, возвращаемые getSeconds и
     * GetMilliseconds, на 0.
     *
     * @return void
     */
    function ResetTimer()
    {
    }

    /**
     * Устанавливает значение вознаграждения AdMob равным 0. Вы можете использовать это после обнаружения события
     * вознаграждения и действовать так, чтобы не вознаграждать пользователя более одного раза.
     *
     * @return void
     */
    function ResetRewardAdMob()
    {
    }

    /**
     * Устанавливает значение вознаграждения Chartboost равным 0. Вы можете использовать это после обнаружения события
     * вознаграждения и действовать так, чтобы не вознаграждать пользователя более одного раза.
     *
     * @return void
     */
    function ResetRewardChartboost()
    {
    }

    /**
     * Сбрасывает количество испускаемых частиц, когда излучатель был установлен с максимальным количеством частиц с
     * помощью SetParticlesMax. Вы можете проверить, когда излучатель достиг своего максимального количества, используя
     * GetParticlesMaxReached. Если максимум установлен на -1, то эта команда не имеет никакого эффекта.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function ResetParticleCount($ID)
    {
    }

    /**
     * Останавливает любую воспроизводимую анимацию и сбрасывает кости объекта в их положение привязки.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @return void
     */
    function ResetObjectAnimation($objID)
    {
    }

    /**
     * Это удаляет физический мир и все формы, твердые тела, суставы, совместные двигатели, тряпичные куклы и
     * контроллеры персонажей. Затем воссоздается пустой физический мир с масштабом и гравитацией по умолчанию. Затем
     * вам нужно будет воссоздать все формы, твердые тела, суставы, совместные двигатели, тряпичные куклы и контроллеры
     * персонажей, которые вам нужны.
     *
     * @return void
     */
    function Reset3DPhysicsWorld()
    {
    }

    /**
     * Сбрасывает количество испускаемых частиц, когда излучатель был установлен с максимальным количеством частиц с
     * помощью Set3DParticlesMax. Вы можете проверить, когда излучатель достиг своего максимального количества,
     * используя Get3DParticlesMaxReached. Если максимум установлен на -1, то эта команда не имеет никакого эффекта.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function Reset3DParticleCount($ID)
    {
    }

    /**
     * Только для Android все остальные платформы ничего не сделают. Генерирует системный диалог с запросом у
     * пользователя указанного разрешения устройства, используемого определенными командами Android. Разрешения
     * следующие: "writeExternal" - используется командами SaveSharedVariable и любыми путями "raw:", которые
     * обращаются к SD-карте. "Местоположение" - используется командами GPS "Камера" - используется командой
     * SetDeviceCameraToImage и для канала AR - камеры "RecordAudio" - используется командой StartScreenRecording Вы
     * можете проверить результат запроса, вызвав checkPermission. После первого запроса Android предоставит
     * пользователю возможность прекратить отображение диалогового окна запроса. В этом случае эта команда больше не
     * будет генерировать диалоговое окно запроса и вместо этого ничего не будет делать. Пользователю придется зайти в
     * настройки приложения устройства, чтобы отменить это решение. Любое разрешение, не указанное здесь, не требует от
     * вас запроса разрешения пользователя, оно будет автоматически предоставлено при установке, если ваше приложение
     * этого требует. Все разрешения, которые использует ваше приложение, даже те, которые требуют запроса, должны быть
     * указаны в диалоговом окне экспорта APK, установив соответствующие флажки.
     *
     * @param string $szPermission Разрешение на запрос
     * @return void
     */
    function RequestPermission($szPermission)
    {
    }

    /**
     * Отображает всплывающее диалоговое окно с запросом согласия пользователя на показ персонализированной рекламы.
     * Ответ пользователя будет автоматически использован для изменения настроек AdMob таким образом, чтобы реклама
     * отображалась в соответствии с предпочтениями пользователя. Статус согласия также будет сохранен на сервере
     * AdMob, чтобы будущий вызов LoadConsentStatusAdMob мог получить это значение. Вы можете вызвать эту команду в
     * любое время в вашем приложении, чтобы пользователь мог изменить свои предпочтения, пользователь должен иметь
     * возможность сделать это где-то внутри вашего приложения.  Это согласие не распространяется на Chartboost или
     * Amazon, оно запрашивает только согласие на показ персонализированной рекламы от AdMob. Вам понадобится свой
     * собственный метод запроса согласия для Chartboost и Amazon.
     *
     * @return void
     */
    function RequestConsentAdMob()
    {
    }

    /**
     * iOS 10.3 имеет специальную функцию, которая позволит пользователю просматривать ваше приложение изнутри самого
     * приложения, эта команда подскажет iOS начать этот процесс. Обратите внимание, что iOS не гарантирует отображение
     * чего-либо при вызове этой команды, и она не должна вызываться в ответ на нажатие кнопки или другое
     * взаимодействие пользователя. Вы должны вызвать его, когда в приложении наступает затишье, например в конце
     * уровня. Если вы хотите запустить процесс проверки в ответ на действие пользователя, например нажатие кнопки, то
     * вам следует использовать команду OpenBrowser для открытия AppStore.
     *
     * @return void
     */
    function RequestAppReview()
    {
    }

    /**
     * Вызовите эту команду, чтобы запросить новое объявление. Обычно реклама предоставляется автоматически. Вы можете
     * сделать это только при переключении на новые экраны в вашем приложении
     *
     * @return void
     */
    function RequestAdvertRefresh()
    {
    }

    /**
     * Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает
     * Render2DBack, RenderShadowMap, Render3D, Render2DFront, чтобы нарисовать все в мире. Эта команда вычисляет
     * только карту теней.
     *
     * @return void
     */
    function RenderShadowMap()
    {
    }

    /**
     * Возвращает строку со всеми экземплярами "find", замененными на "replace". Вы можете использовать параметр qty
     * для ограничения количества сделанных замен или использовать -1 для ограничения без ограничений. Исходная строка
     * не изменяется, и возвращается новая строка с заменами в ней. Обратите внимание, что если вы вызываете эту
     * команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы закончите с ней.
     *
     * @param string $str Строка для изменения
     * @param string $find Строка, которую нужно найти
     * @param string $replace Строка, чтобы заменить его на
     * @param int $qty Максимальное количество замен, которые нужно сделать, используйте минус 1 без ограничений
     * @return string
     */
    function ReplaceString($str, $find, $replace, $qty)
    {
    }

    /**
     * Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает
     * Render2DBack, ClearDepthBuffer, Render3D, ClearDepthBuffer, Render2DFront, чтобы нарисовать все в мире. Эта
     * команда рисует только 2D-спрайты и текст, которые находятся перед 3D.
     *
     * @return void
     */
    function Render2DFront()
    {
    }

    /**
     * Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает
     * Render2DBack, RenderShadowMap, Render3D, Render2DFront, чтобы нарисовать все в мире. Эта команда рисует только
     * 3D-объекты.
     *
     * @return void
     */
    function Render3D()
    {
    }

    /**
     * Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает
     * Render2DBack, ClearDepthBuffer, Render3D, ClearDepthBuffer, Render2DFront, чтобы нарисовать все в мире. Эта
     * команда рисует только 2D-спрайты и текст, которые находятся за 3D.
     *
     * @return void
     */
    function Render2DBack()
    {
    }

    /**
     * Рисует все 2D и 3D, созданные с использованием идентификационного номера, в текущий буфер кадров. Он не
     * переключает backbuffer на экран. Он не рисует спрайты или объекты, созданные вами с помощью указателей, вам
     * придется либо рисовать их по отдельности, либо назначать их менеджеру спрайтов для пакетного рисования. В этом
     * случае Рендеринг все равно должен быть вызван, так как он также рисует печатный текст. Вызываемый автоматически
     * Sync, вы можете использовать Sync или Update(), Render(), Swap() для ручной синхронизации. Если вы хотите иметь
     * больше контроля, вы можете разбить это дальше и заменить Рендеринг на Render2DBack, ClearDepthBuffer, Render3D,
     * ClearDepthBuffer, Render2DFront
     *
     * @return void
     */
    function Render()
    {
    }

    /**
     * Удаляет заголовок, который вы ранее добавили, если вы не использовали AddHTTPHeader для добавления заголовка с
     * заданным именем, то эта команда ничего не делает. Если имя заголовка является стандартным заголовком, который
     * обычно включается, то эта команда не удаляет его, а вместо этого использует AddHTTPHeader с пустой строкой,
     * чтобы перезаписать его. Если имя заголовка является стандартным заголовком, который вы перезаписали, то эта
     * команда возвращает его к нормальному значению. Обратите внимание, что эта команда не работает в версии HTML5.
     *
     * @param int $iHTTP Идентификатор соединения для изменения.
     * @param string $headerName Имя заголовка для удаления
     * @return void
     */
    function RemoveHTTPHeader($iHTTP, $headerName)
    {
    }

    /**
     * Еще не функционирует.
     *
     * @param string $szFilename Файл для сохранения звука.
     * @return void
     */
    function RecordSound($szFilename)
    {
    }

    /**
     * Получает сообщение в очереди из приложения watch. Это будет в виде строки JSON. Если вы вызываете эту команду из
     * уровня 2, вы должны удалить возвращенную строку, когда закончите с ней, вызвав agk::DeleteString.  В настоящее
     * время работает только на iOS.
     *
     * @return string
     */
    function ReceiveSmartWatchData()
    {
    }

    /**
     * Считывает строку из данного файла, который должен быть открыт для чтения. Обратите внимание, что это может
     * читать только строки в двоичной форме, такие как те, которые написаны с помощью WriteString2, если вы пытаетесь
     * прочитать строки, разделенные новыми строками, то вместо этого используйте ReadLine. Если вы используете эту
     * команду на уровне 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней.
     * Это использует другой метод от ReadString, который немного быстрее, но эта команда может читать только строки,
     * написанные с помощью WriteString2
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return string
     */
    function ReadString2($iFileID)
    {
    }

    /**
     * Считывает строку с нулевым завершением из данного файла, который должен быть открыт для чтения. Обратите
     * внимание, что это может читать только строки в двоичной форме, такие как те, которые написаны с помощью
     * WriteString, если вы пытаетесь прочитать строки, разделенные новыми строками, то вместо этого используйте
     * ReadLine. Если вы используете эту команду на уровне 2, вы должны удалить возвращенную строку с помощью
     * agk::DeleteString, когда закончите с ней.
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return string
     */
    function ReadString($iFileID)
    {
    }

    /**
     * Считывает новую строку, завершенную строкой из данного файла, который должен быть открыт для чтения. Если вы
     * используете эту команду на уровне 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда
     * закончите с ней.
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return string
     */
    function ReadLine($iFileID)
    {
    }

    /**
     * Считывает 4-байтовое целое число из данного файла, который должен быть открыт для чтения.
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return int
     */
    function ReadInteger($iFileID)
    {
    }

    /**
     * Считывает 1-байтовое целое число без знака (0-255) из данного файла, который должен быть открыт для чтения.
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return int
     */
    function ReadByte($iFileID)
    {
    }

    /**
     * Считывает 4-байтовый поплавок из данного файла, который должен быть открыт для чтения.
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return float
     */
    function ReadFloat($iFileID)
    {
    }

    /**
     * Бросьте луч и проверьте объект.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $rayID Идентификатор луча
     * @param int $fromVec3ID Идентификатор вектора начальной точки. Создайте вектор с помощью команды CreateVector3 ().
     * @param int $toVec3ID Идентификатор вектора назначения
     * @param int $allOrClosest 1 = все контакты, 0 = ближайший контакт
     * @return int
     */
    function RayCast3DPhysicsObject($objID, $rayID, $fromVec3ID, $toVec3ID, $allOrClosest)
    {
    }

    /**
     * Бросьте луч
     *
     * @param int $rayID Идентификатор луча
     * @param int $fromVec3ID Идентификатор вектора начальной точки. Создайте вектор с помощью команды CreateVector3 ().
     * @param int $toVec3ID Идентификатор вектора назначения
     * @param int $allOrClosest 1 = все контакты, 0 = ближайший контакт
     * @return void
     */
    function RayCast3DPhysics($rayID, $fromVec3ID, $toVec3ID, $allOrClosest)
    {
    }

    /**
     * Верните 1, если луч существует. Возвращает 0, если это не так.
     *
     * @param int $rayID Идентификатор луча
     * @return int
     */
    function Ray3DPhysicsExist($rayID)
    {
    }

    /**
     * Отображает диалоговое окно с запросом пользователя оценить приложение в App Store. В настоящее время эта команда
     * поддерживается только на iOS.
     *
     * @param string $szID Это идентификатор вашего приложения. Вы можете получить его в iTunes Connect.
     * @param string|null $szTitle Строка, используемая в качестве заголовка диалогового окна, обычно это "Rate AppName"
     * @param string|null $szMessage Строка, используемая в качестве сообщения диалогового окна
     * @return void
     */
    function RateApp(string $szID, string $szTitle = null, string $szMessage = null)
    {
    }


    /**
     * Генерирует случайное число на основе текущего начального значения. Генератор случайных чисел встроен в AGK,
     * поэтому определенное начальное значение будет производить одну и ту же последовательность чисел на каждой
     * платформе. Производит случайное число между -2,147,483,648 и 2,147,483,647. Этот генератор работает медленнее,
     * чем Случайный, но производит более качественную случайность в большем диапазоне значений.
     *
     * Пример вызова:
     *
     * int Random2();
     *
     * int Random2($from, $to);
     * @param int|null $from Самое низкое значение для возврата
     * @param int|null $to Самое высокое значение для возврата
     * @return int
     */
    function Random2(int $from = null, int $to = null): int
    {
    }

    /**
     * Будет случайным образом отрицать данное значение и возвращать его. Имеет 50-50 шансов на отрицание ценности.
     * Начальное значение может быть отрицательным, и в этом случае оно случайно станет положительным.
     *
     * @param int $value Значение, которое нужно изменить.
     * @return int
     */
    function RandomSign($value)
    {
    }

    /**
     * Генерирует случайное число на основе текущего начального значения. Генератор случайных чисел встроен в AGK,
     * поэтому определенное начальное значение будет производить одну и ту же последовательность чисел на каждой
     * платформе. Производит случайное число от 0 до 65535
     *
     * пример вызова:
     *
     * int Random();
     *
     * int Random($from, $to);
     * @param int|null $from Самое низкое значение для возврата
     * @param int|null $to Самое высокое значение для возврата
     * @return int
     */
    function Random(int $from = null, int $to = null): int
    {
    }

    /**
     * Возвращает 1, если настройка прошла успешно, 0, если она не удалась или устройство не поддерживает
     * push-уведомления.
     *
     * @return int
     */
    function PushNotificationSetup()
    {
    }

    /**
     * Печать изображения на подключенном принтере. Эта команда не гарантированно работает на всех платформах. Параметр
     * size определяет размер изображения на странице, значение 100 позволяет использовать как можно большую часть
     * страницы, 50-половину этой суммы, 25-четверть и так далее.
     *
     * @param int $image идентификатор изображения для печати
     * @param float $size объем пространства, используемого на странице, находится в диапазоне от 0 до 100.
     * @return void
     */
    function PrintImage($image, $size)
    {
    }

    /**
     * Выводит заданное значение или строку на экран, но не добавляет новый символ строки в конец. Следующая команда
     * Print или PrintC будет следовать непосредственно из этой.
     *
     * @param mixed $szString Значание или строка для печати
     * @return void
     */
    function PrintC(mixed $szString)
    {
    }

    /**
     * Выводит заданное значение или строку на экран и добавляет новый символ строки, чтобы следующая команда печати
     * была на одну строку ниже.
     *
     * @param mixed $szString Значание или строка для печати.
     * @return void
     */
    function Print(mixed $szString)
    {
    }

    /**
     * Возвращает a, возведенное в степень b.
     *
     * @param float $a База.
     * @param float $b Сила.
     * @return float
     */
    function Pow(float $a, float $b): float
    {
    }

    /**
     * Воспроизводит указанное видео Youtube в отдельном окне над вашим приложением. Для Android вы должны включить
     * Youtube Data API v3 в Google Cloud Console для вашего приложения и создать для него ключ API в разделе учетные
     * данные. Вы можете создать ключ специально для использования с API Youtube или использовать неограниченный ключ,
     * который может использоваться несколькими API. Видеоид-это строка, которая следует за ?v= часть URL-адреса
     * Youtube, например "eLIgxYHCgWA". Вы также можете указать время начала воспроизведения видео с середины, а не с
     * самого начала. Время указывается в секундах и принимает десятичные значения для представления долей секунды.  В
     * Windows, Mac и Linux эта команда откроет браузер по умолчанию для воспроизведения видео Youtube. Поле ключа
     * разработчика требуется только для Android.
     *
     * @param string $developerKey Учетные данные ключа API, созданные в облачной консоли Google для API данных Youtube
     *     v3.
     * @param string $videoID Идентификатор видео, например eLIgxYHCgWA
     * @param float $startTime Время поиска в секундах, с которого начинается воспроизведение видео
     * @return void
     */
    function PlayYoutubeVideo($developerKey, $videoID, $startTime)
    {
    }

    /**
     * Воспроизведение видео или возобновление его после паузы. Воспроизведение видео на изображение, а не на экран,
     * изображение не должно уже существовать. Изображение будет удалено при вызове DeleteVideo, вы не должны удалять
     * его вручную. Вы можете использовать либо эту команду, либо playVideo, но не оба. Если вы приостановите видео, вы
     * должны возобновить его с помощью той же команды, что и при запуске, с теми же параметрами. В настоящее время это
     * поддерживается только на iOS 7.0 или выше, Android 4.0.3 или выше и Windows.
     *
     * @param int $imageID Идентификатор, используемый для ссылки на новое изображение, не должен уже существовать
     * @return void
     */
    function PlayVideoToImage($imageID)
    {
    }

    /**
     * Воспроизводит видео на экране или возобновляет его после паузы. Вы можете использовать либо эту команду, либо
     * PlayVideoToImage, но не оба. Если вы ставите видео на паузу, вы должны возобновить его с помощью той же команды,
     * что и при запуске.
     *
     * @return void
     */
    function PlayVideo()
    {
    }

    /**
     * Применяет данный идентификатор анимации к заданному текстовому идентификатору с необязательной задержкой и
     * начинает его воспроизведение. Анимация может воспроизводиться на нескольких текстовых объектах одновременно,
     * просто вызовите эту команду еще раз с другим текстовым идентификатором. Текст не будет изменен до тех пор, пока
     * не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным
     * значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения
     * анимации на текстовом объекте, текст будет соответствующим образом корректировать свою интерполяцию. Изменение
     * продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param int $textID Идентификатор изменяемого текстового объекта
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenText($tweenID, $textID, $delay)
    {
    }

    /**
     * Применяет заданный идентификатор анимации к заданному идентификатору спрайта с необязательной задержкой и
     * начинает его воспроизведение. Анимация может воспроизводиться на нескольких спрайтах одновременно, просто
     * вызовите эту команду снова с другим идентификатором спрайта. Спрайт не будет изменен до тех пор, пока не пройдет
     * время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в
     * течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения
     * анимации на спрайте, то спрайт соответствующим образом скорректирует свою интерполяцию. Изменение
     * продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param int $spriteID Идентификатор изменяемого спрайта
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenSprite($tweenID, $spriteID, $delay)
    {
    }

    /**
     * Применяет заданный идентификатор анимации к заданному идентификатору объекта с необязательной задержкой и
     * начинает его воспроизведение. Анимация может воспроизводиться на нескольких объектах одновременно, просто
     * вызовите эту команду снова с другим идентификатором объекта. Объект не будет изменен до тех пор, пока не пройдет
     * время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в
     * течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на
     * объекте, то объект соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время
     * игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param int $objectID ИДЕНТИФИКАТОР объекта для изменения
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenObject($tweenID, $objectID, $delay)
    {
    }

    /**
     * Применяет заданный идентификатор анимации к заданному символу в текстовом объекте с необязательной задержкой и
     * начинает его воспроизведение. Анимация может воспроизводиться на нескольких символах в нескольких текстовых
     * объектах одновременно, просто вызовите эту команду снова с другим идентификатором текста или символа. Символ не
     * будет изменен до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и
     * будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется
     * во время воспроизведения анимации на символе, то символ соответствующим образом настраивает свою интерполяцию.
     * Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param int $textID Идентификатор изменяемого текстового объекта
     * @param int $charID Индекс символа, индексы начинаются с 0, если он выходит за пределы диапазона, то будет
     *     проигнорирован
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenChar($tweenID, $textID, $charID, $delay)
    {
    }

    /**
     * Воспроизводит заданный пользовательский идентификатор анимации с дополнительной задержкой и начинает его
     * воспроизведение. В отличие от других подростков, это не применяется к какому-либо конкретному элементу или
     * объекту и не может иметь несколько копий, работающих одновременно, вам придется создать отдельный
     * пользовательский твин для каждой копии, которую вы хотите запустить одновременно. Значения анимации не будут
     * изменены до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет
     * двигаться к конечным значениям в течение длительности анимации. Если конечное значение tween изменяется во время
     * воспроизведения tween, то tween соответствующим образом скорректирует свою интерполяцию. Изменение
     * продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenCustom($tweenID, $delay)
    {
    }

    /**
     * Применяет заданный идентификатор анимации к заданному идентификатору камеры с дополнительной задержкой и
     * начинает его воспроизведение. Анимация может воспроизводиться на нескольких камерах одновременно, просто
     * вызовите эту команду еще раз с другим идентификатором камеры. Камера не будет изменена до тех пор, пока не
     * пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям
     * в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения
     * анимации на камере, камера соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во
     * время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param int $cameraID Идентификатор камеры для изменения
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenCamera($tweenID, $cameraID, $delay)
    {
    }

    /**
     * Начинает воспроизведение данной цепочки с самого начала или возобновляет ее, если она была приостановлена.
     *
     * @param int $chainID Идентификатор цепочки для изменения
     * @return void
     */
    function PlayTweenChain($chainID)
    {
    }

    /**
     * Начинается анимация спрайта на основе заданных значений. Скорость анимации основана на кадрах анимации в секунду
     * и не зависит от частоты кадров рисования.
     *
     * Пример вызова:
     *
     * void PlaySprite($iSpriteIndex);
     * void PlaySprite($iSpriteIndex, $fFps);
     * void PlaySprite($iSpriteIndex, $fFps, $iLoop);
     *
     * @param int $iSpriteIndex Идентификатор анимируемого спрайта.
     * @param float|null $fFps Кадров в секунду. Количество кадров, которые спрайт должен пытаться циклически проходить
     *     каждую секунду (необязательно, по умолчанию 10).
     * @param int|null $iLoop Режим зацикливания спрайта, 0 равно не зацикливаться, 1 равно зацикливаться навсегда
     *     (необязательно, по умолчанию 1).
     * @return void
     */
    function PlaySprite(int $iSpriteIndex, float $fFps = null, int $iLoop = null)
    {
    }

    /**
     * Воспроизведение звука, ранее загруженного в указанный звуковой номер. Эта команда может быть вызвана несколько
     * раз для одного и того же идентификатора звука, и она запустит несколько копий этого звука, воспроизводимых в
     * качестве экземпляров. Команда вернет идентификатор экземпляра, который можно использовать для взаимодействия с
     * этим экземпляром во время его воспроизведения. Когда экземпляр перестает воспроизводиться, он автоматически
     * удаляется и больше не может быть использован. По умолчанию звук не зацикливается.
     * Пример вызова:
     *
     * int PlaySound($iID);
     *
     * int PlaySound($iID, $iVol);
     *
     * int PlaySound($iID, $iVol, $iLoop);
     *
     * int PlaySound(int $iID, int $iVol = null, int $iLoop = null, int $iPriority = null);
     *
     * @param int $iID Звуковой номер для воспроизведения.
     * @param int|null $iVol Громкость, на которой должен воспроизводиться звук (необязательно, по умолчанию 100).
     * @param int|null $iLoop Количество раз, чтобы зациклить экземпляр, или 1 навсегда.
     * @param int|null $iPriority Зарезервировано для будущего использования, должно быть 0 (необязательно, по умолчанию 0).
     * @return int
     */
    function PlaySound(int $iID, int $iVol = null, int $iLoop = null, int $iPriority = null): int
    {
    }


    /**
     * Воспроизводит данную анимацию по имени, если она существует с необязательным временем начала (По умолчанию 0),
     * необязательным циклом и необязательным временем анимации (по умолчанию 0). Время анимации будет плавно
     * интерполировать скелет из его текущего состояния в первый кадр указанной анимации, прежде чем он начнет
     * анимацию, так что резкого перехода не будет. Значение цикла 1 будет петлять вечно, значение цикла больше 1 будет
     * петлять столько раз, а затем остановится, а значение цикла 0 будет воспроизводить анимацию один раз, а затем
     * остановится
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param string $anim Название анимации для воспроизведения
     * @param float $starttime Необязательное смещение в анимацию для пропуска некоторых кадров
     * @param int $loop 1, чтобы зациклить анимацию до тех пор, пока она не остановится, 0, чтобы воспроизвести ее один
     *     раз, больше 1, чтобы зациклить столько раз
     * @param float $tweentime Количество секунд для перехода из текущего состояния перед анимацией
     * @return void
     */
    function PlaySkeleton2DAnimation($iSkeleton, $anim, $starttime, $loop, $tweentime)
    {
    }

    /**
     * Воспроизводит заданную анимацию на своем родительском объекте. Только объекты, загруженные с помощью
     * LoadObjectWithChildren, будут иметь назначенные им анимации. Имена анимаций определяются программой
     * моделирования при создании анимаций вы можете узнать, что это за имена, используя GetObjectAnimationName.
     * Анимация может быть запущена и закончена в любой момент анимации с использованием параметров start и end, они
     * задаются в секундах, и если цикл включен, то объект вернется к заданному времени начала в начале каждого цикла.
     * Если вы хотите, чтобы петля была бесшовной, то положение костей в начале и в конце должно быть точно таким же,
     * так как при петле между ними не будет интерполяции. Параметр tweentime можно использовать для интерполяции между
     * текущими позициями костей и временем начала анимации, чтобы не было резкого скачка в позициях костей. Это
     * твининг происходит только один раз, он не происходит каждый цикл и не вносит свой вклад во время анимации. По
     * сути, анимация приостанавливается до тех пор, пока твининг не закончит. Обратите внимание, что как только эта
     * команда будет вызвана, кости будут управляться анимацией и не могут быть перемещены с помощью
     * SetObjectBonePosition или аналогичных команд. Вы можете восстановить ручное управление отдельными костями,
     * используя SetObjectBoneCanAnimate на нем. Вы можете восстановить контроль над всей костной структурой с помощью
     * ResetObjectAnimation.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param string $animName Название воспроизводимой анимации, определяемое программой моделирования
     * @param float $starttime Точка в анимации, в которой объект должен начать воспроизведение, в секундах
     * @param float $endtime Точка в анимации, в которой объект должен прекратить воспроизведение, минус 1, чтобы
     *     продолжить до конца
     * @param int $loop 1, чтобы зациклить анимацию навсегда, 0, чтобы воспроизвести один раз, любое другое
     *     положительное целое число, чтобы зациклить столько раз
     * @param float $tweentime Время в секундах для перехода от текущего состояния объектов к первому кадру анимации
     * @return void
     */
    function PlayObjectAnimation($objID, $animName, $starttime, $endtime, $loop, $tweentime)
    {
    }

    /**
     * Воспроизведение музыкального файла. Несколько музыкальных файлов OGG могут воспроизводиться одновременно.
     *
     * @param int $musicID Идентификатор музыкального файла для воспроизведения
     * @param int|null $iLoop Количество раз, чтобы зациклиться, или 1, чтобы зациклиться навсегда
     * @return void
     */
    function PlayMusicOGG(int $musicID, int $iLoop = null)
    {
    }

    /**
     * Воспроизводит только данный музыкальный файл и при желании зацикливает его. Это изменение по сравнению с
     * предыдущими версиями, где AGK продолжал бы воспроизводить следующий музыкальный трек после этого. Теперь вы
     * должны использовать дополнительные параметры PlayMusic для воспроизведения треков один за другим. В любой момент
     * времени может воспроизводиться только один музыкальный файл.
     *
     * Пример вызова:
     *
     * void PlayMusic();
     *
     * void PlayMusic($iID);
     *
     * void PlayMusic($iID, $bLoop);
     * void PlayMusic($iID, $bLoop, $iStartID, $iEndID);
     * @param int $iID Начнем с музыкального файла.
     * @param int $bLoop 1
     * @param int $iStartID Идентификатор, к которому нужно вернуться при циклическом переходе от конца к началу списка
     *     файлов.
     * @param int $iEndID Идентификатор, после которого он должен вернуться к началу цикла.
     * @return void
     */
    function PlayMusic(int...$args)
    {
    }

    /**
     * Бросает луч через все физические объекты, включая спрайты, у которых включена физика, и сохраняет ближайший
     * предмет, попавший в цель. Результаты приведения лучей могут быть получены с помощью других функций приведения
     * лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в
     * результатах. Эта функция фильтрует проверяемые спрайты, поэтому проверяются только спрайты определенной группы,
     * а значение группы 0 означает, что будут проверены все группы. Возвращает 1, если произошло столкновение, и 0,
     * если нет.
     *
     * @param int $group Идентификатор группы, проверяемый на пересечение с лучом, может быть отрицательным.
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function PhysicsRayCastGroup(int $group, float $x, float $y, float $x2, float $y2): int
    {
    }

    /**
     * Бросает луч через все физические объекты, включая спрайты, у которых включена физика, и сохраняет ближайший
     * предмет, попавший в цель. Результаты приведения лучей могут быть получены с помощью других функций приведения
     * лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в
     * результатах. Эта функция фильтрует проверяемые спрайты, поэтому проверяются только спрайты определенных
     * категорий. Параметр category - это побитовое поле, которое использует младшие 16 битов для представления каждой
     * из возможных 16 категорий, используемых при настройке спрайта. Значение по умолчанию all 1s означает, что все
     * категории будут включены, тогда как значение all 0s означает, что никакие категории не будут включены. Вы можете
     * установить отдельные биты, чтобы установить, какие из них должны быть проверены. Возвращает 1, если произошло
     * столкновение, и 0, если нет.
     *
     * @param int $category Категории для проверки на пересечение с лучом, побитовое поле с использованием самых нижних
     *     16 бит.
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function PhysicsRayCastCategory($category, $x, $y, $x2, $y2)
    {
    }

    /**
     * Бросает луч через все физические объекты, включая спрайты, у которых включена физика, и сохраняет ближайший
     * предмет, попавший в цель. Результаты приведения лучей могут быть получены с помощью других функций приведения
     * лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в
     * результатах. Возвращает 1, если произошло столкновение, и 0, если нет.
     *
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function PhysicsRayCast($x, $y, $x2, $y2)
    {
    }

    /**
     * Приостанавливает видео и сохраняет его на экране.
     *
     * @return void
     */
    function PauseVideo()
    {
    }

    /**
     * Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван
     * ResumeTweenText. Если анимация уже остановилась или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @param int $textID ИДЕНТИФИКАТОР текста для паузы
     * @return void
     */
    function PauseTweenText($tweenID, $textID)
    {
    }

    /**
     * Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван
     * ResumeTweenSprite. Если анимация уже остановилась или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @param int $spriteID Идентификатор спрайта для паузы
     * @return void
     */
    function PauseTweenSprite($tweenID, $spriteID)
    {
    }

    /**
     * Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван
     * ResumeTweenObject. Если анимация уже остановилась или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @param int $objectID Идентификатор объекта для приостановки
     * @return void
     */
    function PauseTweenObject($tweenID, $objectID)
    {
    }

    /**
     * Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван
     * ResumeTweenCustom. Если анимация уже остановилась или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @return void
     */
    function PauseTweenCustom($tweenID)
    {
    }

    /**
     * Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван
     * ResumeTweenChar. Если твин уже остановился или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @param int $textID ИДЕНТИФИКАТОР текста для паузы
     * @param int $charID Индекс символа для паузы
     * @return void
     */
    function PauseTweenChar($tweenID, $textID, $charID)
    {
    }

    /**
     * Приостанавливает данную цепочку, которая начала играть, она может быть возобновлена с помощью PlayTweenChain
     *
     * @param int $chainID Идентификатор цепочки для изменения
     * @return void
     */
    function PauseTweenChain($chainID)
    {
    }

    /**
     * Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет
     * вызвана ResumeTweenCamera. Если твин уже остановился или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @param int $cameraID Идентификатор камеры для паузы
     * @return void
     */
    function PauseTweenCamera($tweenID, $cameraID)
    {
    }

    /**
     * Ставит музыкальный файл на паузу. GetMusicPlayingOGG будет продолжать возвращать 1.
     *
     * @param int $musicID Идентификатор музыкального файла для приостановки
     * @return void
     */
    function PauseMusicOGG($musicID)
    {
    }

    /**
     * Приостанавливает воспроизведение музыки в данный момент, какой бы идентификатор это ни был.
     *
     * @return void
     */
    function PauseMusic()
    {
    }

    /**
     * Заставляет Chartboost использовать данное значение согласия при показе рекламы, по умолчанию AGK показывает
     * неперсонализированные объявления из Chartboost. Эта команда может быть использована, если у вас есть собственный
     * метод получения согласия пользователя на показ персонализированной рекламы. Обратите внимание, что GDPR требует
     * от вас по закону получить согласие пользователей ЕС, прежде чем показывать им персонализированную рекламу.
     *
     * @param int $consent Значение согласия на использование, 1=неперсонализированное, 2=персонализированное
     * @return void
     */
    function OverrideConsentChartboost($consent)
    {
    }

    /**
     * Если AdMob использует заданное значение согласия при показе рекламы, оно не сохраняется на сервере AdMob и
     * переопределяет обычный процесс получения согласия. Это используется, если у вас есть собственный метод получения
     * согласия пользователя на показ персонализированной рекламы. Обратите внимание, что GDPR требует от вас по закону
     * получить согласие пользователей ЕС, прежде чем показывать им персонализированную рекламу.
     *
     * @param int $consent Значение согласия на использование, 1=неперсонализированное, 2=персонализированное
     * @return void
     */
    function OverrideConsentAdMob($consent)
    {
    }

    /**
     * Открывает файл, хранящийся в локальной файловой системе, для записи в указанный идентификатор. Все платформы
     * ограничены одной папкой для записи, поэтому пути к файлам должны быть относительными, а не абсолютными. Эта
     * папка записи не является той же папкой, что и само приложение, поэтому изображения, звуки и само приложение не
     * могут быть перезаписаны. Файлы, записанные в эту папку, можно читать с помощью OpenToRead. Если файл не
     * существует, он будет создан, если файл существует, он будет перезаписан, если append равен 0. или добавлен, если
     * append равен 1. Если каталог указан в имени файла и не существует, он будет создан. Чтобы записать файл вне
     * обычной папки записи, вы можете использовать "raw:", за которым следует абсолютный путь для текущей платформы,
     * например "raw:C:\MyFolder\MyFile.txt" на окнах или "raw:/sdcard/Documents/MyFile.txt-на Андроиде. Если
     * какие-либо папки в выбранном вами пути не существуют, они будут созданы. На Raspberry Pi вы можете использовать
     * эту команду, чтобы открыть pin-код GPIO для записи, используя имя файла "gpio:", за которым следует номер
     * pin-кода GPIO, например OpenToWrite(1, "gpio:4"), это чувствительно к регистру. Затем вы можете использовать
     * writeByte для записи 0 или 1 в pin-код и CloseFile для закрытия pin-кода.
     *
     * Пример вызова:
     *
     * int OpenToWrite($szFile);
     *
     * int OpenToWrite($szFile, $append);
     *
     * void OpenToWrite($ID, $szFile)
     *
     * void OpenToWrite($ID, $szFile, $append);
     * @param int $ID Идентификатор, который будет использоваться для ссылки на этот файл позже.
     * @param string $szFile Имя файла, которое нужно открыть для записи.
     * @param int $append Установите значение 1 для добавления в файл, 0 для перезаписи всех данных (необязательно, по
     *     умолчанию 0).
     * @return int|void
     */
    function OpenToWrite(mixed...$args): int
    {
    }

    /**
     * Открывает файл, хранящийся в локальной файловой системе, для чтения в указанный идентификатор. Все платформы
     * ограничены одной папкой для чтения и записи, поэтому пути к файлам должны быть относительными, а не абсолютными.
     * Эта команда сначала проверит специальную папку записи, а если она не сможет найти файл, то проверит папку
     * мультимедиа, так что вы можете загрузить изображения, звуки и другие связанные медиафайлы с помощью этой
     * команды. Чтобы прочитать файл вне обычных папок чтения или записи, вы можете использовать "raw:", за которым
     * следует абсолютный путь для текущей платформы, например "raw:C:\MyFolder\MyFile.txt" на окнах или
     * "raw:/sdcard/Documents/MyFile.txt-на Андроиде. На Raspberry Pi вы можете использовать эту команду, чтобы открыть
     * pin-код GPIO для чтения, используя имя файла "gpio:", за которым следует номер pin-кода GPIO, например
     * OpenToRead(1, "gpio:4"), это чувствительно к регистру. Затем вы можете использовать ReadByte для чтения из
     * pin-кода и CloseFile для закрытия pin-кода.
     *
     * Пример вызова:
     *
     * int OpenToRead($szFile);
     *
     * void OpenToRead($ID, $szFile)
     * @param int $ID Идентификатор, который будет использоваться для ссылки на этот файл позже.
     * @param string $szFile Имя файла, которое нужно открыть для чтения.
     * @return int|void
     */
    function OpenToRead(mixed...$args): int
    {
    }

    /**
     * Открывает папку в любом месте файловой системы и считывает список содержащихся в ней файлов и папок. Это
     * делается немедленно, поэтому любые изменения, которые происходят в папке после этой команды, не будут замечены,
     * вам нужно будет вызвать эту команду снова, чтобы получить обновленное содержимое. Путь к файлу должен быть
     * абсолютным для текущего устройства, то есть он должен начинаться с буквы диска и двоеточия в Windows и прямой
     * косой черты на всех других платформах. Путь должен существовать и быть доступен для текущего приложения, иначе
     * эта команда выдаст ошибку. Путь может начинаться с текста "raw:" или нет, принимаются обе формы. Эта команда
     * вернет идентификатор, который вы можете использовать для доступа к найденному списку файлов, он будет оставаться
     * доступным до тех пор, пока вы не закроете его с помощью CloseRawFolder. Несколько папок могут быть открыты
     * одновременно, каждому из них будет присвоен свой идентификатор.
     *
     * @param string $szPath Путь к папке, которую нужно открыть
     * @return int
     */
    function OpenRawFolder($szPath)
    {
    }

    /**
     * Открывает браузер по умолчанию текущей платформы и указывает его на заданную страницу.
     *
     * @param string $url URL
     * @return void
     */
    function OpenBrowser($url)
    {
    }

    /**
     * Немедленно перемещает все существующие частицы на заданное смещение. Например,смещение x=3, y=5 сдвинет все
     * частицы вправо на 3 единицы и вниз на 5 единиц. Это не влияет на излучатель частиц, но может быть использовано в
     * сочетании с SetParticlesPosition для перемещения как излучателя, так и уже существующих частиц.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x Расстояние для перемещения частиц в направлении X.
     * @param float $y Расстояние для перемещения частиц в направлении Y.
     * @return void
     */
    function OffsetParticles($ID, $x, $y)
    {
    }

    /**
     * Эта команда делает то же самое, что и ObjectSphereCast, но в течение нескольких итераций, чтобы создать точку
     * скольжения для использования в скользящих столкновениях. Он создает скользящую точку, которая снова проверяется,
     * чтобы убедиться, что эта новая точка не сталкивается ни с какими объектами. Это порождает еще одну точку,
     * которую необходимо проверить и так далее. ObjectSphereSlide использует максимум три итерации для завершения
     * точки, которая будет держать сферу вне всех проверенных объектов. Команда GetObjectRayCastNumHits может быть
     * использована для получения количества итераций, используемых этой командой. Подробная информация о точке
     * столкновения, нормали и точке скольжения для каждой итерации также доступна с использованием индексов
     * столкновения от 1 до 3, т. е. GetObjectRayCastX(1) (2) или (3). Конечная точка столкновения, нормаль и точка
     * скольжения находятся в индексе 0, то есть GetObjectRayCastSlideX(0).
     *
     * @param int $objID Идентификатор проверяемого объекта-0 для всех объектов.
     * @param float $oldx Компонент X начальной позиции.
     * @param float $oldy Компонент Y начальной позиции.
     * @param float $oldz Z-компонент начальной позиции.
     * @param float $newx X-компонент конечного положения.
     * @param float $newy Компонент Y конечного положения.
     * @param float $newz Z-компонент конечного положения.
     * @param float $radius Радиус сферы для отливки.
     * @return int
     */
    function ObjectSphereSlide($objID, $oldx, $oldy, $oldz, $newx, $newy, $newz, $radius)
    {
    }

    /**
     * Немедленно перемещает все существующие частицы на заданное смещение. Например, смещение x=3,y=5,z=0 сдвинет все
     * частицы вправо на 3 единицы и вниз на 5 единиц. Это не влияет на излучатель частиц, но может быть использовано в
     * сочетании с Set3DParticlesPosition для перемещения как излучателя, так и уже существующих частиц.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x Расстояние для перемещения частиц в направлении X.
     * @param float $y Расстояние для перемещения частиц в направлении Y.
     * @param float $z Расстояние для перемещения частиц в направлении Z.
     * @return void
     */
    function Offset3DParticles($ID, $x, $y, $z)
    {
    }

    /**
     * Бросает луч через 1 или все объекты, чтобы проверить пересечение с объектом. Лучи определяются с начальным
     * положением и конечным положением и не сталкиваются с задними поверхностями, вернут номер объекта, попавшего
     * первым, или 0 для отсутствия столкновения. Команды лучевого литья полезны для расчета столкновений пуль с
     * уровнями и объектами или для представления линии визирования противника, чтобы определить, могут ли они видеть
     * игрока.
     *
     * @param int $objID Идентификатор проверяемого объекта-0 для всех объектов.
     * @param float $oldx Компонент X начальной позиции.
     * @param float $oldy Компонент Y начальной позиции.
     * @param float $oldz Z-компонент начальной позиции.
     * @param float $newx X-компонент конечного положения.
     * @param float $newy Компонент Y конечного положения.
     * @param float $newz Z-компонент конечного положения.
     * @return int
     */
    function ObjectRayCast($objID, $oldx, $oldy, $oldz, $newx, $newy, $newz)
    {
    }

    /**
     * Проверит, не сталкивается ли луч, начинающийся в oldx, oldy, oldz и заканчивающийся в newx, newy, newz и
     * радиусом ширины, с указанным объектом (ObjId=0 для всех). Не сталкивается с задними гранями, вернет номер
     * объекта, попавшего первым, или 0 для отсутствия столкновения. Команды Sphere casting добавляют измерение ширины
     * к нормальному лучевому кастингу, которое можно использовать для проверки того, ударил ли игрок что-нибудь во
     * время движения, и для позиционирования их в точке столкновения, чтобы обеспечить "липкое" столкновение, где
     * игрок останавливается, если он что-нибудь ударит. Альтернативой является скользящее столкновение. см. раздел
     * ObjectSphereSlide
     *
     * @param int $objID Идентификатор проверяемого объекта-0 для всех объектов.
     * @param float $oldx Компонент X начальной позиции.
     * @param float $oldy Компонент Y начальной позиции.
     * @param float $oldz Z-компонент начальной позиции.
     * @param float $newx X-компонент конечного положения.
     * @param float $newy Компонент Y конечного положения.
     * @param float $newz Z-компонент конечного положения.
     * @param float $radius Радиус сферы для отливки.
     * @return int
     */
    function ObjectSphereCast($objID, $oldx, $oldy, $oldz, $newx, $newy, $newz, $radius)
    {
    }

    /**
     * Перемещает указанный объект вдоль его локальной оси Z, то есть если бы объект был символом, эта команда
     * заставила бы его двигаться вперед независимо от того, в каком направлении он находится.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении Z, может быть отрицательным.
     * @return void
     */
    function MoveObjectLocalZ($objID, $amount)
    {
    }

    /**
     * Перемещает указанный объект вдоль его локальной оси Y, то есть если бы объект был символом, эта команда
     * заставила бы его прыгать независимо от того, в каком направлении он находится.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении Y, может быть отрицательным.
     * @return void
     */
    function MoveObjectLocalY($objID, $amount)
    {
    }

    /**
     * Перемещает указанный объект вдоль его локальной оси X, то есть, если бы объект был символом, эта команда
     * заставила бы их стреляться независимо от того, в каком направлении они были обращены.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении X, может быть отрицательным.
     * @return void
     */
    function MoveObjectLocalX($objID, $amount)
    {
    }

    /**
     * Перемещает указанную камеру вдоль ее локальной оси Z, то есть если бы камера была символом, эта команда
     * заставила бы их двигаться вперед независимо от того, в каком направлении они были обращены.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении Z, может быть отрицательным.
     * @return void
     */
    function MoveCameraLocalZ($cameraID, $amount)
    {
    }

    /**
     * Перемещает указанную камеру вдоль ее локальной оси Y, то есть если бы камера была символом, эта команда
     * заставила бы их прыгать независимо от того, в каком направлении они были обращены.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении Y, может быть отрицательным.
     * @return void
     */
    function MoveCameraLocalY($cameraID, $amount)
    {
    }

    /**
     * Перемещает указанную камеру вдоль ее локальной оси X, то есть если бы камера была символом, эта команда
     * заставила бы их стреляться независимо от того, в каком направлении они были обращены.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении X, может быть отрицательным.
     * @return void
     */
    function MoveCameraLocalX($cameraID, $amount)
    {
    }

    /**
     * Перемещает контроллер.
     *
     * Пример вызова:
     *
     * void Move3DPhysicsCharacterController($objID, $x, $z, $velocity);
     *
     * void Move3DPhysicsCharacterController($objID, $direction, $velocity)
     * @param int $objID идентификатор объекта
     * @param int $direction 0 = стоп, 1 = вперед, 2 = назад, 3 = стрейф влево, 4 = стрейф вправо
     * @param float $x Сумма, которая будет двигаться в направлении x, будет нормализована с направлением z
     * @param float $z Сумма, которая будет двигаться в направлении z, будет нормализована с направлением x
     * @param float $velocity скорость перемещения
     * @return void
     */
    function Move3DPhysicsCharacterController(mixed...$args)
    {
    }

    /**
     * Возвращает остаток от целочисленного деления a/b.
     *
     * @param int $a Числитель.
     * @param int $b Знаменатель.
     * @return int
     */
    function Mod($a, $b)
    {
    }

    /**
     * Отправляет приложение в фоновый режим. На настольных платформах, таких как Windows, приложение будет продолжать
     * работать, когда оно свернуто. На Android приложение будет приостановлено. На iOS он ничего не сделает, так как
     * пользователь должен свернуть приложение, нажав кнопку home. На настольных платформах окно можно восстановить с
     * помощью RestoreApp.
     *
     * @return void
     */
    function MinimizeApp()
    {
    }

    /**
     * Извлекает подстроку из заданной строки, расположенной в указанной позиции.
     *
     * @param string $strin Строка, из которой нужно извлечь
     * @param int $position Позиция, которая начинается в строке, первый символ-это позиция 1.
     * @param int $length Количество символов, извлекаемых из строки, используйте минус 1, чтобы продолжить до конца
     *     строки
     * @return string
     */
    function Mid($strin, $position, $length)
    {
    }

    /**
     * Отображает окно сообщения, содержащее заданный текст. Ваше приложение не гарантированно приостановится во время
     * отображения сообщения.
     *
     * @param string $msg Сообщение для отображения
     * @return void
     */
    function Message($msg)
    {
    }

    /**
     * Максимизирует окно таким образом, чтобы оно было максимально возможным размером в текущем видимом пространстве
     * без перехода на полный экран. Ничего не делает на мобильных устройствах.
     *
     * @return void
     */
    function MaximizeWindow()
    {
    }

    /**
     * Создает папку по текущему пути. По умолчанию это определяется командой SetFolder. Вы также можете использовать
     * имя файла, начинающееся с "raw:", чтобы создать папку в любом месте файловой системы, например
     * MakeFolder("raw:C:\Temp\MyFolder")
     *
     * @param string $szName Имя папки create.
     * @return int
     */
    function MakeFolder($szName)
    {
    }

    /**
     * Создает составное значение цвета из цветовых компонентов, которое затем можно использовать с командами
     * 2D-рисования.
     *
     * @param int $red Красная составляющая цвета.
     * @param int $green Зеленая составляющая цвета.
     * @param int $blue Синяя составляющая цвета.
     * @return int
     */
    function MakeColor($red, $green, $blue)
    {
    }

    /**
     * Преобразует строку в символы нижнего регистра.
     *
     * @param string $strin Строка для преобразования
     * @return string
     */
    function Lower($strin)
    {
    }

    /**
     * Отображает указанный текст в соответствующем окне журнала устройства или вывода.
     *
     * @param string $szMessage текстовое сообщение для отправки в область журнала/вывода
     * @return void
     */
    function Log(string $szMessage)
    {
    }

    /**
     * Возвращает натуральный логарифм заданного значения.
     *
     * @param float $a Входное значение
     * @return float

    function Log($a)
    {
    }
    */

    /**
     * Загружает субизображение из текстуры атласа для использования в качестве автономного изображения в указанный
     * идентификатор изображения. В subimages.txt файл должен начинаться с того же имени, что и файл изображения,
     * например, атласное изображение myImage.png будет иметь файл подизображений с именем "myImage subimages.txt".
     * Файл подизображений содержит ряд строк, каждая из которых описывает изображение, существующее в изображении
     * атласа. Каждая строка должна иметь имя формата:X:Y:Width:Height с разделителем :, используемым между полями.
     * Поле Name - это имя, которое вы хотите использовать для ссылки на субизображение при загрузке, оно должно
     * соответствовать параметру sImageFilename этой команды LoadSubImage. Поля X:Y-это координаты пикселей X и Y,
     * представляющие верхний левый угол подизображения, а поля Width:Height-это размер в пикселях подизображения. Эти
     * значения затем используются для извлечения вашего именованного изображения из атласа и загрузки его в свой
     * собственный идентификатор изображения, который будет использоваться как обычное изображение. Изображение атласа
     * должно оставаться загруженным в течение всего времени использования загруженного субизображения. Обратите
     * внимание, что при загрузке подизображения AGK немного изменит UV-координаты, чтобы изображение не крало пиксели
     * из соседних изображений во время фильтрации, по умолчанию он сдвигает UV внутрь на 0,5 пикселя. Вы можете
     * переопределить это, установив SetSpriteUVBorder равным 0 для спрайтов, где вам нужны идеальные пиксельные
     * результаты, но вам придется следить за тем, чтобы пиксель кровоточил по краям, и, возможно, вам придется дать
     * вашим субизображениям границу в 1 пиксель соответствующего цвета, которую он может безопасно украсть при
     * фильтрации.
     *
     *
     * Пример вызова:
     *
     * int LoadSubImage($iParentIndex, $sImageFilename);
     *
     * void LoadSubImage($iImageIndex, $iParentIndex, $sImageFilename);
     * @param int $iImageIndex Идентификатор изображения, который будет использоваться для ссылки на это изображение
     * позже.
     * @param int $iParentIndex Идентификатор изображения, содержащего текстуру атласа, загруженную ранее.
     * @param string $sImageFilename Имя файла вложенного образа, хранящегося в subimages.txt. Не используйте путь
     * перед именем файла.
     * @return int|void
     */
    function LoadSubImage(mixed...$args): int
    {
    }

    /**
     * Эта команда загружает видеофайл, готовый к воспроизведению. Одновременно может быть загружен только один
     * видеофайл, поэтому загрузка видео удаляет все существующие видеофайлы. На iOS, Android и Mac рекомендуется
     * использовать файлы .mp4 с кодеком H264 (MPEG-4 AVC) для видео. Для аудио он должен быть закодирован в формате
     * MP3 или AAC. В Windows это зависит от установленных кодеков, и хотя в некоторых случаях он будет воспроизводить
     * файлы mp4, рекомендуется использовать wmv в Windows для максимальной поддержки. Возвращает 1 в случае успеха, 0,
     * если произошла ошибка, -1, если эта платформа не поддерживает видео.
     *
     * @param string $szFilename Видеофайл для загрузки.
     * @return int
     */
    function LoadVideo($szFilename)
    {
    }

    /**
     * Создает спрайт в пустом идентификаторе спрайта с явным изображением для использования при рендеринге, возвращает
     * используемый идентификатор спрайта. По умолчанию спрайты создаются с глубиной 10, имеют размер, используя данное
     * изображение в качестве направляющей, и позиционируются на 0,0, используя их верхний левый угол. Если назначенное
     * изображение имеет альфа-пиксели, то спрайт создается с режимом прозрачности 1, в противном случае он использует
     * режим прозрачности 0 (непрозрачный) Эта команда берет имя файла изображения и загружает его специально для этого
     * спрайта, это изображение будет удалено, когда спрайт будет удален. Если много спрайтов собираются использовать
     * одно и то же изображение, вы должны загрузить его отдельно и передать его идентификатор команде CreateSprite для
     * экономии памяти.
     *
     * Пример вызова:
     *
     * int LoadSprite($imagefile);
     *
     * void LoadSprite($iSpriteIndex, $imagefile);
     * @param int $iSpriteIndex Идентификатор спрайта, который будет использоваться для ссылки на этот спрайт позже
     *     (отдельно от идентификаторов изображений, поэтому может быть как спрайт 1, так и изображение 1)
     * @param string $imagefile Имя файла изображения, которое будет использоваться при рисовании этого спрайта
     * @return int|void
     */
    function LoadSprite(mixed...$args): int
    {
    }

    /**
     * Загружает шейдер, используемый для изменения спрайтов, поскольку он содержит только пиксельный шейдер, вершинный
     * шейдер автоматически генерируется, чтобы убедиться, что он появляется в нужном месте. Этот тип шейдера должен
     * применяться только к спрайтам, но ничего плохого не произойдет, если вы решите применить его к объектам, он
     * просто даст необычные результаты рендеринга для этого объекта. В настоящее время шейдеры по умолчанию используют
     * GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы
     * не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер
     * работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть
     * включено в исходный код шейдера. Возвращает идентификатор, который можно использовать для ссылки на этот шейдер
     * в других командах. Идентификаторы являются общими для всех типов шейдеров, поэтому загрузка спрайтового шейдера
     * в ID 1 не будет работать, если 3D-шейдер существует с ID 1.
     *
     * Пример вызова:
     *
     * int LoadSpriteShader($szPixelFile);
     *
     * void LoadSpriteShader($shaderID, $szPixelFile);
     * @param int $shaderID Идентификатор, используемый для ссылки на этот шейдер в других командах.
     * @param string $szPixelFile Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return int|void
     */
    function LoadSpriteShader(mixed...$args): int
    {
    }

    /**
     * Загружает анимацию спрайтера, экспортированную в формате JSON. Пожалуйста, обратитесь к разделу руководства для
     * получения подробной информации о том, что поддерживается. Возвращает идентификатор, используемый для ссылки на
     * этот скелет. Параметр atlas image еще не поддерживается и должен быть равен 0, изображения будут загружаться по
     * путям, указанным в файле Spriter JSON. Вы можете использовать значение масштаба, чтобы изменить размер спрайтов
     * и костей в соответствии с выбранным вами разрешением. Значение 1 не изменит размеров, значение 2 сделает все в
     * два раза больше, значение 0,5 уменьшит размер вдвое, и так далее.
     *
     *
     * Пример вызова:
     *
     * int LoadSkeleton2DFromSpriterFile($filename, $scale, $atlasImage);
     *
     * void LoadSkeleton2DFromSpriterFile($iSkeleton, $filename, $scale, $atlasImage)
     * @param int $iSkeleton ID для использования для этого скелета
     * @param string $filename Имя файла, который нужно загрузить, должно быть таким .экспорт json из позвоночника
     * @param float $scale Сумма для масштабирования размеров объекта
     * @param int $atlasImage зарезервировано, должно быть 0
     * @return int|void
     */
    function LoadSkeleton2DFromSpriterFile(mixed...$args): int
    {
    }

    /**
     * Загружает звуковой файл из папки мультимедиа приложения и возвращает номер звука. Пути к файлам должны быть
     * относительными, а не абсолютными, вы не можете загружать звуковые файлы из другого места на диске. Обратите
     * внимание, что сжатые WAV-файлы не поддерживаются. Вы должны использовать несжатые WAV-файлы, чтобы обеспечить
     * совместимость на всех платформах.
     *
     * Пример вызова:
     *
     * int LoadSound($sFilename);
     *
     * void LoadSound($iID, $sFilename);
     * @param int $iID Звуковой номер для хранения звука.
     * @param string $sFilename Имя файла загружаемого звукового файла должно быть WAV-файлом.
     * @return int|void
     */
    function LoadSound(mixed...$args): int
    {
    }

    /**
     * Загружает звуковой файл из папки мультимедиа приложения. Пути к файлам должны быть относительными, а не
     * абсолютными, вы не можете загружать звуковые файлы из других мест на диске. Эта команда берет сжатый OGG-файл и
     * распаковывает его во время загрузки, позволяя вам сохранить размер файла, но использование памяти будет таким
     * же, как если бы вы использовали WAV-файл. Если вы хотите использовать OGG, а также экономить память, то
     * используйте новые команды LoadMusicOGG.
     *
     * Пример вызова:
     *
     * int LoadSoundOGG($sFilename);
     * void LoadSoundOGG($iID, $sFilename);
     * @param int $iID Звуковой номер для хранения звука.
     * @param string $sFilename Имя файла загружаемого звукового файла должно быть OGG-файлом.
     * @return int|void
     */
    function LoadSoundOGG(mixed...$args): int
    {
    }

    /**
     * Загружает анимацию позвоночника, экспортированную в формате JSON. Пожалуйста, обратитесь к разделу руководства
     * для получения подробной информации о том, что поддерживается. Возвращает идентификатор, используемый для ссылки
     * на этот скелет. Сначала вы должны загрузить изображение атласа, экспортированное Spine, в изображение AGK с
     * помощью команды normal LoadImage и передать его в эту функцию. Вы также можете загрузить анимацию или просто
     * спрайты и кости и переместить или изменить их вручную. Вы можете использовать значение масштаба, чтобы изменить
     * размер спрайтов и костей в соответствии с выбранным вами разрешением. Значение 1 не изменит размеров, значение 2
     * сделает все в два раза больше, значение 0,5 уменьшит размер вдвое, и так далее.
     *
     * Пример вызова:
     *
     * int LoadSkeleton2DFromSpineFile($filename, $scale, $atlasImage, $loadAnim);
     *
     * void LoadSkeleton2DFromSpineFile($iSkeleton, $filename, $scale, $atlasImage, $loadAnim);
     * @param int $iSkeleton ID для использования для этого скелета
     * @param string $filename Имя файла, который нужно загрузить, должно быть таким .экспорт json из позвоночника
     * @param float $scale Сумма для масштабирования размеров объекта
     * @param int $atlasImage Идентификатор изображения атласа, содержащего все изображения
     * @param int $loadAnim 1 для загрузки анимации, 0 для загрузки только спрайтов и костей
     * @return int|void
     */
    function LoadSkeleton2DFromSpineFile(mixed...$args): int
    {
    }

    /**
     * Загружает переменную, сохраненную этим приложением или другим приложением. Это работает только на платформах
     * iOS, Android 10 и ниже, а также HTML5. Приложения могут совместно использовать переменную только в том случае,
     * если они отвечают определенным требованиям, основанным на платформе. В iOS приложения должны иметь один и тот же
     * начальный идентификатор пакета (также называемый префиксом идентификатора приложения) и иметь один и тот же
     * явный идентификатор приложения до последней точки. Например, com.mycompany.mygroup.myapp1 и
     * com.mycompany.mygroup.myapp2 смогут совместно использовать переменные. На Android 10 и ниже приложения должны
     * иметь разрешение WRITE_EXTERNAL_STORAGE и иметь одно и то же имя пакета до последней точки. Например,
     * com.mycompany.mygroup.myapp1 и com.mycompany.mygroup.myapp2 смогут совместно использовать переменные. На Android
     * общие переменные записываются в доступное пользователю место, поэтому имейте в виду, что пользователи могут
     * читать и/или редактировать сохраненные вами переменные. На Android 11 или выше эта команда не будет работать,
     * так как приложения ограничены в записи в общие места. В HTML приложения должны размещаться в одном домене,
     * значения хранятся в виде файлов cookie. Переменные идентифицируются по имени, поэтому использование
     * SaveSharedVariable("username", "Alice") установит переменную с именем "username" в значение "Alice". Затем это
     * может быть прочитано другими приложениями с помощью LoadSharedVariable( "username", "" ). Если переменная с
     * заданным именем не существует, то вместо нее возвращается указанное значение по умолчанию
     *
     * @param string $varName Имя переменной для извлечения
     * @param string $defaultValue Значение, возвращаемое, если переменная не существует
     * @return string
     */
    function LoadSharedVariable($varName, $defaultValue)
    {
    }

    /**
     * Загружает шейдер, используемый для рисования объектов. Вершинный шейдер преобразует полигоны в экранное
     * пространство, а пиксельный шейдер определяет окончательный цвет каждого пикселя, который покрывает объект. В
     * настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически
     * добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите
     * внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное
     * значение "точность" будет добавлено и не должно быть включено в исходный код шейдера.
     *
     * Пример:
     *
     * int LoadShaderFromString($szVertexSource, $szPixelSource);
     *
     * void LoadShaderFromString($shaderID, $szVertexSource, $szPixelSource);
     * @param int $shaderID Идентификатор, используемый для ссылки на этот шейдер в других командах.
     * @param string $szVertexSource Имя файла вершинного шейдера, обычно заканчивающееся .vs
     * @param string $szPixelSource Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return int|void
     */
    function LoadShaderFromString(mixed...$args): int
    {
    }

    /**
     * Загружает шейдер, используемый для рисования объектов. Вершинный шейдер преобразует полигоны в экранное
     * пространство, а пиксельный шейдер определяет окончательный цвет каждого пикселя, который покрывает объект. В
     * настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически
     * добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите
     * внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное
     * значение "точность" будет добавлено и не должно быть включено в исходный код шейдера.
     *
     * Пример вызова:
     * int LoadShader($szVertexFile, $szPixelFile);
     *
     * void LoadShader($shaderID, $szVertexFile, $szPixelFile);
     * @param int $shaderID Идентификатор, используемый для ссылки на этот шейдер в других командах.
     * @param string $szVertexFile Имя файла вершинного шейдера, обычно заканчивающееся .vs
     * @param string $szPixelFile Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return int|void
     */
    function LoadShader(mixed...$args)
    {
    }

    /**
     * Загружает объект из файла, в настоящее время поддерживаются форматы .X .FBX .dae (collada) .3ds .md3 .smd .md5
     * .lwo .ac .b3d .dae .3d .lws .ms3d .blend .obj и .ago. Если файл модели содержит иерархию костей или анимационные
     * данные, то они также будут загружены и связаны с объектом. Обратите внимание, что объекты с более чем 50 костями
     * могут не отображаться на некоторых старых устройствах. AGK имеет предел в 200 костей. Если файл модели содержит
     * график сцены, содержащий несколько объектов, то они также будут загружены и сохранены в отдельных объектах,
     * которые могут быть обнаружены с помощью GetObjectNumChildren. Если вы просто хотите загрузить один объект без
     * каких-либо костей, анимации или детей, то вместо этого используйте LoadObject. Возвращает идентификатор, который
     * можно использовать для ссылки на этот объект в других командах.
     *
     * Пример вызова:
     *
     * int LoadObjectWithChildren($szFilename);
     *
     * void LoadObjectWithChildren($objID, $szFilename)
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param string $szFilename Имя загружаемого объектного файла.
     * @return int|void
     */
    function LoadObjectWithChildren(mixed...$args): int
    {
    }

    /**
     * загружает форму столкновения из файла .bcs (Bullet Collision Shape) и устанавливает ее на объект. Возвращает
     * true, если это удалось.
     *
     * @param int $objID идентификатор объекта
     * @param string $fileName имя файла
     * @return int
     */
    function LoadObjectShape($objID, $fileName): int
    {
    }



    /**
     * Загружает объект из файла, в настоящее время поддерживаются форматы .X .3ds .md3 .smd .md5 .lwo. ac .b3d .dae
     * .3d .lws .ms3d .blend .m3 .obj и .ago. Эта команда не будет загружать никаких анимационных или костных данных и
     * объединит вершины в один объект с как можно меньшим количеством сеток. Для загрузки анимации и костных данных
     * используйте вместо этого LoadObjectWithChildren.
     *
     * ################################################
     *
     * void LoadObject( int $objID, string $szFilename );
     *
     * int LoadObject( string $szFilename, float $height );
     *
     * void LoadObject( int $objID, string $szFilename, float $height );
     *
     * int LoadObject( string szFilename );
     *
     * ################################################
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param string $szFilename - Имя загружаемого объектного файла.
     * @param float $height Масштабируйте загруженный объект до этой высоты.
     *
     * @return mixed
     */

    function LoadObject(...$args): mixed
    {
    }

    /**
     * Загружает музыкальный файл из папки мультимедиа приложения в указанный идентификатор. Пути к файлам должны быть
     * относительными, а не абсолютными, вы не можете загружать музыкальные файлы из других мест на диске. Он
     * возвращает идентификатор музыкального файла для последующей ссылки на него. Рекомендуемый формат для
     * кросс-платформенной совместимости-MP3. Обратите внимание, что платформа Meego в настоящее время не поддерживает
     * MP3, вместо этого она попытается загрузить файл OGG Vorbis. Например, если вы попытаетесь загрузить "music.mp3",
     * на Meego это будет интерпретировано как "music.ogg". Идентификатор должен находиться в диапазоне от 1 до 50.
     *
     * Пример вызова:
     * int LoadMusic($sFile);
     *
     * void LoadMusic($iID, $sFile)
     * @param int $iID Музыкальный номер для хранения музыки.
     * @param string $sFile Имя файла загружаемого музыкального файла.
     * @return int|void
     */
    function LoadMusic(mixed...$args): int
    {
    }

    /**
     * Загружает музыкальный файл, сжатый с помощью OGG Vorbis. Это поддерживается на всех платформах, как и новый
     * предпочтительный способ воспроизведения музыки, заменяющий команду LoadMusic. Одновременно можно воспроизводить
     * несколько музыкальных файлов OGG. Идентификаторы музыкальных файлов OGG отделены от обычных идентификаторов
     * музыкальных файлов и не ограничены определенным диапазоном чисел.
     *
     * Пример вызова:
     *
     * int LoadMusicOGG($sFile);
     *
     * void LoadMusicOGG($musicID, $sFile);
     * @param int $musicID Идентификатор, используемый для ссылки на этот музыкальный файл.
     * @param string $sFile Имя файла загружаемого музыкального файла.
     * @return int|void
     */
    function LoadMusicOGG(mixed...$args): int
    {
    }


    /**
     * Загружает изображение, изменяя его размер в процессе. Это позволяет вам иметь одно высококачественное
     * изображение, а затем изменять его размер в зависимости от разрешения устройства во время выполнения, вместо того
     * чтобы иметь несколько уровней качества. Уменьшение размера изображения предпочтительнее увеличения размера
     * изображения, так как увеличение размера изображения не улучшает качество, но оба варианта поддерживаются.
     * Значение 1.0 не изменяет размер изображения, значение меньше 1 сделает изображение меньше, значение больше 1
     * сделает изображение больше. Значения масштабирования должны быть больше 0, но могут быть любой дробью, то есть
     * допустима шкала 0,6742. Масштаб 0,5 уменьшит размер изображения вдвое, 2,0-вдвое, и так далее. Изображение может
     * быть изменено по-разному в направлениях X и Y, хотя это приведет к растяжению. Если вы загружаете текстуру
     * атласа с помощью этой команды, то subimages.txt файл также будет иметь свои значения, измененные таким образом,
     * чтобы LoadSubImage по-прежнему работал правильно. Параметр кэша больше не используется, так как масштабирование
     * изображения теперь выполняется графическим процессором, поэтому почти не влияет на производительность
     *
     * Пример вызова:
     *
     * int LoadImageResized($szFilename, $scaleX, $scaleY, $cache);
     *
     * void LoadImageResized($iImageID, $szFilename, $scaleX, $scaleY, $cache);
     * @param int $iImageID Идентификатор, который будет использоваться для ссылки на это изображение в будущем
     * @param string $szFilename Имя загружаемого файла
     * @param float $scaleX Сумма для масштабирования в направлении X, 1.0-это исходный размер
     * @param float $scaleY Сумма для масштабирования в направлении Y, 1.0-это исходный размер
     * @param int $cache Больше не используется, должно быть 0
     * @return int|void
     */
    function LoadImageResized(mixed...$args): int
    {
    }

    /*######################################################################################################*/

    /**
     * Загружает изображение из файла в указанный идентификатор изображения, также может использоваться для загрузки
     * текстуры атласа, которая будет использоваться вспомогательными изображениями. При загрузке текстуры атласа
     * должен существовать файл subimages.txt с подробным описанием всех содержащихся в нем изображений.
     * Ширина и высота изображения должны быть от 1 до 2048 пикселей, некоторые устройства могут поддерживать большие
     * размеры, но это не гарантируется. Размер изображений не обязательно должен быть степенью двойки (2,4,8,16,32 и
     * т. Д.).Если у вас много маленьких изображений, вы можете объединить их в текстуру атласа для повышения
     * производительности.
     *
     * ################################################
     *
     * void LoadImage ($ID, $sImageFilename, $bBlackToAlpha);
     *
     * void LoadImage( $ID, $sImageFilename );
     *
     * int LoadImage( $sImageFilename, $bBlackToAlpha );
     *
     * int LoadImage( $sImageFilename );
     *
     * ################################################
     *
     * @param int $ID Идентификатор, который будет использоваться для ссылки на это изображение позже.
     * @param string $sImageFilename Имя файла загружаемого изображения.
     * @param int $bBlackToAlpha Установите значение 1, чтобы переопределить альфа-канал изображения, чтобы он был
     *     прозрачным там, где есть черные пиксели, и непрозрачным в противном случае (по умолчанию 0)
     * @return mixed
     */
    function LoadImage(...$value): mixed
    {

    }



    /*######################################################################################################*/

    /**
     * Загружает файл шрифта в AGK, как правило, в формате TrueType, но все, что поддерживается FreeType, должно
     * работать. Параметр szFontFile может быть либо файлом шрифта, расположенным в вашей папке мультимедиа, либо
     * именем системного шрифта, эта команда сначала проверит вашу папку мультимедиа, прежде чем проверять наличие
     * системных шрифтов. Если вы загружаете системный шрифт, то расширение файла является необязательным, например
     * "Arial.ttf" и "Arial" будут загружать системный шрифт "Arial", если он существует. При загрузке системного
     * шрифта имя файла не должно иметь никаких путей к папкам в имени файла, то есть никаких прямых или обратных косых
     * черт. Чтобы повысить производительность, вы должны загрузить шрифт только один раз. Например, если вы хотите
     * использовать шрифт "Arial" в нескольких местах, то вам следует загрузить его в идентификатор, а затем
     * использовать этот идентификатор для всех целей, а не загружать несколько копий файла шрифта Arial в отдельные
     * идентификаторы.
     *
     *
     * Пример вызова:
     *
     * int LoadFont($szFontFile);
     *
     * void LoadFont($iFontID, $szFontFile);
     * @param int $iFontID Идентификатор, который будет использоваться для ссылки на этот шрифт в будущем
     * @param string $szFontFile Имя файла загружаемого шрифта
     * @return int|void
     */
    function LoadFont(mixed...$args): int
    {
    }


    /**
     * Загружает текущий статус согласия пользователя с сервера AdMob, это необходимо сделать перед вызовом
     * RequestConsentAdMob. Вы должны дождаться, пока GetConsentStatusAdMob вернет неотрицательное значение, прежде чем
     * использовать другие команды согласия AdMob.
     *
     * @param string $szPubID Идентификатор издателя для вашей учетной записи AdMob
     * @param string $privacyPolicy URL
     * @return void
     */
    function LoadConsentStatusAdMob($szPubID, $privacyPolicy)
    {
    }

    /**
     * Загружает шейдер, используемый для изменения целей рендеринга, поскольку он содержит только пиксельный шейдер,
     * вершинный шейдер автоматически генерируется, чтобы убедиться, что он применим к полному экрану. Этот тип шейдера
     * должен применяться только к объектам, созданным с помощью CreateObjectQuad, но ничего плохого не произойдет,
     * если вы решите применить его к другим объектам, он просто даст необычные результаты рендеринга для этого
     * объекта. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет
     * автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version".
     * Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах.
     * Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера. Возвращает
     * идентификатор, который можно использовать для ссылки на этот шейдер в других командах. Идентификаторы являются
     * общими для всех типов шейдеров, поэтому загрузка полноэкранного шейдера в ID 1 не будет работать, если
     * существует обычный шейдер с ID 1.
     *
     * Пример вызова:
     *
     * int LoadFullScreenShader($szPixelFile);
     *
     * void LoadFullScreenShader($shaderID, $szPixelFile);
     * @param int $shaderID Идентификатор, используемый для ссылки на этот шейдер в других командах.
     * @param string $szPixelFile Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return int|void
     */
    function LoadFullScreenShader(mixed...$args): int
    {
    }

    /**
     * Возвращает количество символов в данной строке. Обратите внимание, что для строк, закодированных в UTF-8, это
     * может быть не равно количеству байтов в строке, так как каждый символ может использовать до 4 байт. Для
     * определения длины в байтах используйте команду ByteLen.
     *
     * @param string $strin Строка для измерения длины
     * @return int
     */
    function Len($strin)
    {
    }

    /**
     * Обрезает заданную строку, сохраняя наибольшее количество символов слева до заданного значения счетчика.
     *
     * @param string $strin Строка, которую нужно обрезать
     * @param int $count Количество символов, которые нужно сохранить
     * @return string
     */
    function Left($strin, $count)
    {
    }

    /**
     * Пинает клиента из сети. Это происходит не сразу, и клиент может оставаться в течение нескольких кадров, прежде
     * чем его окончательно пнут. Клиент отключится обычным способом, вы должны проверить GetNetworkClientDisconnected,
     * чтобы обнаружить, когда клиент был выгнан, а затем вызвать DeleteNetworkClient, чтобы окончательно избавиться от
     * него.
     *
     * @param int $iNetID Идентификатор сети.
     * @param int $client идентификатор клиента, которого нужно пнуть.
     * @return void
     */
    function KickNetworkClient($iNetID, $client)
    {
    }

    /**
     * Соединяет два пути вместе и упрощает их, например, соединение пути с ../ удалит последнюю папку из пути. При
     * необходимости между ними будет добавлена прямая косая черта, если первый путь заканчивается прямой косой чертой,
     * а второй путь начинается с прямой косой черты, то один из них будет удален, чтобы сделать правильный путь. Любые
     * обратные косые черты будут преобразованы в прямые косые черты. Первый путь может быть относительным или
     * абсолютным, второй путь должен быть относительным. Это не будет проверено.
     *
     * @param string $szPath Первая часть пути
     * @param string $szPath2 Вторая часть пути
     * @return string
     */
    function JoinPaths($szPath, $szPath2)
    {
    }

    /**
     * Перемещает контроллер вверх на высоту прыжка.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Jump3DPhysicsCharacterController($objID)
    {
    }

    /**
     * Присоединяется к сети AGK, размещенной другим приложением. Сеть определяется по имени или по IP-адресу и номеру
     * порта. Для именованных сетей приложение будет искать любые сети AGK, транслируемые с этим именем, и подключаться
     * к ним, если они будут найдены. В качестве альтернативы, используя IP-адрес и номер порта, вы попытаетесь
     * установить прямое соединение с хостом. В случае подключения к Интернету IP-адрес и порт-это единственный способ
     * подключения, так как широковещательные передачи не покидают локальную сеть. IP-адреса могут быть IPv4 или IPv6 в
     * зависимости от того, какие IP-адреса использует хост (он может иметь один или несколько из них). Вы можете
     * обнаружить все сети, доступные для подключения, настроив прослушиватель широковещательных передач и прослушивая
     * их самостоятельно, а затем отобразить список обнаруженных сетей пользователю, чтобы он мог решить, к какой из
     * них подключиться. Эта функция не подключается сразу, она возвращает идентификатор сети и продолжает пытаться
     * подключиться в фоновом режиме. Вы можете определить, когда установлено соединение, проверив, что
     * GetNetworkNumClients больше 1, что указывает на то, что по крайней мере локальный клиент и серверный клиент были
     * обнаружены. Если IsNetworkActive возвращает 0 в любой момент, то соединение с сервером не удалось и сеть должна
     * быть закрыта, вы можете попытаться восстановить соединение, открыв новую сеть. После подключения приложение
     * становится клиентом сети вместе с хостом и любыми другими клиентами, которые подключились к нему. Все клиенты
     * обрабатываются одинаково и имеют список локальных переменных, которые они могут читать и записывать, все клиенты
     * также могут читать любые переменные на других клиентах только для чтения. Вы должны идентифицировать своего
     * клиента с именем клиента, которое будет видно другим клиентам, имя клиента не обязательно должно быть
     * уникальным. Возвращает идентификатор сети, используемый при взаимодействии с этой сетью. Не работает при
     * экспорте в HTML5
     *
     * Пример вызова:
     *
     * int JoinNetwork($szIP, $port, $szMyName);
     *
     * int JoinNetwork($szNetworkName, $szMyName);
     * @param string $szIP IP-адрес хоста для подключения может быть IPv4 или IPv6.
     * @param int $port Порт для подключения.
     * @param string $szNetworkName Имя сети для подключения.
     * @param string $szMyName Имя, которое нужно использовать для идентификации этого клиента.
     * @return int
     */
    function JoinNetwork(mixed...$args): int
    {
    }

    /**
     * Эта команда возвращает 1, если текущее устройство поддерживает использование изображений глубины с помощью
     * SetRenderToImage. Если это возвращает 0, то единственными допустимыми идентификаторами изображения глубины для
     * SetRenderToImage являются 0 для отсутствия глубины или -1 для нормального буфера глубины.
     *
     * @return int
     */
    function IsSupportedDepthTexture()
    {
    }

    /**
     * Возвращает 1, если Speak был вызван, а текст еще не закончен. Если несколько элементов текста были поставлены в
     * очередь, то эта команда будет продолжать возвращать 1 до тех пор, пока все они не будут произнесены или не будет
     * вызван StopSpeaking.  В настоящее время работает только на iOS и Android.
     *
     * @return int
     */
    function IsSpeaking()
    {
    }

    /**
     * Возвращает 1, если запись экрана в данный момент активна, и 0, если она остановилась. На Android он мог
     * остановиться, потому что приложение было отправлено в фоновый режим или было активировано другое действие,
     * например покупка в приложении.
     *
     * @return int
     */
    function IsScreenRecording()
    {
    }

    /**
     * Еще не функционирует.
     *
     * @return int
     */
    function IsSoundRecording()
    {
    }

    /**
     * Проверяет, что сеть активна, в случае присоединения к сети это вернет 0, если соединение не удалось или по
     * какой-то причине соединение с сервером разорвалось. Для хостера эта функция вернет 0, если ему не удалось
     * прослушать указанный порт для клиентов, в противном случае она навсегда вернет 1, так как не перестанет
     * управлять никакими подключенными клиентами, даже если все отключатся.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function IsNetworkActive($iNetID)
    {
    }

    /**
     * Возвращает 1, если AGK в данный момент отображает экран выбора изображения и ждет, пока пользователь выберет
     * изображение. Когда это возвращает 0, пользователь либо отменил, либо выбрал изображение, проверьте
     * GetChosenImage, чтобы увидеть, каков был результат.
     *
     * @return int
     */
    function IsChoosingImage()
    {
    }

    /**
     * Эта функция устарела, вместо нее используйте SetDeviceCameraToImage. Возвращает 1, если AGK в данный момент
     * отображает ленту камеры и ждет, когда пользователь захватит изображение. Когда это возвращает 0, пользователь
     * либо отменил, либо захватил изображение, проверьте GetCapturedImage, чтобы увидеть, каков был результат.
     *
     * @return int
     */
    function IsCapturingImage()
    {
    }

    /**
     * Возвращает 1, если данный путь является абсолютным, 0, если он относителен. Это зависит от платформы, поэтому
     * путь, начинающийся с "C:/", считается абсолютным в Windows, но не в Linux, в то время как путь, начинающийся с
     * прямой косой черты, считается абсолютным в Linux, но не в Windows. Путь может начинаться с префикса "raw:" или
     * нет, принимаются оба варианта.
     *
     * @param string $szPath Путь для проверки
     * @return int
     */
    function IsAbsolutePath($szPath)
    {
    }

    /**
     * Возвращает 1, если Тряпичная кукла статична.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function Is3dPhysicsRagdollStatic(int $objID): int
    {
    }


    /**
     * Копирует объект в новый идентификатор, новый объект делится данными вершин с исходным объектом. Исходный объект
     * должен существовать для того, чтобы экземпляр объекта рисовался правильно. Создание экземпляра объекта, который
     * уже является экземпляром, ничего не даст. Создание экземпляра объекта, а затем удаление оригинала, вероятно,
     * приведет к сбою. Установка шейдера на объект экземпляра разрешена до тех пор, пока атрибуты вершин, используемые
     * шейдером, точно совпадают по имени и порядку с теми, которые используются на шейдере исходного объекта.
     * Поддерживается установка различных изображений на экземпляре и исходном объекте.
     *
     *
     * Пример вызова:
     *
     * int InstanceObject($objID); - вернет ID скопированного объекта.
     *
     * void InstanceObject($newobjID,$objID); - задает ID при копировании объекта.
     *
     * @param int ...$objID Идентификатор нового объекта (и/или) идентификатор объекта для копирования.
     * @return mixed
     */
    function InstanceObject(int...$objID): mixed
    {
    }

    /**
     * После установки названия покупки в приложении и добавления идентификаторов продуктов вызовите
     * InAppPurchaseSetup, чтобы завершить процесс. После этого момента вы можете попытаться приобрести разблокируемый
     * контент. В настоящее время эта команда поддерживается только на iOS и Android.
     *
     * @return void
     */
    function InAppPurchaseSetup()
    {
    }

    /**
     * Устанавливает все необходимые внутренние данные при настройке IAP для этой платформы. В настоящее время это
     * относится только к Google Play и Ouya, где вам нужно предоставить свой открытый ключ в base64. Это должно быть
     * вызвано перед InAppPurchaseSetup. Чтобы найти открытый ключ для приложений Google Play, откройте сведения о
     * приложении в консоли Google PlayDeveloper и нажмите кнопку Службы и API. Открытый ключ будет находиться в поле
     * под названием "Ваш лицензионный ключ для этого приложения".
     *
     * @param string $szData1 Открытый ключ
     * @param string $szData2 Разработчик UUID (только Ouya)
     * @return void
     */
    function InAppPurchaseSetKeys($szData1, $szData2)
    {
    }

    /**
     * Задает имя приложения таким образом, чтобы оно отображалось в любых диалоговых окнах, отображаемых при
     * использовании команд покупки в приложении. В настоящее время эта команда поддерживается только на iOS и Android.
     *
     * @param string $szTitle Название вашей заявки
     * @return void
     */
    function InAppPurchaseSetTitle($szTitle)
    {
    }

    /**
     * Восстанавливает все управляемые покупки, сделанные на этой платформе. Например, если пользователь приобрел
     * товар, а затем переустановил приложение, то приложение вернет 0 для GetInAppPurchaseAvailable, если оно не было
     * приобретено снова. Несмотря на то, что это не будет взимать плату с пользователя снова за управляемые товары,
     * Apple требует, чтобы у вас была кнопка, вызывающая эту функцию, вместо того чтобы заставлять пользователя снова
     * проходить процесс покупки. После вызова этой команды вы можете вызвать GetInAppPurchaseAvailable. В настоящее
     * время эта команда поддерживается только на iOS. Эта команда не нужна на Android и Amazon, так как она
     * автоматически восстанавливается в InAppPurchaseSetup
     *
     * @return void
     */
    function InAppPurchaseRestore()
    {
    }

    /**
     * Используйте эту команду для добавления любых идентификаторов продуктов в список, например
     * com.yourcompany.yourproduct.iap. Первый идентификатор продукта, который вы добавляете, становится 0, второй-1 и
     * т. Д. Вы также должны указать тип этого продукта: расходуемый (1) или непотребляемый(0). Расходные материалы-это
     * как монеты, которые можно покупать снова и снова, они называются неуправляемыми предметами в Google Play.
     * Непотребляемые продукты-это одноразовые покупки, такие как разблокировка полной версии приложения, они
     * называются управляемыми элементами Google Play. В настоящее время эта команда поддерживается только на iOS,
     * Google Play и Amazon. Это должно быть вызвано до InAppPurchaseSetup, после чего никакие другие продукты не могут
     * быть добавлены.
     *
     * @param string $szID Идентификатор продукта, указанный в iTunes Connect или консоли разработчика Google Play
     * @param int $type Тип этого продукта-расходуемый (1) или непотребляемый(0)
     * @return void
     */
    function InAppPurchaseAddProductID($szID, $type)
    {
    }

    /**
     * Вызовите это, когда вы хотите начать процесс активации / разблокировки дополнительного контента. В настоящее
     * время эта команда поддерживается только на iOS и Android.
     *
     * @param int $iID этот идентификатор соответствует идентификаторам продуктов, которые были добавлены, например,
     *     ваш первый продукт
     * @return void
     */
    function InAppPurchaseActivate($iID)
    {
    }

    /**
     * Создает сеть AGK с этим приложением в качестве контроллера, это приложение добавляется в качестве первого
     * клиента в сеть. Сети AGK идентифицируются по имени и автоматически транслируются всем, кто слушает в локальной
     * сети, а это означает, что другие приложения AGK в локальной сети могут принимать все широковещательные сети,
     * отображать их имена своим пользователям и позволять им выбирать одну из них для присоединения. Приложения AGK
     * вне локальной сети нуждаются в IP-адресе и порту хостера, чтобы присоединиться к сети, этот порт будет нуждаться
     * в переадресации на хост через любой промежуточный брандмауэр. Значение порта должно быть между 1025 и 65535 и
     * завершится ошибкой, если другое приложение уже прослушивает этот порт. Вы также должны указать имя клиента,
     * которое будет использоваться для идентификации вашего клиента, все имена клиентов должны быть уникальными. Это
     * имя будет видно всем остальным клиентам. Клиенты будут добавлены в сеть автоматически и могут быть подсчитаны с
     * помощью GetNetworkNumClients. Вы можете вызвать IsNetworkActive сразу после этой команды, чтобы проверить, что
     * сеть была успешно настроена, после установки сеть не станет неактивной для хостера. После подключения приложение
     * становится клиентом сети, и все другие клиенты, подключающиеся к нему, присоединяются к сети. Все клиенты
     * обрабатываются одинаково и имеют список локальных переменных, которые они могут читать и записывать, все клиенты
     * также могут читать любые переменные на других клиентах только для чтения. Некоторые порты используются AGK для
     * внутренней сети и не должны использоваться вашим приложением. Порты 5689-5692 используются для управления
     * приложениями, транслируемыми из IDE. Порты 45631 и 45632 используются для именованных сетевых соединений. В
     * сетях IPv4 сетевая трансляция идет на все устройства в локальной подсети, в сетях IPv6 трансляция идет на адрес
     * AGK multicast "FF02::41:474B". Если устройство имеет как IPv4, так и IPv6 IP-адреса, то хост-сеть будет
     * принимать соединения как из сетей IPv4, так и из сетей IPv6. Если вы укажете 0 для порта, то он отключит
     * IPv4-соединения, если вы установите portv6 в 0, то он отключит IPv6-соединения. По крайней мере один должен быть
     * больше 0, иначе будет сгенерирована ошибка. Если вы вообще не укажете portv6, то он будет установлен в 0. Должно
     * быть безопасно использовать один и тот же порт как для IPv4, так и для IPv6, но это не было широко
     * протестировано. Возвращает идентификатор, который можно использовать для взаимодействия с этой сетью. Не
     * работает при экспорте в HTML5
     *
     * @param string $szNetworkName Имя, используемое для идентификации этой сети.
     * @param string $szMyName Имя, которое нужно использовать для идентификации этого клиента.
     * @param int $port Порт, который другие клиенты должны использовать для подключения к этой сети при использовании
     *     IPv4, 0 для отключения IPv4-соединений.
     * @param int|null $portv6 Порт, который другие клиенты должны использовать для подключения к этой сети при
     *     использовании IPv6, 0 для отключения соединений IPv6.
     * @return int
     */
    function HostNetwork(string $szNetworkName, string $szMyName, int $port, int $portv6 = null): int
    {
    }

    /**
     * Преобразует шестнадцатеричную строку в строку Base64. Шестнадцатеричная строка-это строка, содержащая только
     * символы 0-9 и A-F. Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите
     * с ней.
     *
     * @param string $input Строка для преобразования
     * @return string
     */
    function HexToBase64($input)
    {
    }

    /**
     * Кодирует строку таким образом, чтобы она могла быть отправлена на сервер по протоколу HTTP без вмешательства в
     * HTTP-запрос. Например, если вы хотите отправить переменную POST, содержащую символы & или=, они будут выглядеть
     * как дополнительные переменные внутри строки, которую вы хотите отправить. Использование HTTPEncode в этой строке
     * превратит эти символы в ПОСТ-безопасные значения, которые затем автоматически преобразуются обратно в исходные
     * символы, как только они достигнут чего-то вроде PHP-скрипта. При этом используется стандартная кодировка
     * URL-адреса для не буквенно-цифровых символов, оставляя только буквенно-цифровые символы.
     *
     * @param string $str Строка для кодирования
     * @return string
     */
    function HTTPEncode($str)
    {
    }

    /**
     * Преобразует целочисленное значение в строку, содержащую его шестнадцатеричное представление. Например, Hex(31)
     * вернет строку, содержащую "1F". Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда
     * вы закончите с ней.
     *
     * @param int $i Целочисленное значение для преобразования в шестнадцатеричную строку
     * @return string
     */
    function Hex($i)
    {
    }

    /**
     * Декодирует строку, закодированную URL-адресом. Он может декодировать все буквенно-цифровые символы и большинство
     * не буквенно-цифровых символов.
     *
     * @param string $str Строка для декодирования
     * @return string
     */
    function HTTPDecode($str)
    {
    }

    /**
     * Возвращает значение от 0 до 100 для представления хода извлечения zip-файла, запущенного с помощью
     * ExtractZipASync.
     *
     * @return float
     */
    function GetZipExtractProgress()
    {
    }

    /**
     * Возвращает год заданного значения времени unix. Время Unix представлено как количество секунд с 1 января 1970
     * года, оно также может быть отрицательным. Если не использовать 64 - битные значения, то значение времени unix
     * ограничено периодом с 1901 по 2038 год.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetYearFromUnix($unixtime)
    {
    }

    /**
     * Возвращает 0, если выполняется извлечение zip-файла, начатое с помощью ExtractZipASync, или 1, если оно
     * завершено. Он не дает указания на то, была ли добыча успешной, только на то, что она закончилась.
     *
     * @return int
     */
    function GetZipExtractComplete()
    {
    }

    /**
     * Возвращает каталог, в который будут записаны новые файлы на текущей платформе, на которой работает приложение.
     *
     * @return string
     */
    function GetWritePath()
    {
    }

    /**
     * Преобразует точку на спрайте в мировые координаты. Например,если спрайт 10x10 был повернут на 45 градусов вокруг
     * своей центральной точки (в точке 5x5), то, чтобы найти положение в мире верхнего левого угла спрайта, вы бы
     * вызвали эту команду со значениями -5, -5, так как значения относятся к центральной точке спрайта (определяемой
     * SetSpriteOffset). Команда не ограничена размером спрайта, поэтому в приведенном выше примере допустимы значения
     * 20 или -15.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $x X-компонент точки на спрайте.
     * @param float $y Компонент Y точки на спрайте.
     * @return float
     */
    function GetWorldYFromSprite($iSpriteIndex, $x, $y)
    {
    }

    /**
     * Преобразует точку на спрайте в мировые координаты. Например,если спрайт 10x10 был повернут на 45 градусов вокруг
     * своей центральной точки (в точке 5x5), то, чтобы найти положение в мире верхнего левого угла спрайта, вы бы
     * вызвали эту команду со значениями -5, -5, так как значения относятся к центральной точке спрайта (определяемой
     * SetSpriteOffset). Команда не ограничена размером спрайта, поэтому в приведенном выше примере допустимы значения
     * 20 или -15.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $x X-компонент точки на спрайте.
     * @param float $y Компонент Y точки на спрайте.
     * @return float
     */
    function GetWorldXFromSprite($iSpriteIndex, $x, $y)
    {
    }

    /**
     * Возвращает букву диска указанного диска, от 0 до CountWindowsDrives минус один. Значения вне этого диапазона
     * будут возвращать пустую строку. Возвращаемая строка будет включать букву диска и двоеточие, больше ничего. Это
     * относится только к Windows, другие платформы вернут пустую строку. Если вы вызываете эту команду из уровня 2, то
     * вы должны удалить возвращенную строку с помощью agk::DeleteString (), когда закончите с ней.
     *
     * @param int $index Индекс диска для возврата
     * @return string
     */
    function GetWindowsDrive($index)
    {
    }

    /**
     * Возвращает высоту окна текущего устройства. Это значение может отличаться от GetDeviceHeight, если размер окна
     * не соответствует размеру пикселя backbuffer, который используется для рисования окна. Например, на Mac с
     * дисплеем Retina размер окна будет равен половине размера пикселя.
     *
     * @return int
     */
    function GetWindowHeight()
    {
    }

    /**
     * Возвращает ширину окна текущего устройства. Это значение может отличаться от GetDeviceWidth, если размер окна не
     * соответствует размеру пикселя backbuffer, который используется для рисования окна. Например, на Mac с дисплеем
     * Retina размер окна будет равен половине размера пикселя.
     *
     * @return int
     */
    function GetWindowWidth()
    {
    }

    /**
     * Возвращает координату для крайней правой части экрана. В системе координат, основанной на процентах по
     * умолчанию, это 100. Если вы настроили виртуальное разрешение с помощью SetVirtualResolution, то будет возвращена
     * указанная здесь ширина.
     *
     * @return int
     */
    function GetVirtualWidth()
    {
    }

    /**
     * Возвращает значение X виртуального джойстика по заданному индексу. Это будет находиться в диапазоне от -1.0 до
     * 1.0 с центрированием 0. Когда пользователь не взаимодействует с виртуальным джойстиком, он возвращает 0.
     *
     * @param int $index Идентификатор виртуального джойстика для проверки.
     * @return float
     */
    function GetVirtualJoystickX($index)
    {
    }

    /**
     * Возвращает значение Y виртуального джойстика по заданному индексу. Это будет находиться в диапазоне от -1.0 до
     * 1.0 с центрированием 0. Когда пользователь не взаимодействует с виртуальным джойстиком, он возвращает 0.
     *
     * @param int $index Идентификатор виртуального джойстика для проверки.
     * @return float
     */
    function GetVirtualJoystickY($index)
    {
    }

    /**
     * Возвращает 1, если виртуальный джойстик существует по заданному индексу. Должно быть в диапазоне от 1 до 4.
     *
     * @param int $index Идентификатор виртуального джойстика для проверки.
     * @return int
     */
    function GetVirtualJoystickExists($index)
    {
    }

    /**
     * Возвращает координату для нижней части экрана. В системе координат, основанной на процентах по умолчанию, это
     * 100. Если вы настроили виртуальное разрешение с помощью SetVirtualResolution, то будет возвращена указанная
     * здесь высота.
     *
     * @return int
     */
    function GetVirtualHeight()
    {
    }

    /**
     * Возвращает 1, если виртуальная кнопка в данный момент находится внизу, и 0, если она поднята. Используйте
     * GetVirtualButtonPressed или GetVirtualButtonReleased, чтобы проверить, нажата или отпущена ли кнопка.
     *
     * @param int $index Идентификатор виртуальной кнопки для проверки.
     * @return int
     */
    function GetVirtualButtonState($index)
    {
    }

    /**
     * Возвращает 1 если виртуальная кнопка была нажата в этом кадре, то после первоначального нажатия эта функция
     * вернется к 0. Используйте GetVirtualButtonState, чтобы проверить, находится ли виртуальная кнопка вверх или
     * вниз.
     *
     * @param int $index Идентификатор виртуальной кнопки для проверки.
     * @return int
     */
    function GetVirtualButtonPressed($index)
    {
    }

    /**
     * Возвращает 1 если виртуальная кнопка была выпущена в этом кадре, то после первоначального выпуска эта функция
     * вернется к 0. Используйте GetVirtualButtonState, чтобы проверить, находится ли виртуальная кнопка вверх или
     * вниз.
     *
     * @param int $index Идентификатор виртуальной кнопки для проверки.
     * @return int
     */
    function GetVirtualButtonReleased($index)
    {
    }

    /**
     * Возвращает 1, если виртуальная кнопка существует в данном индексе. 0 в противном случае.
     *
     * @param int $index Идентификатор виртуальной кнопки для проверки.
     * @return int
     */
    function GetVirtualButtonExists($index)
    {
    }

    /**
     * Возвращает текущий уровень масштабирования прокрутки, установленный с помощью SetViewZoom.
     *
     * @return float
     */
    function GetViewZoom()
    {
    }

    /**
     * Возвращает текущее смещение вида в направлении Y, заданное с помощью SetViewOffset.
     *
     * @return float
     */
    function GetViewOffsetY()
    {
    }

    /**
     * Возвращает текущее смещение вида в направлении X, заданное с помощью SetViewOffset.
     *
     * @return float
     */
    function GetViewOffsetX()
    {
    }

    /**
     * Возвращает ширину в пикселях текущего загруженного видео, если это возвращает 0, то вызовите его в цикле с
     * помощью функции Sync (), чтобы дождаться завершения загрузки метаданных видео. Если он возвращает меньше 0, то
     * эта платформа не поддерживает эту команду или произошла ошибка. пример: width = GetVideoWidth() if ( width = 0 )
     * repeat Sync() width = GetVideoWidth() until width != 0 endif
     *
     * @return float
     */
    function GetVideoWidth()
    {
    }

    /**
     * Возвращает 1, если видео воспроизводится в данный момент, 0, если оно закончено или остановлено с помощью
     * stopVideo() или PauseVideo().
     *
     * @return int
     */
    function GetVideoPlaying()
    {
    }

    /**
     * Возвращает количество секунд, сыгранных до сих пор.
     *
     * @return float
     */
    function GetVideoPosition()
    {
    }

    /**
     * Возвращает высоту в пикселях текущего загруженного видео, если это возвращает 0, то вызовите его в цикле с
     * помощью функции Sync (), чтобы дождаться завершения загрузки метаданных видео. Если он возвращает меньше 0, то
     * эта платформа не поддерживает эту команду или произошла ошибка. пример: height = GetVideoHeight() if ( height =
     * 0 ) repeat Sync() height = GetVideoHeight() until height != 0 endif
     *
     * @return float
     */
    function GetVideoHeight()
    {
    }

    /**
     * Возвращает количество секунд, в течение которых видео длится от начала до конца. Если это возвращает 0, то
     * вызовите его в цикле с помощью функции Sync (), чтобы дождаться завершения загрузки метаданных видео. Если он
     * возвращает меньше 0, то эта платформа не поддерживает эту команду или произошла ошибка. пример: duration =
     * GetVideoDuration() if ( duration = 0 ) repeat Sync() duration = GetVideoDuration() until duration != 0 endif
     *
     * @return float
     */
    function GetVideoDuration()
    {
    }

    /**
     * Возвращает количество вершин, обработанных последним кадром графического процессора.
     *
     * @return int
     */
    function GetVerticesProcessed()
    {
    }

    /**
     * Получает z из вектора.
     *
     * @param int $vectorID идентификатор вектора
     * @return float
     */
    function GetVector3Z($vectorID)
    {
    }

    /**
     * Получает y из вектора.
     *
     * @param int $vectorID идентификатор вектора
     * @return float
     */
    function GetVector3Y($vectorID)
    {
    }

    /**
     * Получает x из вектора.
     *
     * @param int $vectorID идентификатор вектора
     * @return float
     */
    function GetVector3X($vectorID)
    {
    }

    /**
     * Умножает компоненты данного вектора на данный множитель
     *
     * @param int $resultVec ИДЕНТИФИКАТОР вектора для умножения.
     * @param float $multiplier плавающее значение для умножения.
     * @return void
     */
    function GetVector3Multiply($resultVec, $multiplier)
    {
    }

    /**
     * Возвращает длину вектора
     *
     * @param int $vectorID Идентификатор вектора
     * @return float
     */
    function GetVector3Length($vectorID)
    {
    }

    /**
     * Возвращает расстояние между 2 векторами.
     *
     * @param int $vectorU Идентификатор первого вектора
     * @param int $vectorV Идентификатор второго вектора
     * @return float
     */
    function GetVector3Distance($vectorU, $vectorV)
    {
    }

    /**
     * Заполняет результирующий вектор перекрестным произведением 2 переданных векторов.
     *
     * @param int $resultVec ИДЕНТИФИКАТОР вектора для результатов
     * @param int $vectorU Идентификатор первого вектора
     * @param int $vectorV Идентификатор второго вектора
     * @return void
     */
    function GetVector3Cross($resultVec, $vectorU, $vectorV)
    {
    }

    /**
     * Возвращает точечное произведение 2 векторов
     *
     * @param int $vectorU Идентификатор первого вектора
     * @param int $vectorV Идентификатор второго вектора
     * @return float
     */
    function GetVector3Dot($vectorU, $vectorV)
    {
    }

    /**
     * Заполняет вектор resultVec суммой вектора resultVec и вектора addVec.
     *
     * @param int $resultVec ИДЕНТИФИКАТОР вектора для добавления и удержания результатов.
     * @param int $addVec ИДЕНТИФИКАТОР вектора для добавления.
     * @return void
     */
    function GetVector3Add($resultVec, $addVec)
    {
    }

    /**
     * Возвращает количество секунд и долей секунд, потраченных на обновление всего в мире, кроме физики. Это включает
     * в себя анимацию спрайтов, эмуляцию ввода и обработку звуков.
     *
     * @return float
     */
    function GetUpdateTime()
    {
    }

    /**
     * Возвращает текущую дату и время в формате unix time, которое измеряется в секундах с 1 января 1970 года. Он
     * может быть отрицательным для дат до 1970 года.
     *
     * @return int
     */
    function GetUnixTime()
    {
    }

    /**
     * Преобразует заданную дату и время в свой эквивалент времени unix, unix time-это количество секунд с 1 января
     * 1970 года. Если не использовать 64 - битные значения, то значение времени unix ограничено периодом с 1901 по
     * 2038 год.
     *
     * @param int $year Годовая часть даты.
     * @param int $month Месячная часть даты, в диапазоне от 1 до 12.
     * @param int $days Дневная часть даты, в диапазоне от 1 до 31.
     * @param int $hours Часовая часть даты, в диапазоне от 0 до 23.
     * @param int $minutes Минутная часть даты, в диапазоне от 0 до 59.
     * @param int $seconds Секундная часть даты в диапазоне от 0 до 59.
     * @return int
     */
    function GetUnixFromDate($year, $month, $days, $hours, $minutes, $seconds)
    {
    }

    /**
     * Возвращает количество изображений, загруженных в данный момент в приложение, но не назначенных спрайту или
     * текстовому объекту. Это полезно для отладки, чтобы проверить, что вы удалили все неиспользуемые изображения при
     * переключении из меню на уровень или с одного уровня на другой.
     *
     * @return int
     */
    function GetUnassignedImages()
    {
    }

    /**
     * Возвращает имя файла указанного неназначенного изображения.
     *
     * @param int $index Индекс неназначенного изображения, между 1 и значением, возвращаемым GetUnassignedImages
     * @return string
     */
    function GetUnassignedImageFileName($index)
    {
    }

    /**
     * На Android и iOS это возвращает полный URL-адрес, который был использован для открытия этого приложения, если
     * использовалась схема URL-адресов. Например, если вы установили схему URL-адресов "myapp" для этого приложения и
     * пользователь нажимает на ссылку типа "myapp: sometext", то ОС откроет ваше приложение, а GetURLSchemeText будет
     * возвращать "myapp: sometext" до тех пор, пока приложение не будет открыто в следующий раз. Если URL - адрес не
     * был использован для открытия приложения или платформа не поддерживает схемы URL-адресов, то будет возвращена
     * пустая строка. При выборе схемы URL-адресов вы должны убедиться, что она уникальна для вашего приложения, так
     * как iOS не позволит двум приложениям иметь одну и ту же схему.
     *
     * @return string
     */
    function GetURLSchemeText()
    {
    }

    /**
     * Проверяет прослушиватель UDP на наличие любых широковещательных передач. Возвращает 0, если ничего не было
     * получено. Возвращает идентификатор сообщения если что-то было получено, вы можете получить доступ к содержимому
     * этого сообщения с помощью команд сетевого сообщения. Сообщение должно быть удалено, когда вы закончите чтение.
     *
     * @param int $listenerID Идентификатор прослушивателя для проверки сообщений
     * @return int
     */
    function GetUDPNetworkMessage($listenerID)
    {
    }

    /**
     * Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном текстовом объекте, в
     * противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @param int $textID ИДЕНТИФИКАТОР текста для проверки
     * @return int
     */
    function GetTweenTextPlaying($tweenID, $textID)
    {
    }

    /**
     * Возвращает 1, если существует анимация с заданным идентификатором и это текстовая анимация, в противном случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenTextExists($tweenID)
    {
    }

    /**
     * Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном спрайте, в противном
     * случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @param int $spriteID Идентификатор спрайта для проверки
     * @return int
     */
    function GetTweenSpritePlaying($tweenID, $spriteID)
    {
    }

    /**
     * Возвращает 1, если существует анимация с заданным идентификатором и это спрайт-анимация, в противном случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenSpriteExists($tweenID)
    {
    }

    /**
     * Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном объекте, в противном
     * случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @param int $objectID ИДЕНТИФИКАТОР проверяемого объекта
     * @return int
     */
    function GetTweenObjectPlaying($tweenID, $objectID)
    {
    }

    /**
     * Возвращает 1, если анимация любого типа существует в данном идентификаторе, и 0 в противном случае.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenExists($tweenID)
    {
    }

    /**
     * Возвращает текущее значение четвертого целого числа пользовательского твина.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomInteger4($tweenID)
    {
    }

    /**
     * Возвращает 1, если данный пользовательский идентификатор анимации воспроизводится в данный момент, в противном
     * случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomPlaying($tweenID)
    {
    }

    /**
     * Возвращает текущее значение третьего целого числа пользовательского твина.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomInteger3($tweenID)
    {
    }

    /**
     * Возвращает текущее значение второго целого числа пользовательского твина.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomInteger2($tweenID)
    {
    }

    /**
     * Возвращает текущее значение первого целого числа пользовательского твина.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomInteger1($tweenID)
    {
    }

    /**
     * Возвращает текущее значение четвертого поплавка пользовательской анимации.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return float
     */
    function GetTweenCustomFloat4($tweenID)
    {
    }

    /**
     * Возвращает текущее значение третьего поплавка пользовательской анимации.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return float
     */
    function GetTweenCustomFloat3($tweenID)
    {
    }

    /**
     * Возвращает текущее значение второго поплавка пользовательской анимации.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return float
     */
    function GetTweenCustomFloat2($tweenID)
    {
    }

    /**
     * Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном символе и текстовом
     * объекте, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @param int $textID ИДЕНТИФИКАТОР текста для проверки
     * @param int $charID Индекс проверяемого символа, индексы начинаются с 0, если он находится вне диапазона, то
     *     игнорируется
     * @return int
     */
    function GetTweenCharPlaying($tweenID, $textID, $charID)
    {
    }

    /**
     * Возвращает 1, если существует анимация с заданным идентификатором и это пользовательская анимация, в противном
     * случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomExists($tweenID)
    {
    }

    /**
     * Возвращает текущее значение первого поплавка пользовательской анимации.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return float
     */
    function GetTweenCustomFloat1($tweenID)
    {
    }

    /**
     * Возвращает 1, если цепочка в данный момент работает со своим списком подростков. Если последняя анимация
     * закончилась или цепочка еще не запущена, она вернет 0.
     *
     * @param int $chainID Идентификатор цепочки для проверки
     * @return int
     */
    function GetTweenChainPlaying($chainID)
    {
    }

    /**
     * Возвращает 1, если анимация существует в данном идентификаторе и это объект tween, в противном случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenObjectExists($tweenID)
    {
    }

    /**
     * Возвращает общую длину цепочки твинов в секундах.
     *
     * @param int $chainID Идентификатор цепочки для проверки
     * @return float
     */
    function GetTweenChainEndTime($chainID)
    {
    }

    /**
     * Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данной камере, в противном
     * случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @param int $cameraID Идентификатор камеры для проверки
     * @return int
     */
    function GetTweenCameraPlaying($tweenID, $cameraID)
    {
    }

    /**
     * Возвращает 1, если анимация существует по заданному идентификатору и это анимация камеры, в противном случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCameraExists($tweenID)
    {
    }

    /**
     * Возвращает текущее положение X текстового объекта в мировых координатах, текст позиционируется с помощью его
     * верхнего левого угла.
     *
     * @param int $iTextIndex Идентификатор возвращаемого текстового объекта.
     * @return float
     */
    function GetTextX($iTextIndex)
    {
    }

    /**
     * Возвращает текущее положение Y текстового объекта в мировых координатах, текст позиционируется с помощью его
     * верхнего левого угла.
     *
     * @param int $iTextIndex Идентификатор возвращаемого текстового объекта.
     * @return float
     */
    function GetTextY($iTextIndex)
    {
    }

    /**
     * Возвращает 0, если текущий текст был установлен как невидимый с помощью SetTextVisible, 1, если он установлен
     * как видимый (по умолчанию). Это не проверяет, находится ли текст в данный момент в видимом видовом окне.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return int
     */
    function GetTextVisible($iTextIndex)
    {
    }

    /**
     * Возвращает текущую ширину текстового объекта в мировых единицах измерения. Если текстовый объект отображает
     * текст в нескольких строках, он возвращает ширину самой длинной строки. Это не учитывает индивидуальные смещения
     * символов, если вы использовали SetTextCharX или что-то подобное для перемещения символа. Возвращаемое
     * значение-это ширина, используемая положением рисунка текстовых символов по умолчанию.
     *
     * @param int $iTextIndex Идентификатор возвращаемого текстового объекта.
     * @return float
     */
    function GetTextTotalWidth($iTextIndex)
    {
    }

    /**
     * Возвращает 1, когда механизм преобразования текста в речь готов начать преобразование текста в речь. Вызов
     * других команд преобразования текста в речь, когда он не готов, будет проигнорирован.  В настоящее время работает
     * только на iOS и Android.
     *
     * @return int
     */
    function GetTextToSpeechReady()
    {
    }

    /**
     * Возвращает текущую высоту текстового объекта в мировых единицах измерения. Это не учитывает индивидуальные
     * смещения символов, если вы использовали SetTextCharY или что-то подобное для перемещения символа. Возвращаемое
     * значение-это высота, используемая для расположения текстовых символов на чертеже по умолчанию. Обратите
     * внимание, что если строка текста пуста, то это значение вернет 0.
     *
     * @param int $iTextIndex Идентификатор возвращаемого текстового объекта.
     * @return float
     */
    function GetTextTotalHeight($iTextIndex)
    {
    }

    /**
     * Возвращает текущую строку, отображаемую текстовым объектом. В tier 2 возвращаемая строка должна быть удалена,
     * когда вы закончите с ней.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return string
     */
    function GetTextString($iTextIndex)
    {
    }

    /**
     * Возвращает текущий размер текстового объекта, заданного с помощью setTextSize.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return float
     */
    function GetTextSize($iTextIndex)
    {
    }

    /**
     * Возвращает текущий интервал текстового объекта, заданного с помощью SetTextSpacing.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return float
     */
    function GetTextSpacing($iTextIndex)
    {
    }

    /**
     * Возвращает 1, если существует анимация с заданным идентификатором и она является char tween, в противном случае
     * 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCharExists($tweenID)
    {
    }

    /**
     * Возвращает текущий межстрочный интервал текстового объекта, заданного с помощью SetTextLineSpacing.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return float
     */
    function GetTextLineSpacing($iTextIndex)
    {
    }

    /**
     * Возвращает текущую длину строки, отображаемой текстовым объектом.
     *
     * @param int $iTextIndex Идентификатор возвращаемого текстового объекта.
     * @return int
     */
    function GetTextLength($iTextIndex)
    {
    }

    /**
     * Возвращает 1 для кадра, который пользователь завершил ввод текста (успешно или нет). После завершения эта
     * команда вернется к 0. На этом этапе вы можете проверить, отменил ли пользователь ввод, используя
     * GetTextInputCancelled.
     *
     * @return int
     */
    function GetTextInputCompleted()
    {
    }

    /**
     * Возвращает 1, если пользователь отменил ввод текста, и 0, если нет. Это значение команды не определяется до тех
     * пор, пока GetTextInputCompleted не вернет 1.
     *
     * @return int
     */
    function GetTextInputCancelled()
    {
    }

    /**
     * Возвращает 0, если пользователь в данный момент вводит текст, и 1, если нет.
     *
     * @return int
     */
    function GetTextInputState()
    {
    }

    /**
     * Возвращает строку, введенную пользователем. Он будет содержать символы, закодированные с помощью UTF-8,
     * некоторые устройства также могут разрешать возврат символов новой строки. Это значение команды не определяется
     * до тех пор, пока GetTextInputCompleted не вернет 1.
     *
     * @return string
     */
    function GetTextInput()
    {
    }

    /**
     * Возвращает 1, если заданная точка в мировых координатах находится внутри ограничивающего прямоугольника текста.
     * Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью
     * ScreenToWorldX и ScreenToWorldY. Это не учитывает отдельные позиции символов, например, если вы расположили
     * символ с помощью SetTextCharX или аналогичного. Проверяется только ограничивающая рамка, созданная путем
     * рисования символов в их позициях по умолчанию.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param float $x Координата x точки для проверки в мировых координатах.
     * @param float $y Координата y точки для проверки в мировых координатах.
     * @return int
     */
    function GetTextHitTest($iTextIndex, $x, $y)
    {
    }

    /**
     * Получите красную составляющую цвета текста. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для проверки.
     * @return int
     */
    function GetTextColorRed($iTextIndex)
    {
    }

    /**
     * Возвращает 1, если текст существует, и 0, если его нет.
     *
     * @param int $iTextIndex Идентификатор текста для проверки
     * @return int
     */
    function GetTextExists($iTextIndex)
    {
    }

    /**
     * Получите зеленую составляющую цвета текста. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для проверки.
     * @return int
     */
    function GetTextColorGreen($iTextIndex)
    {
    }

    /**
     * Возвращает текущую глубину текстового объекта, где 0-передняя часть экрана, а 10000 - задняя.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return int
     */
    function GetTextDepth($iTextIndex)
    {
    }

    /**
     * Получите синий компонент цвета текста. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для проверки.
     * @return int
     */
    function GetTextColorBlue($iTextIndex)
    {
    }

    /**
     * Получите альфа-компонент цвета текста. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для проверки.
     * @return int
     */
    function GetTextColorAlpha($iTextIndex)
    {
    }

    /**
     * Возвращает красный компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона,
     *     он будет проигнорирован.
     * @return int
     */
    function GetTextCharColorRed($iTextIndex, $iCharIndex)
    {
    }

    /**
     * Возвращает текущую позицию Y указанного символа относительно текстового объекта.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона,
     *     он будет проигнорирован.
     * @return float
     */
    function GetTextCharY($iTextIndex, $iCharIndex)
    {
    }

    /**
     * Возвращает текущую позицию X указанного символа относительно текстового объекта.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона,
     *     он будет проигнорирован.
     * @return float
     */
    function GetTextCharX($iTextIndex, $iCharIndex)
    {
    }

    /**
     * Возвращает зеленый компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона,
     *     он будет проигнорирован.
     * @return int
     */
    function GetTextCharColorGreen($iTextIndex, $iCharIndex)
    {
    }

    /**
     * Возвращает синий компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона,
     *     он будет проигнорирован.
     * @return int
     */
    function GetTextCharColorBlue($iTextIndex, $iCharIndex)
    {
    }

    /**
     * Возвращает текущий угол в радианах указанного символа.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона,
     *     он будет проигнорирован.
     * @return float
     */
    function GetTextCharAngleRad($iTextIndex, $iCharIndex)
    {
    }

    /**
     * Возвращает альфа-компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона,
     *     он будет проигнорирован.
     * @return int
     */
    function GetTextCharColorAlpha($iTextIndex, $iCharIndex)
    {
    }

    /**
     * Возвращает текущее выравнивание набора текстовых объектов с помощью SetTextAlignment.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return int
     */
    function GetTextAlignment($iTextIndex)
    {
    }

    /**
     * Возвращает 1, если система содержит шрифт с заданным именем, и 0 в противном случае. Если возвращается 1, то
     * передача того же имени файла в LoadFont будет успешной. В iOS это всегда будет возвращать 0, так как системные
     * файлы шрифтов недоступны, однако AGK поставляется со встроенным шрифтом, который вы можете использовать,
     * используя идентификатор шрифта 0 с текстовыми объектами.
     *
     * @param string $szFontFile Название шрифта для проверки
     * @return int
     */
    function GetSystemFontExists($szFontFile)
    {
    }

    /**
     * Возвращает количество изменяющихся значений, которые могут быть использованы в шейдерах на текущем устройстве.
     * Вариации-это переменные, которые передают данные между вершинным и пиксельным шейдерами. Это значение
     * гарантированно будет не менее 32, но большинство устройств поддерживают больше. Один vec4 varying содержит 4
     * различных значения, поэтому 32 значения varyings означают, что вы можете иметь максимум 8 вариаций vec4.
     * Обратите внимание, что переменная vec3 может занимать 4 пространства значений, если она не может быть упакована
     * с какой-либо другой переменной. Вариации будут автоматически упакованы вместе, если они могут заполнить vec4 без
     * разделения, например, vec3 и поплавок могут быть упакованы вместе, как и два вариации vec2. Однако две вариации
     * vec3 не могут быть упакованы вместе без разделения, поэтому каждая из них будет использовать до 4 значений, а
     * дополнительное пространство будет потрачено впустую.
     *
     * @return int
     */
    function GetSupportedShaderVaryings()
    {
    }

    /**
     * Возвращает определенный токен из строки, разделенной заданным разделителем, например строка, содержащая
     * "first:second:third", имеет три токена, разделенных ":". Аналогично GetStringToken, за исключением того, что эта
     * команда принимает только один символ в качестве разделителя и распознает пустые поля. Например,
     * "first:second::fourth" имеет четыре токена, а третий-пустую строку. В tier 2 возвращаемая строка должна быть
     * удалена, когда вы закончите с ней. Вы можете использовать CountStringTokens2 для подсчета количества токенов в
     * строке.
     *
     * @param string $str Строка для проверки.
     * @param string $delimiter Символ, разделяющий строку.
     * @param int $token индекс возвращаемого токена, начинающийся с 1 для первого токена.
     * @return string
     */
    function GetStringToken2($str, $delimiter, $token)
    {
    }

    /**
     * Возвращает определенный токен из строки, разделенной заданными разделителями, например строка, содержащая
     * "first:second:third", имеет три токена, разделенных ":" и "first:second;third", имеет три токена, разделенных
     * разделителями ":;". Вы можете иметь несколько разделителей между каждым токеном, например "first:;second:third"
     * является допустимым и имеет три токена. В tier 2 возвращаемая строка должна быть удалена, когда вы закончите с
     * ней. Вы можете использовать CountStringTokens для подсчета количества токенов в строке. Эта команда полезна для
     * разделения слов в предложении, которое может быть разделено как пробелом, так и пунктуацией.
     *
     * @param string $str Строка для проверки.
     * @param string $delimiters Набор символов, разделяющих строку.
     * @param int $token индекс возвращаемого токена, начинающийся с 1 для первого токена.
     * @return string
     */
    function GetStringToken($str, $delimiters, $token)
    {
    }

    /**
     * Возвращает общее количество МБ хранения данных по указанному пути, использованных и неиспользуемых. Например,
     * использование пути, указывающего на местоположение на SD-карте на Android, вернет размер sd-карты, в то время
     * как использование пути, указывающего на папку записи AGK, вернет количество МБ во внутреннем хранилище. В
     * некоторых случаях это может быть одно и то же. Эта команда возвращает значение -1, если размер хранилища не
     * может быть определен. В настоящее время реализовано только на iOS и Android, другие платформы вернут -1.
     *
     * @param string $path Путь для проверки
     * @return int
     */
    function GetStorageTotal($path)
    {
    }

    /**
     * Возвращает количество МБ, доступных приложению для хранения данных по указанному пути. Например, использование
     * пути, указывающего на местоположение на SD-карте Android, вернет, сколько МБ может быть сохранено там, в то
     * время как использование пути, указывающего на папку записи AGK, вернет количество МБ, которое приложение может
     * хранить в своем внутреннем хранилище. В некоторых случаях это может быть одно и то же. Эта команда возвращает
     * -1, если доступное пространство не может быть определено. В настоящее время реализовано только на iOS и Android,
     * другие платформы вернут -1.
     *
     * @param string $path Путь для проверки
     * @return int
     */
    function GetStorageRemaining($path)
    {
    }

    /**
     * Преобразует точку пикселя на изображении спрайта в точку на поверхности спрайта, которая представляет, где
     * находится этот пиксель. Например, если изображение размером 200x100 пикселей было назначено спрайту размером
     * 10x10, то вызов этой команды со значением пикселя 50 (центр изображения) вернет 5 (центр спрайта). Для этого
     * спрайту должно быть назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером
     * изображения или спрайта, поэтому в приведенном выше примере допустимо значение пикселя 300 или -10.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param int $y Координата y пикселя для проверки.
     * @return float
     */
    function GetSpriteYFromPixel($iSpriteIndex, $y)
    {
    }

    /**
     * Возвращает текущую координату Y текущей точки смещения спрайта в мире.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteYByOffset($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущую координату Y верхнего левого угла спрайта в виде значения с плавающей запятой.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteY($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущий угол в градусах указанного символа.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона,
     *     он будет проигнорирован.
     * @return float
     */
    function GetTextCharAngle($iTextIndex, $iCharIndex)
    {
    }

    /**
     * Преобразует точку в мировых координатах в точку на спрайте. Это противоположно GetWorldXFromSprite и будет
     * возвращать значения относительно центральной точки спрайта, определенной с помощью SetSpriteOffset. По умолчанию
     * это центр спрайта. Команда не ограничена размером спрайта, она может возвращать значения, превышающие границы
     * спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $x X-компонент точки для преобразования в координаты спрайта.
     * @param float $y Компонент Y точки для преобразования в координаты спрайта.
     * @return float
     */
    function GetSpriteXFromWorld($iSpriteIndex, $x, $y)
    {
    }

    /**
     * Преобразует точку пикселя на изображении спрайта в точку на поверхности спрайта, которая представляет, где
     * находится этот пиксель. Например, если изображение размером 200x100 пикселей было назначено спрайту размером
     * 10x10, то вызов этой команды со значением пикселя 100 (центр изображения) вернет 5 (центр спрайта). Для этого
     * спрайту должно быть назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером
     * изображения или спрайта, поэтому в приведенном выше примере допустимо значение пикселя 300 или -10.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param int $x Координата x пикселя для проверки.
     * @return float
     */
    function GetSpriteXFromPixel($iSpriteIndex, $x)
    {
    }

    /**
     * Возвращает текущую координату X текущей точки смещения спрайта в мире.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteXByOffset($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущую координату X верхнего левого угла спрайта в виде значения с плавающей запятой.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteX($iSpriteIndex)
    {
    }

    /**
     * Возвращает 0, если спрайт был установлен как невидимый с помощью SetSpriteVisible, в противном случае возвращает
     * 1.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteVisible($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущий режим прозрачности спрайта, 0=отсутствие прозрачности, 1=прозрачность альфа-канала,
     * 2=аддитивное смешивание.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteTransparency($iSpriteIndex)
    {
    }

    /**
     * Преобразует точку в мировых координатах в точку на спрайте. Это противоположно GetWorldYFromSprite и будет
     * возвращать значения относительно центральной точки спрайта, определенной с помощью SetSpriteOffset. По умолчанию
     * это центр спрайта. Команда не ограничена размером спрайта, она может возвращать значения, превышающие границы
     * спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $x X-компонент точки для преобразования в координаты спрайта.
     * @param float $y Компонент Y точки для преобразования в координаты спрайта.
     * @return float
     */
    function GetSpriteYFromWorld($iSpriteIndex, $x, $y)
    {
    }

    /**
     * Возвращает значение Y данной вершины в заданной форме. Это относится только к полигональным и цепным формам.
     * Идентификаторы фигур начинаются с 1 для первой фигуры вплоть до значения, возвращаемого GetSpriteNumShapes.
     * Идентификаторы вершин начинаются с 1 для первой вершины вплоть до значения, возвращаемого
     * GetSpriteShapeNumVertices
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @param int $shapeID Идентификатор формы для проверки
     * @param int $vertex идентификатор проверяемой вершины, вершины начинаются с идентификатора 1.
     * @return float
     */
    function GetSpriteShapeVertexY($iSpriteIndex, $shapeID, $vertex)
    {
    }

    /**
     * Возвращает текущую ширину спрайта в виде значения с плавающей запятой.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteWidth($iSpriteIndex)
    {
    }

    /**
     * Возвращает значение X данной вершины в заданной форме. Это относится только к полигональным и цепным формам.
     * Идентификаторы фигур начинаются с 1 для первой фигуры вплоть до значения, возвращаемого GetSpriteNumShapes.
     * Идентификаторы вершин начинаются с 1 для первой вершины вплоть до значения, возвращаемого
     * GetSpriteShapeNumVertices
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @param int $shapeID Идентификатор формы для проверки
     * @param int $vertex идентификатор проверяемой вершины, вершины начинаются с идентификатора 1.
     * @return float
     */
    function GetSpriteShapeVertexX($iSpriteIndex, $shapeID, $vertex)
    {
    }

    /**
     * Возвращает количество вершин в заданной форме. Это относится только к полигональным и цепным формам.
     * Идентификаторы фигур начинаются с 1 для первой фигуры вплоть до значения, возвращаемого GetSpriteNumShapes.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @param int $shapeID Идентификатор формы для проверки
     * @return int
     */
    function GetSpriteShapeNumVertices($iSpriteIndex, $shapeID)
    {
    }

    /**
     * Возвращает текущее масштабирование спрайта в направлении Y как задано с помощью SetSpriteScale или
     * SetSpriteScaleByOffset
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteScaleY($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущее масштабирование спрайта в направлении X как задано с помощью SetSpriteScale или
     * SetSpriteScaleByOffset
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteScaleX($iSpriteIndex)
    {
    }

    /**
     * Возвращает 1, если спрайт в данный момент воспроизводит анимацию, и 0, если нет.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpritePlaying($iSpriteIndex)
    {
    }

    /**
     * Преобразует точку на изображении спрайта в пиксель на изображении спрайта, который находится под этой точкой.
     * Например, если изображение размером 200x100 пикселей было назначено спрайту размером 10x10, то вызов этой
     * команды со значением пикселя 5 (центр спрайта) вернет 100 (центр изображения). Для этого спрайту должно быть
     * назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером изображения или
     * спрайта, поэтому в приведенном выше примере значение пикселя 20 или -1 будет допустимым.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $x Координата x точки спрайта для проверки.
     * @return int
     */
    function GetSpritePixelFromX($iSpriteIndex, $x)
    {
    }

    /**
     * Преобразует точку на изображении спрайта в пиксель на изображении спрайта, который находится под этой точкой.
     * Например, если изображение размером 200x100 пикселей было назначено спрайту размером 10x10, то вызов этой
     * команды со значением пикселя 5 (центр спрайта) вернет 50 (центр изображения). Для этого спрайту должно быть
     * назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером изображения или
     * спрайта, поэтому в приведенном выше примере допустимо значение пикселя 20 или -1.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $y Координата y точки спрайта для проверки.
     * @return int
     */
    function GetSpritePixelFromY($iSpriteIndex, $y)
    {
    }

    /**
     * Возвращает линейную скорость спрайта в направлении Y. Это количество единиц в секунду, которое спрайт в данный
     * момент перемещает в выбранном вами разрешении.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return float
     */
    function GetSpritePhysicsVelocityY($iSpriteIndex)
    {
    }

    /**
     * Возвращает массу спрайта в килограммах, используемых в данный момент. Он либо генерировался автоматически при
     * создании формы, либо добавлялся, либо устанавливался вручную.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return float
     */
    function GetSpritePhysicsMass($iSpriteIndex)
    {
    }

    /**
     * Возвращает значение X текущего Центра масс для физического тела данного спрайта. Все фигуры, добавленные в
     * данный момент к этому спрайту, вносят свой вклад в это значение. Если вы установили центр масс вручную, то он
     * вернет это значение. Для работы команды необходимо включить физику, иначе она вернет 0.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @return float
     */
    function GetSpritePhysicsCOMX($iSpriteIndex)
    {
    }

    /**
     * Возвращает угловую скорость спрайта в радианах в секунду. Это скорость, с которой в данный момент вращается
     * спрайт.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return float
     */
    function GetSpritePhysicsAngularVelocity($iSpriteIndex)
    {
    }

    /**
     * Возвращает компонент Y текущей точки смещения спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteOffsetY($iSpriteIndex)
    {
    }

    /**
     * Возвращает компонент X текущей точки смещения спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteOffsetX($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущее количество фигур, назначенных этому спрайту. Идентификаторы фигур действительны от 1 до
     * значения, возвращаемого этой командой, включая его.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @return int
     */
    function GetSpriteNumShapes($iSpriteIndex)
    {
    }

    /**
     * Возвращает 1, если спрайт в данный момент находится в видимой области экрана, и 0, если он находится за
     * пределами видимой области. Обратите внимание, что если спрайт находится очень близко к краю, где может быть
     * трудно определить, находятся ли все пиксели в спрайте за пределами видимой области, то эта команда вернет 1 и
     * предположит, что он виден. Другими словами, если эта команда возвращает 0, то спрайт определенно находится вне
     * экрана, если она возвращает 1, то спрайт, скорее всего, находится на экране, но на самом деле может быть вне
     * экрана и очень близко к краю.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteInScreen($iSpriteIndex)
    {
    }

    /**
     * Возвращает 1, если форма столкновения спрайта касается заданного круга в мировых координатах, и 0, если нет.
     * Если спрайт не имеет формы, ему присваивается собственная прямоугольная форма, которая останется после этой
     * команды. Эта команда учитывает поворот и масштаб спрайта при проверке пересечения. Обратите внимание, что из-за
     * изменений соотношения сторон эта команда ведет себя не так, как ожидалось при использовании процентной системы
     * координат. Вместо этого он будет проверять эллипс с правильным радиусом в направлении X, но большим радиусом в
     * направлении Y.
     *
     * @param int $iSprite Идентификатор спрайта для проверки
     * @param float $x1 Координата X центра окружности в мировых координатах.
     * @param float $y1 Координата Y центра окружности в мировых координатах.
     * @param float $radius Радиус окружности в мировых координатах.
     * @return int
     */
    function GetSpriteInCircle($iSprite, $x1, $y1, $radius)
    {
    }

    /**
     * Возвращает линейную скорость спрайта в направлении X. Это количество единиц в секунду, которое спрайт в данный
     * момент перемещает в выбранном вами разрешении.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return float
     */
    function GetSpritePhysicsVelocityX($iSpriteIndex)
    {
    }

    /**
     * Возвращает 1, если форма столкновения спрайта касается заданного поля в мировых координатах, и 0, если нет. Если
     * спрайт не имеет формы, ему присваивается собственная прямоугольная форма, которая останется после этой команды.
     * Эта команда учитывает поворот и масштаб спрайта при проверке пересечения.
     *
     * @param int $iSprite Идентификатор спрайта для проверки
     * @param float $x1 Координата X верхнего левого угла прямоугольника в мировых координатах.
     * @param float $y1 Координата Y верхнего левого угла прямоугольника в мировых координатах.
     * @param float $x2 Координата X в правом нижнем углу прямоугольника в мировых координатах.
     * @param float $y2 Координата Y нижнего правого угла коробки в мировых координатах.
     * @return int
     */
    function GetSpriteInBox($iSprite, $x1, $y1, $x2, $y2)
    {
    }

    /**
     * Возвращает идентификатор изображения, назначенного в данный момент спрайту. Это работает только в том случае,
     * если изображение было загружено с идентификатором (или присвоено ему AGK).
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteImageID($iSpriteIndex)
    {
    }

    /**
     * Возвращает значение Y текущего Центра масс для физического тела данного спрайта. Все фигуры, добавленные в
     * данный момент к этому спрайту, вносят свой вклад в это значение. Если вы установили центр масс вручную, то он
     * вернет это значение. Для работы команды необходимо включить физику, иначе она вернет 0.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @return float
     */
    function GetSpritePhysicsCOMY($iSpriteIndex)
    {
    }

    /**
     * Возвращает 1,если точка x, y в мировых координатах лежит внутри спрайта, 0, если нет. Учитывает вращение и
     * масштабные значения спрайта. Использует форму, назначенную ему из SetSpriteShape, если форма не задана, она
     * использует ширину и высоту спрайта в качестве формы коробки. Если вы тестируете мышь или сенсорную координату,
     * не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY.
     *
     * @param int $iSpriteIndex Спрайт для проверки.
     * @param float $x Положение x в мировых координатах нужно проверить.
     * @param float $y Положение y в мировых координатах для проверки.
     * @return int
     */
    function GetSpriteHitTest($iSpriteIndex, $x, $y)
    {
    }

    /**
     * Возвращает идентификатор первого спрайта,найденного под точкой x, y в мировых координатах, 0, если нет. Спрайты
     * упорядочены по глубине, поэтому спрайт, появляющийся над другим в порядке розыгрыша, будет возвращен вместо
     * спрайта позади него. Фильтрует результаты только для тех спрайтов, которые находятся в указанной группе. По
     * умолчанию спрайты создаются в группе 0, вы можете изменить это с помощью SetSpriteGroup. Учитывается вращение и
     * масштаб значений спрайта. Он не учитывает прозрачность спрайта, только его форму столкновения. Использует форму,
     * назначенную ему из SetSpriteShape, если форма не задана, то она использует ширину и высоту спрайта в качестве
     * формы коробки. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые
     * координаты с помощью ScreenToWorldX и ScreenToWorldY.
     *
     * @param int $group Идентификатор группы для проверки.
     * @param float $x Положение x в мировых координатах нужно проверить.
     * @param float $y Положение y в мировых координатах для проверки.
     * @return int
     */
    function GetSpriteHitGroup($group, $x, $y)
    {
    }

    /**
     * Возвращает идентификатор первого спрайта,найденного под точкой x, y в мировых координатах, 0, если нет. Спрайты
     * упорядочены по глубине, поэтому спрайт, появляющийся над другим в порядке розыгрыша, будет возвращен вместо
     * спрайта позади него. Эта функция фильтрует результаты, поэтому проверяются только спрайты определенных
     * категорий. Параметр category - это побитовое поле, которое использует младшие 16 битов для представления каждой
     * из возможных 16 категорий, используемых при настройке спрайта. Значение по умолчанию all 1s означает, что все
     * категории будут включены, тогда как значение all 0s означает, что никакие категории не будут включены. Вы можете
     * установить отдельные биты, чтобы установить, какие из них должны быть проверены. Вы можете установить, к каким
     * категориям относится спрайт, с помощью SetSpriteCategoryBits. Учитывает вращение и масштабные значения спрайта.
     * Он не учитывает прозрачность спрайта, только его форму столкновения. Использует форму, назначенную ему из
     * SetSpriteShape, если форма не задана, она использует ширину и высоту спрайта в качестве формы коробки. Если вы
     * тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью
     * ScreenToWorldX и ScreenToWorldY.
     *
     * @param int $categories Категории, которые нужно проверить.
     * @param float $x Положение x в мировых координатах нужно проверить.
     * @param float $y Положение y в мировых координатах для проверки.
     * @return int
     */
    function GetSpriteHitCategory($categories, $x, $y)
    {
    }

    /**
     * Возвращает идентификатор первого спрайта,найденного под точкой x, y в мировых координатах, 0, если нет. Спрайты
     * упорядочены по глубине, поэтому спрайт, появляющийся над другим в порядке розыгрыша, будет возвращен вместо
     * спрайта позади него. Учитывает вращение и масштабные значения спрайта. Он не учитывает прозрачность спрайта,
     * только его форму столкновения. Использует форму, назначенную ему из SetSpriteShape, если форма не задана, она
     * использует ширину и высоту спрайта в качестве формы коробки. Если вы тестируете мышь или сенсорную координату,
     * не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY.
     *
     * @param float $x Положение x в мировых координатах нужно проверить.
     * @param float $y Положение y в мировых координатах для проверки.
     * @return int
     */
    function GetSpriteHit($x, $y)
    {
    }

    /**
     * Возвращает текущую высоту спрайта в виде значения с плавающей запятой.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteHeight($iSpriteIndex)
    {
    }

    /**
     * Возвращает значение набора групп с помощью SetSpriteGroup. Если вы не установили группу, то это будет 0.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteGroup($iSpriteIndex)
    {
    }

    /**
     * Возвращает общее количество кадров, которые спрайту удалось получить из своего изображения. Может быть меньше,
     * чем количество кадров, запрошенных во время настройки.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения.
     * @return int
     */
    function GetSpriteFrameCount($iSpriteIndex)
    {
    }

    /**
     * Циклически просматривает список контактов только для данного спрайта. Возвращает 1 если контакт существует, вы
     * можете получить другой спрайт, вовлеченный в этот контакт, используя GetSpriteContactSpriteID2, вы можете
     * перейти к следующему контакту, снова вызвав эту команду, она вернет 0, когда больше контактов не будет. Работает
     * только на спрайтах, настроенных для физики.
     *
     * @return int
     */
    function GetSpriteNextContact()
    {
    }

    /**
     * Возвращает 1, если спрайт был перевернут вертикально с помощью SetSpriteFlip, в противном случае возвращает 0.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteFlippedV($iSpriteIndex)
    {
    }

    /**
     * Возвращает 1, если спрайт был перевернут горизонтально с помощью SetSpriteFlip, в противном случае возвращает 0.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteFlippedH($iSpriteIndex)
    {
    }

    /**
     * Циклически просматривает список контактов только для данного спрайта. Возвращает 1 если контакт существует, вы
     * можете получить другой спрайт, вовлеченный в этот контакт, используя GetSpriteContactSpriteID2, вы можете
     * перейти к следующему контакту с GetSpriteNextContact. Работает только на спрайтах, настроенных для физики.
     * Возвращает 0, если контактов нет.
     *
     * @param int $iSprite1 Спрайт для проверки физических контактов.
     * @return int
     */
    function GetSpriteFirstContact($iSprite1)
    {
    }

    /**
     * Возвращает координату Y ближайшей точки на sprite 2 к sprite 1 из последнего вызова GetSpriteDistance в мировых
     * координатах.
     *
     * @return float
     */
    function GetSpriteDistancePoint2Y()
    {
    }

    /**
     * Возвращает 1, если спрайт существует, и 0, если нет.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @return int
     */
    function GetSpriteExists($iSpriteIndex)
    {
    }

    /**
     * Возвращает координату X ближайшей точки на sprite 2 к sprite 1 из последнего вызова GetSpriteDistance в мировых
     * координатах.
     *
     * @return float
     */
    function GetSpriteDistancePoint2X()
    {
    }

    /**
     * Возвращает координату X ближайшей точки на спрайте 1 к спрайту 2 от последнего вызова GetSpriteDistance в
     * мировых координатах.
     *
     * @return float
     */
    function GetSpriteDistancePoint1X()
    {
    }

    /**
     * Возвращает координату Y ближайшей точки на спрайте 1 к спрайту 2 от последнего вызова GetSpriteDistance в
     * мировых координатах.
     *
     * @return float
     */
    function GetSpriteDistancePoint1Y()
    {
    }

    /**
     * Возвращает текущую глубину спрайта в диапазоне 0-10000, где 0-передняя часть экрана, а 10000-задняя.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteDepth($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущий идентификатор кадра спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения.
     * @return int
     */
    function GetSpriteCurrentFrame($iSpriteIndex)
    {
    }

    /**
     * Возвращает координату Y точки контакта в мировых координатах.
     *
     * @return float
     */
    function GetSpriteContactWorldY()
    {
    }

    /**
     * Возвращает координату X точки контакта в мировых координатах.
     *
     * @return float
     */
    function GetSpriteContactWorldX()
    {
    }

    /**
     * Возвращает идентификатор другого спрайта, участвующего в этом контакте.
     *
     * @return int
     */
    function GetSpriteContactSpriteID2()
    {
    }

    /**
     * Возвращает текущий красный компонент спрайта в диапазоне 0-255.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteColorRed($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущий синий компонент спрайта в диапазоне 0-255.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteColorBlue($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущий зеленый компонент спрайта в диапазоне 0-255.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteColorGreen($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущее альфа-значение спрайта в диапазоне 0-255.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteColorAlpha($iSpriteIndex)
    {
    }

    /**
     * Проверяет два спрайта на столкновение, если они перекрываются, то возвращает 1. В противном случае возвращает 0.
     * Никакая другая информация не может быть возвращена об этом типе столкновения. Эта команда предназначена в первую
     * очередь для спрайтов, которые не используют физику. Хотя он может быть использован на физических спрайтах,
     * физическая система уже вычислит перекрытие всех физических спрайтов в течение последнего кадра и сохранит
     * результаты в списке контактов. Эта функция фактически выполняет вычисления, необходимые для определения того,
     * перекрываются ли спрайты. Эта функция не ограничена настройками группы или категории. Эта функция работает
     * только с базовой формой спрайта. Любые дополнительные фигуры, добавленные к физическим спрайтам, не будут
     * использоваться в этой функции, вместо этого используйте GetPhysicsCollision. Кроме того, цепные формы всегда не
     * будут возвращать никаких столкновений с помощью этой команды, цепные формы используются только в физических
     * расчетах. Если вы не назначили форму ни одному из спрайтов с помощью SetSpriteShape, они будут использовать
     * форму коробки по умолчанию, основанную на ширине и высоте спрайта.
     *
     * @param int $iSprite1 Спрайт для проверки на пересечение со спрайтом 2
     * @param int $iSprite2 Спрайт для проверки на пересечение со спрайтом 1
     * @return int
     */
    function GetSpriteCollision($iSprite1, $iSprite2)
    {
    }

    /**
     * Возвращает текущий угол спрайта в радианах, 0 радианов-это направление x=0 y=-1 и движение по часовой стрелке.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения.
     * @return float
     */
    function GetSpriteAngleRad($iSpriteIndex)
    {
    }

    /**
     * Возвращает текущий угол спрайта в градусах, 0 градусов-это направление x=0 y=-1 и движение по часовой стрелке.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения.
     * @return float
     */
    function GetSpriteAngle($iSpriteIndex)
    {
    }

    /**
     * Возвращает 0, если спрайт был установлен как неактивный с помощью SetSpriteActive, в противном случае возвращает
     * 1.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteActive($iSpriteIndex)
    {
    }

    /**
     * Возвращает имя заданного голоса. На iOS это имя читается человеком, но не дает никаких подробностей о акценте
     * или языке этого голоса. На Android имя дает информацию о языке и акценте, но не так легко читается.  В настоящее
     * время работает только на iOS и Android.
     *
     * @param int $index Индекс голоса, который нужно проверить, начинается с 0 для первого голоса
     * @return string
     */
    function GetSpeechVoiceName($index)
    {
    }

    /**
     * Вычисляет минимальное расстояние, разделяющее два спрайта. Если спрайты перекрываются, это будет меньше 0. В
     * противном случае это будет расстояние между ближайшими точками на каждом спрайте, эти точки можно найти с
     * помощью GetSpriteDistancePoint1X и т. Д. Этот расчет занимает больше времени, чем просто проверка перекрытия
     * спрайтов, если вам не нужно расстояние, разделяющее спрайты, используйте GetSpriteCollision. Эта функция не
     * ограничена настройками группы или категории. Если вы не назначили форму ни одному из спрайтов с помощью
     * SetSpriteShape, они будут использовать форму коробки по умолчанию, основанную на ширине и высоте спрайта.
     *
     * @param int $iSprite1 Спрайт для проверки расстояния с помощью спрайта 2
     * @param int $iSprite2 Спрайт для проверки расстояния с помощью спрайта 1
     * @return float
     */
    function GetSpriteDistance($iSprite1, $iSprite2)
    {
    }

    /**
     * Возвращает идентификатор данного голоса. Идентификатор можно использовать с SetSpeechLanguageByID для выбора
     * конкретного голоса.
     *
     * @param int $index Индекс голоса, который нужно проверить, начинается с 0 для первого голоса
     * @return string
     */
    function GetSpeechVoiceID($index)
    {
    }

    /**
     * Возвращает количество голосов, которые можно выбрать с помощью команды SetSpeechLanguage. Вы можете использовать
     * команды GetSpeechVoiceName и GetSpeechVoiceLanguage, чтобы получить подробную информацию о различных голосах.  В
     * настоящее время работает только на iOS и Android.
     *
     * @return int
     */
    function GetSpeechNumVoices()
    {
    }

    /**
     * Возвращает языковую строку данного голоса. Это можно использовать непосредственно с командой SetSpeechLanguage,
     * чтобы использовать этот голос для любой будущей речи.  В настоящее время работает только на iOS и Android.
     *
     * @param int $index Индекс голоса, который нужно проверить, начинается с 0 для первого голоса
     * @return string
     */
    function GetSpeechVoiceLanguage($index)
    {
    }

    /**
     * Возвращает количество экземпляров этого звукового идентификатора, которые в данный момент воспроизводятся или
     * зацикливаются. Это точно так же, как GetSoundInstances.
     *
     * @param int $iID Звуковой номер для проверки.
     * @return int
     */
    function GetSoundsPlaying($iID)
    {
    }

    /**
     * Получает минимальную скорость и какие звуковые файлы могут быть воспроизведены на этом устройстве. Скорость 1,0
     * - это нормальная скорость, скорость 2,0-это двойная скорость, 0,5-половина скорости и так далее. Если вы
     * попытаетесь изменить скорость воспроизведения звука за пределами этих значений, она будет привязана к этим
     * значениям. Если и min, и max возвращают 1.0, то изменение скорости воспроизведения звука на этом устройстве не
     * поддерживается.
     *
     * @return float
     */
    function GetSoundMinRate()
    {
    }

    /**
     * Получает максимальную скорость и какие звуковые файлы могут быть воспроизведены на этом устройстве. Скорость 1,0
     * - это нормальная скорость, скорость 2,0-это двойная скорость, 0,5-половина скорости и так далее. Если вы
     * попытаетесь изменить скорость воспроизведения звука за пределами этих значений, она будет привязана к этим
     * значениям. Если и min, и max возвращают 1.0, то изменение скорости воспроизведения звука на этом устройстве не
     * поддерживается.
     *
     * @return float
     */
    function GetSoundMaxRate()
    {
    }

    /**
     * Возвращает количество экземпляров этого звукового идентификатора, которые в данный момент воспроизводятся или
     * зацикливаются. Это точно так же, как GetSoundsPlaying.
     *
     * @param int $iID Звуковой номер для проверки.
     * @return int
     */
    function GetSoundInstances($iID)
    {
    }

    /**
     * Возвращает текущую скорость воспроизведения указанного экземпляра, где 1.0-нормальная скорость, 2.0 - двойная
     * скорость и т. Д. Не все устройства гарантированно поддерживают изменение скорости воспроизведения.
     *
     * @param int $iID Идентификатор проверяемого экземпляра
     * @return float
     */
    function GetSoundInstanceRate($iID)
    {
    }

    /**
     * Возвращает текущий объем указанного экземпляра в диапазоне от 0 до 100.
     *
     * @param int $iID Идентификатор проверяемого экземпляра
     * @return int
     */
    function GetSoundInstanceVolume($iID)
    {
    }

    /**
     * Возвращает 1, если данный экземпляр все еще воспроизводится или зацикливается, и 0, если он остановился.
     * Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука. Как
     * только эта команда вернет 0, экземпляр будет удален и на него больше нельзя будет ссылаться, любая попытка
     * изменить его будет проигнорирована. Вам нужно будет создать новый экземпляр, снова используя PlaySound.
     *
     * @param int $iID Идентификатор проверяемого экземпляра
     * @return int
     */
    function GetSoundInstancePlaying($iID)
    {
    }

    /**
     * Если звук воспроизводился с включенным циклированием, эта команда возвращает количество завершенных до сих пор
     * циклов. Если экземпляр использует фиксированное количество циклов, то он никогда на самом деле не достигнет
     * этого значения количества циклов, так как будет немедленно удален по достижении конца своего последнего цикла.
     * Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.
     *
     * @param int $iID Идентификатор проверяемого экземпляра
     * @return int
     */
    function GetSoundInstanceLoopCount($iID)
    {
    }

    /**
     * Будет считывать строку из соединения сокета и возвращать ее. Если вы отправляете строку из источника, отличного
     * от AGK, то строка должна начинаться со значения длины 4 байта, за которым следует X байт строковых данных, где
     * X-значение длины. Строка не должна заканчиваться null. Если существует менее 4 байт данных, ожидающих чтения, то
     * эта команда немедленно вернется и вернет пустую строку. Вы можете проверить, сколько данных нужно прочитать,
     * используя GetSocketBytesAvailable. Если есть 4 или более байтов, ожидающих чтения, то эта команда будет ждать,
     * пока вся строка не будет получена, прежде чем вернуться.
     *
     * @param int $socketID Идентификатор сокета для чтения
     * @return string
     */
    function GetSocketString($socketID)
    {
    }

    /**
     * Возвращает IP-адрес компьютера или устройства на другом конце соединения. Это может быть адрес IPv4 или IPv6.
     *
     * @param int $socketID Идентификатор сокета для проверки
     * @return string
     */
    function GetSocketRemoteIP($socketID)
    {
    }

    /**
     * Возвращает значение 1, если указанный звуковой номер существует, в противном случае возвращается 0.
     *
     * @param int $iID Звуковой номер для проверки.
     * @return int
     */
    function GetSoundExists($iID)
    {
    }

    /**
     * Возвращает идентификатор сокета, подключенного к вашему устройству. Прослушиватель будет принимать соединения в
     * фоновом режиме и добавлять их в очередь, эта команда удаляет один из сокетов из очереди и передает вам
     * управление им. Если вы не хотите принимать соединение, вы должны удалить его с помощью DeleteSocket. Вы должны
     * вызвать GetSocketListenerConnection в цикле до тех пор, пока он не вернет 0, чтобы убедиться, что вы справились
     * со всеми подключенными сокетами. Вы можете узнать IP-адрес устройства, которое подключилось к вам, вызвав
     * GetSocketRemoteIP на возвращенном сокете.
     *
     * @param int $listenerID Идентификатор прослушивателя для проверки
     * @return int
     */
    function GetSocketListenerConnection($listenerID)
    {
    }

    /**
     * Будет считывать 4-байтовый поплавок из соединения сокета и возвращать его. Если существует менее 4 байт данных,
     * ожидающих чтения, то эта команда немедленно вернется и вернет 0. Вы можете проверить, сколько данных нужно
     * прочитать, используя GetSocketBytesAvailable.
     *
     * @param int $socketID Идентификатор сокета для чтения
     * @return float
     */
    function GetSocketFloat($socketID)
    {
    }

    /**
     * Возвращает 1, если указанный сокет подключен, и 0, если он все еще находится в процессе подключения. Если сокет
     * будет отключен или не сможет подключиться, то это вернет -1.
     *
     * @param int $socketID Идентификатор сокета для проверки
     * @return int
     */
    function GetSocketConnected($socketID)
    {
    }

    /**
     * Возвращает 1, если указанный сокет существует, и 0 в противном случае.
     *
     * @param int $socketID Идентификатор сокета для проверки
     * @return int
     */
    function GetSocketExists($socketID)
    {
    }

    /**
     * Возвращает количество байтов, доступных для чтения. Если это возвращает 0, то команды чтения, такие как
     * GetSocketInteger, не будут возвращать никаких данных.
     *
     * @param int $socketID Идентификатор сокета для проверки
     * @return int
     */
    function GetSocketBytesAvailable($socketID)
    {
    }

    /**
     * Получает Y-положение корня скелета, не изменяется во время анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return float
     */
    function GetSkeleton2DY($iSkeleton)
    {
    }

    /**
     * Получает положение X корня скелета, не изменяется во время анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return float
     */
    function GetSkeleton2DX($iSkeleton)
    {
    }

    /**
     * возвращает 1, если скелет переходит в анимационный кадр.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return int
     */
    function GetSkeleton2DIsTweening($iSkeleton)
    {
    }

    /**
     * возвращает 1, если скелет анимируется или переходит в первый кадр воспроизводимой анимации
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return int
     */
    function GetSkeleton2DIsAnimating($iSkeleton)
    {
    }

    /**
     * Будет считывать 4-байтовое целое число из соединения сокета и возвращать его. Если существует менее 4 байт
     * данных, ожидающих чтения, то эта команда немедленно вернется и вернет 0. Вы можете проверить, сколько данных
     * нужно прочитать, используя GetSocketBytesAvailable.
     *
     * @param int $socketID Идентификатор сокета для чтения
     * @return int
     */
    function GetSocketInteger($socketID)
    {
    }

    /**
     * Возвращает 1, если скелет существует с указанным идентификатором, в противном случае 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return int
     */
    function GetSkeleton2DExists($iSkeleton)
    {
    }

    /**
     * Получает текущую глубину скелета. Это находится в диапазоне 0-10000. 0 находится сверху, 10000 - сзади
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return int
     */
    function GetSkeleton2DDepth($iSkeleton)
    {
    }

    /**
     * Получить текущее время текущей воспроизводимой анимации в секундах
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return float
     */
    function GetSkeleton2DCurrentTime($iSkeleton)
    {
    }

    /**
     * Будет считывать один байт из сокета соединения и возвращать его. Если нет данных, ожидающих чтения, то эта
     * команда немедленно вернется и вернет 0. Вы можете проверить, сколько данных нужно прочитать, используя
     * GetSocketBytesAvailable.
     *
     * @param int $socketID Идентификатор сокета для чтения
     * @return int
     */
    function GetSocketByte($socketID)
    {
    }

    /**
     * Возвращает исходное положение Y указанной кости, также известное как установочная поза. Это значение не
     * изменится, пока кость анимируется, вместо этого анимация строится поверх установочной позы, чтобы создать
     * положение кости, видимое на экране. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с
     * 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneY($iSkeleton, $bone)
    {
    }

    /**
     * Возвращает текущее состояние подключения смарт-часов: 0=начальное состояние, ActivateSmartWatch не вызывался.
     * 1=подключение, через мгновение перейдет в более детальное состояние. 2=соединение успешно, вы можете отправлять
     * и получать данные. -1=команды watch не поддерживаются на этом устройстве. -2=соединение не удалось или часы не
     * найдены. -3=часы найдены, но в данный момент они не сопряжены с устройством, -4=часы найдены, но наше приложение
     * для часов в данный момент не установлено.  В настоящее время работает только на iOS.
     *
     * @return int
     */
    function GetSmartWatchState()
    {
    }

    /**
     * Возвращает исходное положение X указанной кости, также известное как установочная поза. Это значение не
     * изменится, пока кость анимируется, вместо этого анимация строится поверх установочной позы, чтобы создать
     * положение кости, видимое на экране. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с
     * 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneX($iSkeleton, $bone)
    {
    }

    /**
     * Возвращает идентификатор родителя указанной кости. Если кость не существует или у нее нет родителя, она вернет
     * -1. Индексы начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return int
     */
    function GetSkeleton2DBoneParent($iSkeleton, $bone)
    {
    }

    /**
     * Возвращает текущее положение Y указанной кости в ее текущем анимированном положении. Это значение будет меняться
     * во время анимации кости. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneCurrY($iSkeleton, $bone)
    {
    }

    /**
     * Возвращает текущий угол указанной кости в ее текущем анимированном положении. Это значение будет меняться во
     * время анимации кости. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneCurrAngle($iSkeleton, $bone)
    {
    }

    /**
     * Возвращает идентификатор указанной кости для этого скелета. Если кости с заданным именем не существует, она
     * вернет -1. Индекс 0-это допустимая кость.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param string $name Имя кости, которую нужно найти
     * @return int
     */
    function GetSkeleton2DBone($iSkeleton, $name)
    {
    }

    /**
     * получить общее время именованной анимации
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param string $anim Имя анимации для проверки
     * @return float
     */
    function GetSkeleton2DAnimationTime($iSkeleton, $anim)
    {
    }

    /**
     * Получает угол наклона корня скелета, не меняется во время анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return float
     */
    function GetSkeleton2DAngle($iSkeleton)
    {
    }

    /**
     * Возвращает количество полигонов, нарисованных последним кадром графического процессора при построении теневых
     * карт.
     *
     * @return int
     */
    function GetShadowPolygonsDrawn()
    {
    }

    /**
     * Возвращает 1, если теневое отображение поддерживается на этом устройстве, и 0 в противном случае.
     *
     * @return int
     */
    function GetShadowMappingSupported()
    {
    }

    /**
     * Возвращает текущий режим отображения теней, который был установлен с помощью SetShadowMappingMode
     *
     * @return int
     */
    function GetShadowMappingMode()
    {
    }

    /**
     * Возвращает 1, если шейдер в данный момент загружен с заданным идентификатором, в противном случае он возвращает
     * 0.
     *
     * @param int $shaderID Идентификатор шейдера для проверки
     * @return int
     */
    function GetShaderExists($shaderID)
    {
    }

    /**
     * Возвращает секунды заданного значения времени unix (от 0 до 59). Время Unix представлено как количество секунд с
     * 1 января 1970 года, оно также может быть отрицательным.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetSecondsFromUnix($unixtime)
    {
    }

    /**
     * Получите количество целых секунд с момента запуска приложения. С точностью до 1 секунды.  Вызов этой команды
     * внутренне вызовет системный вызов, чтобы получить количество прошедшего времени, поэтому он может меняться
     * каждый раз, когда вы его вызываете.
     *
     * @return int
     */
    function GetSeconds()
    {
    }

    /**
     * Возвращает текущее положение X указанной кости в ее текущем анимированном положении. Это значение будет меняться
     * во время анимации кости. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneCurrX($iSkeleton, $bone)
    {
    }

    /**
     * Возвращает исходный угол указанной кости, также известный как установочная поза. Это значение не изменится, пока
     * кость анимируется, вместо этого анимация строится поверх установочной позы, чтобы создать вращение кости,
     * видимое на экране. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneAngle($iSkeleton, $bone)
    {
    }

    /**
     * Преобразует 3D-точку в экранные координаты.
     *
     * @param float $x X-компонент 3D-точки.
     * @param float $y Компонент Y трехмерной точки.
     * @param float $z Z-компонент 3D-точки.
     * @return float
     */
    function GetScreenYFrom3D($x, $y, $z)
    {
    }

    /**
     * Возвращает верхний край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть
     * черные границы в верхней и нижней части дисплея, то это значение будет отрицательным. Это означает, что 0-это
     * конец видимой области и начало черной границы, а верхняя граница - это конец черной границы и край экрана. Если
     * сверху нет черной границы, то верхняя граница всегда будет равна 0.
     *
     * @return float
     */
    function GetScreenBoundsTop()
    {
    }

    /**
     * Преобразует 3D-точку в экранные координаты.
     *
     * @param float $x X-компонент 3D-точки.
     * @param float $y Компонент Y трехмерной точки.
     * @param float $z Z-компонент 3D-точки.
     * @return float
     */
    function GetScreenXFrom3D($x, $y, $z)
    {
    }

    /**
     * Возвращает правый край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть
     * черные границы слева и справа от дисплея, то это значение будет больше, чем GetVirtualWidth. Это означает, что
     * виртуальная ширина-это конец видимой области и начало черной границы, а правая граница - это конец черной
     * границы и край экрана. Если справа нет черной границы, то правая граница всегда будет равна GetVirtualWidth.
     *
     * @return float
     */
    function GetScreenBoundsRight()
    {
    }

    /**
     * Возвращает левый край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть
     * черные границы слева и справа от дисплея, то это значение будет отрицательным. Это означает, что 0-это конец
     * видимой области и начало черной границы, а левая граница - это конец черной границы и край экрана. Если слева
     * нет черной границы, то левая граница всегда будет равна 0.
     *
     * @return float
     */
    function GetScreenBoundsLeft()
    {
    }

    /**
     * Возвращает нижний край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть
     * черные границы в верхней и нижней части дисплея, то это значение будет больше, чем GetVirtualHeight. Это
     * означает, что виртуальная высота является концом видимой области и началом черной границы, а нижняя
     * граница-концом черной границы и краем экрана. Если внизу нет черной границы, то нижняя граница всегда будет
     * равна GetVirtualHeight.
     *
     * @return float
     */
    function GetScreenBoundsBottom()
    {
    }

    /**
     * Возвращает значение загруженного в данный момент объявления о вознаграждении, это вернет 0, если значение
     * вознаграждения неизвестно. Если в данный момент не загружено ни одно объявление о вознаграждении, то это
     * значение не определено, оно может быть равно 0 или это может быть значение предыдущего объявления. Вы должны
     * спросить пользователя, хочет ли он просмотреть объявление о вознаграждении, прежде чем показывать его, а также
     * вознаграждение, которое он получит за это. Вы можете использовать эту функцию значения для определения
     * подходящего вознаграждения. Это значение останется неизменным при вызове ResetRewardAdMob
     *
     * @return int
     */
    function GetRewardAdValueAdMob()
    {
    }

    /**
     * Возвращает 1, если текущее устройство имеет датчик вектора вращения, который в настоящее время поддерживается
     * AGK, и 0, если нет.
     *
     * @return int
     */
    function GetRotationVectorSensorExists()
    {
    }

    /**
     * Возвращает 1, если ранее показанное объявление о вознаграждении привело к вознаграждению, которое должно быть
     * дано пользователю, например, некоторые внутриигровые монеты. При вызове ShowRewardAdAdMob это значение
     * устанавливается равным 0 и устанавливается равным 1 только в том случае, если пользователь завершил бонусное
     * видео, в противном случае оно останется равным 0. После того как вы дали пользователю вознаграждение, вы можете
     * установить его обратно в 0 с помощью ResetRewardAdMob.
     *
     * @return int
     */
    function GetRewardAdRewardedChartboost()
    {
    }

    /**
     * Возвращает 1, если есть предварительно загруженное и готовое к показу объявление Chartboost reward, в противном
     * случае 0. Если это так, вы можете отобразить его с помощью ShowRewardAdChartboost. Объявления предварительно
     * загружаются после вызова CacheRewardAdChartboost и после того, как каждое объявление о вознаграждении
     * отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной
     * из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам
     * следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают
     * 0, вы можете попробовать снова позвонить в CacheRewardAdChartboost, чтобы перезапустить процесс загрузки и
     * посмотреть, стали ли доступны новые объявления.
     *
     * @return int
     */
    function GetRewardAdLoadedChartboost()
    {
    }

    /**
     * Возвращает 1, если объявление AdMob reward предварительно загружено и готово к показу, в противном случае 0.
     * Если это так, вы можете отобразить его с помощью ShowRewardAdAdMob. Объявления предварительно загружаются, как
     * только вы устанавливаете свои данные о вознаграждении AdMob, и после того, как каждое объявление о
     * вознаграждении отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может
     * быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом
     * случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы
     * возвращают 0, то вы можете попробовать вызвать ShowRewardAdAdMob в любом случае, он ничего не покажет, так как
     * ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны какие-либо новые
     * объявления.
     *
     * @return int
     */
    function GetRewardAdLoadedAdMob()
    {
    }

    /**
     * Возвращает 1, если ваше приложение было передано в фоновый режим и только что было повторно активировано. Когда
     * это произойдет, вы должны активировать экран паузы. На мобильных платформах приложения не будут работать, пока
     * они находятся в фоновом режиме, так что первый шанс, что ваше приложение получит это уведомление, - это когда
     * оно вернется из фонового режима и продолжит работу. Поскольку пользователь, возможно, еще не готов продолжить
     * воспроизведение, вы должны проверить это значение и показать экран паузы до тех пор, пока он не будет готов.
     *
     * @return int
     */
    function GetResumed()
    {
    }

    /**
     * Возвращает каталог, содержащий исполняемый файл приложения на текущей платформе, на которой оно запущено.
     * Обратите внимание, что на Android этот путь недоступен при обычном использовании и вернет пустую строку.
     *
     * @return string
     */
    function GetReadPath()
    {
    }

    /**
     * Возвращает координату X точки пересечения последней проверки приведения луча. Результат - в мировых координатах.
     *
     * @return float
     */
    function GetRayCastX()
    {
    }

    /**
     * Возвращает компонент Y нормали самой последней проверки приведения луча. Это не будет единичный вектор, так как
     * он был преобразован в мировые координаты.
     *
     * @return float
     */
    function GetRayCastNormalY()
    {
    }

    /**
     * Возвращает X-компоненту нормали самой последней проверки приведения луча. Это не будет единичный вектор, так как
     * он был преобразован в мировые координаты.
     *
     * @return float
     */
    function GetRayCastNormalX()
    {
    }

    /**
     * Возвращает 1, если ранее показанное объявление о вознаграждении привело к вознаграждению, которое должно быть
     * дано пользователю, например, некоторые внутриигровые монеты. При вызове ShowRewardAdAdMob это значение
     * устанавливается равным 0 и устанавливается равным 1 только в том случае, если пользователь завершил бонусное
     * видео, в противном случае оно останется равным 0. После того как вы дали пользователю вознаграждение, вы можете
     * установить его обратно в 0 с помощью ResetRewardAdMob.
     *
     * @return int
     */
    function GetRewardAdRewardedAdMob()
    {
    }

    /**
     * Возвращает имя текущего средства визуализации, например "OpenGL" или "OpenGLES"
     *
     * @return string
     */
    function GetRendererName()
    {
    }

    /**
     * Извлекает значение, ранее сохраненное в этом событии с помощью SetRawTouchValue.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return int
     */
    function GetRawTouchValue($iIndex)
    {
    }

    /**
     * Возвращает долю луча, пройденного до достижения столкновения. 0 означает начало луча, а 1.0-его конец.
     *
     * @return float
     */
    function GetRayCastFraction()
    {
    }

    /**
     * Возвращает координату Y точки пересечения последней проверки приведения луча. Результат - в мировых координатах.
     *
     * @return float
     */
    function GetRayCastY()
    {
    }

    /**
     * Возвращает тип данного события касания. Все, в чем вы можете быть уверены при неизвестных событиях, - это то,
     * что палец в данный момент находится на экране и находится там менее 1 секунды. Через 1 секунду он автоматически
     * становится событием удержания. Если пользователь поднимает палец с экрана до этого, то это становится коротким
     * событием, а если он перемещает палец дальше, чем расстояние, указанное SetRawTouchMoveSensitivity, то это
     * становится событием перетаскивания. Если текущее событие неизвестно, то оно возвращает 0. События могут
     * измениться с событий удержания на события перетаскивания, но короткие события и события перетаскивания не
     * изменяют тип. Неизвестные события гарантированно изменят тип, как только появится дополнительная информация.
     * Возможные возвращаемые значения-0 для обозначения неизвестного, 1 для короткого касания, 2 для удержания и 3 для
     * перетаскивания.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return int
     */
    function GetRawTouchType($iIndex)
    {
    }

    /**
     * Возвращает положение Y в координатах экрана, в котором началось событие касания. Эта координата будет находиться
     * в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью
     * ScreenToWorldY.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchStartY($iIndex)
    {
    }

    /**
     * Возвращает общее время, которое заняло это событие, от нажатия до выпуска в секундах.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchTime($iIndex)
    {
    }

    /**
     * Возвращает идентификатор спрайта, попавшего в самую последнюю проверку ray cast. Если луч попал в не спрайтовую
     * фигуру, то будет возвращено 0.
     *
     * @return int
     */
    function GetRayCastSpriteID()
    {
    }

    /**
     * Возвращает позицию X в координатах экрана, где началось событие касания. Эта координата будет находиться в
     * координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью
     * ScreenToWorldX.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchStartX($iIndex)
    {
    }

    /**
     * Возвращает позицию Y в координатах экрана, где событие касания было записано в последний раз до его текущего
     * местоположения. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете
     * преобразовать его в мировые координаты с помощью ScreenToWorldY.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchLastY($iIndex)
    {
    }

    /**
     * Возвращает позицию X в координатах экрана, где событие касания было записано в последний раз до его текущего
     * местоположения. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете
     * преобразовать его в мировые координаты с помощью ScreenToWorldX.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchLastX($iIndex)
    {
    }

    /**
     * Возвращает позицию X в координатах экрана, где в данный момент находится событие касания. Эта координата будет
     * находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с
     * помощью ScreenToWorldX.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchCurrentX($iIndex)
    {
    }

    /**
     * Возвращает положение Y в координатах экрана, где в данный момент находится событие касания. Эта координата будет
     * находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с
     * помощью ScreenToWorldY.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchCurrentY($iIndex)
    {
    }

    /**
     * Возвращает количество событий касания, происходящих в данный момент. По умолчанию AGK не считает событие до тех
     * пор, пока не узнает, какой это тип события, например короткое, длинное, перетаскивание и т. Д. Чтобы также
     * подсчитать неизвестные события, установите значение bIncludeUnknown равным 1. Используйте 0, чтобы игнорировать
     * неизвестные события.
     *
     * @param int $bIncludeUnknown Установите значение 1, чтобы подсчитать неизвестные события, которые могут стать
     *     любым типом сенсорного события в будущем.
     * @return int
     */
    function GetRawTouchCount($bIncludeUnknown)
    {
    }

    /**
     * Возвращает Z-компонент текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с
     * SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет
     * внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для
     * текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите
     * сориентировать объект, используйте GetRawRotationVectorZ
     *
     * @return float
     */
    function GetRawRotationVectorZ2()
    {
    }

    /**
     * Возвращает компонент Y текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с
     * SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет
     * внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для
     * текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите
     * сориентировать объект, используйте GetRawRotationVectorY
     *
     * @return float
     */
    function GetRawRotationVectorY2()
    {
    }

    /**
     * Возвращает Z-компонент текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с
     * помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для
     * использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorZ2
     *
     * @return float
     */
    function GetRawRotationVectorZ()
    {
    }

    /**
     * Возвращает компонент Y текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с
     * помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для
     * использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorY2
     *
     * @return float
     */
    function GetRawRotationVectorY()
    {
    }

    /**
     * Возвращает компонент X текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с
     * SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет
     * внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для
     * текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите
     * сориентировать объект, используйте GetRawRotationVectorX
     *
     * @return float
     */
    function GetRawRotationVectorX2()
    {
    }

    /**
     * Возвращает компонент X текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с
     * помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для
     * использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorX2
     *
     * @return float
     */
    function GetRawRotationVectorX()
    {
    }

    /**
     * Возвращает W-компонент текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с
     * SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет
     * внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для
     * текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите
     * сориентировать объект, используйте GetRawRotationVectorW
     *
     * @return float
     */
    function GetRawRotationVectorW2()
    {
    }

    /**
     * Возвращает W-компонент текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с
     * помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для
     * использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorW2
     *
     * @return float
     */
    function GetRawRotationVectorW()
    {
    }

    /**
     * Если датчик приближения существует, возвращает расстояние устройства от любого объекта, находящегося в данный
     * момент перед ним, непроверенное, поскольку ни одно устройство не поддерживало его во время тестирования.
     *
     * @return float
     */
    function GetRawProximityDistance()
    {
    }

    /**
     * Возвращает 1 если прикосновение было отпущено, это всегда будет 1 для коротких событий, события удержания и
     * перетаскивания будут продолжать сообщать 0 до тех пор, пока они не будут отпущены, и в этот момент вы, возможно,
     * захотите предпринять какие-то действия. Каждое событие будет сообщаться только как 1 раз, прежде чем быть
     * удаленным из списка событий. Если событие касания игнорируется (не запрашивается) в течение одного кадра после
     * его освобождения, оно будет удалено из списка событий.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return int
     */
    function GetRawTouchReleased($iIndex)
    {
    }

    /**
     * Возвращает индекс к следующему событию касания, доступному для чтения, если больше нет доступных событий, он
     * возвращает 0.
     *
     * @return int
     */
    function GetRawNextTouchEvent()
    {
    }

    /**
     * Возвращает компонент Y текущего положения мыши в координатах экрана. Если мыши не существует, она всегда будет
     * возвращать 0.
     *
     * @return float
     */
    function GetRawMouseY()
    {
    }

    /**
     * Возвращает компонент X текущего положения мыши в координатах экрана. Если мыши не существует, она всегда будет
     * возвращать 0.
     *
     * @return float
     */
    function GetRawMouseX()
    {
    }

    /**
     * Возвращает разницу между текущим положением колесика мыши и предыдущим положением колесика мыши, может быть
     * положительной или отрицательной, обновляется один раз в кадр. Если мыши не существует, она всегда будет
     * возвращать 0.
     *
     * @return float
     */
    function GetRawMouseWheelDelta()
    {
    }

    /**
     * Возвращает текущее положение колесика мыши, может быть положительным или отрицательным, начинается с 0. Если
     * мыши не существует, она всегда будет возвращать 0.
     *
     * @return float
     */
    function GetRawMouseWheel()
    {
    }

    /**
     * Возвращает 1, если правая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда
     * будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseRightState()
    {
    }

    /**
     * Возвращает 1, если правая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не
     * существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseRightReleased()
    {
    }

    /**
     * Возвращает 1, если была нажата правая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если
     * мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseRightPressed()
    {
    }

    /**
     * Возвращает 1, если средняя кнопка мыши в данный момент опущена, и 0, если нет. Если мыши не существует, она
     * всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseMiddleState()
    {
    }

    /**
     * Возвращает 1, если средняя кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не
     * существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseMiddleReleased()
    {
    }

    /**
     * Возвращает 1, если была нажата средняя кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если
     * мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseMiddlePressed()
    {
    }

    /**
     * Возвращает 1, если левая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда
     * будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseLeftState()
    {
    }

    /**
     * Возвращает 1, если четвертая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не
     * существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFourthReleased()
    {
    }

    /**
     * Возвращает 1, если была нажата четвертая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой.
     * Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFourthPressed()
    {
    }

    /**
     * Возвращает 1, если пятая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда
     * будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFifthState()
    {
    }

    /**
     * Возвращает 1, если пятая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не
     * существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFifthReleased()
    {
    }

    /**
     * Возвращает 1, если была нажата пятая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если
     * мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFifthPressed()
    {
    }

    /**
     * Если магнитный датчик существует, возвращает Z-компоненту любого окружающего магнитного поля. На iOS может
     * потребоваться несколько секунд, чтобы начать отображать данные, отличные от 0, во время этого процесса
     * устройство использует данные движения для калибровки магнитного датчика
     *
     * @return float
     */
    function GetRawMagneticZ()
    {
    }

    /**
     * Возвращает 1, если левая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не
     * существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseLeftReleased()
    {
    }

    /**
     * Возвращает 1, если четвертая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она
     * всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFourthState()
    {
    }

    /**
     * Если магнитный датчик существует, возвращает Y-компоненту любого окружающего магнитного поля. На iOS может
     * потребоваться несколько секунд, чтобы начать отображать данные, отличные от 0, во время этого процесса
     * устройство использует данные движения для калибровки магнитного датчика
     *
     * @return float
     */
    function GetRawMagneticY()
    {
    }

    /**
     * Возвращает 1, если была нажата левая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если
     * мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseLeftPressed()
    {
    }

    /**
     * Если магнитный датчик существует, возвращает X-компоненту любого окружающего магнитного поля. На iOS может
     * потребоваться несколько секунд, чтобы начать отображать данные, отличные от 0, во время этого процесса
     * устройство использует данные движения для калибровки магнитного датчика
     *
     * @return float
     */
    function GetRawMagneticX()
    {
    }

    /**
     * Если датчик окружающего света существует, получите измерение окружающего света в люмел в виде поплавка.
     *
     * @return float
     */
    function GetRawLightLevel()
    {
    }

    /**
     * Возвращает код последней нажатой клавиши. Это относится только к платформам с полноразмерной клавиатурой, таким
     * как ПК, Mac и Linux. Вы можете проверить, существует ли клавиатура, используя GetKeyboardExists. Эта функция
     * продолжает возвращать последнюю нажатую клавишу даже после того, как она была отпущена. Проверьте страницу коды
     * сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому коду ключа
     *
     * @return int
     */
    function GetRawLastKey()
    {
    }

    /**
     * Возвращает 1, если данный код ключа в данный момент не работает. 0, если он поднят. Это относится только к
     * платформам с полноразмерной клавиатурой, таким как ПК и Mac, в противном случае все клавиши вернут 0. Вы можете
     * проверить, существует ли клавиатура, проверив, что GetKeyboardExists возвращает 1. Коды клавиш находятся в
     * диапазоне от 0 до 255, все, что выходит за пределы диапазона, возвращает 0. Проверьте страницу коды сканирования
     * в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому коду ключа
     *
     * @param int $key Код ключа от ключа для проверки.
     * @return int
     */
    function GetRawKeyState($key)
    {
    }

    /**
     * Возвращает 1, если данный код ключа был выпущен в этом кадре, а затем возвращает 0, пока ключ находится вверх.
     * Это относится только к платформам с полноразмерной клавиатурой, таким как ПК и Mac, в противном случае все
     * клавиши вернут 0. Вы можете проверить, существует ли клавиатура, проверив, что GetKeyboardExists возвращает 1.
     * Коды клавиш находятся в диапазоне от 0 до 255, все, что выходит за пределы диапазона, возвращает 0. Проверьте
     * страницу коды сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому
     * коду ключа
     *
     * @param int $key Код ключа от ключа для проверки.
     * @return int
     */
    function GetRawKeyReleased($key)
    {
    }

    /**
     * Возвращает 1, если данный код клавиши был нажат в этом кадре, а затем возвращает 0, пока клавиша удерживается
     * нажатой. Это относится только к платформам с полноразмерной клавиатурой, таким как ПК и Mac, в противном случае
     * все клавиши вернут 0. Вы можете проверить, существует ли клавиатура, проверив, что GetKeyboardExists возвращает
     * 1. Коды клавиш находятся в диапазоне от 0 до 255, все, что выходит за пределы диапазона, возвращает 0. Проверьте
     * страницу коды сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому
     * коду ключа
     *
     * @param int $key Код ключа от ключа для проверки.
     * @return int
     */
    function GetRawKeyPressed($key)
    {
    }

    /**
     * Возвращает текущее значение Z (если применимо) для физического джойстика с заданным индексом. Это будет
     * находиться в диапазоне от -1.0 до 1.0 с центрированием 0.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickZ($index)
    {
    }

    /**
     * Возвращает текущее значение ползунка джойстика, которое может варьироваться в зависимости от типа джойстика. В
     * настоящее время индекс ползунка должен быть либо 0, либо 1. Ползунки обычно используются для дополнительных
     * осей.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @param int $slider Индекс ползунка для проверки.
     * @return int
     */
    function GetRawJoystickSlider($index, $slider)
    {
    }

    /**
     * Возвращает текущее значение Y для физического джойстика с заданным индексом. Это будет находиться в диапазоне от
     * -1.0 до 1.0 с центрированием 0.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickY($index)
    {
    }

    /**
     * Возвращает текущее значение X для физического джойстика с заданным индексом. Это будет находиться в диапазоне от
     * -1.0 до 1.0 с центрированием 0.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickX($index)
    {
    }

    /**
     * Возвращает текущее вращательное значение Z (если применимо) для физического джойстика с заданным индексом. Это
     * будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. На самом деле некоторые джойстики используют это
     * значение для второго аналогового джойстика.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickRZ($index)
    {
    }

    /**
     * Возвращает имя джойстика, обнаруженное операционной системой, в настоящее время работает только на Windows и
     * Linux. В Tier 2 строка кодируется в UTF-8 и должна быть удалена с помощью agk::DeleteString, когда вы закончите
     * с ней.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return string
     */
    function GetRawJoystickName($index)
    {
    }

    /**
     * Возвращает текущее вращательное значение X (если применимо) для физического джойстика с заданным индексом. Это
     * будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. На самом деле некоторые джойстики используют это
     * значение для второго аналогового джойстика.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickRX($index)
    {
    }

    /**
     * Возвращает текущее значение POV джойстика, это может варьироваться в зависимости от типа джойстика. В настоящее
     * время индекс POV должен быть либо 0, 1, 2, либо 3
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @param int $pov Индекс POV для проверки.
     * @return int
     */
    function GetRawJoystickPOV($index, $pov)
    {
    }

    /**
     * Возвращает 1, если джойстик существует в данном индексе. Физические джойстики обнаруживаются при запуске и
     * постепенно помещаются в идентификаторы 1-8. Вы должны вызвать CompleteRawJoystickDetection в какой-то момент
     * перед этой командой, чтобы убедиться, что все присутствующие джойстики были обнаружены. После первоначального
     * процесса обнаружения подключение дополнительных джойстиков не будет обнаружено (за исключением Android, который
     * обнаружит новые джойстики). Отсоединение джойстика не приведет к удалению его индекса, и эта команда все равно
     * вернет 1. Вы можете использовать GetRawJoystickConnected для обнаружения отсоединения ранее обнаруженного
     * джойстика. Если отсоединенный джойстик будет снова подключен, AGK попытается снова подключиться к нему.
     * Альтернативная версия этой команды существует GetJoystickExists, и в этом случае она вернет 1, если есть
     * какие-либо необработанные джойстики.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return int
     */
    function GetRawJoystickExists($index)
    {
    }

    /**
     * Возвращает 1, если указанный джойстик подключен, и 0, если нет. Это относится только к джойстикам, которые были
     * подключены при запуске приложения, подключение нового джойстика после запуска приложения не будет обнаружено.
     * Используйте GetRawJoystickExists, чтобы узнать, какие джойстики были обнаружены при запуске. Эта команда в
     * настоящее время не работает на Mac.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return int
     */
    function GetRawJoystickConnected($index)
    {
    }

    /**
     * Возвращает 1, если данная кнопка в данный момент опущена, в противном случае возвращает 0. Чтобы обнаружить
     * экземпляр, в котором кнопка нажата или отпущена, используйте GetRawJoystickButtonPressed или
     * GetRawJoystickButtonReleased. AGK поддерживает до 64 кнопок джойстика в диапазоне 1-64.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @param int $button Идентификатор кнопки для проверки.
     * @return int
     */
    function GetRawJoystickButtonState($index, $button)
    {
    }

    /**
     * Возвращает 1, если данная кнопка была отпущена в этом кадре, в противном случае возвращает 0. Как только кнопка
     * была отпущена, эта функция возвращается к 0, чтобы проверить состояние кнопки, используйте
     * GetRawJoystickButtonState. AGK поддерживает до 64 кнопок джойстика в диапазоне 1-64.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @param int $button Идентификатор кнопки для проверки.
     * @return int
     */
    function GetRawJoystickButtonReleased($index, $button)
    {
    }

    /**
     * Если гироскоп существует, возвращает Z-составляющую текущей скорости вращения устройства. Если вы не
     * использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в
     * текущей ориентации, чтобы предотвратить вращение экрана. Вы должны использовать SetOrientationAllowed, если
     * хотите включить вращение экрана при использовании гироскопа.
     *
     * @return float
     */
    function GetRawGyroVelocityZ()
    {
    }

    /**
     * Если гироскоп существует, возвращает Y-компоненту текущей скорости вращения устройства. Если вы не использовали
     * SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей
     * ориентации, чтобы предотвратить вращение экрана. Вы должны использовать SetOrientationAllowed, если хотите
     * включить вращение экрана при использовании гироскопа.
     *
     * @return float
     */
    function GetRawGyroVelocityY()
    {
    }

    /**
     * Если гироскоп существует, возвращает X-компоненту текущей скорости вращения устройства. Если вы не использовали
     * SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей
     * ориентации, чтобы предотвратить вращение экрана. Вы должны использовать SetOrientationAllowed, если хотите
     * включить вращение экрана при использовании гироскопа.
     *
     * @return float
     */
    function GetRawGyroVelocityX()
    {
    }

    /**
     * Возвращает текущее вращательное значение Y (если применимо) для физического джойстика с заданным индексом. Это
     * будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. На самом деле некоторые джойстики используют это
     * значение для второго аналогового джойстика.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickRY($index)
    {
    }

    /**
     * Возвращает самую последнюю доступную долготу.
     *
     * @return float
     */
    function GetRawGPSLongitude()
    {
    }

    /**
     * Возвращает самую актуальную высоту, доступную в метрах над уровнем моря.
     *
     * @return float
     */
    function GetRawGPSAltitude()
    {
    }

    /**
     * Возвращает количество файлов, найденных при вызове OpenRawFolder.
     *
     * @param int $ID Идентификатор папки для проверки
     * @return int
     */
    function GetRawFolderNumFiles($ID)
    {
    }

    /**
     * Возвращает количество папок, найденных при вызове OpenRawFolder.
     *
     * @param int $ID Идентификатор папки для проверки
     * @return int
     */
    function GetRawFolderNumFolders($ID)
    {
    }

    /**
     * Возвращая конкретное имя папки из списка файлов, индекс должен быть в диапазоне от 0 до GetRawFolderNumFolders
     * минус один.
     *
     * @param int $ID Идентификатор папки для проверки
     * @param int $index Индекс возвращаемой папки, индексы начинаются с 0
     * @return string
     */
    function GetRawFolderFolderName($ID, $index)
    {
    }

    /**
     * Возвращая конкретное имя файла из списка файлов, индекс должен быть в диапазоне от 0 до GetRawFolderNumFiles
     * минус один.
     *
     * @param int $ID Идентификатор папки для проверки
     * @param int $index Индекс возвращаемого файла, индексы начинаются с 0
     * @return string
     */
    function GetRawFolderFileName($ID, $index)
    {
    }

    /**
     * Возвращает 1, если данная кнопка была нажата в этом кадре, в противном случае возвращает 0. После нажатия кнопки
     * эта функция возвращается к 0, чтобы проверить состояние кнопки, используйте GetRawJoystickButtonState. AGK
     * поддерживает до 64 кнопок джойстика в диапазоне 1-64.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @param int $button Идентификатор кнопки для проверки.
     * @return int
     */
    function GetRawJoystickButtonPressed($index, $button)
    {
    }

    /**
     * Возвращает индекс к первому событию касания, доступному для чтения. По умолчанию AGK не считает событие до тех
     * пор, пока не узнает, какой это тип события, например короткое, длинное, перетаскивание и т. Д. Для получения
     * неизвестных событий также установите значение bIncludeUnknown равным 1. Используйте 0, чтобы игнорировать
     * неизвестные события. Все, в чем вы можете быть уверены при неизвестных событиях, - это то, что палец в данный
     * момент находится на экране и находится там менее 1 секунды. Через 1 секунду он автоматически становится событием
     * удержания. Если пользователь поднимает палец с экрана, это становится коротким событием, а если он двигает
     * пальцем, это становится событием перетаскивания. Если никакие события не доступны, он возвращает 0.
     *
     * @param int $bIncludeUnknown Установите значение true для получения неизвестных событий, которые могут стать
     *     событиями любого типа в будущем.
     * @return int
     */
    function GetRawFirstTouchEvent($bIncludeUnknown)
    {
    }

    /**
     * Если акселерометр существует, возвращает текущее значение акселерометра для направления Z в диапазоне от -1 до
     * 1. Положительное значение Z означает, что экран направлен вверх. Если акселерометр не существует, то он всегда
     * будет возвращать 0, так как нет эмулируемой команды для направления Z. Если вы не использовали
     * SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей
     * ориентации, чтобы предотвратить вращение экрана акселерометром. Вы должны использовать SetOrientationAllowed,
     * если хотите включить вращение экрана при использовании акселерометра.
     *
     * @return float
     */
    function GetRawAccelZ()
    {
    }

    /**
     * Если акселерометр существует, возвращает текущее значение акселерометра для направления X в диапазоне от -1 до
     * 1. Это соответствует экранной системе координат положительного существа справа. Если акселерометра не
     * существует, то он всегда будет возвращать 0. Вы можете использовать команду GetDirectionX для эмуляции ввода
     * направления. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда
     * заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана акселерометром. Вы должны
     * использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании акселерометра.
     *
     * @return float
     */
    function GetRawAccelX()
    {
    }

    /**
     * Если акселерометр существует, возвращает текущее значение акселерометра для направления Y в диапазоне от -1 до
     * 1. Это соответствует экранной системе координат положительного бытия вниз. Если акселерометра не существует, то
     * он всегда будет возвращать 0. Вы можете использовать команду GetDirectionY для эмуляции ввода направления. Если
     * вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в
     * текущей ориентации, чтобы предотвратить вращение экрана акселерометром. Вы должны использовать
     * SetOrientationAllowed, если хотите включить вращение экрана при использовании акселерометра.
     *
     * @return float
     */
    function GetRawAccelY()
    {
    }

    /**
     * Возвращает маркер push-уведомления для этого устройства, он должен быть отправлен на ваш сервер, который
     * отправляет уведомления, чтобы он мог отправлять уведомления на это устройство. Если PushNotificationSetup вернул
     * 1, то вы должны продолжать вызывать эту команду до тех пор, пока она не вернет непустую строку. Если
     * PushNotificationSetup вернул 0, то эта команда всегда будет возвращать пустую строку.  Пожалуйста, обратитесь к
     * руководству по Push-уведомлениям Android для получения более подробной информации о том, как использовать токен
     * устройства для отправки Push-уведомлений на это устройство.
     *
     * @return string
     */
    function GetPushNotificationToken()
    {
    }

    /**
     * Возвращает 1, если текущее устройство имеет датчик приближения, который в настоящее время поддерживается AGK, и
     * 0, если нет.
     *
     * @return int
     */
    function GetProximitySensorExists()
    {
    }

    /**
     * Возвращает самую последнюю доступную широту.
     *
     * @return float
     */
    function GetRawGPSLatitude()
    {
    }

    /**
     * Возвращает количество полигонов, нарисованных последним кадром графического процессора.
     *
     * @return int
     */
    function GetPolygonsDrawn()
    {
    }

    /**
     * Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана.
     * Если устройство имеет мышь, то это возвращает текущее положение X мыши. В противном случае AGK проверит наличие
     * сенсорного экрана и, если он будет найден, вернет положение X самого последнего события касания. Если никаких
     * событий не происходит, то это последняя позиция X, записанная сенсорным событием. На устройствах, не имеющих ни
     * мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого
     * аналоговыми стиками или подобными. Эта координата будет находиться в координатах вида, если вы смещаете порт
     * вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldX.
     *
     * @return float
     */
    function GetPointerX()
    {
    }

    /**
     * Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана.
     * Если на устройстве есть мышь, то это вернет 1, если левая кнопка мыши в данный момент нажата, и 0, если нет. В
     * противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет 1, если в данный момент
     * нажимается одно или несколько сенсорных событий. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK
     * попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными.
     * Существует три команды для получения состояния нажатия указателя: GetPointerPressed возвращает 1 в момент
     * нажатия указателя, а затем возвращает 0, GetPointerReleased возвращает 1 в момент отпускания указателя, а затем
     * возвращает 0, GetPointerState возвращает 1 все время нахождения указателя в нажатом состоянии.
     *
     * @return int
     */
    function GetPointerState()
    {
    }

    /**
     * возвращает 1, если указанный точечный свет существует, и 0 в противном случае.
     *
     * @param int $lightID Идентификатор света для проверки.
     * @return int
     */
    function GetPointLightExists($lightID)
    {
    }

    /**
     * Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана.
     * Если на устройстве есть мышь, то это вернет 1, если левая кнопка мыши отпущена, и 0, если нет. В противном
     * случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет 1, если будет выпущено одно или
     * несколько сенсорных событий. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать
     * некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными. Существует три команды для
     * получения состояния нажатия указателя: GetPointerPressed возвращает 1 в момент нажатия указателя, а затем
     * возвращает 0, GetPointerReleased возвращает 1 в момент отпускания указателя, а затем возвращает 0,
     * GetPointerState возвращает 1 все время нахождения указателя в нажатом состоянии.
     *
     * @return int
     */
    function GetPointerReleased()
    {
    }

    /**
     * Возвращает оценку количества пикселей, которые были нарисованы на экране в последнем кадре. Как правило, чем
     * ниже это значение, тем лучше производительность. Количество нарисованных пикселей может быть больше, чем
     * количество пикселей на экране, так как перекрывающиеся спрайты могут рисовать один и тот же пиксель дважды.
     *
     * @return int
     */
    function GetPixelsDrawn()
    {
    }

    /**
     * Возвращает количество островов, обработанных решателем на последнем шаге
     *
     * @return int
     */
    function GetPhysicsIslandCount()
    {
    }

    /**
     * Возвращает количество секунд и долей секунд, затраченных на обновление физического моделирования.
     *
     * @return float
     */
    function GetPhysicsTime()
    {
    }

    /**
     * Возвращает количество миллисекунд, затраченных в решателе
     *
     * @return float
     */
    function GetPhysicsSolveTime()
    {
    }

    /**
     * Возвращает координату X точки столкновения от последнего вызова GetPhysicsCollision относительно смещения
     * первого спрайта.
     *
     * @return float
     */
    function GetPhysicsCollisionX()
    {
    }

    /**
     * Возвращает координату Y точки столкновения от последнего вызова GetPhysicsCollision относительно смещения
     * первого спрайта.
     *
     * @return float
     */
    function GetPhysicsCollisionY()
    {
    }

    /**
     * Возвращает координату Y точки столкновения из последнего вызова GetPhysicsCollision в мировых координатах.
     *
     * @return float
     */
    function GetPhysicsCollisionWorldY()
    {
    }

    /**
     * Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана.
     * Если устройство имеет мышь, то это возвращает текущее положение мыши Y. В противном случае AGK проверит наличие
     * сенсорного экрана и, если он будет найден, вернет положение Y самого последнего события касания. Если никаких
     * событий не происходит, то это последняя позиция Y, записанная сенсорным событием. На устройствах, не имеющих ни
     * мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого
     * аналоговыми стиками или подобными. Эта координата будет находиться в координатах вида, если вы смещаете порт
     * вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldY.
     *
     * @return float
     */
    function GetPointerY()
    {
    }

    /**
     * Возвращает 1, если два физических спрайта перекрываются, в противном случае он возвращает 0. Эта функция не
     * делает никаких вычислений, она просто просматривает результаты последнего физического шага, чтобы определить,
     * перекрываются ли спрайты в данный момент. Если эта функция возвращает true, вы можете получить точку
     * столкновения с помощью GetPhysicsCollisionX и GetPhysicsCollisionY, если существует более одной точки
     * столкновения, неизвестно, какая точка будет возвращена. Вы можете проверить список контактов спрайта, чтобы
     * получить полный список контактных точек. На эту функцию влияют настройки групп и категорий.
     *
     * @param int $iSprite1 Идентификатор первого спрайта для проверки
     * @param int $iSprite2 Идентификатор второго спрайта для проверки
     * @return int
     */
    function GetPhysicsCollision($iSprite1, $iSprite2)
    {
    }

    /**
     * Возвращает координату X точки столкновения из последнего вызова GetPhysicsCollision в мировых координатах.
     *
     * @return float
     */
    function GetPhysicsCollisionWorldX()
    {
    }

    /**
     * Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана.
     * Если устройство имеет мышь, то это вернет 1, если левая кнопка мыши нажата, 0, если нет. В противном случае AGK
     * проверит наличие сенсорного экрана и, если он будет найден, вернет 1, если существует одно или несколько событий
     * касания. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму
     * экранного указателя, управляемого аналоговыми стиками или подобными.  Существует три команды для получения
     * состояния нажатия указателя: GetPointerPressed возвращает 1 в момент нажатия указателя, а затем возвращает 0,
     * GetPointerReleased возвращает 1 в момент отпускания указателя, а затем возвращает 0, GetPointerState возвращает
     * 1 все время нахождения указателя в нажатом состоянии.
     *
     * @return int
     */
    function GetPointerPressed()
    {
    }

    /**
     * Возвращает текущее положение Y излучателя, это точка, из которой будут появляться новые частицы. Невозможно
     * получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesY($ID)
    {
    }

    /**
     * Возвращает текущее положение X излучателя, это точка, из которой будут появляться новые частицы. Невозможно
     * получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesX($ID)
    {
    }

    /**
     * Возвращает 0, если данные частицы были установлены как невидимые с помощью SetParticlesVisible, или 1, если они
     * в данный момент установлены как видимые (по умолчанию). Это не проверяет, находятся ли частицы в видимом окне
     * просмотра.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function GetParticlesVisible($ID)
    {
    }

    /**
     * Возвращает текущий размер всех частиц в мировых координатах. Подробнее об установке размера частиц см. в разделе
     * SetParticlesSize.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesSize($ID)
    {
    }

    /**
     * Возвращает 1, если излучатель испустил количество частиц, указанное в SetParticlesMax, и все испущенные частицы
     * с тех пор умерли, в противном случае возвращает 0. Если максимальное значение равно -1, то оно всегда будет
     * возвращать 0. Чтобы сбросить счетчик и заставить излучатель снова начать излучать, используйте
     * ResetParticleCount.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function GetParticlesMaxReached($ID)
    {
    }

    /**
     * Возвращает текущую жизнь частиц в секундах. Невозможно получить текущую жизнь отдельных частиц. Это значение не
     * зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesLife($ID)
    {
    }

    /**
     * Возвращает текущую частоту генерации частиц в частицах в секунду. Это значение не зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesFrequency($ID)
    {
    }

    /**
     * Возвращает 1, если излучатель частиц существует с заданным идентификатором, и 0, если нет.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function GetParticlesExists($ID)
    {
    }

    /**
     * Возвращает y-компоненту направления излучателя, которое является базовым направлением движения частиц при их
     * создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения
     * SetParticlesAngle.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesDirectionY($ID)
    {
    }

    /**
     * Возвращает X-компоненту направления излучателя, которое является базовым направлением движения частиц при их
     * создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения
     * GetParticlesAngle.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesDirectionX($ID)
    {
    }

    /**
     * Возвращает текущую глубину, на которой будут нарисованы все частицы. Это значение находится в диапазоне от 0 до
     * 10000, причем 0 находится в передней части экрана.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function GetParticlesDepth($ID)
    {
    }

    /**
     * Возвращает текущий угол излучателя в радианах. Это значение представляет собой величину отклонения частицы от
     * направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 2*PI означает, что
     * частица может двигаться в любом направлении при испускании.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesAngleRad($ID)
    {
    }

    /**
     * Возвращает 1, если ваше настольное приложение теряет фокус. Вы можете активировать экран паузы, когда это
     * произойдет, или позволить приложению продолжать работать в обычном режиме. Это относится только к настольным
     * платформам, на мобильных платформах вы должны использовать GetResumed вместо этого.
     *
     * @return int
     */
    function GetPaused()
    {
    }

    /**
     * Возвращает текущий угол излучателя в градусах. Это значение представляет собой величину отклонения частицы от
     * направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 360 означает, что
     * частица может двигаться в любом направлении при испускании.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesAngle($ID)
    {
    }

    /**
     * Возвращает 0, если данные частицы были приостановлены с помощью SetParticlesActive, или 1, если они в данный
     * момент обновляются как обычно (по умолчанию).
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function GetParticlesActive($ID)
    {
    }

    /**
     * Возвращает количество отдельных частиц, которые были нарисованы в последнем кадре с помощью метода quad. Чем
     * выше это число, тем больше работы выполняет двигатель, обрабатывая частицы.
     *
     * @return int
     */
    function GetParticleDrawnQuadCount()
    {
    }

    /**
     * Начиная с версии 108 эта команда всегда будет возвращать 0, так как все частицы рисуются квадратиками. Вместо
     * этого используйте GetParticleDrawnQuadCount.
     *
     * @return int
     */
    function GetParticleDrawnPointCount()
    {
    }

    /**
     * Возвращает текущую ориентацию устройства. Возвращаемые значения: 1 = портретный режим, 2 = портретный режим -
     * поворот на 180 градусов, 3 = ландшафтный режим - 90 градусов против часовой стрелки, 4 = ландшафтный режим - 90
     * градусов по часовой стрелке
     *
     * @return int
     */
    function GetOrientation()
    {
    }

    /**
     * Заполняет outPosVec3 контактным положением. Возвращает false, если нет контакта. Сначала создайте вектор с
     * помощью CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен
     * результатами.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $outPosVec3 Идентификатор вектора положения, который должен быть заполнен. Сначала создайте этот
     *     вектор.
     * @return int
     */
    function GetObjects3DPhysicsContactPositionVector($objA, $objB, $outPosVec3)
    {
    }

    /**
     * Возвращает текущее Z-положение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectZ($objID)
    {
    }

    /**
     * Возвращает текущее положение X объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectX($objID)
    {
    }

    /**
     * Возвращает текущее Z-положение объекта в мировых координатах. Это учитывает родительские позиции в результате
     * FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое положение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldZ($objID)
    {
    }

    /**
     * Возвращает текущее положение объекта Y в мировых координатах. Это учитывает родительские позиции в результате
     * FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое положение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldY($objID)
    {
    }

    /**
     * Возвращает Z-компоненту текущего вращения объекта, преобразованную в кватернион в мировых координатах. Это
     * учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное
     * мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldQuatZ($objID)
    {
    }

    /**
     * Возвращает Y-компоненту текущего вращения объекта, преобразованную в кватернион в мировых координатах. Это
     * учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное
     * мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldQuatY($objID)
    {
    }

    /**
     * Возвращает текущее положение X объекта в мировых координатах. Это учитывает родительские позиции в результате
     * FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое положение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldX($objID)
    {
    }

    /**
     * Возвращает X-компоненту текущего вращения объекта, преобразованную в кватернион в мировых координатах. Это
     * учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное
     * мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldQuatX($objID)
    {
    }

    /**
     * Возвращает W-компонент текущего вращения объекта, преобразованный в кватернион в мировых координатах. Это
     * учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное
     * мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldQuatW($objID)
    {
    }

    /**
     * Возвращает Z-компоненту текущего вращения объекта, преобразованную в углы Эйлера в мировых координатах. Это
     * учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное
     * мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldAngleZ($objID)
    {
    }

    /**
     * Возвращает Y-компоненту текущего вращения объекта, преобразованную в углы Эйлера в мировых координатах. Это
     * учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное
     * мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldAngleY($objID)
    {
    }

    /**
     * Возвращает X-компоненту текущего вращения объекта, преобразованную в углы Эйлера в мировых координатах. Это
     * учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное
     * мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldAngleX($objID)
    {
    }

    /**
     * Возвращает текущее положение объекта Y.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectY($objID)
    {
    }

    /**
     * Возвращает текущий режим прозрачности для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectTransparency($objID)
    {
    }

    /**
     * Возвращает имя текстуры, определенное в файле модели, из которого она была загружена, но текстурам не
     * гарантируется наличие имен. Имена текстур находятся в диапазоне от 1 до GetObjectNumTextures включительно. Если
     * вы вызываете эту команду из уровня 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда
     * закончите с ней.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $textureIndex Индекс текстуры для проверки, первая текстура находится в индексе 1.
     * @return string
     */
    function GetObjectTextureName($objID, $textureIndex)
    {
    }

    /**
     * Возвращает минимальный экстент объекта в направлении Z, это может быть объединено с GetObjectSizeMaxZ для
     * определения размера объекта в направлении Z. Обратите внимание, что объект может быть смещен от центра, поэтому
     * его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2
     * единицы в направлении Z. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы
     * одной сетки, используйте GetObjectMeshSizeMinZ.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMinZ($objID)
    {
    }

    /**
     * Возвращает минимальный экстент объекта в направлении X, это может быть объединено с GetObjectSizeMaxY для
     * определения размера объекта в направлении Y. Обратите внимание, что объект может быть смещен от центра, поэтому
     * его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2
     * единицы в направлении Y. Эта команда берет границы всех сеток, составляющих этот объект, для проверки границ
     * одной сетки используйте GetObjectMeshSizeMinY.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMinY($objID)
    {
    }

    /**
     * Возвращает минимальный экстент объекта в направлении X, это может быть объединено с GetObjectSizeMaxX для
     * определения размера объекта в направлении X. Обратите внимание, что объект может быть смещен от центра, поэтому
     * его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2
     * единицы в направлении X. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы
     * одной сетки, используйте GetObjectMeshSizeMinX.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMinX($objID)
    {
    }

    /**
     * Возвращает максимальный экстент объекта в направлении Z, это может быть объединено с GetObjectSizeMinZ для
     * определения размера объекта в направлении Z. Обратите внимание, что объект может быть смещен от центра, поэтому
     * его минимальное значение может быть равно 10, а максимальное-12, то есть его размер составляет 2 единицы в
     * направлении Z. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной
     * сетки, используйте GetObjectMeshSizeMaxZ.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMaxZ($objID)
    {
    }

    /**
     * Возвращает максимальный экстент объекта в направлении X, это можно объединить с GetObjectSizeMinY для
     * определения размера объекта в направлении Y. Обратите внимание, что объект может быть смещен от центра, поэтому
     * его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2
     * единицы в направлении Y. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы
     * одной сетки, используйте GetObjectMeshSizeMaxY.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMaxY($objID)
    {
    }

    /**
     * Возвращает максимальный экстент объекта в направлении X, это может быть объединено с GetObjectSizeMinX для
     * определения размера объекта в направлении X. Обратите внимание, что объект может быть смещен от центра, поэтому
     * его минимальное значение может быть равно 10, а максимальное-12, то есть его размер составляет 2 единицы в
     * направлении X. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной
     * сетки, используйте GetObjectMeshSizeMaxX.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMaxX($objID)
    {
    }

    /**
     * Возвращает 1, если объект в данный момент настроен на получение теней, и 0 в противном случае.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectReceiveShadowMode($objID)
    {
    }

    /**
     * Возвращает Z-компоненту точки столкновения для заданного индекса столкновения в последней проверке столкновения.
     * Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastZ($index)
    {
    }

    /**
     * Возвращает текущий режим видимости для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectVisible($objID)
    {
    }

    /**
     * Возвращает компонент Y точки столкновения для заданного индекса столкновения в последней проверке столкновения.
     * Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastY($index)
    {
    }

    /**
     * Возвращает компонент X точки столкновения для заданного индекса столкновения в последней проверке столкновения.
     * Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastX($index)
    {
    }

    /**
     * Возвращает Z-компоненту конечной точки покоя для скользящих столкновений. Это допустимо только для индекса 0 и
     * после вызова ObjectSphereSlide. Поместите объект здесь, чтобы он выглядел так, как будто он скользил после
     * столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastSlideZ($index)
    {
    }

    /**
     * Возвращает компонент Y конечной точки покоя для скользящих столкновений. Это допустимо только для индекса 0 и
     * после вызова ObjectSphereSlide. Поместите объект здесь, чтобы он выглядел так, как будто он скользил после
     * столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastSlideY($index)
    {
    }

    /**
     * Возвращает Z-компонент нормальной коллизии при последней проверке коллизии. Вы можете проверить количество
     * допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastNormalZ($index)
    {
    }

    /**
     * Возвращает компонент X конечной точки покоя для скользящих столкновений. Это допустимо только для индекса 0 и
     * после вызова ObjectSphereSlide. Поместите объект здесь, чтобы он выглядел так, как будто он скользил после
     * столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastSlideX($index)
    {
    }

    /**
     * Возвращает компонент Y нормальной коллизии при последней проверке коллизии. Вы можете проверить количество
     * допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastNormalY($index)
    {
    }

    /**
     * Возвращает попадание идентификатора объекта для данного индекса коллизии при последней проверке коллизии. Вы
     * можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return int
     */
    function GetObjectRayCastHitID($index)
    {
    }

    /**
     * Возвращает расстояние между начальной точкой луча и точкой столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastDistance($index)
    {
    }

    /**
     * Возвращает Z-компоненту вектора отскока для последней проверки столкновения. Вы можете проверить количество
     * допустимых индексов с помощью GetObjectRayCastNumHits. Расположите объект здесь так, чтобы он выглядел так, как
     * будто отскочил после столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastBounceZ($index)
    {
    }

    /**
     * Возвращает компонент Y вектора отскока для последней проверки столкновения. Вы можете проверить количество
     * допустимых индексов с помощью GetObjectRayCastNumHits. Расположите объект здесь так, чтобы он выглядел так, как
     * будто отскочил после столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastBounceY($index)
    {
    }

    /**
     * Возвращает X-компоненту вектора отскока для последней проверки столкновения. Вы можете проверить количество
     * допустимых индексов с помощью GetObjectRayCastNumHits. Расположите объект здесь так, чтобы он выглядел так, как
     * будто отскочил после столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastBounceX($index)
    {
    }

    /**
     * Возвращает Z-компонент текущего вращения объекта, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectQuatZ($objID)
    {
    }

    /**
     * Возвращает компонент Y текущего вращения объекта, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectQuatY($objID)
    {
    }

    /**
     * Возвращает W-компонент текущего вращения объекта, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectQuatW($objID)
    {
    }

    /**
     * Возвращает количество коллизий, произошедших при последней проверке коллизий. В случае ObjectRayCast и
     * ObjectSphereCast это будет 0 или 1. Для ObjectSphereSlide это может быть где-то между 0 и 4.
     *
     * @return int
     */
    function GetObjectRayCastNumHits()
    {
    }

    /**
     * Возвращает компонент X нормальной коллизии при последней проверке коллизии. Вы можете проверить количество
     * допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastNormalX($index)
    {
    }

    /**
     * Возвращает количество ссылок на текстуру, найденных при загрузке объекта. Объект может иметь несколько ссылок на
     * текстуру. Эта информация будет доступна только в том случае, если файл модели имеет настройку материала с
     * ссылкой на диффузную текстуру.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectNumTextures($objID)
    {
    }

    /**
     * Возвращает количество сеток, принадлежащих этому объекту. Объект может иметь несколько сеток, обычно это
     * происходит в случае мультиматериальных объектов, где объект разделен на несколько сеток, каждая из которых
     * использует другую текстуру. Обратите внимание, что экземпляры объектов могут не иметь никаких сеток.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectNumMeshes($objID)
    {
    }

    /**
     * Получает количество костей, которые были загружены в результате загрузки этого объекта. Это происходит только в
     * том случае, если объект был загружен с помощью LoadObjectWithChildren. Если объект имеет анимацию конечностей,
     * как в DarkBasic Classic, то кости представляют иерархию конечностей, и каждая конечность загружается как
     * дочерний объект, прикрепленный к кости. Если объект имеет взвешенную вершинную анимацию, то кости представляют
     * скелет, а кожа загружается как единая сетка, хранящаяся в корневом объекте. Эти две формы анимации могут быть
     * объединены, так что взвешенная вершинная костная структура может иметь объекты, прикрепленные к ее костям
     * одновременно с деформацией кожной сетки.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectNumBones($objID)
    {
    }

    /**
     * Возвращает имя объекта, определенное в файле модели. Это полезно при использовании LoadObjectWithChildren для
     * идентификации дочерних объектов, к которым можно получить доступ с помощью GetObjectChildID.  Если вы вызываете
     * эту команду из уровня 2, то возвращаемая строка должна быть удалена с помощью agk::DeleteString, когда вы
     * закончите с ней.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return string
     */
    function GetObjectName($objID)
    {
    }

    /**
     * Возвращает компонент X текущего вращения объекта, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectQuatX($objID)
    {
    }

    /**
     * Возвращает минимальную протяженность сетки в направлении Y, это может быть объединено с GetObjectMeshSizeMaxY
     * для определения размера сетки в направлении Y. Обратите внимание, что сетка может быть смещена от центра,
     * поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2
     * единицы в направлении Y.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMinY($objID, $meshIndex)
    {
    }

    /**
     * Возвращает количество дочерних объектов, которые были загружены в результате загрузки этого объекта. Например,
     * объект анимированного персонажа из кости может иметь модель пистолета, прикрепленную к кости, представляющей его
     * руку, эта модель пистолета будет загружена как отдельный объект и получит свой собственный идентификатор,
     * которым вы можете манипулировать отдельно от основного объекта. Вы даже можете отсоединить пистолет от руки с
     * помощью FixObjectToBone(ID,0), чтобы сделать его нормальным объектом, который не будет двигаться при движении
     * персонажа. Однако он всегда будет оставаться в этом списке дочерних объектов для справки и будет удален, если
     * DeleteObjectWithChildren вызывается для объекта character. Для тех из вас, кто знаком с DarkBasic, объекты,
     * содержащие конечности в DarkBasic, будут загружены как дочерние объекты в AGK. Однако в дочерних объектах нет
     * иерархии, у них не было бы собственных детей. Вместо этого в корневом объекте создается костная структура,
     * представляющая иерархию конечностей, а дочерние объекты присоединяются к соответствующим костям.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectNumChildren($objID)
    {
    }

    /**
     * Возвращает количество анимаций, назначенных объекту в данный момент. Только объекты, загруженные с помощью
     * LoadObjectWithChildren, получают назначенные им анимации.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectNumAnimations($objID)
    {
    }

    /**
     * Возвращает минимальный экстент сетки в направлении X, это можно объединить с GetObjectMeshSizeMaxX для
     * определения размера сетки в направлении X. Обратите внимание, что сетка может быть смещена от центра, поэтому ее
     * минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в
     * направлении X.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMinX($objID, $meshIndex)
    {
    }

    /**
     * Возвращает максимальную протяженность сетки в направлении Z, это может быть объединено с GetObjectMeshSizeMinZ
     * для определения размера сетки в направлении Z. Обратите внимание, что сетка может быть смещена от центра,
     * поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2
     * единицы в направлении Z.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMaxZ($objID, $meshIndex)
    {
    }

    /**
     * Возвращает максимальную протяженность сетки в направлении Y, это может быть объединено с GetObjectMeshSizeMinY
     * для определения размера сетки в направлении Y. Обратите внимание, что сетка может быть смещена от центра,
     * поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2
     * единицы в направлении Y.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMaxY($objID, $meshIndex)
    {
    }

    /**
     * Возвращает максимальный экстент сетки в направлении X, это может быть объединено с GetObjectMeshSizeMinX для
     * определения размера сетки в направлении X. Обратите внимание, что сетка может быть смещена от центра, поэтому ее
     * минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в
     * направлении X.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMaxX($objID, $meshIndex)
    {
    }

    /**
     * Возвращает исходный код вершинного шейдера, используемого в данный момент на этом объекте. Если вы не назначили
     * шейдер для этой сетки, то он генерируется автоматически, и вы можете использовать эту команду, чтобы получить
     * его исходный код, если хотите внести в него коррективы. Затем вы можете загрузить этот модифицированный источник
     * шейдера с помощью LoadShader и назначить его SetObjectMeshShader. Обратите внимание, что изменение количества
     * текстур или использование SetObjectLightMode обычно генерирует новый шейдер для обработки изменений, однако если
     * вы использовали SetObjectMeshShader, то AGK больше не будет изменять ваш шейдер, предполагая, что вы сами учли
     * эти изменения. Обратите внимание, что шейдеры, использующие освещение, будут иметь функции GetVSLighting() и
     * GetPSLighting (), которые будут заполняться AGK во время выполнения в зависимости от того, сколько огней
     * находится рядом с сеткой. Удаление этих функций из источника шейдера приведет к удалению всего освещения из
     * сетки. Если вы вызываете эту команду из уровня 2, вы должны удалить строку, когда закончите с ней.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки, первая сетка находится в индексе 1.
     * @return string
     */
    function GetObjectMeshVSSource($objID, $meshIndex)
    {
    }

    /**
     * Возвращает минимальный экстент сетки в направлении Z, это может быть объединено с GetObjectMeshSizeMaxZ для
     * определения размера сетки в направлении Z. Обратите внимание, что сетка может быть смещена от центра, поэтому ее
     * минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в
     * направлении Z.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMinZ($objID, $meshIndex)
    {
    }

    /**
     * Возвращает исходный код пиксельного шейдера, используемого в данный момент на этом объекте. Если вы не назначили
     * шейдер для этой сетки, то он генерируется автоматически, и вы можете использовать эту команду, чтобы получить
     * его исходный код, если хотите внести в него коррективы. Затем вы можете загрузить этот модифицированный источник
     * шейдера с помощью LoadShader и назначить его SetObjectMeshShader. Обратите внимание, что изменение количества
     * текстур или использование SetObjectLightMode обычно генерирует новый шейдер для обработки изменений, однако если
     * вы использовали SetObjectMeshShader, то AGK больше не будет изменять ваш шейдер, предполагая, что вы сами учли
     * эти изменения. Обратите внимание, что шейдеры, использующие освещение, будут иметь функции GetVSLighting() и
     * GetPSLighting (), которые будут заполняться AGK во время выполнения в зависимости от того, сколько огней
     * находится рядом с сеткой. Удаление этих функций из источника шейдера приведет к удалению всего освещения из
     * сетки. Если вы вызываете эту команду из уровня 2, вы должны удалить строку, когда закончите с ней.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки, первая сетка находится в индексе 1.
     * @return string
     */
    function GetObjectMeshPSSource($objID, $meshIndex)
    {
    }

    /**
     * Получает имя сетки, как определено в файле модели, из которого она была загружена, но сетки не гарантированно
     * имеют имена. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes включительно. Если вы вызываете эту
     * команду из уровня 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки, первая сетка находится в индексе 1.
     * @return string
     */
    function GetObjectMeshName($objID, $meshIndex)
    {
    }

    /**
     * Возвращает 1, если объект в данный момент находится в кадре анимации, или в начале, или в готовящейся к
     * воспроизведению анимации. Это происходит только сразу после PlayObjectAnimation или SetObjectAnimationFrame,
     * если вы указали время анимации больше 0. Это не происходит в любое другое время во время анимации.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectIsTweening($objID)
    {
    }

    /**
     * Возвращает 1 если объект в данный момент воспроизводит анимацию, это включает твин до начала анимации, но не
     * твин до одного кадра. По сути, он возвращает 1, если объект должен воспроизводить анимацию. Если анимация
     * настроена на цикл заданное количество раз или воспроизводится только один раз, то эта команда вернет 0, когда
     * анимация будет закончена.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectIsAnimating($objID)
    {
    }

    /**
     * Если объект был создан с помощью CreateObjectFromHeightMap, то эта команда может быть использована для быстрого
     * получения высоты объекта в определенном мировом положении. Это объясняет положение объекта и поворот Y, чтобы
     * обеспечить высоту независимо от того, где находится объект. Если объект повернут под углом X или Z, то это
     * приведет к неправильным значениям. Вы должны указать координаты X и Z в мировых единицах измерения, если точка
     * лежит вне объекта, то будет возвращено 0.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param float $x X компонент позиции для проверки
     * @param float $z Z компонент позиции для проверки
     * @return float
     */
    function GetObjectHeightMapHeight($objID, $x, $z)
    {
    }

    /**
     * Возвращает 1, если AGK считает, что объект в данный момент находится на экране, и 0, если нет. Это оценка, и
     * если вы сомневаетесь, предположим, что объект находится на экране. Таким образом, если эта команда возвращает 0,
     * то объект определенно находится вне экрана, если она возвращает 1, то объект может быть или не быть на экране.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectInScreen($objID)
    {
    }

    /**
     * Возвращает 1, если объект существует с заданным идентификатором, и 0 в противном случае.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectExists($objID)
    {
    }

    /**
     * Возвращает текущий режим записи глубины для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectDepthWrite($objID)
    {
    }

    /**
     * Возвращает текущий режим чтения глубины для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectDepthReadMode($objID)
    {
    }

    /**
     * Возвращает текущее красное значение цвета этого объекта, заданное параметром SetObjectColor.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectColorRed($objID)
    {
    }

    /**
     * Возвращает текущее зеленое значение цвета этого объекта, заданное параметром SetObjectColor.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectColorGreen($objID)
    {
    }

    /**
     * Возвращает текущее синее значение цвета этого объекта, заданное параметром SetObjectColor.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectColorBlue($objID)
    {
    }

    /**
     * Возвращает идентификатор объекта для указанного дочернего объекта, который был загружен в результате этого
     * объекта. Чтобы найти количество дочерних объектов, используйте GetObjectNumChildren. childIndex находится в
     * диапазоне от 1 до количества детей включительно. Для тех из вас, кто знаком с DarkBasic, объекты, содержащие
     * конечности в DarkBasic, будут загружены как дочерние объекты в AGK. Однако в дочерних объектах нет иерархии, у
     * них не было бы собственных детей. Вместо этого в корневом объекте создается костная структура, представляющая
     * иерархию конечностей, а дочерние объекты присоединяются к соответствующим костям.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $childIndex Индекс ребенка получить.
     * @return int
     */
    function GetObjectChildID($objID, $childIndex)
    {
    }

    /**
     * Возвращает 1, если объект в данный момент настроен на отбрасывание теней, и 0 в противном случае.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectCastShadowMode($objID)
    {
    }

    /**
     * Возвращает текущее Z - положение кости.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneZ($objID, $boneIndex)
    {
    }

    /**
     * Возвращает текущее положение кости по оси Y.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneY($objID, $boneIndex)
    {
    }

    /**
     * Возвращает текущее положение X кости.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneX($objID, $boneIndex)
    {
    }

    /**
     * Возвращает текущее Z - положение кости в мировых координатах.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldZ($objID, $boneIndex)
    {
    }

    /**
     * Возвращает текущее смещение глубины для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectDepthBias($objID)
    {
    }

    /**
     * Возвращает текущее положение кости по оси Y в мировых координатах.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldY($objID, $boneIndex)
    {
    }

    /**
     * Возвращает текущий режим отбраковки для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectCullMode($objID)
    {
    }

    /**
     * Возвращает Z-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldQuatZ($objID, $boneIndex)
    {
    }

    /**
     * Возвращает Y-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldQuatY($objID, $boneIndex)
    {
    }

    /**
     * Возвращает X-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldQuatX($objID, $boneIndex)
    {
    }

    /**
     * Возвращает W-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldQuatW($objID, $boneIndex)
    {
    }

    /**
     * Возвращает Z-компоненту текущего вращения кости, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldAngleZ($objID, $boneIndex)
    {
    }

    /**
     * Возвращает Y-компоненту текущего вращения кости, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldAngleY($objID, $boneIndex)
    {
    }

    /**
     * Возвращает X-компоненту текущего вращения кости в мировых координатах, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldAngleX($objID, $boneIndex)
    {
    }

    /**
     * Возвращает Z-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneQuatZ($objID, $boneIndex)
    {
    }

    /**
     * Возвращает Y-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneQuatY($objID, $boneIndex)
    {
    }

    /**
     * Возвращает X-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneQuatX($objID, $boneIndex)
    {
    }

    /**
     * Возвращает W-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneQuatW($objID, $boneIndex)
    {
    }

    /**
     * Возвращает текущее положение кости X в мировых координатах.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldX($objID, $boneIndex)
    {
    }

    /**
     * Получает индекс кости по ее имени. Имена загружаются из файла модели при использовании LoadObjectWithChildren, в
     * противном случае кости не загружаются. Индексы будут находиться в диапазоне от 1 до num bones или 0, если они не
     * найдены.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param string $name Имя кости, которую нужно найти.
     * @return int
     */
    function GetObjectBoneByName($objID, $name)
    {
    }

    /**
     * Возвращает Z-компоненту текущего вращения кости, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneAngleZ($objID, $boneIndex)
    {
    }

    /**
     * Возвращает Y-компоненту текущего вращения кости, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneAngleY($objID, $boneIndex)
    {
    }

    /**
     * Возвращает текущее время воспроизводимой анимации, или если анимация остановилась, то возвращается последнее
     * время, использованное для интерполяции.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectAnimationTime($objID)
    {
    }

    /**
     * Возвращает X-компоненту текущего вращения кости, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneAngleX($objID, $boneIndex)
    {
    }

    /**
     * Возвращает имя указанной анимации для данного объекта. Вы можете найти количество анимаций для этого объекта с
     * помощью GetObjectNumAnimations. Индекс должен находиться в диапазоне от 1 до numAnimations включительно.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $index Индекс анимации для проверки, индексы начинаются с 1.
     * @return string
     */
    function GetObjectAnimationName($objID, $index)
    {
    }

    /**
     * Возвращает длительность указанной анимации в секундах.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param string $animName Название проверяемой анимации, определяемое программой моделирования
     * @return float
     */
    function GetObjectAnimationDuration($objID, $animName)
    {
    }

    /**
     * Возвращает Z-компоненту текущего вращения объекта, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectAngleZ($objID)
    {
    }

    /**
     * Возвращает Y-компоненту текущего вращения объекта, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectAngleY($objID)
    {
    }

    /**
     * Возвращает X-компоненту текущего вращения объекта, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectAngleX($objID)
    {
    }

    /**
     * Возвращает текущее альфа-значение цвета этого объекта, заданное SetObjectColor или SetObjectAlpha.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectAlpha($objID)
    {
    }

    /**
     * Возвращает имя кости. Если эта команда вызывается с уровня 2, то вы должны удалить возвращенную строку, когда
     * закончите с ней.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return string
     */
    function GetObjectBoneName($objID, $boneIndex)
    {
    }

    /**
     * Возвращает трение качения для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsRollingFriction($objID)
    {
    }

    /**
     * Возвращает текущее значение реституции для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsRestitution($objID)
    {
    }

    /**
     * Возвращает true, если есть еще один контакт для отчета.
     *
     * @return int
     */
    function GetObject3DPhysicsNextContact()
    {
    }

    /**
     * Возвращает максимальную линейную скорость для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsMaxLinearVelocity($objID)
    {
    }

    /**
     * Возвращает массу объектов
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsMass($objID)
    {
    }

    /**
     * Возвращает маску столкновения объектов. По умолчанию все физические объекты находятся в одной группе и не
     * маскируются. Если вы используете группы столкновений и маски, вы должны использовать их для всех физических
     * объектов.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function GetObject3DPhysicsMask($objID)
    {
    }

    /**
     * Возвращает X-компоненту вектора линейной скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsLinearVelocityZ($objID)
    {
    }

    /**
     * Возвращает X-компоненту вектора линейной скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsLinearVelocityY($objID)
    {
    }

    /**
     * Возвращает X-компоненту вектора линейной скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsLinearVelocityX($objID)
    {
    }

    /**
     * Возвращает линейный порог сна для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsLinearSleepingThreshold($objID)
    {
    }

    /**
     * Возвращает группу столкновений объектов. По умолчанию все физические объекты находятся в одной группе и не
     * маскируются. Если вы используете группы столкновений и маски, вы должны использовать их для всех физических
     * объектов.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function GetObject3DPhysicsGroup($objID)
    {
    }

    /**
     * Возвращает значение линейного демпфирования
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsLinearDamp($objID)
    {
    }

    /**
     * Возвращает трение для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsFriction($objID)
    {
    }

    /**
     * Возвращает true, если объект имел контакт на физическом шаге.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function GetObject3DPhysicsFirstContact($objID)
    {
    }

    /**
     * Возвращает положение контакта Y
     *
     * @return float
     */
    function GetObject3DPhysicsContactY()
    {
    }

    /**
     * Возвращает X положение контакта
     *
     * @return float
     */
    function GetObject3DPhysicsContactX()
    {
    }

    /**
     * Возвращает true, если есть контактный вектор, и заполняет вектор outPosVec3. Сначала создайте вектор с помощью
     * CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен
     * результатами.
     *
     * @param int $outPosVec3 Идентификатор вектора, который будет заполнен результатами.
     * @return int
     */
    function GetObject3DPhysicsContactVector($outPosVec3)
    {
    }

    /**
     * Возвращает идентификатор объекта второго объекта в контакте.
     *
     * @return int
     */
    function GetObject3DPhysicsContactObjectB()
    {
    }

    /**
     * Верните Z-компоненту вектора угловой скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsAngularVelocityZ($objID)
    {
    }

    /**
     * Верните Y-компоненту вектора угловой скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsAngularVelocityY($objID)
    {
    }

    /**
     * Верните X-компоненту вектора угловой скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsAngularVelocityX($objID)
    {
    }

    /**
     * Возвращает порог углового сна для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsAngularSleepingThreshold($objID)
    {
    }

    /**
     * Возвращает значение углового демпфирования
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsAngularDamp($objID)
    {
    }

    /**
     * Возвращает количество ядер логического процессора на устройстве
     *
     * @return int
     */
    function GetNumProcessors()
    {
    }

    /**
     * Возвращает количество камер, доступных для SetDeviceCameraToImage. В настоящее время работает только на Android,
     * iOS и Windows
     *
     * @return int
     */
    function GetNumDeviceCameras()
    {
    }

    /**
     * Возвращает имя следующей папки, найденной в текущей папке, которая задается с помощью SetFolder. GetFirstFolder
     * должен быть вызван первым, чтобы это сработало, любой вызов SetFolder или OpenToWrite потребует повторного
     * запуска с GetFirstFolder. Возвращает пустую строку, если в текущей папке больше нет папок. Не включает в себя .
     * или ..
     *
     * @return string
     */
    function GetNextFolder()
    {
    }

    /**
     * Возвращает имя следующего файла, найденного в текущей папке, который задается с помощью SetFolder. GetFirstFile
     * должен быть вызван первым, чтобы это сработало, любой вызов SetFolder или OpenToWrite потребует повторного
     * запуска с GetFirstFile. Возвращает пустую строку, если в текущей папке больше нет файлов.
     *
     * @return string
     */
    function GetNextFile()
    {
    }

    /**
     * Возвращает Z положение контакта
     *
     * @return float
     */
    function GetObject3DPhysicsContactZ()
    {
    }

    /**
     * Возвращает 1 если контакт существует, вы можете получить спрайты, вовлеченные в этот контакт, используя
     * GetContactSpriteID1 и GetContactSpriteID2, вы можете перейти к следующему контакту, снова вызвав эту команду,
     * когда контактов больше не будет, она вернет 0.
     *
     * @return int
     */
    function GetNextContact()
    {
    }

    /**
     * Возвращает IP-адрес, используемый сервером. Эта команда работает только на клиентах, так как сервер может
     * получить свой собственный IP-адрес с помощью GetDeviceIP и GetDeviceIPv6.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return string
     */
    function GetNetworkServerIP($iNetID)
    {
    }

    /**
     * Возвращает идентификатор клиента клиента хоста. Это полезно, если вы используете сервер для обработки переменных
     * настройки игры, таких как размер доски, длина игры и т. Д., поскольку только хост - клиент должен иметь копию
     * этих переменных.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function GetNetworkServerID($iNetID)
    {
    }

    /**
     * Возвращает количество клиентов, подключенных к указанной сети. Хост считается клиентом, как и локальный клиент.
     * Это означает, что в подключенной сети должно быть не менее 2 клиентов. Хост, ожидающий клиентов, возвращает 1,
     * если он находится сам по себе. Клиент, пытающийся подключиться, возвращает 0 до тех пор, пока он не подключится
     * и хост не примет клиента, предоставив ему уникальный идентификатор, затем он должен вернуть 2.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function GetNetworkNumClients($iNetID)
    {
    }

    /**
     * Возвращает идентификатор клиента следующего клиента в списке клиентов. Используйте эту функцию, чтобы продолжить
     * просмотр списка клиентов, запущенных с помощью GetNetworkFirstClient. Очень важно, чтобы эта команда вызывалась
     * до тех пор, пока она не вернет 0, так как фоновый сетевой код не может продолжаться до тех пор, пока он не
     * узнает, что вы закончили работу со списком клиентов. Локальный клиент также будет возвращен в какой-то момент,
     * который можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkMyClientID. Хост-клиент также будет
     * возвращен в какой-то момент, который можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkServerID.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function GetNetworkNextClient($iNetID)
    {
    }

    /**
     * Каждому клиенту при подключении хост присваивает уникальный идентификатор. Эта функция возвращает идентификатор,
     * который вам был назначен. Хост также присваивает себе идентификатор, который можно найти с помощью
     * GetNetworkServerID.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function GetNetworkMyClientID($iNetID)
    {
    }

    /**
     * Получает одну строку из сообщения и перемещает указатель сообщения на следующий элемент сообщения. Сообщения
     * должны создаваться и считываться в соответствии с известными форматами, например string, int, string, поскольку
     * у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное целое число
     * для указания идентификатора типа сообщения, который можно использовать для идентификации формата сообщения.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return string
     */
    function GetNetworkMessageString($iMsgID)
    {
    }

    /**
     * Получает одно целое число из сообщения и перемещает указатель сообщения к следующему элементу сообщения.
     * Сообщения должны создаваться и считываться в соответствии с известными форматами, например string, int, string,
     * поскольку у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное
     * целое число для указания идентификатора типа сообщения, который можно использовать для идентификации формата
     * сообщения.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return int
     */
    function GetNetworkMessageInteger($iMsgID)
    {
    }

    /**
     * Возвращает IP-адрес, отправивший это сообщение. Только применительно к сообщениям, полученным от UDP и
     * широковещательных прослушивателей, сетевые сообщения будут возвращать пустую строку для этой функции. Он также
     * вернет пустую строку для сообщений, созданных с помощью CreateNetworkMessage. Это может быть адрес IPv4 или
     * IPv6.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return string
     */
    function GetNetworkMessageFromIP($iMsgID)
    {
    }

    /**
     * Возвращает идентификатор клиента, отправившего это сообщение. Применимо только к сообщениям, полученным из
     * сетей, широковещательный прослушиватель и UDP-сообщения вернут 0 для этой функции. Он также вернет 0 для
     * сообщений, созданных с помощью CreateNetworkMessage.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return int
     */
    function GetNetworkMessageFromClient($iMsgID)
    {
    }

    /**
     * Получает один байт без знака из сообщения и перемещает указатель сообщения на следующий элемент сообщения.
     * Сообщения должны создаваться и считываться в соответствии с известными форматами, например string, int, string,
     * поскольку у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное
     * целое число для указания идентификатора типа сообщения, который можно использовать для идентификации формата
     * сообщения.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return int
     */
    function GetNetworkMessageByte($iMsgID)
    {
    }

    /**
     * Проверьте сеть на наличие любых сообщений, отправленных этому клиенту. Если ничего не найдено, он возвращает 0.
     * Если сообщение найдено, оно возвращает идентификатор сообщения, который вы можете использовать для его чтения.
     * Вы должны удалить сообщение с помощью DeleteNetworkMessage, когда закончите его читать. Вы должны продолжать
     * вызывать GetNetworkMessage до тех пор, пока он не вернет 0, чтобы убедиться, что вы получили все сообщения. Вы
     * можете использовать команды чтения сообщений, чтобы узнать, какой идентификатор клиента отправил сообщение.
     *
     * @param int $iNetID Идентификатор сети для проверки сообщений.
     * @return int
     */
    function GetNetworkMessage($iNetID)
    {
    }

    /**
     * Возвращает 1, если сеть существует с заданным идентификатором, в противном случае она возвращает 0.
     *
     * @param int $iNetID Идентификатор сети для проверки
     * @return int
     */
    function GetNetworkExists($iNetID)
    {
    }

    /**
     * Возвращает идентификатор клиента первого клиента в списке клиентов. Используйте эту функцию, чтобы начать
     * просмотр списка клиентов и продолжить работу с GetNetworkNextClient до тех пор, пока он не вернет 0. Очень
     * важно, чтобы после вызова этой команды GetNetworkNextClient вызывался до тех пор, пока не вернет 0, так как
     * фоновый сетевой код не может продолжать работу до тех пор, пока не будет известно, что вы закончили работу со
     * списком клиентов. Локальный клиент также будет возвращен в какой-то момент, который можно обнаружить, сравнив
     * возвращаемый идентификатор с GetNetworkMyClientID. Хост-клиент также будет возвращен в какой-то момент, который
     * можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkServerID.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function GetNetworkFirstClient($iNetID)
    {
    }

    /**
     * Считывает один из локальных слотов данных, назначенных клиентскому набору, с помощью SetNetworkClientUserData.
     *
     * @param int $iNetID Идентификатор сети, из которой будет получено значение.
     * @param int $client Идентификатор клиента в сети, от которого требуется получить значение.
     * @param int $index Индекс (0-4) считываемого слота данных.
     * @return int
     */
    function GetNetworkClientUserData($iNetID, $client, $index)
    {
    }

    /**
     * Возвращает пинг между данным клиентом и хостом. Чтобы получить общее время передачи данных от одного клиента к
     * другому, вы должны сложить два времени пинга для обоих клиентов вместе, поскольку все данные проходят через
     * хост. Если вы используете идентификатор клиента хоста, он вернет 0, так как хост не имеет пинга для себя.
     * Возвращаемое значение выражается в секундах как значение с плавающей запятой.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client Идентификатор клиента для проверки.
     * @return float
     */
    function GetNetworkClientPing($iNetID, $client)
    {
    }

    /**
     * Возвращает исходный порт, который был использован этим сообщением. Только применительно к сообщениям, полученным
     * от UDP и широковещательных прослушивателей, сетевые сообщения вернут 0 для этой функции. Он также вернет 0 для
     * сообщений, созданных с помощью CreateNetworkMessage. Это будет в диапазоне от 0 до 65535.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return int
     */
    function GetNetworkMessageFromPort($iMsgID)
    {
    }

    /**
     * Возвращает IP-адрес, используемый указанным клиентом. Эта команда работает только на сервере, так как клиенты не
     * подключаются непосредственно друг к другу
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client идентификатор клиента для проверки.
     * @return string
     */
    function GetNetworkClientIP($iNetID, $client)
    {
    }

    /**
     * Получает один поплавок из сообщения и перемещает указатель сообщения к следующему элементу сообщения. Сообщения
     * должны создаваться и считываться в соответствии с известными форматами, например string, int, string, поскольку
     * у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное целое число
     * для указания идентификатора типа сообщения, который можно использовать для идентификации формата сообщения.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return float
     */
    function GetNetworkMessageFloat($iMsgID)
    {
    }

    /**
     * Получает копию переменной float удаленного клиента по имени. Также может быть использован для собственных
     * переменных клиента, если ClientID равен GetNetworkMyClientID. Если переменная была установлена как переменная
     * сброса, она вернется к 0 после чтения, это не повлияет на способность других клиентов считывать исходное
     * значение. Каждый из них сбросит свою собственную копию. Если указанный клиент не установил переменную с заданным
     * именем, то возвращается значение 0.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client Идентификатор клиента для проверки.
     * @param string $name Имя возвращаемой переменной.
     * @return float
     */
    function GetNetworkClientFloat($iNetID, $client, $name)
    {
    }

    /**
     * Проверяет, отключился ли указанный клиент. Отключенные клиенты не удаляются автоматически из списка клиентов,
     * что позволяет вам правильно обрабатывать их очистку. Как только вы справитесь с этим клиентом, вы должны удалить
     * его из списка клиентов, вызвав DeleteNetworkClient. Клиент может сохраняться в течение некоторого времени, пока
     * фоновый сетевой код не начнет фактически удалять его, поэтому будьте готовы к тому, что этот клиент будет
     * болтаться вокруг в течение нескольких кадров, объявляя, что он отключен, и убедитесь, что вы очистите его только
     * один раз. Вы можете обнаружить это, установив одно из значений SetNetworkClientUserData, чтобы уведомить себя о
     * том, что оно было обработано.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client идентификатор клиента для проверки.
     * @return int
     */
    function GetNetworkClientDisconnected($iNetID, $client)
    {
    }

    /**
     * Возвращает 1, если текущее устройство имеет встроенное устройство NFC, в противном случае возвращается 0. Эта
     * команда еще не функционирует.
     *
     * @return int
     */
    function GetNFCExists()
    {
    }

    /**
     * Возвращает текущую позицию в музыкальном файле, между 0 для начала файла и GetMusicDurationOGG для конца файла.
     *
     * @param int $musicID Идентификатор музыкального файла для проверки
     * @return float
     */
    function GetMusicPositionOGG($musicID)
    {
    }

    /**
     * Возвращает количество секунд воспроизведения текущего музыкального файла. Если в данный момент музыка не
     * воспроизводится, эта команда вернет 0.
     *
     * @return float
     */
    function GetMusicPosition()
    {
    }

    /**
     * Возвращает имя, которое клиент использовал для идентификации себя при подключении к хосту.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client идентификатор клиента для проверки.
     * @return string
     */
    function GetNetworkClientName($iNetID, $client)
    {
    }

    /**
     * Возвращает 1, если музыкальный файл воспроизводится в данный момент, и 0 в противном случае. Это будет
     * продолжать возвращать 1, пока файл находится на паузе.
     *
     * @param int $musicID Идентификатор музыкального файла для проверки
     * @return int
     */
    function GetMusicPlayingOGG($musicID)
    {
    }

    /**
     * Возвращает идентификатор воспроизводимого в данный момент музыкального файла. Если музыка не воспроизводится,
     * она возвращает 0.
     *
     * @return int
     */
    function GetMusicPlaying()
    {
    }

    /**
     * Получает копию целочисленной переменной удаленного клиента по имени. Также может быть использован для
     * собственных переменных клиента, если ClientID равен GetNetworkMyClientID. Если переменная была установлена как
     * переменная сброса, она вернется к 0 после чтения, это не повлияет на способность других клиентов считывать
     * исходное значение. Каждый из них сбросит свою собственную копию. Если указанный клиент не установил переменную с
     * заданным именем, то возвращается значение 0.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client Идентификатор клиента для проверки.
     * @param string $name Имя возвращаемой переменной.
     * @return int
     */
    function GetNetworkClientInteger($iNetID, $client, $name)
    {
    }

    /**
     * Возвращает количество раз, когда этот музыкальный файл был зациклен.
     *
     * @param int $musicID Идентификатор музыкального файла для проверки
     * @return int
     */
    function GetMusicLoopCountOGG($musicID)
    {
    }

    /**
     * Возвращает 1, если музыкальный файл существует с текущим идентификатором, и 0, если нет.
     *
     * @param int $iID Удостоверение личности для проверки.
     * @return int
     */
    function GetMusicExists($iID)
    {
    }

    /**
     * Возвращает 1, если музыкальный файл существует с указанным идентификатором, и 0 в противном случае.
     *
     * @param int $musicID Удостоверение личности для проверки
     * @return int
     */
    function GetMusicExistsOGG($musicID)
    {
    }

    /**
     * Возвращает длительность музыкального файла в секундах в виде значения с плавающей запятой
     *
     * @param int $musicID Идентификатор музыкального файла для проверки
     * @return float
     */
    function GetMusicDurationOGG($musicID)
    {
    }

    /**
     * Возвращает 1, если текущее устройство поддерживает мультитач, и 0, если нет.
     *
     * @return int
     */
    function GetMultiTouchExists()
    {
    }

    /**
     * Возвращает 1, если на текущем устройстве есть мышь, и 0, если нет.
     *
     * @return int
     */
    function GetMouseExists()
    {
    }

    /**
     * Возвращает месяц заданного значения времени unix (от 1 до 12). Время Unix представлено как количество секунд с 1
     * января 1970 года, оно также может быть отрицательным.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetMonthFromUnix($unixtime)
    {
    }

    /**
     * Возвращает минуты заданного значения времени unix (от 0 до 59). Время Unix представлено как количество секунд с
     * 1 января 1970 года, оно также может быть отрицательным.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetMinutesFromUnix($unixtime)
    {
    }

    /**
     * Обеспечивает быстрый способ получить Z-позицию указанной вершины из memblock. Он использует атрибутивные данные
     * из начала memblock для определения смещения вершины и расположения значений позиции.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexZ($memID, $vertexIndex)
    {
    }

    /**
     * Обеспечивает быстрый способ получения Y-позиции указанной вершины из memblock. Он использует атрибутивные данные
     * из начала memblock для определения смещения вершины и расположения значений позиции.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexY($memID, $vertexIndex)
    {
    }

    /**
     * Обеспечивает быстрый способ получения X-позиции указанной вершины из memblock. Он использует атрибутивные данные
     * из начала memblock для определения смещения вершины и расположения значений позиции.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexX($memID, $vertexIndex)
    {
    }

    /**
     * Обеспечивает быстрый способ получения значения V указанной вершины из memblock. Он использует атрибутивные
     * данные из начала memblock для определения смещения вершин и расположения значений UV.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexV($memID, $vertexIndex)
    {
    }

    /**
     * Обеспечивает быстрый способ получения значения U указанной вершины из memblock. Он использует атрибутивные
     * данные из начала memblock для определения смещения вершин и расположения значений UV.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexU($memID, $vertexIndex)
    {
    }

    /**
     * Предоставляет быстрый способ получить красное значение указанной вершины из memblock. Он использует атрибутивные
     * данные из начала memblock для определения смещения вершин и расположения значений цвета.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return int
     */
    function GetMeshMemblockVertexRed($memID, $vertexIndex)
    {
    }

    /**
     * Возвращает количество секунд, которое потребуется для воспроизведения данного музыкального файла от начала до
     * конца. Для работы этой команды не должно быть никаких звуков, или данный идентификатор должен быть дорожкой,
     * воспроизводимой в данный момент. Например, если вы попытаетесь получить продолжительность ID 2 и ID 1 в данный
     * момент воспроизводится, то это не удастся, но если ID 2 в данный момент воспроизводится, то это будет успешно.
     * Для файлов с переменной скоростью передачи битов эта команда вернет аппроксимацию.
     *
     * @param int $iID Идентификатор музыки для проверки.
     * @return float
     */
    function GetMusicDuration($iID)
    {
    }

    /**
     * Обеспечивает быстрый способ получить Z-компоненту нормали указанной вершины из memblock. Он использует
     * атрибутивные данные из начала мемблока для определения смещения вершин и расположения нормальных значений.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexNormalZ($memID, $vertexIndex)
    {
    }

    /**
     * Обеспечивает быстрый способ получения Y-компонента нормали указанной вершины из memblock. Он использует
     * атрибутивные данные из начала мемблока для определения смещения вершин и расположения нормальных значений.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexNormalY($memID, $vertexIndex)
    {
    }

    /**
     * Обеспечивает быстрый способ получения X-компонента нормали указанной вершины из memblock. Он использует
     * атрибутивные данные из начала мемблока для определения смещения вершин и расположения нормальных значений.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexNormalX($memID, $vertexIndex)
    {
    }

    /**
     * Предоставляет быстрый способ получить зеленое значение указанной вершины из memblock. Он использует атрибутивные
     * данные из начала memblock для определения смещения вершин и расположения значений цвета.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return int
     */
    function GetMeshMemblockVertexGreen($memID, $vertexIndex)
    {
    }

    /**
     * Обеспечивает быстрый способ получения альфа - значения указанной вершины из memblock. Он использует атрибутивные
     * данные из начала memblock для определения смещения вершин и расположения значений цвета.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return int
     */
    function GetMeshMemblockVertexAlpha($memID, $vertexIndex)
    {
    }

    /**
     * Получите количество миллисекунд с момента запуска приложения. Вызов этой команды внутренне вызовет системный
     * вызов, чтобы получить количество прошедшего времени, поэтому он может меняться каждый раз, когда вы его
     * вызываете.
     *
     * @return int
     */
    function GetMilliseconds()
    {
    }

    /**
     * Обеспечивает быстрый способ получения синего значения указанной вершины из memblock. Он использует атрибутивные
     * данные из начала memblock для определения смещения вершин и расположения значений цвета.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return int
     */
    function GetMeshMemblockVertexBlue($memID, $vertexIndex)
    {
    }

    /**
     * Возвращает размер данного memblock в байтах.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @return int
     */
    function GetMemblockSize($memID)
    {
    }

    /**
     * Возвращает короткое (2 байта) значение при заданном смещении. Смещение должно быть меньше размера мемблока.
     * Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 2,
     * поскольку чтение коротких значений, не выровненных по 2-байтовым границам, влечет за собой снижение
     * производительности оборудования. Короткие значения хранятся в формате little endian, поэтому запись короткого
     * числа 23 со смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, а байт со
     * смещением 1 как 0. Возвращаемое значение будет коротким со знаком между -32768 и 32767.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @return int
     */
    function GetMemblockShort($memID, $offset)
    {
    }

    /**
     * Хэширует memblock с помощью SHA1 и возвращает полученный хэш
     *
     * @param int $memID Идентификатор мемблока для хэширования
     * @return string
     */
    function GetMemblockSHA1($memID)
    {
    }

    /**
     * Возвращает значение int (4 байта) при заданном смещении. Смещение должно быть меньше размера мемблока. Первое
     * значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку
     * чтение целочисленных значений, не выровненных по 4-байтовым границам, влечет за собой снижение
     * производительности оборудования. Значения Int хранятся в формате little endian, поэтому запись int 23 со
     * смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, байт со смещением 1 как 0,
     * байт со смещением 2 как 0 и байт со смещением 3 как 0. Возвращаемое значение будет целым числом со знаком от
     * -2,147,483,648 до 2,147,483,647.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @return int
     */
    function GetMemblockInt($memID, $offset)
    {
    }

    /**
     * Возвращает 1, если существует memblock с заданным идентификатором, и 0, если нет.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @return int
     */
    function GetMemblockExists($memID)
    {
    }

    /**
     * Возвращает значение байта с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение
     * имеет смещение 0. Возвращаемое значение будет байтом со знаком от -128 до 127.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @return int
     */
    function GetMemblockByteSigned($memID, $offset)
    {
    }

    /**
     * Возвращает значение байта с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение
     * имеет смещение 0. Возвращаемое значение будет байтом без знака между 0 и 255.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @return int
     */
    function GetMemblockByte($memID, $offset)
    {
    }

    /**
     * Возвращает заданное количество байтов с заданным смещением и интерпретирует их как строку. Смещение плюс длина
     * должны быть меньше размера memblock. Первое значение имеет смещение 0. Строка будет завершаться null, даже если
     * в memblock не будет найден нулевой терминатор. Если нулевой терминатор возникает до достижения длины, то все
     * байты все равно будут считаны, но только символы до первого нулевого терминатора будут доступны в AGK. Если вы
     * используете уровень 2, вы должны удалить указатель, возвращаемый этой функцией.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @param int $length Количество байтов для чтения
     * @return string
     */
    function GetMemblockString($memID, $offset, $length)
    {
    }

    /**
     * Получает максимальную высоту, которую может иметь окно вашего приложения. Для платформ, поддерживающих оконный
     * режим, таких как Windows и Mac, ваше приложение может достичь такого размера только в полноэкранном режиме,
     * поскольку оконный режим имеет границу вокруг вашего приложения. Для приложений HTML5 это вернет размер текущего
     * HTML-документа и не гарантирует работу, если приложение HTML5 работает в полноэкранном режиме. Лучшим названием
     * для этой команды было бы GetMaxWindowHeight, но теперь она высечена в камне.
     *
     * @return int
     */
    function GetMaxDeviceHeight()
    {
    }

    /**
     * Возвращает количество спрайтов, которые внутренний менеджер спрайтов должен был отсортировать по их правильным
     * позициям с момента последнего кадра. Спрайты нужно использовать только в том случае, если они меняют глубину или
     * текстуру во время текущего кадра.
     *
     * @return int
     */
    function GetManagedSpriteSortedCount()
    {
    }

    /**
     * Хэширует memblock с помощью SHA256 и возвращает полученный хэш
     *
     * @param int $memID Идентификатор мемблока для хэширования
     * @return string
     */
    function GetMemblockSHA256($memID)
    {
    }

    /**
     * Возвращает количество спрайтов, которые фактически были отправлены для рендеринга в последний кадр графического
     * процессора, и чем больше их будет нарисовано, тем медленнее будет работать приложение.
     *
     * @return int
     */
    function GetManagedSpriteDrawnCount()
    {
    }

    /**
     * Возвращает количество спрайтов, управляемых внутренним менеджером спрайтов. Он отвечает за обновление анимации
     * спрайтов и вычисление того, какие спрайты видны и должны быть отправлены для рисования. Он также сортирует
     * спрайты, когда это необходимо для правильного рисования прозрачности.  До тех пор, пока не будет отправлено
     * слишком много спрайтов для рисования, менеджер спрайтов должен быть в состоянии обрабатывать несколько сотен
     * спрайтов.
     *
     * @return int
     */
    function GetManagedSpriteCount()
    {
    }

    /**
     * Возвращает значение float (4 байта) при заданном смещении. Смещение должно быть меньше размера мемблока. Первое
     * значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку
     * чтение значений float, не выровненных по 4-байтовым границам, влечет за собой снижение производительности
     * оборудования. Значения Float хранятся в формате IEEE 754, поэтому запись float и последующее чтение его обратно
     * в байтах вернут различные компоненты формата float.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @return float
     */
    function GetMemblockFloat($memID, $offset)
    {
    }

    /**
     * Возвращает количество вызовов OpenGL draw, используемых для рисования всех управляемых спрайтов. Как правило,
     * чем меньше это число, тем лучше производительность. AGK пытается паковать спрайты в как можно меньшее количество
     * вызовов рисования, он делает это, ища спрайты с одинаковой текстурой и рисуя их одновременно.
     *
     * @return int
     */
    function GetManagedSpriteDrawCalls()
    {
    }

    /**
     * Возвращает 1, если текущее устройство имеет датчик магнетизма, который в настоящее время поддерживается AGK, и
     * 0, если нет.
     *
     * @return int
     */
    function GetMagneticSensorExists()
    {
    }

    /**
     * Возвращает дату и время отображения указанного уведомления. Возвращаемое время будет в формате unix timestamp,
     * который измеряется количеством секунд с 1 января 1970 года. Если по указанному идентификатору уведомления не
     * существует, то возвращается 0
     *
     * @param int $iID ИДЕНТИФИКАТОР уведомления для проверки
     * @return int
     */
    function GetLocalNotificationTime($iID)
    {
    }

    /**
     * Возвращает сообщение, которое будет отображаться указанное уведомление. Если по указанному идентификатору
     * уведомления не существует, то будет возвращена пустая строка
     *
     * @param int $iID ИДЕНТИФИКАТОР уведомления для проверки
     * @return string
     */
    function GetLocalNotificationMessage($iID)
    {
    }

    /**
     * Возвращает 1, если уведомление с этим идентификатором ожидает отображения, в противном случае 0. Уведомления
     * обновляются каждые 5 секунд, так что это может продолжать возвращать 1 вскоре после того, как уведомление
     * сработало.
     *
     * @param int $iID ИДЕНТИФИКАТОР уведомления для проверки
     * @return int
     */
    function GetLocalNotificationExists($iID)
    {
    }

    /**
     * Получает максимальную ширину окна вашего приложения. Для платформ, поддерживающих оконный режим, таких как
     * Windows и Mac, ваше приложение может достичь такого размера только в полноэкранном режиме, поскольку оконный
     * режим имеет границу вокруг вашего приложения. Для приложений HTML5 это вернет размер текущего HTML-документа и
     * не гарантирует работу, если приложение HTML5 работает в полноэкранном режиме. Лучшим названием для этой команды
     * было бы GetMaxWindowWidth, но теперь она высечена в камне.
     *
     * @return int
     */
    function GetMaxDeviceWidth()
    {
    }

    /**
     * Возвращает количество изображений, загруженных в данный момент в приложение.
     *
     * @return int
     */
    function GetLoadedImages()
    {
    }

    /**
     * Возвращает 1, если данный год является високосным, в противном случае 0.
     *
     * @param int $year Год, чтобы проверить.
     * @return int
     */
    function GetLeapYear($year)
    {
    }

    /**
     * Возвращает значение unicode последнего ввода символа
     *
     * @return int
     */
    function GetLastChar()
    {
    }

    /**
     * Возвращает 1, если текущее устройство имеет полноразмерную клавиатуру, 2, если устройство имеет виртуальную
     * клавиатуру или клавиатуру мобильного телефона, и 0, если клавиатура вообще отсутствует.
     *
     * @return int
     */
    function GetKeyboardExists()
    {
    }

    /**
     * Джойстик AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания ввода
     * в стиле джойстика в диапазоне от -1 до 1. Если к системе подключен физический джойстик, то он будет
     * использоваться,в противном случае,если будет найдена полноразмерная клавиатура,клавиши W, A, S, D будут
     * использоваться в качестве четырех направлений для джойстика. Если ни того, ни другого не существует, то на
     * экране будет создан виртуальный джойстик, которым можно управлять либо с помощью сенсорного экрана, либо с
     * помощью мыши. Используемый виртуальный джойстик будет иметь индекс 1, если он уже существует, его значения будут
     * введены в эту эмулируемую команду джойстика. Вы можете расположить этот виртуальный джойстик в выбранном вами
     * положении на экране с помощью SetJoystickScreenPosition. Каждая платформа гарантированно имеет метод генерации
     * значения AGK - Y.
     *
     * @return float
     */
    function GetJoystickY()
    {
    }

    /**
     * Джойстик AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания ввода
     * в стиле джойстика в диапазоне от -1 до 1. Если к системе подключен физический джойстик, то он будет
     * использоваться,в противном случае,если будет найдена полноразмерная клавиатура,клавиши W, A, S, D будут
     * использоваться в качестве четырех направлений для джойстика. Если ни того, ни другого не существует, то на
     * экране будет создан виртуальный джойстик, которым можно управлять либо с помощью сенсорного экрана, либо с
     * помощью мыши. Используемый виртуальный джойстик будет иметь индекс 1, если он уже существует, его значения будут
     * введены в эту эмулируемую команду джойстика. Вы можете расположить этот виртуальный джойстик в выбранном вами
     * положении на экране с помощью SetJoystickScreenPosition. Каждая платформа гарантированно имеет метод генерации
     * значения AGK джойстика X.
     *
     * @return float
     */
    function GetJoystickX()
    {
    }

    /**
     * Возвращает величину крутящего момента, приложенного к соединению на последнем временном шаге. Вы можете
     * использовать это для обнаружения больших сил и удаления соединения, чтобы имитировать разрыв. Крутящий момент
     * применяется к соединениям, которые вращаются, таким как вращающиеся соединения.
     *
     * @param int $iJointIndex Идентификатор сустава для проверки.
     * @return float
     */
    function GetJointReactionTorque($iJointIndex)
    {
    }

    /**
     * Возвращает величину силы, приложенной к соединению в направлении Y на последнем временном шаге. Вы можете
     * использовать это для обнаружения больших сил и удаления соединения, чтобы имитировать разрыв.
     *
     * @param int $iJointIndex Идентификатор сустава для проверки.
     * @return float
     */
    function GetJointReactionForceY($iJointIndex)
    {
    }

    /**
     * Возвращает 1, если текущее устройство имеет датчик окружающего света, который в настоящее время поддерживается
     * AGK, и 0, если нет.
     *
     * @return int
     */
    function GetLightSensorExists()
    {
    }

    /**
     * Возвращает величину силы, приложенной к соединению в направлении X на последнем временном шаге. Вы можете
     * использовать это для обнаружения больших сил и удаления соединения, чтобы имитировать разрыв.
     *
     * @param int $iJointIndex Идентификатор сустава для проверки.
     * @return float
     */
    function GetJointReactionForceX($iJointIndex)
    {
    }

    /**
     * Возвращает строку, описывающую последнюю возникшую ошибку. Эта функция будет продолжать возвращать ту же строку
     * до тех пор, пока не возникнет другая ошибка. Это не включает в себя предупреждения.
     *
     * @return string
     */
    function GetLastError()
    {
    }

    /**
     * Возвращает 1, если указанное соединение все еще существует, и 0 в противном случае. Стыки могут быть удалены
     * системой.
     *
     * @param int $iJointIndex Идентификатор сустава для проверки.
     * @return int
     */
    function GetJointExists($iJointIndex)
    {
    }

    /**
     * Возвращает текущее состояние попытки активации содержимого. Значение 0 указывает на то, что процесс
     * продолжается, в то время как 1 подтверждает, что процесс завершен. В настоящее время эта команда поддерживается
     * только на iOS и Android.
     *
     * @return int
     */
    function GetInAppPurchaseState()
    {
    }

    /**
     * Возвращает 1, если устройство подключено к Интернету, и 0, если нет.
     *
     * @return int
     */
    function GetInternetState()
    {
    }

    /**
     * Возвращает подпись для последней покупки данного товара, это можно проверить по вашему открытому ключу, чтобы
     * подтвердить, что покупка была действительной. Рекомендуется передать эту подпись серверу для выполнения
     * проверки, чтобы ее нельзя было обойти.
     *
     * @param int $iID Например, ваш первый идентификатор продукта равен 0, ваш второй-1 и т. Д.
     * @return string
     */
    function GetInAppPurchaseSignature($iID)
    {
    }

    /**
     * Возвращает 1, если текущее устройство имеет по крайней мере один физический джойстик, доступный в качестве
     * метода ввода. 0, если у него нет физических джойстиков джойстика. Если вы обнаружите, что платформа не имеет
     * физических джойстиков, вы можете создать виртуальные джойстики, которые появляются на экране для использования
     * сенсорными экранами или мышами с помощью AddVirtualJoystick. GetJoystickExists не учитывает виртуальные
     * джойстики в своей проверке. На некоторых платформах обнаружение джойстика выполняется в фоновом потоке, который
     * может не завершиться в течение некоторого времени после запуска вашего приложения, чтобы дождаться завершения
     * потока, используйте CompleteRawJoystickDetection, чтобы убедиться, что все подключенные джойстики были найдены.
     *
     * @return int
     */
    function GetJoystickExists()
    {
    }

    /**
     * Возвращает текущую цену указанного в приложении продукта покупки в местной валюте, это будет строка с включенным
     * символом валюты, где это возможно. После вызова InAppPurchaseSetup может потребоваться несколько секунд, чтобы
     * эти данные стали доступными, поэтому, если вы получите пустую строку, повторите попытку позже. При вызове этого
     * метода из уровня 2 вы должны удалить возвращаемую строку, когда закончите с ней.
     *
     * @param int $iID этот идентификатор соответствует идентификаторам продуктов которые были добавлены например ваш
     *     первый продукт
     * @return string
     */
    function GetInAppPurchaseLocalPrice($iID)
    {
    }

    /**
     * Возвращает описание для указанного продукта, как определено текущим магазином платформы. После вызова
     * InAppPurchaseSetup может потребоваться несколько секунд, чтобы эти данные стали доступными, поэтому, если вы
     * получите пустую строку, повторите попытку позже. При вызове этого метода из уровня 2 вы должны удалить
     * возвращаемую строку, когда закончите с ней.
     *
     * @param int $iID этот идентификатор соответствует идентификаторам продуктов, которые были добавлены, например,
     *     ваш первый продукт
     * @return string
     */
    function GetInAppPurchaseDescription($iID)
    {
    }

    /**
     * Возвращает 1, если дополнительный контент был приобретен и поэтому доступен. Возвращает 0, если содержимое
     * недоступно. В настоящее время эта команда поддерживается только на iOS и Android.
     *
     * @param int $iID этот идентификатор соответствует идентификаторам продуктов которые были добавлены например ваш
     *     первый продукт
     * @return int
     */
    function GetInAppPurchaseAvailable($iID)
    {
    }

    /**
     * Возвращает ширину изображения в пикселях. Даже если эта команда возвращает float, значение гарантированно будет
     * целым числом.
     *
     * @param int $iImageIndex Идентификатор извлекаемого изображения.
     * @return float
     */
    function GetImageWidth($iImageIndex)
    {
    }

    /**
     * Возвращает объем памяти в мегабайтах, используемый в данный момент всеми загруженными изображениями (включая
     * изображения, используемые шрифтами). Это может помочь отследить проблемы с памятью GPU, которые могут привести к
     * сбою, если она закончится. Каждое загруженное изображение будет помещено в память графического процессора, даже
     * если вы его не используете, поэтому загрузка слишком большого количества больших изображений может израсходовать
     * всю память.
     *
     * @return float
     */
    function GetImageMemoryUsage()
    {
    }

    /**
     * Возвращает 1, если изображение существует, и 0, если нет.
     *
     * @param int $iImageIndex Идентификатор изображения для проверки
     * @return int
     */
    function GetImageExists($iImageIndex)
    {
    }

    /**
     * Возвращает часы заданного значения времени unix (от 0 до 23). Время Unix представлено как количество секунд с 1
     * января 1970 года, оно также может быть отрицательным.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetHoursFromUnix($unixtime)
    {
    }

    /**
     * Возвращает код состояния, который был возвращен с сервера в ответе. Вы должны дождаться, пока
     * GetHTTPResponseReady вернет ненулевое значение, прежде чем проверять эту команду, иначе она вернет 0. Обычно код
     * состояния равен 200, когда запрос был успешным
     *
     * @param int $iHTTP Идентификатор соединения для проверки.
     * @return int
     */
    function GetHTTPStatusCode($iHTTP)
    {
    }

    /**
     * Открывает файл изображения для извлечения значений ширины и высоты, а затем немедленно закрывает файл. Это
     * намного быстрее, чем загрузка всего изображения. Это может быть полезно при использовании LoadImageResized,
     * чтобы знать, насколько масштабировать изображение перед его загрузкой. И ширина, и высота будут возвращены в
     * одном целочисленном значении, верхние 16 бит будут шириной, а нижние 16 бит-высотой. Вы можете извлечь эти
     * значения в Tier 1, выполнив width = result >> 16 height = result && 0xFFFF
     *
     * @param string $filename Имя файла изображения для проверки
     * @return int
     */
    function GetImageSizeFromFile($filename)
    {
    }

    /**
     * Возвращает имя файла, используемого для загрузки этого образа. В tier 2 возвращаемая строка должна быть удалена,
     * когда вы закончите с ней.
     *
     * @param int $imageID Идентификатор изображения для проверки.
     * @return string
     */
    function GetImageFilename($imageID)
    {
    }

    /**
     * Возвращает высоту изображения в пикселях. Даже если эта команда возвращает float, значение гарантированно будет
     * целым числом.
     *
     * @param int $iImageIndex Идентификатор извлекаемого изображения.
     * @return float
     */
    function GetImageHeight($iImageIndex)
    {
    }

    /**
     * Возвращает 1, если запрос, ранее отправленный с помощью SendHTTPRequestASync, завершен. Вы можете получить ответ
     * с помощью GetHTTPResponse. Возвращает 0, если запрос все еще выполняется, или -1, если запрос не удался.
     *
     * @param int $iHTTP Идентификатор соединения для проверки.
     * @return int
     */
    function GetHTTPResponseReady($iHTTP)
    {
    }

    /**
     * Возвращает 1, если загрузка файла, ранее начатая с помощью GetHTTPFile, завершена, в противном случае-0. Даже
     * если это возвращает 1, чтобы сказать, что загрузка завершена, возможно, она не удалась, проверьте
     * GetHTTPResponseReady на наличие отрицательных значений, прежде чем предполагать, что загрузка прошла успешно.
     *
     * @param int $iHTTP Идентификатор соединения для проверки.
     * @return int
     */
    function GetHTTPFileComplete($iHTTP)
    {
    }

    /**
     * Захватывает часть backbuffer и создает из нее новое изображение. Значения положения и размера должны быть
     * указаны в координатах экрана. Возвращает идентификатор нового изображения, он должен быть удален, когда вы
     * закончите с ним. Чтобы эффективно использовать эту команду, вы должны знать, как AGK обращается к заднему
     * буферу. При вызове синхронизации AGK обновляет позиции всех объектов с помощью Update, затем рисует их все в
     * задний буфер с помощью Render, не очищая его, а затем выводит задний буфер на экран с помощью Swap. Затем он
     * очищает задний буфер и возвращается к вашему коду, так что если бы вы вызвали getImage сразу после
     * синхронизации, то получили бы пустое изображение, заполненное текущим чистым цветом. Поэтому, если вы хотите
     * захватить изображение текущей сцены полностью нарисованной, вы должны вызвать Render, а затем getImage, а затем
     * ClearScreen, чтобы очистить задний буфер, чтобы синхронизация не перерисовывала все по полностью нарисованному
     * буферу глубины. Если вы уже используете Update, Render и Swap вместо Sync, то вызовите getImage между Render и
     * Swap. Это также позволяет вам делать такие вещи, как рисовать линии в заднем буфере, получать изображение
     * результата и затем очищать его, чтобы он не влиял на то, что отображается на экране. Вызов getImage-это
     * медленная команда, и не рекомендуется вызывать ее каждый кадр. Обратите внимание, что изображение, полученное
     * этой командой, не гарантированно будет иметь ту же ширину и высоту, что и заданные этой командой, это происходит
     * потому, что изображение создается из части экрана, которая имеет разный размер на разных устройствах. Например,
     * при виртуальном разрешении 480х360 вы получите изображение во весь экран, вызвав эту команду с шириной 480 и
     * высотой 360, но на iPod это даст изображение 480х360 пикселей, в то время как на iPad оно будет около 1024х768
     * пикселей. Это не должно влиять на то, как вы используете изображение, поскольку применение его к спрайту и
     * установка размера спрайта на тот же 480x360 заставит спрайт заполнить экран в обоих случаях. Это просто
     * означает, что на iPad у вас есть более качественное изображение для игры. Это также относится к командам
     * рисования линий: рисование линии от 0,0 до 100,100, а затем получение изображения от 0,0 до 100,100 приведет к
     * получению изображения диагональной линии на всех устройствах, но устройства с высоким разрешением экрана будут
     * производить изображение более высокого качества, содержащее больше пикселей. Используйте GetImageWidth и
     * GetImageHeight, если вам нужно знать фактический размер изображения, полученного в пикселях.
     *
     * Пример вызова:
     *
     * int GetImage($x, $y, $width, $height); - вернет ID нового изображения.
     *
     * void GetImage($imageID, $x, $y, $width, $height); - задаем ID нового изображения.
     *
     * @param int $imageID Номер изображения, которое будет содержать захваченное изображение
     * @param float $x Координата x верхнего левого угла поля для копирования
     * @param float $y Координата y верхнего левого угла поля для копирования
     * @param float $width Ширина коробки для копирования
     * @param float $height Высота коробки для копирования
     * @return mixed
     */
    function GetImage(mixed... $arg) : mixed
    {
    }


    /**
     * Возвращает ход загрузки файла в виде плавающего значения от 0 до 100. Это не следует полагаться на то, чтобы
     * работать, когда загрузка закончена, и на некоторых платформах может не дать точного представления о ходе
     * загрузки. Используйте GetHTTPFileComplete или GetHTTPResponseReady, чтобы определить, завершена ли загрузка.
     *
     * @param int $iHTTP Идентификатор соединения для проверки.
     * @return float
     */
    function GetHTTPFileProgress($iHTTP)
    {
    }

    /**
     * Загружает HTTP - файл с сервера, указанного в SetHTTPHost, и сохраняет его в указанном месте. Также позволяет
     * отправлять POST-данные на сервер, которые могут включать переменные или файловые данные, например
     * "myvar=5&var2=test". Эта команда немедленно возвращается и продолжает загрузку файла в фоновом режиме. Вы можете
     * проверить ход загрузки с помощью GetHTTPFileProgress и GetHTTPFileComplete. Затем файл будет находиться в
     * указанном вами месте, готовый к использованию с AGK.
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после
     *     доменной части URL-адреса.
     * @param string $szLocalFile Место для сохранения в файл, это будет внутри папки записи для текущего устройства.
     * @param string|null $szPostData Необработанные данные post для отправки на сервер обратите внимание, что & и =
     * @return int
     */
    function GetHTTPFile(int $iHTTP, string $szServerFile, string $szLocalFile, string $szPostData = null): int
    {
    }


    /**
     * Возвращает 1, если текущее устройство имеет гироскоп, который в настоящее время поддерживается AGK, и 0, если
     * нет.
     *
     * @return int
     */
    function GetGyroSensorExists()
    {
    }

    /**
     * Возвращает уникальный идентификатор игрока, вошедшего в систему в данный момент. Если никто не вошел в систему
     * или платформа не поддерживает команды GameCenter, то это вернет пустую строку. Если вы вызываете эту команду из
     * уровня 2, то возвращаемая строка должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.
     *
     * @return string
     */
    function GetGameCenterPlayerID()
    {
    }

    /**
     * Возвращает отображаемое имя для текущего вошедшего в систему игрока. Если никто не вошел в систему или платформа
     * не поддерживает команды GameCenter, то это вернет пустую строку. Если вы вызываете эту команду из уровня 2, то
     * возвращенная строка должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.
     *
     * @return string
     */
    function GetGameCenterPlayerDisplayName()
    {
    }

    /**
     * Вернет 1, если пользователь вошел в Game Center или Google Play Games, и 0, если нет. Процесс входа в систему
     * асинхронен, поэтому после вызова GameCenterLogin может потребоваться несколько секунд, чтобы эта команда вернула
     * 1. Если пользователь не может войти в систему или GameCenter недоступен, то это вернет -1.
     *
     * @return int
     */
    function GetGameCenterLoggedIn()
    {
    }

    /**
     * Возвращает 1, если текущая платформа поддерживает Game Center или Google Play Games.
     *
     * @return int
     */
    function GetGameCenterExists()
    {
    }

    /**
     * Возвращает 1, если текущее устройство имеет GPS-приемник, который в настоящее время поддерживается AGK, и 0,
     * если нет.
     *
     * @return int
     */
    function GetGPSSensorExists()
    {
    }

    /**
     * Возвращает 1, если есть предварительно загруженное и готовое к показу интерстициальное объявление Chartboost, в
     * противном случае 0. Если это так, вы можете отобразить его с помощью ShowFullscreenAdvertChartboost. Реклама
     * предварительно загружается, как только вы устанавливаете свои данные Chartboost, и после того, как каждая
     * полноэкранная реклама отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы
     * может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить.
     * В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики
     * рекламы возвращают 0, то вы можете попробовать вызвать ShowFullscreenAdvertChartboost в любом случае, он ничего
     * не покажет, так как ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны
     * какие-либо новые объявления.
     *
     * @return int
     */
    function GetFullscreenAdvertLoadedChartboost()
    {
    }

    /**
     * Возвращает 1, если есть предварительно загруженная и готовая к показу реклама Amazon interstitial, в противном
     * случае 0. Если это так, вы можете отобразить его с помощью ShowFullscreenAdvertAmazon. Реклама предварительно
     * загружается, как только вы устанавливаете свои данные Amazon, и после того, как каждая полноэкранная реклама
     * отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной
     * из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам
     * следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают
     * 0, то вы можете попробовать вызвать ShowFullscreenAdvertAmazon в любом случае, он ничего не покажет, так как
     * ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны какие-либо новые
     * объявления.
     *
     * @return int
     */
    function GetFullscreenAdvertLoadedAmazon()
    {
    }

    /**
     * Возвращает 1, если есть предварительно загруженное и готовое к показу интерстициальное объявление AdMob, в
     * противном случае 0. Если это так, вы можете отобразить его с помощью ShowFullscreenAdvertAdMob. Объявления
     * предварительно загружаются, как только вы устанавливаете свои данные AdMob, и после того, как каждая
     * полноэкранная реклама отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы
     * может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить.
     * В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики
     * рекламы возвращают 0, то вы можете попробовать вызвать ShowFullscreenAdvertAdMob в любом случае, он ничего не
     * покажет, так как ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны
     * какие-либо новые объявления.
     *
     * @return int
     */
    function GetFullscreenAdvertLoadedAdMob()
    {
    }

    /**
     * Получите время в секундах, потраченное на обработку и рендеринг последнего кадра. Обновляется только при вызове
     * Sync или Swap. Это ограничение ограничено максимальным значением 0,2 секунды, чтобы предотвратить интерполяцию
     * внутреннего кода на основе таймера с большими временными промежутками. Чтобы найти истинное время кадра, вы
     * можете использовать команду Timer ().
     *
     * @return float
     */
    function GetFrameTime()
    {
    }

    /**
     * Возвращает ответ с сервера на предыдущий отправленный запрос SendHTTPRequestASync. Вы должны дождаться, пока
     * GetHTTPResponseReady вернет 1, прежде чем вызывать эту команду. В tier 2 вы должны удалить возвращаемую строку с
     * помощью agk::DeleteString, когда закончите ее использовать. Уровень 2 имеет дополнительную команду
     * GetHTTPResponseReadyC, которая возвращает const char, который не нуждается в удалении.
     *
     * @param int $iHTTP Идентификатор соединения для проверки.
     * @return string
     */
    function GetHTTPResponse($iHTTP)
    {
    }

    /**
     * Возвращает количество папок в текущей папке. Не включает в себя . или ..
     *
     * @param int|null $mode 0 для подсчета только папок в папке чтения, 1 для подсчета только папки записи, 2 для подсчета
     *     обоих
     * @return int
     */
    function GetFolderCount(int $mode = null): int
    {
    }

    /**
     * Возвращает текущую папку, ранее заданную с помощью SetFolder. Возвращаемый путь всегда будет иметь косую черту в
     * качестве конечного символа, за исключением случаев, когда в корневой папке будет возвращена пустая строка.
     *
     * @return string
     */
    function GetFolder()
    {
    }

    /**
     * Возвращает имя первой папки, найденной в текущей папке, которая задается с помощью SetFolder. Вы можете вызвать
     * GetNextFolder, чтобы продолжить вниз по списку папок в текущей папке. Возвращает пустую строку, если в текущей
     * папке нет папок. Не включает в себя . или .. Обратите внимание, что на Android существует известное ограничение,
     * что любые папки в папке "активы" не могут быть найдены с помощью этой команды. Вы можете обойти эту проблему,
     * используя MakeFolder для создания той же структуры папок в папке write, которую AGK затем может использовать для
     * поиска файлов в папке assets с помощью GetFirstFile. По умолчанию эта команда объединит списки папок из папок
     * чтения и записи в один список (mode=2), который можно изменить на только возвращаемые папки в папке чтения
     * (mode=0) или только возвращаемые папки из папки записи (mode=1)
     *
     * @param int|null $mode 0 для возврата только папок из папки чтения, 1 для возврата только папок из папки записи, 2 для
     *     обоих (по умолчанию)
     * @return string
     */
    function GetFirstFolder(int $mode = null): string
    {
    }

    /**
     * Возвращает имя первого файла, найденного в текущей папке, который задается с помощью SetFolder. Вы можете
     * вызвать GetNextFile, чтобы продолжить вниз по списку файлов в текущей папке. Возвращает пустую строку, если в
     * текущей папке нет файлов. По умолчанию эта команда объединит списки файлов из папок чтения и записи в один
     * список (mode=2) это может быть изменено на возврат только файлов из папки чтения (mode=0) или только файлов из
     * папки записи (mode=1) Обратите внимание, что папка чтения не существует при использовании широковещательной
     * передачи или отладки для запуска приложения, так как файлы копируются в папку записи проигрывателя AGK для этих
     * режимов запуска. С другой стороны, папка записи начинается как пустая при запуске приложения непосредственно из
     * IDE или при запуске конечного исполняемого файла приложения в папке проекта.
     *
     * @param int|null $mode 0 для возврата только файлов из папки чтения, 1 для возврата только файлов из папки записи, 2
     *     для обоих (по умолчанию)
     * @return string
     */
    function GetFirstFile(int $mode = null): string
    {
    }

    /**
     * Возвращает текущую позицию чтения в файле
     *
     * @param int $iFileID Идентификатор файла для проверки.
     * @return int
     */
    function GetFilePos($iFileID)
    {
    }

    /**
     * Возвращает размер открытого файла в байтах.
     *
     * @param int $iFileID Идентификатор файла для проверки.
     * @return int
     */
    function GetFileSize($iFileID)
    {
    }

    /**
     * Возвращает 1, если данный файл находится либо в каталоге ресурсов, либо в каталоге записи, назначенном
     * приложению.
     *
     * @param string $szFile Имя файла для проверки.
     * @return int
     */
    function GetFileExists($szFile)
    {
    }

    /**
     * Возвращает количество файлов в текущей папке.
     *
     * @param int|null $mode 0 для подсчета только файлов в папке чтения, 1 для подсчета только папки записи, 2 для подсчета
     * обоих
     * @return int
     */
    function GetFileCount(int $mode = null): int
    {
    }


    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return int
     */
    function GetFacebookDownloadState()
    {
    }

    /**
     * Возвращает 1, если шрифт был успешно загружен с заданным идентификатором.
     *
     * @param int $iFontID Идентификатор шрифта для проверки.
     * @return int
     */
    function GetFontExists($iFontID)
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return string
     */
    function GetFacebookDownloadFile()
    {
    }

    /**
     * Возвращает состояние любого файла расширения, используемого этой платформой, в настоящее время применимого
     * только к Android. Возвращает -1, если во время загрузки произошла ошибка, 0, если файл расширения не
     * используется на этой платформе, 1, если он должен существовать, но не существует (в этом случае вы вызываете
     * функцию DownloadExpansionFile ()), 2, если он в данный момент загружается, и 3, если все завершено и файл
     * существует.
     *
     * @return int
     */
    function GetExpansionFileState()
    {
    }

    /**
     * Проверяет ход загрузки, начатой с помощью DownloadExpansionFile, возвращает плавающее значение от 0 до 100
     * Используйте GetExpansionFileState, чтобы проверить, завершена ли загрузка.
     *
     * @return float
     */
    function GetExpansionFileProgress()
    {
    }

    /**
     * Циклически просматривает список всех контактов, обнаруженных на последнем шаге физики. Возвращает 1 если контакт
     * существует, вы можете получить спрайты, участвующие в этом контакте, используя GetContactSpriteID1 и
     * GetContactSpriteID2, вы можете перейти к следующему контакту с помощью GetNextContact. Возвращает 0, если
     * контактов нет.
     *
     * @return int
     */
    function GetFirstContact()
    {
    }

    /**
     * Возвращает текущую позицию Y поля редактирования. Это верхний левый угол фактического поля ввода текста, любая
     * граница будет простираться выше этой точки.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return float
     */
    function GetEditBoxY($index)
    {
    }

    /**
     * Возвращает 1, если с момента последнего вызова этой команды произошла ошибка. 0, если нет. Это не включает в
     * себя предупреждения.
     *
     * @return int
     */
    function GetErrorOccurred()
    {
    }

    /**
     * Возвращает код ошибки самой последней ошибки, возникшей при загрузке файла расширения. Возможные ошибки включают
     * в себя: 15 = Нелицензированный 16 = Неудачная выборка URL-адреса 17 = Полная SD-карта 18 = Отменена 19 =
     * Неизвестная ошибка
     *
     * @return int
     */
    function GetExpansionFileError()
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return int
     */
    function GetFacebookLoggedIn()
    {
    }

    /**
     * Возвращает 1, если поле редактирования видно и может быть нажато, 0, если поле редактирования невидимо и не
     * может быть изменено.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxVisible($index)
    {
    }

    /**
     * Возвращает текущую ширину поля редактирования. Это ширина фактического поля ввода текста, любая граница будет
     * выходить за пределы этого значения.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return float
     */
    function GetEditBoxWidth($index)
    {
    }

    /**
     * Возвращает текст, отображаемый в данный момент в поле редактирования.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return string
     */
    function GetEditBoxText($index)
    {
    }

    /**
     * Возвращает количество строк текста, введенных пользователем в поле редактирования.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxLines($index)
    {
    }

    /**
     * Возвращает текущую высоту поля редактирования. Это высота фактического поля ввода текста, любая граница будет
     * выходить за пределы этого значения.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return float
     */
    function GetEditBoxHeight($index)
    {
    }

    /**
     * Возвращает 1, если поле редактирования было нажато и принимает входные данные.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxHasFocus($index)
    {
    }

    /**
     * Возвращает текущую глубину поля редактирования, где 0 - передняя часть экрана, а 10000-задняя.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxDepth($index)
    {
    }

    /**
     * Возвращает курсор в заданную позицию в тексте, то есть позиция 0 находится слева от первого символа, позиция
     * 1-слева от второго символа и так далее.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxCursorPosition($index)
    {
    }

    /**
     * Возвращает 1, если поле редактирования только что потеряло фокус, что означает, что текст, возможно, изменился и
     * вряд ли изменится снова в краткосрочной перспективе.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxChanged($index)
    {
    }

    /**
     * Возвращает текущую позицию X поля редактирования. Это верхний левый угол фактического поля ввода текста, любая
     * граница будет простираться влево от этой точки.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return float
     */
    function GetEditBoxX($index)
    {
    }

    /**
     * Возвращает 1, если поле редактирования включено и может быть нажато, 0, если поле редактирования отключено и не
     * может быть изменено.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxActive($index)
    {
    }

    /**
     * Возвращает время, потраченное на замену backbuffer и (при необходимости) ожидание, пока GPU догонит готовый к
     * следующему кадру.
     *
     * @return float
     */
    function GetDrawingTime()
    {
    }

    /**
     * Возвращает каталог, содержащий документы текущих пользователей. На Windows это будет что-то вроде
     * "C:\Users\Me\My Документы", на iOS это будет просто каталог записи приложения. По умолчанию все приложения
     * записываются в указанную системой папку настроек приложения, например "C:\Users\Me\AppData" в Windows",
     * "/home/user/.config" в Linux и защищенная папка данных приложения на Android. Там, где это возможно, содержимое
     * пути к документам видно пользователю, например, на Android 10, а ниже будет папка sdcard. iOS и Android 11 и
     * выше не могут предоставить общедоступное место для записи, поэтому вместо этого будет возвращен каталог записи
     * приложения, который не виден пользователю.
     *
     * @return string
     */
    function GetDocumentsPath()
    {
    }

    /**
     * Возвращает текущее соотношение сторон экрана. Это не соотношение сторон используемой системы координат, вместо
     * этого это значение растягивает систему координат в нужную форму. Объяснение системы координат см. в разделе
     * SetVirtualResolution.
     *
     * @return float
     */
    function GetDisplayAspect()
    {
    }

    /**
     * Возвращает текущее значение направления в направлении Y. Направление-это эмулируемое значение, которое будет
     * использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.
     *
     * @return float
     */
    function GetDirectionY()
    {
    }

    /**
     * Возвращает 1, если существует поле редактирования с заданным идентификатором, и 0 в противном случае.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxExists($index)
    {
    }

    /**
     * Возвращает текущее значение направления в направлении X. Направление-это эмулируемое значение, которое будет
     * использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.
     *
     * @return float
     */
    function GetDirectionX()
    {
    }

    /**
     * Возвращает текущую скорость направления в виде абсолютного значения от 0 до 1,4, это используется с
     * GetDirectionAngle для определения экстента направления. Направление-это эмулируемое значение, которое будет
     * использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.
     *
     * @return float
     */
    function GetDirectionSpeed()
    {
    }

    /**
     * На Android это возвращает 0, если это приложение работает на устройстве Google, или 1, если оно работает на
     * устройстве Amazon. На всех других платформах это возвращает 0.
     *
     * @return int
     */
    function GetDevicePlatform()
    {
    }

    /**
     * Возвращает строку, содержащую конкретную строку устройства, это будет отличаться для каждой платформы, например,
     * в Windows она будет возвращать версию ОС "vista"," 7"," xp " и т. Д. На iOS он вернет имя устройства iOS
     * "ipad1,1", "ipod2,1", "iphone1,2" и т. Д. Для Android он вернет модель устройства "nexus 7" и т. Д. Для Mac он
     * вернет версию ОС "10.7", "10.8" и т. Д. Эта строка всегда будет строчной
     *
     * @return string
     */
    function GetDeviceType()
    {
    }

    /**
     * Возвращает количество секунд и долей секунд, затраченных на подготовку мира к рисованию. Это включает в себя
     * вычисление того, что видно, преобразование спрайтов в их положение на экране и отправку вершин в графический
     * процессор.
     *
     * @return float
     */
    function GetDrawingSetupTime()
    {
    }

    /**
     * Эта команда устарела, пожалуйста, используйте GetDeviceBaseName и GetDeviceType вместо этого. Возвращает строку,
     * содержащую имя текущей платформы, например "windows". При работе с iOS возвращается больше
     * информации,например,на iPad 1 "ios|iPad1,1" и на iPod 2-го поколения: "ios|iPod2, 1" и на iPhone 3G:
     * "ios|iPhone1, 2". Первое число-это главный номер модели, второе - второстепенный номер модели.
     *
     * @return string
     */
    function GetDeviceName()
    {
    }

    /**
     * Возвращает тип сетевого подключения устройства к Интернету. Возвращает 0, если используется мобильное
     * соединение, 1, если используется соединение Wi-Fi или Ethernet, или -1, если тип сети не может быть определен. В
     * настоящее время реализовано только на iOS и Android, другие платформы вернут -1.
     *
     * @return int
     */
    function GetDeviceNetworkType()
    {
    }

    /**
     * Возвращает строку, содержащую язык текущего устройства в виде "en", "fr", "de" и т. Д.
     *
     * @return string
     */
    function GetDeviceLanguage()
    {
    }

    /**
     * Возвращает IPv6-адрес текущего устройства, который может быть использован другими устройствами для подключения к
     * этому устройству. Чтобы получить IPv4-адрес, используйте вместо него GetDeviceIP.
     *
     * @return string
     */
    function GetDeviceIPv6()
    {
    }

    /**
     * Возвращает IPv4-адрес текущего устройства, который может быть использован другими устройствами для подключения к
     * этому устройству. Чтобы получить IPv6-адрес, используйте вместо него GetDeviceIPv6.
     *
     * @return string
     */
    function GetDeviceIP()
    {
    }

    /**
     * Возвращает строку, которая может быть использована для идентификации этого устройства
     *
     * @return string
     */
    function GetDeviceID()
    {
    }

    /**
     * Возвращает текущий угол направления относительно x=0, y=-1 (вверх). Угол будет находиться в диапазоне 0-360.
     * Направление-это эмулируемое значение, которое будет использовать акселерометр, если он доступен, или клавиши со
     * стрелками клавиатуры, если нет.
     *
     * @return float
     */
    function GetDirectionAngle()
    {
    }

    /**
     * Возвращает высоту в пикселях backbuffer текущего устройства. Это значение изменится, если ориентация устройства
     * изменится с книжной на альбомную, но только в том случае, если изменения ориентации разрешены.
     *
     * @return int
     */
    function GetDeviceHeight()
    {
    }

    /**
     * Возвращает ширину в пикселях backbuffer текущего устройства. Это значение изменится, если ориентация устройства
     * изменится с книжной на альбомную, но только в том случае, если изменения ориентации разрешены.
     *
     * @return int
     */
    function GetDeviceWidth()
    {
    }

    /**
     * Получает точки на дюйм (также называемые Пикселями на дюйм) экрана устройства. Это работает только на iOS и
     * Android, другие платформы вернут 0. В iOS это значение жестко закодировано устройством, поэтому, если будет
     * выпущено новое устройство, для получения точного значения потребуется обновление AGK. Тем временем будет
     * сформирована оценочная стоимость.
     *
     * @return int
     */
    function GetDeviceDPI()
    {
    }

    /**
     * Возвращает 1, если данный идентификатор камеры является задней камерой, 2, если это фронтальная камера, или 0,
     * если это неизвестно.
     *
     * @param int $cameraID Идентификатор камеры устройства, которую вы хотите проверить
     * @return int
     */
    function GetDeviceCameraType($cameraID)
    {
    }

    /**
     * Возвращает строку, содержащую имя текущей платформы. Это будет относиться только к базовой платформе, то есть
     * "windows", "ios", "android", "mac", "linux" или "html5". Используйте GetDeviceType, чтобы получить
     * дополнительную информацию о конкретном устройстве. Эта строка всегда будет строчной.
     *
     * @return string
     */
    function GetDeviceBaseName()
    {
    }

    /**
     * Возвращает дни заданного значения времени unix (от 1 до 31). Время Unix представлено как количество секунд с 1
     * января 1970 года, оно также может быть отрицательным.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetDaysFromUnix($unixtime)
    {
    }

    /**
     * Возвращает целое число, представляющее текущий день недели в диапазоне 0-6 с 0 как воскресенье, 1 как
     * понедельник и т. Д.
     *
     * @return int
     */
    function GetDayOfWeek()
    {
    }

    /**
     * Возвращает строку, представляющую текущее время в формате HH-MM-SS, например 15:23:04.
     *
     * @return string
     */
    function GetCurrentTime()
    {
    }

    /**
     * Возвращает ИДЕНТИФИКАТОР текущего активного поля редактирования, только одно поле редактирования может
     * фокусироваться одновременно. Если в данный момент ни одно поле редактирования не имеет фокуса, оно возвращает 0.
     *
     * @return int
     */
    function GetCurrentEditBox()
    {
    }

    /**
     * Эта команда устарела и была заменена GetFolder.
     *
     * @return string
     */
    function GetCurrentDir()
    {
    }

    /**
     * Возвращает строку, представляющую текущую дату в формате ГГГГ-ММ-ДД, например 2012-01-09.
     *
     * @return string
     */
    function GetCurrentDate()
    {
    }

    /**
     * Возвращает положение X точки контакта в мировых координатах.
     *
     * @return float
     */
    function GetContactWorldX()
    {
    }

    /**
     * Возвращает идентификатор второго спрайта, участвующего в этом контакте. Если эта половина контакта находится с
     * элементом, не связанным со спрайтом, то это вернет 0.
     *
     * @return int
     */
    function GetContactSpriteID2()
    {
    }

    /**
     * Возвращает идентификатор первого спрайта, участвующего в этом контакте. Если эта половина контакта находится с
     * элементом, не связанным со спрайтом, то это вернет 0.
     *
     * @return int
     */
    function GetContactSpriteID1()
    {
    }

    /**
     * Возвращает текущий статус согласия пользователя, он возвращает одно из следующих значений: -2 =
     * LoadConsentStatusAdMob еще не был вызван, вы должны вызвать его, прежде чем продолжить -1 =
     * LoadConsentStatusAdMob находится в процессе загрузки статуса согласия пользователя, пожалуйста, подождите 0 =
     * Пользователь еще не был спрошен, AdMob ads по умолчанию не будет использовать личную информацию, вызовите
     * RequestConsentAdMob, чтобы запросить согласие пользователя 1 = Пользователь отказался от согласия, любые
     * показанные объявления AdMob не будут использовать личную информацию 2 = Пользователь дал согласие, любые
     * показанные объявления AdMob будут использовать личную информацию
     *
     * @return int
     */
    function GetConsentStatusAdMob()
    {
    }

    /**
     * Возвращает красный компонент составного значения цвета, созданного с помощью MakeColor
     *
     * @param int $color Значение цвета для разложения.
     * @return int
     */
    function GetColorRed($color)
    {
    }

    /**
     * Возвращает зеленый компонент составного значения цвета, созданного с помощью MakeColor
     *
     * @param int $color Значение цвета для разложения.
     * @return int
     */
    function GetColorGreen($color)
    {
    }

    /**
     * Возвращает синий компонент составного значения цвета, созданного с помощью MakeColor
     *
     * @param int $color Значение цвета для разложения.
     * @return int
     */
    function GetColorBlue($color)
    {
    }

    /**
     * Возвращает значение переменной облачных данных по имени. Если переменная не существует, то вместо нее будет
     * возвращено значение по умолчанию, переданное по умолчанию. Если вы вызываете эту команду из уровня 2, то вы
     * должны удалить возвращенную строку, когда закончите с ней, вызвав agk::DeleteString.
     *
     * @param string $varName Имя переменной, которую нужно проверить, должно быть меньше 64 байт
     * @param string $defaultValue Значение, возвращаемое, если переменная не существует
     * @return string
     */
    function GetCloudDataVariable($varName, $defaultValue)
    {
    }

    /**
     * Возвращает 1 если облачные данные изменились из-за того, что другое устройство изменило значение, оно будет
     * оставаться 1 до тех пор, пока вы не вызовете GetCloudDataVariable. В противном случае возвращает 0. Это не
     * станет 1, когда вы измените значение локально.
     *
     * @return int
     */
    function GetCloudDataChanged()
    {
    }

    /**
     * Возвращает 1, если команды облачных данных доступны для использования. Возвращает 0, если пользователь еще не
     * решил, разрешить или заблокировать доступ, это будет предложено в SetupCloudData, если это применимо. Возвращает
     * -1, если пользователь специально отказал в доступе. Возвращает значение -2, если пользователь не вошел в систему
     * или на устройстве нет iCloud или Google Диска. Вы можете предложить пользователю войти в систему и включить их
     * при первом запуске вашего приложения или когда он решит включить облачное резервное копирование в ваших
     * собственных настройках приложения. Если эта команда возвращает -3 на Android, то данные Google cloud повреждены
     * и должны быть очищены в настройках диска.
     *
     * @return int
     */
    function GetCloudDataAllowed()
    {
    }

    /**
     * Получает любой текст, который в данный момент хранится в буфере обмена устройства, текст остается в буфере
     * обмена, поэтому он все еще может быть использован другими приложениями. Буфер обмена такой же, как и тот,
     * который используется функцией копирования/вставки устройства.
     *
     * @return string
     */
    function GetClipboardText()
    {
    }

    /**
     * Возвращает ИДЕНТИФИКАТОР вновь выбранного изображения, выбранного с помощью ShowChooseImageScreen. Если это
     * возвращает 0, то пользователь отменил процесс или вы еще не запустили его с помощью ShowChooseImageScreen. После
     * того как вы вызвали эту команду для получения идентификатора изображения, она будет возвращать 0 до тех пор,
     * пока ShowChooseImageScreen не будет вызван снова.
     *
     * @return int
     */
    function GetChosenImage()
    {
    }

    /**
     * Возвращает положение точки контакта Y в мировых координатах.
     *
     * @return float
     */
    function GetContactWorldY()
    {
    }

    /**
     * Возвращает текущую длину буфера символов без его изменения. Обратите внимание, что это длина в символах, а не в
     * байтах, которая может отличаться, когда строка содержит символы юникода.
     *
     * @return int
     */
    function GetCharBufferLength()
    {
    }

    /**
     * Возвращает строку всех символов, нажатых с момента последнего вызова этой команды, после вызова которой буфер
     * очищается. Это работает только на устройствах с физической клавиатурой. Буфер ограничен 1024 символами, после
     * чего дополнительные символы будут проигнорированы. В Tier 2 строка кодируется в UTF-8 и должна быть удалена с
     * помощью agk::DeleteString, когда вы закончите с ней.
     *
     * @return string
     */
    function GetCharBuffer()
    {
    }

    /**
     * Эта функция устарела, вместо нее используйте SetDeviceCameraToImage. Возвращает ИДЕНТИФИКАТОР только что
     * захваченного изображения, созданного с помощью ShowImageCaptureScreen. Если это возвращает 0, то пользователь
     * отменил процесс или вы еще не запустили его с помощью ShowImageCaptureScreen. После того как вы вызвали эту
     * команду для получения идентификатора изображения, она будет возвращать 0 до тех пор, пока ShowImageCaptureScreen
     * не будет вызван снова.
     *
     * @return int
     */
    function GetCapturedImage()
    {
    }

    /**
     * Возвращает текущее положение Z камеры.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraZ($cameraID)
    {
    }

    /**
     * Возвращает текущее положение X камеры.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraX($cameraID)
    {
    }

    /**
     * Возвращает текущее положение Y камеры.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraY($cameraID)
    {
    }

    /**
     * Возвращает текущее Z-положение камеры после всех преобразований, вызванных FixCameraToObject.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraWorldZ($cameraID)
    {
    }

    /**
     * Возвращает текущее положение Y камеры после всех преобразований, вызванных FixCameraToObject.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraWorldY($cameraID)
    {
    }

    /**
     * Возвращает текущее положение X камеры после всех преобразований, вызванных FixCameraToObject.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraWorldX($cameraID)
    {
    }

    /**
     * Возвращает Y-компоненту текущего вращения камеры, преобразованную в кватернион.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraQuatY($cameraID)
    {
    }

    /**
     * Возвращает Z-компоненту текущего вращения камеры, преобразованную в кватернион.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraQuatZ($cameraID)
    {
    }

    /**
     * Возвращает компонент X текущего вращения камеры, преобразованный в кватернион.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraQuatX($cameraID)
    {
    }

    /**
     * Возвращает текущее поле зрения для указанной камеры
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraFOV($cameraID)
    {
    }

    /**
     * Возвращает 1, если текущее устройство имеет камеру, и 0, если нет. На некоторых платформах эта команда
     * перечисляет аппаратные устройства для проверки камеры, которая может быть медленной. Не рекомендуется называть
     * это каждый кадр. В Windows эта команда успешно обнаружит новую камеру, подключенную во время работы приложения.
     *
     * @return int
     */
    function GetCameraExists()
    {
    }

    /**
     * Возвращает Y-компоненту текущего поворота камеры, преобразованную в углы Эйлера.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraAngleY($cameraID)
    {
    }

    /**
     * Возвращает Z-компоненту текущего поворота камеры, преобразованную в углы Эйлера.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraAngleZ($cameraID)
    {
    }

    /**
     * Возвращает X-компоненту текущего поворота камеры, преобразованную в углы Эйлера.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraAngleX($cameraID)
    {
    }

    /**
     * Эта функция возвращает 1, если указанная кнопка в данный момент удерживается нажатой. Кнопки AGK-это эмулируемый
     * метод ввода, который использует любые доступные входы устройства для создания 5 кнопок. Если будет найден
     * настоящий джойстик, то первые 5 кнопок из него будут использоваться для команд кнопки AGK. В противном случае
     * AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет использовать следующие клавиши в следующем
     * порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5 соответственно. Если ни джойстик, ни клавиатура
     * не найдены, то создается виртуальная кнопка, которая появится на экране и может быть нажата либо с помощью
     * сенсорного экрана, либо с помощью мыши. Каждая платформа гарантированно имеет способ активации кнопок AGK.
     *
     * @param int $index Идентификатор кнопки, которую нужно проверить, должен находиться в диапазоне от 1 до 5
     *     включительно.
     * @return int
     */
    function GetButtonState($index)
    {
    }

    /**
     * Эта функция возвращает 1, если указанная кнопка только что была нажата, а затем возвращает 0, когда кнопка
     * удерживается нажатой. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы
     * устройства для создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут
     * использоваться для команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет
     * найдена, будет использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки
     * от 1 до 5 соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая
     * появится на экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа
     * гарантированно имеет способ активации кнопок AGK.
     *
     * @param int $index Идентификатор кнопки, которую нужно проверить, должен находиться в диапазоне от 1 до 5
     *     включительно.
     * @return int
     */
    function GetButtonPressed($index)
    {
    }

    /**
     * Эта функция возвращает 1, если указанная кнопка только что была отпущена, а затем возвращает 0, когда кнопка
     * поднята. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для
     * создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут использоваться для
     * команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет
     * использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5
     * соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая появится на
     * экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа
     * гарантированно имеет способ активации кнопок AGK.
     *
     * @param int $index Идентификатор кнопки, которую нужно проверить, должен находиться в диапазоне от 1 до 5
     *     включительно.
     * @return int
     */
    function GetButtonReleased($index)
    {
    }

    /**
     * Проверяет прослушиватель вещания на наличие любых передач. Возвращает 0, если ничего не было получено.
     * Возвращает идентификатор сообщения если что-то было получено, вы можете получить доступ к содержимому этого
     * сообщения с помощью команд сетевого сообщения. Сообщение должно быть удалено, когда вы закончите чтение.
     *
     * @param int $iID Идентификатор широковещательного слушателя для проверки.
     * @return int
     */
    function GetBroadcastMessage($iID)
    {
    }

    /**
     * Возвращает 1, если указанный идентификатор приложения все еще работает, и 0, если это не так.
     *
     * @param int $appID Идентификатор приложения для проверки, возвращенный из runApp()
     * @return int
     */
    function GetAppRunning($appID)
    {
    }

    /**
     * Возвращает имя exe-файла.
     *
     * @return string
     */
    function GetAppName()
    {
    }

    /**
     * На Android это возвращает имя пакета, используемое при экспорте приложения, например, для AGK Player это будет
     * com.thegamecreators.agk_player2. В iOS он возвращает идентификатор пакета, используемый для приложения,
     * например, для AGK Player это будет com.thegamecreators.agk2player. На всех других платформах это в настоящее
     * время возвращает пустую строку. Если вы вызываете это из уровня 2, то возвращаемая строка должна быть удалена,
     * когда она больше не нужна.
     *
     * @return string
     */
    function GetAppPackageName()
    {
    }

    /**
     * Возвращает 1, если указанное приложение установлено и включено на устройстве. Для Android это должно быть имя
     * пакета приложения, например com.faceboook.катана для приложения Facebook. В настоящее время это работает только
     * на Android
     *
     * @param string $packageName Имя пакета приложения для проверки
     * @return int
     */
    function GetAppInstalled($packageName)
    {
    }

    /**
     * Возвращает W-компонент текущего вращения камеры, преобразованный в кватернион.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraQuatW($cameraID)
    {
    }

    /**
     * Возвращает 1, если текущее устройство имеет акселерометр, который в настоящее время поддерживается AGK, и 0,
     * если нет.
     *
     * @return int
     */
    function GetAccelerometerExists()
    {
    }

    /**
     * Преобразует 2D-точку на экране в вектор, указывающий в 3D-мир. Вектор нормализуется на 1 единицу длины, чтобы
     * расширить его в мир, просто умножьте его на желаемое расстояние.  Если камера использует ортогональную
     * проекционную матрицу, то эта команда ведет себя несколько иначе, поскольку все точки на экране будут производить
     * один и тот же вектор, направленный в сторону от камеры, но каждый из них исходит из другой точки в трехмерном
     * пространстве. Это отличается от перспективной проекции, где все векторы начинаются в положении камеры и
     * расходятся веером по мере удаления от камеры. Поэтому при использовании ортогональной проекционной матрицы эта
     * команда вместо этого возвращает боковой ненормализованный вектор из положения камеры в точку в 3D-пространстве,
     * с которой должен начинаться вектор. Затем это может быть объединено с вектором, который указывает в сторону от
     * камеры, чтобы создать луч, брошенный в сцену.
     *
     * @param float $x X-компонент положения экрана.
     * @param float $y Компонент Y положения экрана.
     * @return float
     */
    function Get3DVectorYFromScreen($x, $y)
    {
    }

    /**
     * Возвращает общее количество физических объектов в мире.
     *
     * @return int
     */
    function Get3DPhysicsTotalObjects()
    {
    }

    /**
     * Возвращает общее количество суставов в физическом мире
     *
     * @return int
     */
    function Get3DPhysicsTotalJoints()
    {
    }

    /**
     * Возвращает общее количество попаданий луча по его длине.
     *
     * @param int $rayID Идентификатор луча, который возвращается вызовом Create3DPhysicsRay().
     * @return int
     */
    function Get3DPhysicsRayCastNumHits($rayID)
    {
    }

    /**
     * Возвращает расстояние вдоль луча до столкновения, где 1.0 = полная длина, 0.0 = начало.
     *
     * @param int $rayID Идентификатор луча
     * @return float
     */
    function Get3DPhysicsRayCastFraction($rayID)
    {
    }

    /**
     * Возвращает идентификатор объекта, пораженного лучом по индексу.
     *
     * @param int $rayID Идентификатор луча
     * @param float $fractionIndex значение, возвращаемое командой Get3DPhysicsRayCastFraction ().
     * @return int
     */
    function Get3DPhysicsRayCastObjectHit($rayID, $fractionIndex)
    {
    }

    /**
     * Заполняет переданный вектор значениями нормалей от луча. сначала создайте физический луч, а затем бросьте его
     * перед вызовом Get3DPhysicsRayCastNormalVector().
     *
     * @param int $rayID Идентификатор луча, который возвращается вызовом Create3DPhysicsRay().
     * @param int $returnVec3ID Идентификатор вектора. Vector ID-это возвращаемое значение команды CreateVector3 ().
     * @return void
     */
    function Get3DPhysicsRayCastNormalVector($rayID, $returnVec3ID)
    {
    }

    /**
     * Преобразует 2D-точку на экране в вектор, указывающий в 3D-мир. Вектор нормализуется на 1 единицу длины, чтобы
     * расширить его в мир, просто умножьте его на желаемое расстояние.  Если камера использует ортогональную
     * проекционную матрицу, то эта команда ведет себя несколько иначе, поскольку все точки на экране будут производить
     * один и тот же вектор, направленный в сторону от камеры, но каждый из них исходит из другой точки в трехмерном
     * пространстве. Это отличается от перспективной проекции, где все векторы начинаются в положении камеры и
     * расходятся веером по мере удаления от камеры. Поэтому при использовании ортогональной проекционной матрицы эта
     * команда вместо этого возвращает боковой ненормализованный вектор из положения камеры в точку в 3D-пространстве,
     * с которой должен начинаться вектор. Затем это может быть объединено с вектором, который указывает в сторону от
     * камеры, чтобы создать луч, брошенный в сцену.
     *
     * @param float $x X-компонент положения экрана.
     * @param float $y Компонент Y положения экрана.
     * @return float
     */
    function Get3DVectorXFromScreen($x, $y)
    {
    }

    /**
     * Возвращает true, если есть контактный вектор, и заполняет вектор outVec3ID. Сначала создайте вектор с помощью
     * CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен
     * результатами.
     *
     * @param int $rayID Идентификатор луча
     * @param float $fractionIndex значение, возвращаемое командой Get3DPhysicsRayCastFraction ().
     * @param int $outVec3ID Идентификатор вектора, который будет заполнен позицией.
     * @return int
     */
    function Get3DPhysicsRayCastContactPosition($rayID, $fractionIndex, $outVec3ID)
    {
    }

    /**
     * Возвращает идентификатор объекта модели с ragdoll, который содержит переданный объект ragdoll bone.
     *
     * @param int $objID идентификатор объекта костной капсулы тряпичной куклы.
     * @return int
     */
    function Get3DPhysicsRagdollFromBoneObject($objID)
    {
    }

    /**
     * Преобразует 2D-точку на экране в вектор, указывающий в 3D-мир. Вектор нормализуется на 1 единицу длины, чтобы
     * расширить его в мир, просто умножьте его на желаемое расстояние.  Если камера использует ортогональную
     * проекционную матрицу, то эта команда ведет себя несколько иначе, поскольку все точки на экране будут производить
     * один и тот же вектор, направленный в сторону от камеры, но каждый из них исходит из другой точки в трехмерном
     * пространстве. Это отличается от перспективной проекции, где все векторы начинаются в положении камеры и
     * расходятся веером по мере удаления от камеры. Поэтому при использовании ортогональной проекционной матрицы эта
     * команда вместо этого возвращает боковой ненормализованный вектор из положения камеры в точку в 3D-пространстве,
     * с которой должен начинаться вектор. Затем это может быть объединено с вектором, который указывает в сторону от
     * камеры, чтобы создать луч, брошенный в сцену.
     *
     * @param float $x X-компонент положения экрана.
     * @param float $y Компонент Y положения экрана.
     * @return float
     */
    function Get3DVectorZFromScreen($x, $y)
    {
    }

    /**
     * Возвращает true, если для объекта существует тряпичная кукла.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function Get3DPhysicsRagdollExist($objID)
    {
    }

    /**
     * Возвращает угол поворота суставов X в градусах
     *
     * @param int $jointID Идентификатор сустава.
     * @return int
     */
    function Get3DPhysicsJointRotationVector($jointID)
    {
    }

    /**
     * Возвращает true, если существует ближайший контактный вектор, и заполняет вектор outVec3ID. Сначала создайте
     * вектор с помощью CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет
     * заполнен результатами.
     *
     * @param int $rayID Идентификатор луча
     * @param int $outVec3ID Идентификатор вектора, который будет заполнен позицией.
     * @return int
     */
    function Get3DPhysicsRayCastClosestContactPosition($rayID, $outVec3ID)
    {
    }

    /**
     * Возвращает идентификатор вектора
     *
     * @param int $jointID Идентификатор сустава
     * @return int
     */
    function Get3DPhysicsJointPositionVector($jointID)
    {
    }

    /**
     * Верните ближайший объект, пораженный лучом.
     *
     * @param int $rayID Идентификатор луча
     * @return int
     */
    function Get3DPhysicsRayCastClosestObjectHit($rayID)
    {
    }

    /**
     * Возвращает максимальный наклон в градусах.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function Get3DPhysicsCharacterControllerMaxSlope($objID)
    {
    }

    /**
     * Возвращает контроллер гравитации.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function Get3DPhysicsCharacterControllerGravity($objID)
    {
    }

    /**
     * Возвращает 1, если объект имеет контроллер, в противном случае 0.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function Get3DPhysicsCharacterControllerExists($objID)
    {
    }

    /**
     * Возвращает общее количество активных объектов в физическом мире.
     *
     * @return int
     */
    function Get3DPhysicsActiveObjects()
    {
    }

    /**
     * Возвращает текущее Z - положение излучателя, это точка, из которой будут появляться новые частицы. Невозможно
     * получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesZ($ID)
    {
    }

    /**
     * Возвращает текущее положение X излучателя, это точка, из которой будут появляться новые частицы. Невозможно
     * получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesX($ID)
    {
    }

    /**
     * Возвращает текущее положение Y излучателя, это точка, из которой будут появляться новые частицы. Невозможно
     * получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesY($ID)
    {
    }

    /**
     * Возвращает 0, если данные частицы были установлены как невидимые с помощью Set3DParticlesVisible, или 1, если
     * они в данный момент установлены как видимые (по умолчанию). Это не проверяет, находятся ли частицы в видимом
     * окне просмотра.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function Get3DParticlesVisible($ID)
    {
    }

    /**
     * Возвращает текущий размер всех частиц в мировых координатах. Дополнительные сведения об установке размера частиц
     * см. в разделе Set3DParticlesSize.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesSize($ID)
    {
    }

    /**
     * Возвращает 1, если излучатель испустил количество частиц, указанное в Set3DParticlesMax, и все испущенные
     * частицы с тех пор умерли, в противном случае возвращает 0. Если максимальное значение равно -1, то оно всегда
     * будет возвращать 0. Чтобы сбросить счетчик и заставить излучатель снова начать излучать, используйте
     * Reset3DParticleCount.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function Get3DParticlesMaxReached($ID)
    {
    }

    /**
     * Возвращает текущую жизнь частиц в секундах. Невозможно получить текущую жизнь отдельных частиц. Это значение не
     * зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesLife($ID)
    {
    }

    /**
     * Возвращает порог разрыва соединения.
     *
     * @param int $jointID Id соединения
     * @return int
     */
    function Get3DPhysicsJointEnabled($jointID)
    {
    }

    /**
     * Возвращает 1, если 3D-излучатель частиц существует с заданным идентификатором, и 0, если нет.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function Get3DParticlesExists($ID)
    {
    }

    /**
     * Возвращает z-компоненту направления излучателя, которое является базовым направлением движения частиц при их
     * создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения
     * Set3DParticlesDirection.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesDirectionZ($ID)
    {
    }

    /**
     * Возвращает y-компоненту направления излучателя, которое является базовым направлением движения частиц при их
     * создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения
     * Set3DParticlesDirection.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesDirectionY($ID)
    {
    }

    /**
     * Возвращает X-компоненту направления излучателя, которое является базовым направлением движения частиц при их
     * создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения
     * Set3DParticlesDirection.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesDirectionX($ID)
    {
    }

    /**
     * Возвращает угол второго излучателя в градусах. Это значение представляет собой величину отклонения частицы от
     * направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 360 означает, что
     * частица может двигаться в любом направлении в этой плоскости при излучении.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesDirectionRange2($ID)
    {
    }

    /**
     * Возвращает 0, если данные частицы были приостановлены с помощью Set3DParticlesActive, или 1, если они в данный
     * момент обновляются как обычно (по умолчанию).
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function Get3DParticlesActive($ID)
    {
    }

    /**
     * Возвращает первый угол излучателя в градусах. Это значение представляет собой величину отклонения частицы от
     * направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 360 означает, что
     * частица может двигаться в любом направлении в этой плоскости при излучении.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesDirectionRange1($ID)
    {
    }

    /**
     * Отправляет счет на именованную доску лидеров, которая должна соответствовать идентификатору таблицы лидеров,
     * присвоенному вашей доске в iTunes connect, Google Game Services или GameCircle.
     *
     * @param int $iScore Оценка для представления
     * @param string $szBoardID Название доски лидеров
     * @return void
     */
    function GameCenterSubmitScore($iScore, $szBoardID)
    {
    }

    /**
     * Изменение прогресса пользователей при достижении именованного достижения имя должно совпадать с идентификатором
     * достижения, присвоенным этому достижению в iTunes connect, Google Game Services или GameCircle. Значения
     * iPercentageComplete должны находиться в диапазоне от 0 до 100. Однако для инкрементных достижений это значение
     * фактически является числом завершенных шагов и может находиться за пределами этого диапазона. Это значение будет
     * перезаписывать текущий процент или выполненные шаги достижения.
     *
     * @param string $szAchievementID Название достижения
     * @param int $iPercentageComplete Пользователи продвигаются к получению этого достижения или количества
     *     выполненных шагов
     * @return void
     */
    function GameCenterSubmitAchievement($szAchievementID, $iPercentageComplete)
    {
    }

    /**
     * Показывает пользователю именованную таблицу лидеров, имя которой должно совпадать с идентификатором таблицы
     * лидеров, присвоенным вашей доске в iTunes connect, Google Game Services или GameCircle.
     *
     * @param string $szBoardID Название доски лидеров
     * @return void
     */
    function GameCenterShowLeaderBoard($szBoardID)
    {
    }

    /**
     * Вызовите этот вызов один раз, чтобы настроить приложение для дальнейших команд Game Center.
     *
     * @return void
     */
    function GameCenterSetup()
    {
    }

    /**
     * Возвращает текущую частоту генерации частиц в частицах в секунду. Это значение не зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesFrequency($ID)
    {
    }

    /**
     * Вызовите это один раз, чтобы войти в систему пользователя в Game Center (iOS) или Google Play Games (Android),
     * если они вошли в систему до того, как это произойдет в фоновом режиме и не прерывает пользователя, в противном
     * случае появится всплывающее окно с просьбой войти в систему и предоставить разрешение на продолжение.
     *
     * @return void
     */
    function GameCenterLogin()
    {
    }

    /**
     * Еще не функционирует
     *
     * @return void
     */
    function GameCenterAchievementsReset()
    {
    }

    /**
     * Показывает пользователю свои достижения и прогресс.
     *
     * @return void
     */
    function GameCenterAchievementsShow()
    {
    }

    /**
     * Вызовите эту функцию, чтобы вывести пользователя из Google Play Games. После этого вы можете снова вызвать
     * GameCenterLogin. На Game Center (iOS) это никак не влияет, пользователь должен выйти из приложения Game Center.
     *
     * @return void
     */
    function GameCenterLogout()
    {
    }

    /**
     * Немедленно отправляет все ожидающие данные на удаленный хост. Если вы не вызовете этот вызов, то данные будут
     * вечно ждать в буфере, пока вы не запишете в сокет более 1400 байт, после чего он автоматически будет сброшен.
     * Каждый раз, когда вы вызываете эту команду, будет отправлен новый пакет, поэтому при отправке нескольких
     * значений вы не должны вызывать его после каждого значения, так как это приведет к потере пропускной способности
     * сети. Вы должны записать все значения, а затем сбросить их, чтобы они были отправлены вместе. Если нет данных,
     * ожидающих отправки, эта команда ничего не делает. Возвращает 1, если сокет был успешно сброшен, 0, если сокет
     * отключен.
     *
     * @param int $socketID Идентификатор сокета для проверки
     * @return int
     */
    function FlushSocket($socketID)
    {
    }

    /**
     * Округляет поплавок до следующего наименьшего целого числа. Это отличается от Trunc при использовании
     * отрицательных чисел, Trunc( -1.6 ) равен -1, а Floor( -1.6 ) равен -2.
     *
     * @param float $a Значение для пола.
     * @return int
     */
    function Floor($a)
    {
    }

    /**
     * По умолчанию текстовые объекты создаются в мировых координатах, и SetViewOffset можно использовать для
     * перемещения по всему миру. Используйте эту команду, чтобы вместо этого зафиксировать текст на экране, чтобы он
     * перемещался вместе с видовым окном при перемещении видового окна. Вы все еще можете изменить положение текста,
     * закрепленного на экране, это влияет только на то, что происходит при перемещении видового экрана.
     *
     * @param int $iTextIndex Идентификатор текста, который нужно изменить.
     * @param int $mode 1=экранный текст, 0=мировой текст
     * @return void
     */
    function FixTextToScreen($iTextIndex, $mode)
    {
    }

    /**
     * По умолчанию спрайты создаются в мировых координатах, и SetViewOffset можно использовать для перемещения по
     * всему миру. Используйте эту команду, чтобы вместо этого зафиксировать спрайт на экране, чтобы он перемещался
     * вместе с видовым окном при перемещении видового окна. Вы все еще можете изменить положение спрайта, который
     * закреплен на экране, это влияет только на то, что происходит при перемещении видового экрана. Вы не должны
     * использовать команды физики или столкновения для спрайтов, закрепленных на экране, так как их отладочные формы
     * не будут выстраиваться в линию и будут мешать физическим спрайтам, не закрепленным на экране.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $mode 1=экранный спрайт, 0=мировой спрайт
     * @return void
     */
    function FixSpriteToScreen($iSpriteIndex, $mode)
    {
    }

    /**
     * Фиксирует указанный скелет на экране так, чтобы он не был затронут SetViewOffset
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $mode 1 для фиксации на экране, 0 для нормального поведения (по умолчанию)
     * @return void
     */
    function FixSkeleton2DToScreen($iSkeleton, $mode)
    {
    }

    /**
     * Фиксация частиц на экране гарантирует, что они не будут затронуты прокруткой видового экрана.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $mode Используйте 1 для фиксации на экране. Используйте 0, чтобы позволить частицам быть затронутыми
     *     прокруткой.
     * @return void
     */
    function FixParticlesToScreen($ID, $mode)
    {
    }

    /**
     * Фиксирует объект к другому объекту, так что любое движение родителя также влияет на ребенка. Фиксируемый объект
     * использует свое текущее положение, поворот и масштаб в качестве смещения по отношению к родительскому объекту.
     * Например, если родитель был помещен в 10,5,0 и объект был закреплен на нем с текущей позицией 0,10,0, то ребенок
     * теперь унаследует позицию родителя, объединит ее со своей собственной, и ребенок будет помещен в 10,15,0. То же
     * самое относится к вращению и масштабированию, поэтому, если родитель был повернут вокруг оси Y, то и ребенок
     * будет вращаться на ту же величину. Обратите внимание, что использование GetObjectY на дочернем объекте будет
     * показывать только его локальное положение относительно родительского (в этом случае он вернет 10). Чтобы
     * получить конечную мировую позицию ребенка, используйте GetObjectWorldY на нем, который в этом случае вернет 15.
     * Нет предела количеству объектов, которые объект может зафиксировать на себе, и нет предела тому, чтобы объекты
     * были зафиксированы на объектах, которые фиксированы на других объектах, просто не создавайте никаких циклов.
     * Чтобы остановить фиксацию объекта к чему-либо, установите toObjID в 0, и он снова станет независимым.
     *
     * @param int $objID Идентификатор объекта для исправления.
     * @param int $toObjID Идентификатор объекта для его фиксации.
     * @return void
     */
    function FixObjectToObject($objID, $toObjID)
    {
    }

    /**
     * Аналогично FixObjectToObject, за исключением того, что родитель будет костью в другом объекте.
     *
     * @param int $objID Идентификатор объекта для исправления.
     * @param int $toObjID Идентификатор объекта для его фиксации.
     * @param int $toBoneIndex Указательный палец кости, чтобы зафиксировать его.
     * @return void
     */
    function FixObjectToBone($objID, $toObjID, $toBoneIndex)
    {
    }

    /**
     * По умолчанию спрайты и поля редактирования создаются в мировых координатах, а SetViewOffset можно использовать
     * для перемещения по всему миру. Используйте эту команду, чтобы вместо этого зафиксировать поле редактирования на
     * экране, чтобы оно перемещалось вместе с видовым окном при перемещении видового окна. Вы все еще можете изменить
     * положение поля редактирования, закрепленного на экране, оно влияет только на то, что происходит при перемещении
     * окна просмотра.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $fix 0=двигаться при перемещении видового порта, 1=оставаться неподвижным на экране независимо от
     *     того, куда перемещается видовой порт.
     * @return void
     */
    function FixEditBoxToScreen($index, $fix)
    {
    }

    /**
     * Сбрасывает положение и вращение объекта на 0, сохраняя при этом вершины объекта там, где они находятся. Это
     * можно использовать для изменения центра вращения объекта или настройки его ориентации по умолчанию, когда его
     * вращение равно 0. Эта команда изменяет вершины сеток объекта, поэтому не рекомендуется вызывать ее каждый кадр,
     * если только целевая платформа не является достаточно мощной, то есть Windows, Mac или Linux.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @return void
     */
    function FixObjectPivot($objID)
    {
    }

    /**
     * Запускает систему Firebase analytics и отслеживание некоторых автоматизированных событий. Дополнительные события
     * можно отслеживать с помощью FirebaseLogEvent. Вы должны включить конфигурационный файл Google Services,
     * созданный при настройке проекта Firebase, который можно добавить во время экспорта для Android или iOS. Если вы
     * не укажете свой собственный конфигурационный файл google services во время экспорта, то все ваши данные
     * отслеживания будут отправлены в наш проект AGK Firebase и проигнорированы. Аналогично, если вы используете эти
     * команды во время трансляции, то данные отслеживания будут отправлены в проект AGK и проигнорированы.
     *
     * @return void
     */
    function FirebaseSetup()
    {
    }

    /**
     * Говорит Firebase записать событие, которое произошло в вашем приложении, например, разблокировку достижения. Они
     * появятся на странице аналитики проекта Firebase. Обратите внимание, что имена событий не должны содержать тире
     * или пробелы, иначе они не будут зарегистрированы.
     *
     * @param string $event_name Имя события для передачи в Firebase, некоторые из них зарезервированы для
     *     автоматических событий, например "first_open"
     * @return void
     */
    function FirebaseLogEvent($event_name)
    {
    }

    /**
     * Создает соединение шкива между двумя спрайтами. Это вторая половина двухкомандной установки. Из-за количества
     * требуемых параметров вы должны сначала вызвать CreatePulleyJoint2 с начальным набором параметров для создания
     * соединения. Эта команда возвращает идентификатор нового соединения.
     *
     * @param float $gnd1x Координата x первой наземной точки
     * @param float $gnd1y Координата y первой наземной точки
     * @param float $gnd2x Координата x второй точки заземления
     * @param float $gnd2y Координата y второй точки заземления
     * @param float $a1x Координата x первой опорной точки
     * @param float $a1y Координата y первой опорной точки
     * @param float $a2x Координата x второй опорной точки
     * @param float $a2y Координата y второй опорной точки
     * @return int
     */
    function FinishPulleyJoint($gnd1x, $gnd1y, $gnd2x, $gnd2y, $a1x, $a1y, $a2x, $a2y)
    {
    }

    /**
     * Возвращает индекс первого вхождения findStr в заданную строку, начиная с конца строки и двигаясь назад.
     * Используйте начальное значение -1, чтобы начать с самого конца строки независимо от ее длины. Индекс 1-это
     * первый символ в строке, возвращающий 0, если он не найден. По умолчанию этот параметр не чувствителен к
     * регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.
     *
     * @param string $str Строка для проверки
     * @param string $findStr Строка, которую нужно найти
     * @param int|null $ignoreCase 1-игнорировать регистр при поиске, 0
     * @param int|null $start Индекс для начала, первый символ находится в индексе 1, используйте минус 1, чтобы начать с
     *     самого конца
     * @return int
     */
    function FindStringReverse(string $str, string $findStr, int $ignoreCase = null, int $start = null)
    {
    }

    /**
     * Прикрепляет указанный спрайт к заданному идентификатору скелета и кости. Идентификатор кости можно найти с
     * помощью команды GetSkeleton2DBone. Когда спрайт прикреплен к кости скелета, его положение и вращение становятся
     * относительно положения кости. Например, если положение спрайта равно 0,0, то он будет нарисован в том же
     * положении, что и кость, но если положение равно 0,10, то спрайт будет нарисован над костью относительно кости,
     * то есть если кость повернута влево на 90 градусов, то "выше" кости будет находиться слева от экрана в мировых
     * координатах.  ZOrder может быть задан для рисования спрайта между двумя существующими спрайтами скелета, любое
     * целочисленное значение является допустимым и соответствует текущему порядку спрайтов в скелете. Например,
     * Z-порядок 0 всегда будет рисовать перед первым спрайтом в Z-порядке скелета, значение 1 всегда будет рисовать
     * перед вторым спрайтом в скелете и так далее. Обратите внимание, что на это не влияют другие спрайты, которые вы
     * прикрепили к скелету, он учитывает только те спрайты, которые изначально были загружены вместе со скелетом.
     * Например, если вы прикрепили к скелету два новых спрайта с z-порядком, равным 1, то они оба будут нарисованы
     * между первым и вторым спрайтами в исходном скелете. Любые спрайты, прикрепленные к скелету с использованием
     * одного и того же значения zorder, будут нарисованы в том порядке, в котором они были прикреплены.  Пока этот
     * спрайт прикреплен к скелету, он будет удален из обычных процедур рисования и нарисован только тогда, когда
     * скелет виден. Вы все еще можете заставить спрайт рисовать, вызвав DrawSprite, но он не будет упорядочен с
     * другими спрайтами в скелете.  Чтобы отделить спрайт от скелета, вызовите эту команду с 0 в качестве skeletonID,
     * параметры bone ID и zorder в этом случае не имеют значения.
     *
     * @param int $spriteID Идентификатор спрайта для прикрепления
     * @param int $iSkeletonID Идентификатор скелета, к которому нужно прикрепиться
     * @param int $bone Идентификатор кости в скелете, к которой нужно прикрепиться
     * @param int $zorder ZOrder для размещения нового спрайта в порядке рисования скелета
     * @return void
     */
    function FixSpriteToSkeleton2D($spriteID, $iSkeletonID, $bone, $zorder)
    {
    }

    /**
     * Возвращает количество раз, когда findStr появляется в данной строке. По умолчанию этот параметр не чувствителен
     * к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.
     *
     * @param string $str Строка для проверки
     * @param string $findStr Строка, которую нужно найти
     * @param int|null $ignoreCase 1-игнорировать регистр при поиске, 0
     * @param int|null $start Индекс, с которого нужно начать, первый символ находится в индексе 1
     * @return int
     */
    function FindStringCount(string $str, string $findStr, int $ignoreCase = null, int $start = null): int
    {
    }

    /**
     * Возвращает индекс первого вхождения findStr в заданную строку. Индекс 1-это первый символ в строке, возвращающий
     * 0, если он не найден. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для
     * установки чувствительности к регистру.
     *
     * @param string $str Строка для проверки
     * @param string $findStr Строка, которую нужно найти
     * @param int|null $ignoreCase 1-игнорировать регистр при поиске, 0
     * @param int|null $start Индекс, с которого нужно начать, первый символ находится в индексе 1
     * @return int
     */
    function FindString(string $str, string $findStr, int $ignoreCase = null, int $start = null): int
    {
    }

    /**
     * Заканчивает строительство тряпичной куклы. Вызовите эту команду, когда вы добавите все кости и суставы для вашей
     * тряпичной куклы. Убедитесь, что вы сначала вызвали Create3DPhysicsRagDoll, прежде чем вызывать эту команду.
     *
     * @return void
     */
    function Finalize3DPhysicsRagDoll()
    {
    }

    /**
     * Возвращает 1, если данный файл был успешно открыт, и 0, если нет. Вы можете использовать GetErrorOccurred, чтобы
     * проверить, было ли это результатом ошибки, и GetLastError, чтобы получить указанную ошибку.
     *
     * @param int $iFileID Идентификатор файла для проверки.
     * @return int
     */
    function FileIsOpen($iFileID)
    {
    }

    /**
     * Возвращает 1, если данный файл достиг конца своего потока данных, и 0 в противном случае. Используется только
     * при чтении.
     *
     * @param int $iFileID Идентификатор файла для проверки.
     * @return int
     */
    function FileEOF($iFileID)
    {
    }

    /**
     * Эта команда в настоящее время не поддерживается
     *
     * @param string $szURL URL-адрес, который вам нравится.
     * @param int $iX x положение кнопки like.
     * @param int $iY y положение кнопки like.
     * @param int $iWidth ширина кнопки like.
     * @param int $iHeight высота кнопки like.
     * @return void
     */
    function FacebookShowLikeButton($szURL, $iX, $iY, $iWidth, $iHeight)
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @param string $szID ваш идентификатор приложения Facebook.
     * @return void
     */
    function FacebookSetup($szID)
    {
    }

    /**
     * Фиксирует камеру на объекте таким образом, что любое движение объекта также влияет на камеру. Камера использует
     * свое текущее положение, поворот и масштаб в качестве смещения по отношению к объекту. Например, если объект был
     * помещен в 10,5,0 и к нему была прикреплена камера с текущим положением 0,10,0, то камера теперь унаследует
     * положение объекта, объединит его со своим собственным, и камера будет помещена в 10,15,0. То же самое относится
     * к вращению и масштабированию, поэтому, если объект был повернут вокруг оси Y, то камера будет вращаться на ту же
     * величину. Обратите внимание, что использование GetCameraY покажет только его локальное положение относительно
     * родительского объекта (в этом случае он вернет 10). Чтобы получить конечное мировое положение камеры,
     * используйте GetCameraWorldY, который в этом случае вернет 15. Нет предела количеству объектов или камер, которые
     * объект может зафиксировать на себе, и нет предела тому, что объекты фиксируются на объектах, которые фиксируются
     * на других объектах, просто не создавайте никаких петель. Чтобы остановить фиксацию камеры к чему-либо,
     * установите ObjId в 0, и она снова станет независимой.
     *
     * @param int $cameraID Идентификатор камеры, которую нужно зафиксировать, должен быть равен 1
     * @param int $objID Идентификатор объекта для его фиксации.
     * @return void
     */
    function FixCameraToObject($cameraID, $objID)
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает. Вы можете использовать ShareText или
     * ShareImage, чтобы дать пользователю возможность поделиться своей информацией.
     *
     * @return void
     */
    function FacebookPostOnMyWall($szLink, $szPicture, $szName, $szCaption, $szDescription)
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return void
     */
    function FacebookPostOnFriendsWall($szID, $szLink, $szPicture, $szName, $szCaption, $szDescription)
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return string
     */
    function FacebookGetUserName()
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return string
     */
    function FacebookGetUserID()
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return int
     */
    function FacebookGetFriendsState()
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return string
     */
    function FacebookGetFriendsName($iIndex)
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return string
     */
    function FacebookGetFriendsID($iIndex)
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return int
     */
    function FacebookGetFriendsCount()
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return void
     */
    function FacebookLogout()
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return void
     */
    function FacebookLogin()
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return void
     */
    function FacebookGetFriends()
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return void
     */
    function FacebookInviteFriend($szID, $szMessage)
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return string
     */
    function FacebookGetAccessToken()
    {
    }

    /**
     * Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return void
     */
    function FacebookDownloadFriendsPhoto($iIndex)
    {
    }

    /**
     * Facebook Facebook Facebook SDK Активирует отслеживание в SDK Facebook, это полезно, если вы используете рекламу
     * Facebook, так как это будет связывать установки с рекламой, ранее увиденной и нажатой на Facebook. Обратите
     * внимание, что в iOS эта функция требует IDFA (рекламный идентификатор), и вы должны объявить об этом, если
     * отправляете приложение в Apple. Apple спросит, используете ли вы IDFA и для чего вы его используете. Для
     * отслеживания установки с помощью рекламы Facebook вы ДОЛЖНЫ поставить галочки "Приписать установку этого
     * приложения ранее показанной рекламе" и "Приписать действие, предпринятое в этом приложении, ранее показанной
     * рекламе". Если вы также используете AdMob, Amazon Ads или Chartboost в своем приложении, вы также должны
     * поставить галочку "Показывать рекламу в приложении". Эта команда не требует, чтобы пользователь входил в
     * систему.
     *
     * @return void
     */
    function FacebookActivateAppTracking()
    {
    }

    /**
     * Эта команда в настоящее время не поддерживается
     *
     * @return void
     */
    function FacebookDestroyLikeButton()
    {
    }

    /**
     * Возвращает остаток от деления с плавающей запятой a/b.
     *
     * @param float $a Числитель.
     * @param float $b Знаменатель.
     * @return float
     */
    function FMod($a, $b)
    {
    }

    /**
     * Эта команда делает то же самое, что и ExtractZip, за исключением того, что она возвращается немедленно, а
     * извлечение zip выполняется в потоке в фоновом режиме. Вы можете использовать GetZipExtractProgress и
     * GetZipExtractComplete, чтобы проверить его прогресс. Если вы вызовете эту команду во время извлечения zip-файла,
     * то ничего не произойдет. Если указанный почтовый индекс не имеет пароля, то используйте пустую строку.
     *
     * @param string $zipfilename Путь к zip-файлу для извлечения.
     * @param string $path Путь для размещения вновь извлеченных zip-файлов.
     * @param string $password Пароль, который был использован для создания zip-файла.
     * @return void
     */
    function ExtractZipASync($zipfilename, $path, $password)
    {
    }

    /**
     * Извлекает zip-файл в указанный каталог. Все папки, созданные внутри zip-файла, будут созданы в процессе
     * извлечения. Если zip - файл защищен паролем, укажите пароль для его извлечения. Если вы укажете неправильный
     * пароль, извлеченные файлы из zip-архива будут пусты. Локальный путь к файлу находится относительно текущего
     * каталога, установленного с помощью SetFolder, если только вы не начинаете путь с прямой косой черты, и в этом
     * случае путь будет относительно корня каталога записи на текущей платформе.
     *
     * @param string $zipfilename Путь к zip-файлу для извлечения.
     * @param string $path Путь для размещения вновь извлеченных zip-файлов.
     * @param string|null $password Пароль, который был использован для создания zip-файла.
     * @return void
     */
    function ExtractZip(string $zipfilename, string $path, string $password = null)
    {
    }

    /**
     * Задает, следует ли очищать буфер глубины при вызове Sync или Swap. По умолчанию это значение равно true.
     * Отключать это не рекомендуется, так как все, что использует буфер глубины, будет появляться только в течение
     * одного кадра, а затем, похоже, исчезнет. Эта функция может не иметь никакого влияния на мобильные устройства.
     *
     * @param int $clear Установите значение 1, чтобы очистить буфер глубины, и 0, чтобы не очистить его.
     * @return void
     */
    function EnableClearDepth($clear)
    {
    }

    /**
     * Кодирует данный текст в QR - код и возвращает новый идентификатор изображения, содержащий этот код. Вы можете
     * выбрать количество исправлений ошибок, включенных в код, чтобы часть QR-кода была повреждена, но все еще была
     * читабельной. Чем выше режим коррекции ошибок, тем больше вероятность того, что поврежденный или скрытый QR-код
     * будет считан правильно, но более высокие режимы коррекции ошибок могут привести к увеличению QR-кода. Уровень 0
     * по-прежнему обеспечивает минимальный уровень исправления ошибок, а не никакой.
     *
     * @param string $text Текст для кодирования.
     * @param int $errormode Уровень исправления ошибок для включения в код от 0 (самый низкий) до 3 (самый высокий)
     * @return int
     */
    function EncodeQRCode($text, $errormode)
    {
    }

    /**
     * Задает, следует ли очищать буфер кадров при вызове Sync или Swap. По умолчанию это значение равно true.
     * Единственная причина вызвать эту команду-это если у вас есть фоновый спрайт или набор спрайтов, которые
     * полностью закрывают экран, так что цвет фона никогда не будет виден. В этих случаях некоторые графические
     * процессоры могут извлечь выгоду из отключения четкого цвета. Обратите внимание, что во многих случаях последний
     * нарисованный кадр останется на экране, однако это не гарантировано, и вы не должны создавать эффекты, которые
     * полагаются на него, так как они могут не работать в будущем и не будут работать на мобильных устройствах. Для
     * создания эффектов, сохраняющих содержимое предыдущего кадра, рекомендуется использовать SetRenderToImage для
     * захвата выходных данных одного кадра, а затем нарисовать его в следующем кадре, то есть вы визуализируете все до
     * изображения 1, затем в следующем кадре вы вставляете изображение 1 в фон новой цели рендеринга, а затем рисуете
     * новый кадр. Например, нарисуйте все в кадре 1 к изображению 1, затем в кадре 2 вы нарисуете изображение 1 с
     * полноэкранным четырехугольным объектом к изображению 2, а затем нарисуете все в кадре 2 к изображению 2. Затем
     * вы можете поменять местами цели рендеринга так, чтобы в кадре 3 вы нарисовали изображение 2 с полноэкранным
     * квадратом обратно в изображение 1, затем нарисуйте объекты в кадре 3 на изображение 1. Продолжайте чередовать
     * изображение 1 и 2, чтобы в кадре 4 сначала было нарисовано изображение 1 с полноэкранным квадратом на
     * изображение 2, а затем нарисуйте все в кадре 4 на изображение 2. Важно не продолжать рисовать все на одном и том
     * же изображении, то есть рисовать кадр 1 на изображении 1, затем кадр 2 на изображении 1 и так далее, потому что
     * мобильные устройства используют внутренний отложенный рендеринг, который будет держать все увеличивающийся
     * список вещей, которые нужно нарисовать на изображении 1. Если изображение никогда не будет очищено, то
     * производительность снизится.
     *
     * @param int $clear Установите значение 1, чтобы очистить буфер кадров, и 0, чтобы не очищать его.
     * @return void
     */
    function EnableClearColor($clear)
    {
    }

    /**
     * Сразу же рисует текст в backbuffer в его текущем положении, размере и повороте. Это полезно, если вы хотите
     * настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего
     * собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться
     * дважды в окончательном рендеринге.
     *
     * @param int $iTextIndex Идентификатор текста для рисования.
     * @return void
     */
    function DrawText($iTextIndex)
    {
    }

    /**
     * Немедленно рисует спрайт в backbuffer в его текущем положении, размере и вращении. Это полезно, если вы хотите
     * настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего
     * собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться
     * дважды в окончательном рендеринге.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для рисования.
     * @return void
     */
    function DrawSprite($iSpriteIndex)
    {
    }

    /**
     * Немедленно рисует объект к текущей цели рендеринга в его текущем положении, размере и повороте. Это полезно,
     * если вы хотите нарисовать определенные объекты, такие как небесные ящики, перед любыми другими объектами. В этом
     * случае обязательно сделайте объект невидимым для вызовов Render() или Sync (), иначе объект может появиться
     * дважды.
     *
     * @param int $objID Идентификатор объекта для рисования.
     * @return void
     */
    function DrawObject($objID)
    {
    }

    /**
     * Немедленно притягивает излучатель частиц к обратному буферу в его текущем положении, размере и вращении. Это
     * полезно, если вы хотите настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки
     * любого вашего собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может
     * появиться дважды в окончательном рендеринге.
     *
     * @param int $ID Идентификатор излучателя для рисования.
     * @return void
     */
    function DrawParticles($ID)
    {
    }

    /**
     * Рисует 2D-прямоугольник из одной точки экрана в другую с выбранным цветом с помощью линий. Линии появляются над
     * всеми другими чертежами, кроме команды Print, и могут использоваться с функцией getImage или SetRenderToImage
     * для создания новых изображений. Координаты XY находятся в экранных координатах, поэтому команда SetViewOffset на
     * них не влияет. Цвета могут быть созданы с помощью команды MakeColor или с помощью побитовых операторов типа so,
     * mycolor = (blue
     *
     * @param float $x Компонент X в верхнем левом углу коробки.
     * @param float $y Компонент Y в верхнем левом углу коробки.
     * @param float $x2 Компонент X в правом нижнем углу коробки.
     * @param float $y2 Компонент Y в правом нижнем углу коробки.
     * @param int $color1 Цвет для использования в верхнем левом углу.
     * @param int $color2 Цвет для использования в правом верхнем углу.
     * @param int $color3 Цвет для использования в левом нижнем углу.
     * @param int $color4 Цвет для использования в правом нижнем углу.
     * @param int $filled 1, чтобы нарисовать заполненную коробку, 0, чтобы нарисовать пустую коробку.
     * @return void
     */
    function DrawBox($x, $y, $x2, $y2, $color1, $color2, $color3, $color4, $filled)
    {
    }
    

    /**
     * Рисует 2D-линию из одной точки экрана в другую с выбранным цветом. Линии появляются над всеми другими чертежами,
     * кроме команды Print, и могут использоваться с функцией getImage для создания новых изображений. Координаты XY
     * находятся в экранных координатах, поэтому команда SetViewOffset на них не влияет.
     *
     *
     * Пример вызова:
     *
     * void DrawLine($x, $y, $x2, $y2, $red, $green, $blue);
     *
     * DrawLine($x, $y, $x2, $y2, $color1, $color2);
     * @param float $x X-компонент начальной позиции линии.
     * @param float $y Компонент Y начального положения линии.
     * @param float $x2 X-составляющая конечного положения линии.
     * @param float $y2 Компонент Y конечного положения линии.
     * @param int $color1 Цвет, который будет использоваться в начале строки.
     * @param int $color2 Цвет, который нужно использовать в конце строки.
     * @param int $red Красная составляющая цвета линии.
     * @param int $green Зеленая составляющая цвета линии.
     * @param int $blue Синяя составляющая цвета линии.
     * @return void
     */
    function DrawLine(mixed...$args): void
    {
    }

    /**
     * Рисует 2D-эллипс с центром в координатах, заданных выбранным цветом или градиентом. 2D-фигуры появляются над
     * всеми другими чертежами, кроме команды Print, и могут использоваться с функцией getImage для создания новых
     * изображений. Координаты XY находятся в экранных координатах, поэтому команда SetViewOffset на них не влияет.
     *
     * @param float $x X-составляющая центра эллипса.
     * @param float $y Y-составляющая центра эллипса.
     * @param float $radiusx Радиус эллипса в направлении X.
     * @param float $radiusy Радиус эллипса в направлении Y.
     * @param int $color1 Цвет в верхней части эллипса.
     * @param int $color2 Цвет в нижней части эллипса.
     * @param int $filled 1=заполнено, 0=пусто.
     * @return void
     */
    function DrawEllipse($x, $y, $radiusx, $radiusy, $color1, $color2, $filled)
    {
    }

    /**
     * Запускает загрузку любого файла расширения, необходимого этой платформе и приложению, в настоящее время
     * применимого только к Android. Если загрузка уже началась, это не имеет никакого эффекта. Вы можете использовать
     * GetExpansionFileProgress для проверки хода загрузки и GetExpanionFileState для проверки ее завершения. После
     * вызова этой команды вы должны дождаться, пока GetExpanionFileState вернет -1 (ошибка) или 3 (завершение) при
     * отображении индикатора выполнения.
     *
     * @return void
     */
    function DownloadExpansionFile()
    {
    }

    /**
     * Немедленно притягивает частицы к backbuffer в его текущем положении, размере и вращении. Это полезно, если вы
     * хотите настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего
     * собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться
     * дважды в окончательном рендеринге.
     *
     * @param int $ID Идентификатор излучателя для рисования.
     * @return void
     */
    function Draw3DParticles($ID)
    {
    }

    /**
     * Останавливает любое воспроизводимое видео и удаляет любое загруженное видео из памяти.
     *
     * @return void
     */
    function DeleteVideo()
    {
    }

    /**
     * Удаляет виртуальную кнопку по заданному индексу. Никакие другие команды виртуальных кнопок не могут быть вызваны
     * для этого индекса, если он не будет воссоздан с помощью AddVirtualButton.
     *
     * @param int $index Идентификатор виртуальной кнопки для удаления.
     * @return void
     */
    function DeleteVirtualButton($index)
    {
    }

    /**
     * Удаляет виртуальный джойстик и удаляет его с экрана. Никакие другие команды виртуального джойстика не могут быть
     * вызваны на этом индексе, если он не воссоздан с помощью AddVirtualJoystick.
     *
     * @param int $index Идентификатор виртуального джойстика для удаления.
     * @return void
     */
    function DeleteVirtualJoystick($index)
    {
    }

    /**
     * Удаляет вектор
     *
     * @param int $vectorID Идентификатор вектора
     * @return void
     */
    function DeleteVector3($vectorID)
    {
    }

    /**
     * Удаляет цепочку и останавливает всех подростков, которые были связаны с ней. Любые подростки, которые были
     * добавлены к нему, не затрагиваются и могут быть использованы в будущих цепочках.
     *
     * @param int $chainID Идентификатор удаляемой цепочки
     * @return void
     */
    function DeleteTweenChain($chainID)
    {
    }

    /**
     * Удалите заданный идентификатор анимации. Это может быть использовано для всех типов твинов, спрайтов, текста,
     * объектов и т. Д.
     *
     * @param int $tweenID Идентификатор твина для удаления
     * @return void
     */
    function DeleteTween($tweenID)
    {
    }

    /**
     * Удаляет спрайт с заданным идентификатором.
     *
     * @param int $iSpriteIndex Идентификатор удаляемого спрайта
     * @return void
     */
    function DeleteSprite($iSpriteIndex)
    {
    }

    /**
     * Удалите звук по указанному номеру звука. Это также приведет к удалению всех экземпляров звука.
     *
     * @param int $iID Звуковой номер для удаления.
     * @return void
     */
    function DeleteSound($iID)
    {
    }

    /**
     * Останавливает прослушиватель сокета от получения соединений и освобождает идентификатор для повторного
     * использования. Если какие-либо соединения все еще находятся в очереди и еще не собраны с помощью
     * GetSocketListenerConnection, то они будут закрыты и удалены.
     *
     * @param int $listenerID Идентификатор прослушивателя для проверки
     * @return void
     */
    function DeleteSocketListener($listenerID)
    {
    }

    /**
     * Удаляет скелет с указанным идентификатором. Если в этом идентификаторе нет скелета, то ничего не происходит.
     *
     * @param int $iSkeleton Идентификатор скелета для удаления
     * @return void
     */
    function DeleteSkeleton2D($iSkeleton)
    {
    }

    /**
     * Удаляет идентификатор сокета, чтобы его можно было использовать снова. Если розетка в данный момент подключена,
     * то сначала соединение закрывается.
     *
     * @param int $socketID Идентификатор сокета для удаления
     * @return void
     */
    function DeleteSocket($socketID)
    {
    }

    /**
     * Удаляет общую переменную по имени. Если переменная не существует, то это ничего не даст. Как только переменная
     * будет удалена, LoadSharedVariable вернет значение по умолчанию для любых запросов на ее загрузку.
     *
     * @param string $varName Имя переменной для удаления
     * @return void
     */
    function DeleteSharedVariable($varName)
    {
    }

    /**
     * Удаляет указанный UDP-listenere и освобождает порт, который он использовал.
     *
     * @param int $listenerID Идентификатор прослушивателя для удаления
     * @return void
     */
    function DeleteUDPListener($listenerID)
    {
    }

    /**
     * Удаляет указанный точечный свет. Если точечный свет не существует, эта команда ничего не делает.
     *
     * @param int $lightID Идентификатор света, который нужно удалить.
     * @return void
     */
    function DeletePointLight($lightID)
    {
    }

    /**
     * Удаляет указанную глобальную силу.
     *
     * @param int $iForceIndex Идентификатор силы для удаления.
     * @return void
     */
    function DeletePhysicsForce($iForceIndex)
    {
    }

    /**
     * Удаляет текстовый объект.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для удаления.
     * @return void
     */
    function DeleteText($iTextIndex)
    {
    }

    /**
     * Удаляет излучатель частиц и все его частицы. Если какие-либо частицы были в данный момент видны, они мгновенно
     * исчезнут.
     *
     * @param int $ID Идентификатор излучателя для удаления.
     * @return void
     */
    function DeleteParticles($ID)
    {
    }

    /**
     * Удаляет объект с заданным идентификатором, если объект не существует, то эта команда ничего не делает. Эта
     * команда также удаляет все дочерние объекты, которые были созданы при загрузке этого объекта, если вы не хотите
     * их удалять, то вместо этого используйте DeleteObject. Если вы используете эту команду для объекта, который был
     * загружен с помощью LoadObject, то он удаляет его как обычно.
     *
     * @param int $objID Идентификатор объекта для удаления.
     * @return void
     */
    function DeleteObjectWithChildren($objID)
    {
    }

    /**
     * Удаляет объект с заданным идентификатором, если объект не существует, то эта команда ничего не делает. Эта
     * команда также удаляет все дочерние объекты, созданные при загрузке этого объекта, и все объекты, которые в
     * данный момент прикреплены к этому объекту, из использования FixObjectToObject или FixObjectToBone.
     *
     * @param int $objID Идентификатор объекта для удаления.
     * @return void
     */
    function DeleteObjectTree($objID)
    {
    }

    /**
     * Удаляет объект с заданным идентификатором, если объект не существует, то эта команда ничего не делает. Обратите
     * внимание, что если объект был загружен с помощью LoadObjectWithChildren, то все дочерние объекты, созданные в
     * ходе этого процесса загрузки, не будут удалены этой командой. Вы можете использовать GetObjectChildID для
     * получения и удаления этих объектов вручную или использовать DeleteObjectWithChildren для удаления всего, что
     * было создано при загрузке этого объекта.
     *
     * @param int $objID Идентификатор удаляемого объекта.
     * @return void
     */
    function DeleteObject($objID)
    {
    }

    /**
     * Удаляет сетевое сообщение, это должно быть вызвано для сообщений, полученных от сетевых устройств, и сообщений,
     * которые не были отправлены на сетевое устройство (если код решает отказаться от отправки сообщения). Сообщения,
     * которые были созданы и отправлены, будут обработаны и удалены сетевым кодом и не должны быть удалены с помощью
     * этой команды.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return void
     */
    function DeleteNetworkMessage($iMsgID)
    {
    }

    /**
     * Удаляет отключенный клиент из списка клиентов. Если эта функция вызывается на клиенте, который не отключен, она
     * вызовет ошибку и не повлияет на клиента. Не удаляет клиент сразу, фоновый код может занять несколько кадров,
     * чтобы обойти его удаление. Вызов этой команды несколько раз на отключенном клиенте не должен вызывать проблем.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client идентификатор клиента для удаления.
     * @return void
     */
    function DeleteNetworkClient($iNetID, $client)
    {
    }

    /**
     * Удаляет музыкальный файл и освобождает идентификатор для повторного использования.
     *
     * @param int $musicID Идентификатор музыкального файла для удаления
     * @return void
     */
    function DeleteMusicOGG($musicID)
    {
    }

    /**
     * Удаляет музыкальный файл из списка воспроизведения.
     *
     * @param int $iID Идентификатор музыки, которую нужно удалить.
     * @return void
     */
    function DeleteMusic($iID)
    {
    }

    /**
     * Удаляет memblock с заданным идентификатором. Если memblock не существует или уже был удален, то эта команда
     * ничего не делает.
     *
     * @param int $memID Идентификатор удаляемого мемблока.
     * @return void
     */
    function DeleteMemblock($memID)
    {
    }

    /**
     * Удаляет шейдер и освобождает идентификатор. Шейдер в данный момент не должен быть назначен ни одному объекту,
     * сетке, квадрату или спрайту, иначе он может вызвать сбой при попытке рисования.
     *
     * @param int $shaderID Идентификатор шейдера для удаления
     * @return void
     */
    function DeleteShader($shaderID)
    {
    }

    /**
     * Удалите изображение из глобального хранилища, используя его идентификатор.
     *
     * @param int $iImageIndex Идентификатор удаляемого изображения
     * @return void
     */
    function DeleteImage($iImageIndex)
    {
    }

    /**
     * Удаляет соединение и позволяет соединенным спрайтам снова свободно перемещаться. Стыки следует удалять перед
     * спрайтами. Зубчатые соединения должны быть удалены до тех соединений, от которых они зависят. Удаление
     * несуществующего соединения не приведет к ошибке.
     *
     * @param int $iJointIndex Идентификатор соединения для удаления.
     * @return void
     */
    function DeleteJoint($iJointIndex)
    {
    }

    /**
     * Удаляет шрифт с заданным идентификатором. Шрифт в настоящее время не должен использоваться никакими текстовыми
     * объектами.
     *
     * @param int $iFontID Идентификатор шрифта для удаления.
     * @return void
     */
    function DeleteFont($iFontID)
    {
    }

    /**
     * Удаляет ранее созданное HTTP-соединение.
     *
     * @param int $iHTTP Идентификатор соединения для удаления.
     * @return void
     */
    function DeleteHTTPConnection($iHTTP)
    {
    }

    /**
     * Удаляет папку по текущему пути. По умолчанию это определяется командой SetFolder. Вы также можете использовать
     * имя файла, начинающееся с "raw:", чтобы удалить папку в любом месте файловой системы, например
     * DeleteFolder("raw:C:\Temp\MyFolder"). Для успешного выполнения этой команды папка должна быть пустой.
     *
     * @param string $szName Имя папки create.
     * @return void
     */
    function DeleteFolder($szName)
    {
    }

    /**
     * Удаляет широковещательный прослушиватель и освобождает порт для прослушивания на нем чего-то другого.
     *
     * @param int $iID Идентификатор прослушивателя широковещательной передачи для удаления.
     * @return void
     */
    function DeleteBroadcastListener(int $iID)
    {
    }

    /**
     * Удаляет любое поле редактирования с заданным идентификатором.
     *
     * @param int $index Идентификатор поля редактирования для удаления.
     * @return void
     */
    function DeleteEditBox(int $index)
    {
    }

    /**
     * Удаляет переменную с указанным именем и удаляет все данные, хранящиеся в облаке для этой переменной. Если
     * переменная не существует, то это ничего не делает.
     *
     * @param string $varName Имя переменной, которую нужно удалить, должно быть меньше 64 байт
     * @return void
     */
    function DeleteCloudDataVariable(string $varName)
    {
    }

    /**
     * Удаляет все текстовые объекты, созданные с помощью CreateText. Это также сбрасывает идентификатор автотекста до
     * 10000.
     *
     * @return void
     */
    function DeleteAllText()
    {
    }

    /**
     * Удаляет все спрайты, созданные с помощью CreateSprite, CreateDummySprite или LoadSprite. Это также сбрасывает
     * идентификатор автоматического спрайта до 10000.
     *
     * @return void
     */
    function DeleteAllSprites()
    {
    }

    /**
     * Удаляет все объекты, созданные с идентификатором. Это также сбрасывает идентификатор автоматического объекта до
     * 10000.
     *
     * @return void
     */
    function DeleteAllObjects()
    {
    }

    /**
     * Удаляет все изображения, загруженные LoadImage или LoadSubImage. Это также сбрасывает автоматический
     * идентификатор изображения до 10000.
     *
     * @return void
     */
    function DeleteAllImages()
    {
    }

    /**
     * Удаляет весь мир 3D - физики.
     *
     * @return void
     */
    function Delete3DPhysicsWorld()
    {
    }

    /**
     * Удаляет статическую плоскость.
     *
     * @param int $planeID статический идентификатор плоскости
     * @return void
     */
    function Delete3DPhysicsStaticPlane(int $planeID)
    {
    }

    /**
     * Очищает ранее показанное объявление.
     *
     * @return void
     */
    function DeleteAdvert()
    {
    }

    /**
     * Удаляет физический луч и все связанные с ним данные.
     *
     * @param int $rayID Идентификатор луча для удаления.
     * @return void
     */
    function Delete3DPhysicsRay(int $rayID)
    {
    }

    /**
     * Удаляет тряпичную куклу для объекта.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Delete3DPhysicsRagdoll(int $objID)
    {
    }

    /**
     * Удаляет данный файл из папки записи. Пути к файлам должны быть относительными, а не абсолютными, вы не можете
     * удалять файлы из папки приложения или из другого места на диске.
     *
     * @param string $szFile Имя файла для удаления.
     * @return void
     */
    function DeleteFile(string $szFile)
    {
    }

    /**
     * Удаляет физический стык
     *
     * @param int $jointID Id соединения
     * @return void
     */
    function Delete3DPhysicsJoint($jointID)
    {
    }

    /**
     * Удаляет контроллер для объекта.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Delete3DPhysicsCharacterController(int $objID)
    {
    }

    /**
     * Удаляет соединение кирки.
     *
     * @param int $jointID Id соединения
     * @return void
     */
    function Delete3DPhysicsPickJoint(int $jointID)
    {
    }

    /**
     * Удаляет 3D-излучатель частиц и все его частицы. Если какие-либо частицы были в данный момент видны, они
     * мгновенно исчезнут.
     *
     * @param int $ID Идентификатор излучателя для удаления.
     * @return void
     */
    function Delete3DParticles(int $ID)
    {
    }

    /**
     * Попытка декодировать QR - код и вернуть строку, закодированную в нем. Возвращает пустую строку, если он не смог
     * найти QR-код на изображении или не смог его декодировать. Несколько QR-кодов на изображении, скорее всего,
     * приведут к сбою декодирования.
     *
     * @param int $image Идентификатором изображения, подлежащего декодированию, может быть изображение, снятое с
     *     камеры
     * @return string
     */
    function DecodeQRCode(int $image): string
    {
    }

    /**
     * Показывает объекты капсулы, представляющие контроллер.
     *
     * @param int $objID идентификатор объекта
     * @param int $isDebug 1 = истина, 0 = ложь
     * @return void
     */
    function Debug3DPhysicsCharacterController($objID, $isDebug)
    {
    }

    /**
     * Вызовите цикл перед физикой шага. Рисует отладочное наложение 3D-физического мира. Примечание: Эта команда в
     * настоящее время не работает, требуется возможность рисовать каркас в AGK.
     *
     * @return void
     */
    function Debug3DPhysicsWorld()
    {
    }

    /**
     * Создает zip-файл в указанном месте и открывает его готовым для добавления файлов. Файлы не могут быть прочитаны
     * или извлечены из zip-файла с помощью этой команды. Используйте ExtractZip для извлечения файлов из него. Путь к
     * файлу относится к текущему каталогу, установленному с помощью SetFolder, если только вы не начинаете путь с
     * прямой косой черты, и в этом случае путь будет относительно корня каталога записи на текущей платформе.
     * Пример вызова:
     *
     * int CreateZip($filename);
     *
     * void CreateZip($zipID, $filename)
     * @param int $zipID Идентификатор, используемый для ссылки на этот zip-файл.
     * @param string $filename Имя файла и путь к этому новому zip-файлу.
     * @return int|void
     */
    function CreateZip(mixed...$args): int
    {
    }

    /**
     * Создает сварное соединение между двумя спрайтами. Сварное соединение пытается ограничить все относительные
     * перемещения и вращения между двумя спрайтами. Укажите единственную опорную точку в мировых координатах со
     * спрайтами, уже находящимися в нужных позициях. Соединение не является идеальным креплением, и при достаточно
     * большом усилии спрайты могут сдвинуться с места. Точка привязки может быть смещена от центральных положений
     * спрайта. Соединение может быть удалено системой, если какой-либо из спрайтов, которые он соединяет, будет
     * удален.
     *
     * Пример вызова:
     *
     * int CreateWeldJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $colConnected);
     *
     * void CreateWeldJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $colConnected);
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом,
     *     0=нет, 1=да.
     * @return int|void
     */
    function CreateWeldJoint(mixed...$args): int
    {
    }

    /**
     * Создает вектор и заполняет его переданными значениями. Возвращает идентификатор вектора
     * Пример вызова:
     *
     * int CreateVector3();
     *
     * int CreateVector3($x, $y, $z);
     *
     * @param float|null $x x компонент вектора
     * @param float|null $y Компонент y вектора
     * @param float|null $z z компонент вектора
     * @return int
     */
    function CreateVector3(float $x = null, float $y = null, float $z = null): int
    {
    }

    /**
     * Создает текстовую анимацию с заданной длительностью и возвращает для нее идентификатор. Эта анимация-всего лишь
     * шаблон, который может быть применен к нескольким текстовым объектам или цепочкам одновременно. Все типы твинов
     * разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может
     * существовать одновременно с текстовым твином с идентификатором 1. Вы можете установить несколько параметров для
     * этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным
     * значениям в течение заданной продолжительности.
     *
     * Пример вызова:
     *
     * int CreateTweenText($duration);
     *
     * void CreateTweenText($tweenID, $duration)
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return int|void
     */
    function CreateTweenText(mixed...$args): int
    {
    }

    /**
     * Создает прослушиватель UDP, который будет получать UDP-пакеты по указанному IP-адресу и порту. Значение порта
     * должно находиться в диапазоне от 1 до 65535, хотя значения ниже 1024, скорее всего, будут защищены операционной
     * системой. Если порт уже занят, то эта команда завершится ошибкой и вернет 0. IP-адрес может быть адресом IPv4
     * или IPv6 и может использоваться для привязки к одному входящему сетевому соединению, когда устройство имеет
     * более одного IP-адреса. Для привязки к любому IP-адресу используйте IP-адрес "anyip4" или "anyip6". Один
     * прослушиватель UDP может прослушивать либо IPv4, либо IPv6-адрес, но не оба одновременно. Для прослушивания
     * обоих вы должны создать два прослушивателя, один для IPv4 и один для IPv6, в этом случае они оба могут
     * использовать один и тот же порт. Эта команда вернет идентификатор прослушивателя, который вы можете использовать
     * для ссылки на него в будущих командах.
     *
     *
     * Пример вызова:
     *
     * int CreateUDPListener($ip, $port);
     *
     * int CreateUDPListener($listenerID, $ip, $port);
     * @param int $listenerID Идентификатор, который будет использоваться для ссылки на этот прослушиватель в будущем.
     * @param string $ip Локальный IP-адрес для привязки.
     * @param int $port Локальный порт для привязки.
     * @return int
     */
    function CreateUDPListener(mixed...$args): int
    {
    }

    /**
     * Создает анимацию спрайта с заданной длительностью и возвращает для нее идентификатор. Эта анимация-просто
     * шаблон, который может быть применен к нескольким спрайтам или цепочкам одновременно. Все типы твинов разделяют
     * одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать
     * одновременно с текстовым твином с идентификатором 1. Вы можете установить несколько параметров для этой
     * анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям
     * в течение заданной продолжительности.
     *
     *
     * Пример вызова:
     *
     * int CreateTweenSprite($duration);
     *
     * void CreateTweenSprite($tweenID, $duration);
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return int|void
     */
    function CreateTweenSprite(mixed...$args): int
    {
    }


    /**
     * Создает пользовательскую анимацию с заданной длительностью и возвращает для нее идентификатор. Эта анимация не
     * связана ни с каким элементом, и ее значения можно считывать во время работы. Это делает его полезным для
     * управления значениями, которые не покрываются ни одним из других шаблонов анимации. Все типы твинов используют
     * одно и то же пространство идентификаторов, поэтому пользовательский твин с идентификатором 1 не может
     * существовать одновременно со спрайтовым твином с идентификатором 1. Вы можете установить несколько параметров
     * для этой анимации, до 4 значений с плавающей точкой и 4 целочисленных значений, которые будут перемещаться от их
     * начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * Пример вызова:
     *
     * int CreateTweenCustom($duration);
     *
     * void CreateTweenCustom($tweenID, $duration);
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return int|void
     */
    function CreateTweenCustom(mixed...$args): int
    {
    }

    /**
     * Создает объект tween с заданной длительностью и возвращает для него ИДЕНТИФИКАТОР. Эта анимация-просто шаблон,
     * который может быть применен к нескольким объектам или цепочкам одновременно. Все типы твинов разделяют одно и то
     * же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с
     * объектным твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как
     * положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной
     * продолжительности.
     *
     *
     * Пример вызова:
     *
     * int CreateTweenObject($duration);
     *
     * void CreateTweenObject($tweenID, $duration);
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return int|void
     */
    function CreateTweenObject(mixed...$args): int
    {
    }

    /**
     * Удаляет физическое тело из мира и удаляет его.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Delete3DPhysicsBody($objID)
    {
    }


    /**
     * Создает символ tween с заданной длительностью и возвращает для него ИДЕНТИФИКАТОР. Это может быть применено к
     * отдельным символам текстового объекта. Эта анимация-всего лишь шаблон, который может быть применен к нескольким
     * текстовым символам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство
     * идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с char-твином с
     * идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол,
     * которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * Пример вызова:
     *
     * int CreateTweenChar($duration);
     *
     * void CreateTweenChar($tweenID, $duration);
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return int|void
     */
    function CreateTweenChar(mixed...$args): int
    {
    }

    /**
     * Создает анимацию камеры с заданной длительностью и возвращает для нее идентификатор. Эта анимация-всего лишь
     * шаблон, который может быть применен к нескольким камерам или цепочкам одновременно. Все типы твинов используют
     * одно и то же пространство идентификаторов, поэтому твин камеры с идентификатором 1 не может существовать
     * одновременно с твином объекта с идентификатором 1. Вы можете установить несколько параметров для этой анимации,
     * таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение
     * заданной продолжительности.
     *
     * Пример вызова:
     *
     * int CreateTweenCamera($duration);
     * void CreateTweenCamera($tweenID, $duration);
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return int|void
     */
    function CreateTweenCamera(mixed...$args): int
    {
    }


    /**
     * Создает цепочку твинов, которую можно использовать для заказа Tween, чтобы они играли один за другим.
     * Цепочка анимаций может содержать несколько спрайтов, символов, объектов и т. Д., Так что анимация камеры может
     * быть запущена после завершения анимации спрайтов или наоборот. Несколько цепочек могут быть применены к одним и
     * тем же спрайтам, объектам или другим объектам до тех пор, пока цепочки не изменяют один и тот же параметр
     * одновременно. Например, если цепочка 1 начинается с изменения значения X спрайта и воспроизводится одновременно
     * с цепочкой 2, которая также начинает изменять значение X того же спрайта, то одна цепочка перезапишет изменения
     * другой. В противном случае несколько цепочек на одном и том же спрайте будут работать правильно.
     *
     * Пример вызова:
     *
     * int CreateTweenChain();
     *
     * void CreateTweenChain($chainID);
     *
     * @param int $chainID Идентификатор цепочки
     * @return int|void
     */
    function CreateTweenChain(int $chainID): int
    {
    }

    /**
     * CreateText
     *
     * Создает текстовый объект для отображения текста на экране с помощью пустого идентификатора, возвращает
     * используемый идентификатор. По умолчанию текст рисуется на глубине 9 выше глубины спрайтов по умолчанию (10).
     * Любые спрайты, установленные на глубину 8 или меньше, будут отображаться над текстом. Вы можете переопределить
     * это с помощью SetTextDepth, чтобы установить свой собственный порядок розыгрыша.
     *
     * @param string|int $string_or_iTextIndex Начальная строка (может быть пустой строкой) или текстовый идентификатор,
     * который будет использоваться для ссылки на этот текст позже
     * (отдельно от идентификаторов изображений и спрайтов, поэтому может быть как спрайт 1, так и текст 1)
     * @param string $string Начальная строка, используемая в этом текстовом объекте, может быть пустой строкой.
     * @return void|int
     */
    function CreateText($string_or_iTextIndex, $string = null): int
    {
    }

    /**
     * Приседает контроллер
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Crouch3DPhysicsCharacterController(int $objID)
    {
    }


    /**
     * Создает спрайт в пустом идентификаторе спрайта с изображением, используемым при рендеринге, и возвращает
     * используемый идентификатор спрайта. По умолчанию спрайты создаются с глубиной 10, имеют размер, используя данное
     * изображение в качестве направляющей, и позиционируются на 0,0, используя их верхний левый угол. Вы можете
     * использовать идентификатор изображения 0 для создания пустого спрайта, нарисованного только цветом. Если
     * назначенное изображение имеет альфа-пиксели, то спрайт создается с режимом прозрачности 1, в противном случае он
     * использует режим прозрачности 0 (непрозрачный)
     *
     * Пример вызова:
     *
     * int CreateSprite($iImageIndex);
     *
     * void CreateSprite($iSpriteIndex, $iImageIndex);
     * @param int $iSpriteIndex Идентификатор спрайта, который будет использоваться для ссылки на этот спрайт позже
     * (отдельно от идентификаторов изображений, поэтому может быть как спрайт 1, так и изображение 1)
     * @param int $iImageIndex Идентификатор изображения, которое будет использоваться при рисовании этого спрайта
     * @return int|void
     */
    function CreateSprite(int...$args): int
    {
    }

    /**
     * Создает звук из мемблока. Memblock должен существовать, это создает новый звук и возвращает идентификатор. Это
     * не повлияет ни на какие уже воспроизводимые звуковые экземпляры, только на будущие. Memblock должен содержать
     * допустимый OGG-файл, например загруженный CreateMemblockFromFile(memID, "sound.ogg")
     *
     * Пример вызова:
     *
     * int CreateSoundFromOGGMemblock($memID);
     *
     * void CreateSoundFromOGGMemblock($soundID, $memID);
     * @param int $soundID Идентификатор звука для создания или изменения.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return mixed
     */
    function CreateSoundFromOGGMemblock(int...$args): mixed
    {
    }

    /**
     * Создает прослушиватель сокетов, который прослушивает на указанном порту входящие соединения сокетов. Когда
     * соединение происходит, оно будет удерживаться в очереди до тех пор, пока вы не получите его с помощью
     * GetSocketListenerConnection. Если вы хотите отклонить соединение, вы должны получить его, а затем удалить.
     * Прослушиватель будет продолжать принимать соединения до тех пор, пока он не будет удален. Если ваше устройство
     * имеет несколько сетевых интерфейсов, то вы можете указать, какой из них будет прослушиваться с помощью параметра
     * IP-адрес. Для прослушивания всех интерфейсов используйте пустую строку в качестве IP-адреса. Если устройство
     * имеет оба адреса IPv4 и IPv6, то слушатель может слушать только один или другой, а не оба. Для прослушивания
     * соединений IPv4 и IPv6 необходимо создать два прослушивателя: один для соединений IPv4 и один для соединений
     * IPv6. Соединения из любого из них будут вести себя точно так же после того, как они будут подключены. Чтобы
     * создать прослушиватель IPv6, передайте IPv6 IP-адрес CreateSocketListener или "anyip6" для прослушивания любого
     * подходящего IPv6-адреса. Если вы передадите пустую строку или "anyip4" в качестве IP-адреса, то он будет
     * прослушивать IPv4-соединения. Вы можете иметь несколько активных слушателей одновременно, но все они должны
     * использовать разные порты или IP-адреса. При выборе номера порта следует избегать низких значений, так как они
     * часто будут использоваться другими приложениями и сервисами. Если что-то уже прослушивает порт, то ваша попытка
     * прослушать его потерпит неудачу. Возвращает 0, если он не смог начать прослушивание.
     *
     *
     * Пример вызова:
     *
     * int CreateSocketListener($szIP, $port);
     *
     * int CreateSocketListener($listenerID, $szIP, $port);
     * @param int $listenerID Идентификатор, который будет использоваться для ссылки на этот прослушиватель в будущем
     * @param string $szIP IP-адрес интерфейса для прослушивания может быть IPv4 или IPv6, или "anyip4", или "anyip6"
     * @param int $port TCP-порт для прослушивания находится в диапазоне от 1025 до 65535
     * @return int
     */
    function CreateSocketListener(mixed...$args): int
    {
    }


    /**
     * Создает звук из мемблока. Memblock должен существовать, это создает новый звук и возвращает идентификатор. Это
     * не повлияет ни на какие уже воспроизводимые звуковые экземпляры, только на будущие. Первые 2 байта memlbock
     * хранят количество каналов (1 или 2 поддерживаемых), следующие 2 байта хранят биты на выборку (8 или 16
     * поддерживаемых), следующие 4 байта хранят выборки в секунду, например 44100. Следующие 4 байта-это количество
     * кадров в звуковых данных, размер звуковых данных в байтах можно вычислить из этого с помощью формулы
     * numFrames*(BitsPerSample/8)*channels. В 2-канальном звуке кадр содержит 2 сэмпла, по одному для каждого канала.
     * В моно-звуке кадр содержит 1 образец. Остальная часть memblock-это необработанные звуковые данные, например, в
     * 8-битном стереозвуке с 3 кадрами необработанные данные будут выглядеть так. смещение байта 0 = Кадр 1, смещение
     * байта данных левого канала 1 = Кадр 1, смещение байта данных правого канала 2 = Кадр 2, смещение байта данных
     * левого канала 3 = Кадр 2, смещение байта данных правого канала 4 = Кадр 3, смещение байта данных левого канала 5
     * = Кадр 3, данные правого канала Возвращают идентификатор нового звука.
     *
     * Пример вызова:
     *
     * int CreateSoundFromMemblock($memID);
     *
     * void CreateSoundFromMemblock($soundID, $memID);
     * @param int $soundID Идентификатор звука для создания или изменения.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return void
     */
    function CreateSoundFromMemblock(int...$args): mixed
    {
    }

    /**
     * Создает 2D-скелет, который можно использовать для анимации спрайтов с помощью костей. В настоящее время эта
     * команда не очень полезна, так как существует не так много команд для настройки скелета. Вместо этого скелеты
     * должны быть загружены с помощью LoadSkeleton2DFromSpineFile
     *
     *
     * Пример вызова:
     *
     * int CreateSkeleton2D();
     *
     * void CreateSkeleton2D($iSkeleton);
     * @param int|null $iSkeleton Идентификатор, используемый для ссылки на этот скелет
     * @return mixed
     */
    function CreateSkeleton2D($iSkeleton = null): mixed
    {
    }

    /**
     * Создает соединение веревки между двумя спрайтами. Канатное соединение обеспечивает максимальное расстояние между
     * спрайтами без каких-либо других ограничений. Это не мешает им сближаться. Укажите две опорные точки в мировых
     * координатах с максимальной длиной, которую вы хотите разрешить, текущее положение спрайтов не влияет на
     * инициализацию соединения. Опорные точки могут быть смещены от позиций спрайтов. Соединение может быть удалено
     * системой, если какой-либо из спрайтов, которые он соединяет, будет удален.
     *
     *
     * Пример вызова:
     *
     * int CreateRopeJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $x2, $y2, $maxLength, $colConnected);
     *
     * void CreateRopeJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $x2, $y2, $maxLength, $colConnected);
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки спрайта 1.
     * @param float $y Координата y якорной точки спрайта 1.
     * @param float $x2 Координата x опорной точки спрайта 2.
     * @param float $y2 Координата y опорной точки спрайта 2.
     * @param float $maxLength Максимальная длина, допустимая между опорными точками спрайта.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом,
     *     0=нет, 1=да.
     * @return mixed
     */
    function CreateRopeJoint(mixed...$args): mixed
    {
    }

    /**
     * Создает революционное соединение между двумя спрайтами. Поворотное соединение позволяет спрайтам вращаться
     * только вокруг заданной точки. Укажите единственную опорную точку в мировых координатах, где спрайты уже
     * находятся в нужном относительном положении. Точка привязки может быть смещена от центральных положений спрайта.
     * Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено
     * системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение поддерживает
     * двигатели и ограничения.
     *
     * Пример вызова:
     *
     * int CreateRevoluteJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $colConnected);
     *
     * void CreateRevoluteJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $colConnected);
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом,
     *     0=нет, 1=да.
     * @return mixed
     */
    function CreateRevoluteJoint(mixed...$args): mixed
    {
    }

    /**
     * Создает соединение шкива между двумя спрайтами. Это первая половина двухкомандной установки. Из - за количества
     * требуемых параметров вы должны вызвать FinishPulleyJoint с остальными параметрами для создания соединения. Эта
     * команда ничего не возвращает, идентификатор соединения возвращается FinishPulleyJoint.
     *
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $ratio Соотношение между двумя сторонами шкива.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом,
     *     0=нет, 1=да.
     * @return void
     */
    function CreatePulleyJoint2($iSpriteIndex1, $iSpriteIndex2, $ratio, $colConnected)
    {
    }

    /**
     * Создает соединение шкива между двумя спрайтами. Опорные точки-это координаты мирового пространства, которые
     * прикрепляют соединение к спрайту, опорные точки не обязательно должны находиться в центре спрайта или где-то
     * рядом с ним, но эта точка станет новым центром вращения на то время, пока спрайт прикреплен к шкиву. Точки
     * заземления находятся там, где трос шкива прикрепится к воображаемым шкивам и останется неподвижным в течение
     * всего срока службы соединения, они не должны находиться в одном и том же месте. Значение коэффициента определяет
     * передаточное отношение между двумя сторонами шкива, например, значение 2 будет означать, что спрайт 1 движется с
     * удвоенной скоростью спрайта 2, но будет испытывать половину силы, приложенной к спрайту 2.
     *
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $gnd1x Координата x точки заземления для спрайта 1.
     * @param float $gnd1y Координата y точки заземления для спрайта 1.
     * @param float $gnd2x Координата x точки заземления для спрайта 2.
     * @param float $gnd2y Координата y точки заземления для спрайта 2.
     * @param float $a1x Координата x опорной точки для спрайта 1.
     * @param float $a1y Координата y опорной точки для спрайта 1.
     * @param float $a2x Координата x опорной точки для спрайта 2.
     * @param float $a2y Координата y опорной точки для спрайта 2.
     * @param float $ratio Соотношение между двумя сторонами шкива.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом,
     *     0=нет, 1=да.
     * @return void
     */
    function CreatePulleyJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $gnd1x, $gnd1y, $gnd2x, $gnd2y, $a1x, $a1y, $a2x, $a2y, $ratio, $colConnected)
    {
    }

    /**
     * Создает призматическое соединение между двумя спрайтами. Призматическое соединение позволяет спрайтам двигаться
     * только вдоль заданной оси относительно друг друга. Его можно представить как поршень, на каждом конце которого
     * спрайты не могут вращаться. Это похоже на линейное соединение, за исключением того, что предотвращается
     * относительное вращение. Укажите единственную опорную точку в мировых координатах, чтобы спрайты уже находились в
     * нужном относительном положении, на минимальном расстоянии поршня. С этого момента спрайтам будет позволено
     * разделяться вдоль заданной оси и вращаться как единое целое, но не вращаться относительно друг друга. Точка
     * привязки может быть смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для
     * ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно
     * соединяет, будет удален. Это соединение поддерживает двигатели и ограничения.
     *
     *
     * Пример вызова:
     *
     * int CreatePrismaticJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $vx, $vy, $colConnected);
     *
     * void CreatePrismaticJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $vx, $vy, $colConnected);
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param float $vx Компонент x оси.
     * @param float $vy Компонент y оси.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом,
     *     0=нет, 1=да.
     * @return mixed
     */
    function CreatePrismaticJoint(mixed...$args)
    {
    }

    /**
     * Создает точечный свет, который светит одинаково во всех направлениях. Это влияет на все объекты, использующие
     * внутренний шейдер по умолчанию с SetObjectLightMode равным 1. Если вы используете пользовательский шейдер, то
     * AGK добавит функции освещения в ваш шейдер во время загрузки, если вы ссылаетесь на них, см. Руководство по
     * шейдерам для получения дополнительной информации об этом. По умолчанию свет создается в режиме вершин, это
     * быстрее, чем в пиксельном режиме, но более низкого качества. Чтобы изменить это, используйте SetPointLightMode.
     * Значения цвета должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно
     * насыщать вещи, а значения меньше 0 будут отнимать свет.
     *
     * @param int $lightID Идентификатор источника света для ссылки на него в других командах.
     * @param float $x X-компонент положения света.
     * @param float $y Y-компонент положения света.
     * @param float $z Z-компонент положения света.
     * @param float $radius Диапазон, на который влияет свет.
     * @param int $red Красная составляющая светлого цвета.
     * @param int $green Зеленая составляющая светлого цвета.
     * @param int $blue Синяя составляющая светлого цвета.
     * @return void
     */
    function CreatePointLight($lightID, $x, $y, $z, $radius, $red, $green, $blue)
    {
    }

    /**
     * Создает глобальную силу, которая влияет на все физические спрайты. Можно настроить либо на привлечение, либо на
     * отталкивание спрайтов из определенного места. Он возвращает идентификатор силы, который можно использовать для
     * последующего изменения или удаления силы. Силы продолжают действовать до тех пор, пока они не будут удалены.
     *
     * @param float $x Положение x расположения силы в мировых координатах.
     * @param float $y Положение y расположения силы в мировых координатах.
     * @param float $power Сила силы в 1 единице от точки силы для затухающих сил или сила во все времена для не
     *     затухающих.
     * @param float $limit Применяется только к силам затухания, максимальная сила, которая будет применена к спрайту,
     *     используется, когда спрайт находится ближе 1 единицы.
     * @param float $range Диапазон, на который может действовать эта сила, спрайты больше этого расстояния от точки
     *     силы не ощущают никаких эффектов. меньше 0 означает бесконечный диапазон.
     * @param int $fade Установите значение 1, если сила должна быть слабее, когда спрайты находятся дальше от точки
     *     силы, и 0, если сила равна на всех расстояниях.
     * @return int
     */
    function CreatePhysicsForce($x, $y, $power, $limit, $range, $fade)
    {
    }


    /**
     * Создает излучатель частиц в свободном ID и в заданном месте в мировых координатах. Он возвращает идентификатор,
     * используемый для создания излучателя. Излучатели частиц создают поток маленьких спрайтов, которые длятся
     * фиксированное количество времени, прежде чем исчезнуть. Частицы могут подвергаться воздействию сил в течение
     * своей жизни с помощью AddParticlesForce. Они также могут менять цвет с течением времени с помощью
     * AddParticlesColorKeyFrame. Частицы не могут быть изменены по отдельности и вести себя как группа, используя одну
     * и ту же текстуру и глубину. Это позволяет AGK рисовать их более эффективно, чем аналогичное количество обычных
     * спрайтов.
     *
     * Пример вызова:
     *
     * int CreateParticles($x, $y);
     *
     * void CreateParticles($ID, $x, $y);
     * @param int $ID Идентификатор, используемый при ссылке на этот излучатель частиц.
     * @param float $x Координата x для позиционирования этого излучателя.
     * @param float $y Координата y для позиционирования этого излучателя.
     * @return mixed
     */
    function CreateParticles(mixed...$args): mixed
    {
    }

    /**
     * Создает плоскость, которая заполнит весь экран и может быть использована для рендеринга полноэкранных шейдеров.
     *
     * Пример вызова:
     *
     * int CreateObjectQuad();
     *
     * void CreateObjectQuad($objID);
     *
     * @param int|null $objID Идентификатор, используемый для нового объекта.
     * @return mixed
     */
    function CreateObjectQuad(int $objID = null): mixed
    {
    }

    /**
     * Создает трехмерную двустороннюю плоскость с заданными шириной (X) и высотой (Y). Плоскость создается в плоскости
     * XY и не имеет размера в направлении Z.
     *
     * Пример вызова:
     *
     * int CreateObjectPlane($width, $height);
     *
     * void CreateObjectPlane($objID, $width, $height);
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $width Ширина плоскости.
     * @param float $height Высота самолета.
     * @return mixed
     */
    function CreateObjectPlane(mixed...$args): mixed
    {
    }

    /**
     * Создает объект с одной сеткой, построенной из данного memblock. Любые последующие изменения в memblock не
     * повлияют на сетку, вы должны вызвать SetObjectMeshFromMemblock, чтобы изменить существующую сетку. Первые 4
     * байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке,
     * это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не
     * могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и
     * вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на
     * первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали
     * и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина
     * должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в
     * байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала
     * вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных,
     * будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины.
     * Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные
     * и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага
     * нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для
     * поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов
     * (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция
     * имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что
     * любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг
     * normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0
     * для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего
     * остального. Байт длины строки всегда должен быть кратен 4 по соображениям выравнивания, сама строка может иметь
     * немного меньше символов, но всегда округляется до ближайшего кратного 4 для значения длины строки. например,
     * строка длины 5 должна иметь значение длины строки 8. Обратите внимание, что строка из 4 символов имеет нулевой
     * терминатор на конце, что делает ее длиной 5, поэтому, даже если она уже имеет кратное 4 символам значение длины,
     * она должна использовать значение длины 8 из-за нулевого терминатора. Строка имени атрибута будет использоваться
     * шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal",
     * "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты
     * с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не
     * используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны
     * придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные
     * данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый
     * поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в
     * атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1
     * байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер
     * вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize).
     * Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число,
     * которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник.
     *
     *
     * Пример вызова:
     *
     * int CreateObjectFromMeshMemblock($memID);
     *
     * void CreateObjectFromMeshMemblock($objID, $memID);
     * @param int $objID Идентификатор создаваемого объекта
     * @param int $memID Индекс memblock, используемый для создания сетки объекта
     * @return mixed
     */
    function CreateObjectFromMeshMemblock(int...$args): mixed
    {
    }

    /**
     * Создает пустое изображение, пригодное для рендеринга, и возвращает идентификатор для ссылки на него. Это можно
     * использовать с SetRenderToImage для рисования вещей на изображениях. Вы можете создавать изображения RGBA для
     * обычного рендеринга или изображения глубины для захвата буфера глубины на устройствах, которые его поддерживают.
     * Вы также можете использовать mipmapping на этом изображении или нет, это переопределяет глобальную команду
     * SetGenerateMipmaps() только для этого изображения, это связано с тем, что mipmaps на визуализированных
     * изображениях могут быть хитом производительности, поэтому их не следует использовать без необходимости.
     * Mip-карты должны быть необходимы только в том случае, если вы собираетесь использовать это изображение для
     * текстурирования объектов в вашей сцене, если вы используете это изображение только для полноэкранных шейдеров,
     * вы не должны использовать mip-карты на нем.
     *
     * Пример вызова:
     *
     * int CreateRenderImage($width, $height, $format, $mipmap);
     *
     * void CreateRenderImage($imageID, $width, $height, $format, $mipmap);
     * @param int $imageID Идентификатор изображения, используемый для этого изображения
     * @param int $width Ширина создаваемого изображения
     * @param int $height Высота создаваемого изображения
     * @param int $format 0=RGBA (32bit), 1=Глубина
     * @param int $mipmap 1 для использования mipmapping на этом изображении, 0 для его отключения
     * @return mixed
     */
    function CreateRenderImage(int...$args): mixed
    {
    }

    /**
     * Создает 3D-цилиндр с заданным диаметром и высотой, а также необязательным количеством полигонов. Параметр
     * segments определяет, сколько столбцов полигонов составляет цилиндр и должно быть не менее 3. Формула для
     * вычисления общего числа полигонов, используемых в цилиндре, равна 3*сегментам. Возвращает идентификатор, который
     * можно использовать для ссылки на этот объект в других командах.
     *
     * Пример вызова:
     *
     * int CreateObjectCylinder($height, $diameter, $segments);
     *
     * void CreateObjectCylinder($objID, $height, $diameter, $segments)
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $height Высота цилиндра.
     * @param float $diameter Диаметр основания цилиндра.
     * @param int $segments Число столбцов многоугольников, составляющих цилиндр.
     * @return mixed
     */
    function CreateObjectCylinder(mixed...$args): mixed
    {
    }

    /**
     * Создает объект из заданной карты высот, полезный для создания рельефа. Изображение должно быть PNG 8-битным в
     * оттенках серого или RGB, если это RGB, то считывается только красный канал. В будущем может быть добавлена
     * поддержка 16-битных оттенков серого. Объект будет иметь один УФ-канал с диапазоном от 0 до 1, отображенным на
     * всю местность. Если вы хотите изменить это, то вы можете использовать SetObjectUVOffset и SetObjectUVScale или
     * использовать шейдер, который умножает UV-координаты на заданную величину. Шейдер также можно использовать для
     * создания нескольких УФ-каналов из этого одного канала, применяя к каждому из них различные масштабные
     * коэффициенты. Для удаления артефактов шага рекомендуется использовать значение сглаживания 1, при необходимости
     * корректируя его. Значение split позволяет создавать несколько сеток, которые могут повысить производительность,
     * так как невидимые сетки не будут нарисованы. Значение разделения указывает, сколько сеток нужно создать вдоль
     * каждого ребра, например, значение разделения 5 создаст в общей сложности 5x5 = 25 сеток. В отличие от других
     * объектов, данные о столкновениях не генерируются по умолчанию на этом объекте, так как он может потреблять много
     * памяти, используйте SetObjectCollisionMode, если вы хотите включить его. Для ландшафтов больше 1024x1024 это не
     * рекомендуется на мобильных устройствах, и вы должны использовать GetObjectHeightMapHeight вместо этого, если это
     * возможно. Включение физики для этого объекта будет использовать еще больше памяти и не рекомендуется на
     * местности больше 1024x1024 на любой платформе.
     *
     * Пример вызова:
     *
     * int CreateObjectFromHeightMap($szImageFile, $width, $height, $length, $smoothing, $split);
     *
     * void CreateObjectFromHeightMap($objID, $szImageFile, $width, $height, $length, $smoothing, $split);
     * @param int $objID Идентификатор создаваемого объекта
     * @param string $szImageFile Имя файла изображения для использования в качестве карты высоты, предпочтительно PNG,
     *     также поддерживает JPEG
     * @param float $width Желаемая ширина нового объекта в направлении X
     * @param float $height Желаемая высота нового объекта в направлении Y
     * @param float $length Желаемая длина нового объекта в направлении Z
     * @param int $smoothing Величина сглаживания, применяемая к значениям высоты, 0=нет, 1=один проход, 2=два прохода
     *     и т. Д.
     * @param int $split 1=одна сетка, 2=четыре сетки, 3=девять сеток, 4=шестнадцать сеток и т. Д.
     * @return mixed
     */
    function CreateObjectFromHeightMap(mixed...$args): mixed
    {
    }


    /**
     * Создает 3D-сферу с заданным диаметром и необязательным количеством полигонов. Параметр rows определяет, сколько
     * рядов полигонов составляет сферу и должно быть не менее 2. Параметр columns определяет, сколько столбцов
     * полигонов составляет сферу и должно быть не менее 3. Формула для расчета общего количества полигонов,
     * используемых в сфере, равна 2*столбцам*(строкам-1)
     *
     *
     * Пример вызова:
     *
     * int CreateObjectSphere($diameter, $rows, $columns)ж
     *
     * void CreateObjectSphere($objID, $diameter, $rows, $columns);
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $diameter Диаметр сферы.
     * @param int $rows Число рядов многоугольников, составляющих сферу.
     * @param int $columns Число столбцов многоугольников, составляющих сферу.
     * @return mixed
     */
    function CreateObjectSphere(mixed...$args): mixed
    {
    }



    /**
     * Создает 3D-конус с заданным диаметром и высотой, а также необязательное количество полигонов. Параметр segments
     * определяет, сколько столбцов полигонов составляет конус и должно быть не менее 3. Формула для вычисления общего
     * числа полигонов, используемых в конусе, равна 2*сегментам. Возвращает идентификатор, который можно использовать
     * для ссылки на этот объект в других командах.
     *
     *
     * Пример вызова:
     *
     * int CreateObjectCone($height, $diameter, $segments);
     *
     * void CreateObjectCone($objID, $height, $diameter, $segments);
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $height Высота конуса.
     * @param float $diameter Диаметр основания конуса.
     * @param int $segments Количество столбцов многоугольников, составляющих конус.
     * @return mixed
     */
    function CreateObjectCone(mixed...$args): mixed
    {
    }

    /**
     * Создает примитив Капсулы.
     *
     * Пример вызова:
     *
     * int CreateObjectCapsule($diameter, $height, $axis);
     *
     * void CreateObjectCapsule($objID, $diameter, $height, $axis);
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $diameter Диаметр капсулы.
     * @param float $height Высота капсулы
     * @param int $axis 0 = X, 1 = Y, Z = 2
     * @return mixed
     */
    function CreateObjectCapsule(mixed...$args): mixed
    {
    }


    /**
     * Создает объект из заданной карты высот .raw или .dat, полезной для создания рельефа. Файл должен содержать
     * необработанные 16-битные данные. Если вы используете расширение ".dat" в szFilename, он будет ожидать, что это
     * 32-битная необработанная карта высоты GameGuru, и преобразует ее в 16-битную. Если файл не является картой
     * высоты GameGuru, то вы должны изменить расширение на ".raw". Если вы конвертируете файл GameGuru height map
     * (.dat), то rawWidth и rawHeight всегда должны быть равны 1024. Объект будет иметь один УФ-канал с диапазоном от
     * 0 до 1, отображенным на всю местность. Если вы хотите изменить это, то вы можете использовать SetObjectUVOffset
     * и SetObjectUVScale или использовать шейдер, который умножает UV-координаты на заданную величину. Шейдер также
     * можно использовать для создания нескольких УФ-каналов из этого одного канала, применяя к каждому из них
     * различные масштабные коэффициенты. Обычно при использовании 16-битных данных вам не нужно устанавливать значение
     * сглаживания, но если оно еще не было сглажено, отрегулируйте его по мере необходимости. Значение split позволяет
     * создавать несколько сеток, которые могут повысить производительность, так как невидимые сетки не будут
     * нарисованы. Значение разделения указывает, сколько сеток нужно создать вдоль каждого ребра, например, значение
     * разделения 5 создаст в общей сложности 5x5 = 25 сеток. В отличие от других объектов, данные о столкновениях не
     * генерируются по умолчанию на этом объекте, так как он может потреблять много памяти, используйте
     * SetObjectCollisionMode, если вы хотите включить его. Для ландшафтов больше 1024x1024 это не рекомендуется на
     * мобильных устройствах, и вы должны использовать GetObjectHeightMapHeight вместо этого, если это возможно.
     * Включение физики для этого объекта будет использовать еще больше памяти и не рекомендуется на местности больше
     * 1024x1024 на любой платформе.
     *
     *
     * Пример вызова:
     *
     * int CreateObjectFromRawHeightMap($szFilename, $width, $height, $length, $smoothing, $split, $rawWidth, $rawHeight);
     *
     * void CreateObjectFromRawHeightMap($objID, $szFilename, $width, $height, $length, $smoothing, $split, $rawWidth, $rawHeight);
     * @param int $objID Идентификатор создаваемого объекта
     * @param string $szFilename Имя файла карты высот должно заканчиваться на .raw или .dat
     * @param float $width Желаемая ширина нового объекта в направлении X
     * @param float $height Желаемая высота нового объекта в направлении Y
     * @param float $length Желаемая длина нового объекта в направлении Z
     * @param int $smoothing Величина сглаживания, применяемая к значениям высоты, 0=нет, 1=один проход, 2=два прохода
     * и т. Д.
     * @param int $split 1=одна сетка, 2=четыре сетки, 3=девять сеток, 4=шестнадцать сеток и т. Д.
     * @param int $rawWidth Ширина данных карты высот
     * @param int $rawHeight Высота данных карты высот
     * @return mixed
     */
    function CreateObjectFromRawHeightMap(mixed...$args): mixed
    {
    }

    /**
     * Создает 3D-окно с заданными шириной (X), высотой (Y) и длиной (Z). Возвращает идентификатор, который можно
     * использовать для ссылки на этот объект в других командах.
     *
     * Пример вызова:
     *
     * int CreateObjectBox($width, $height, $length);
     *
     * void CreateObjectBox($objID, $width, $height, $length);
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $width Размер объекта в направлении X.
     * @param float $height Размер объекта в направлении Y.
     * @param float $length Размер объекта в направлении Z.
     * @return mixed
     */
    function CreateObjectBox(mixed...$args): mixed
    {
    }

    /**
     * Создает объект путем копирования одной сетки из другого объекта. Объект может содержать много сеток, и
     * использование CloneObject скопирует их все. Используйте эту команду, если вы хотите скопировать только одну
     * сетку. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes включительно.
     *
     * Пример вызова:
     *
     * int CreateObjectFromObjectMesh($fromObjID, $meshIndex);
     *
     * void CreateObjectFromObjectMesh($objID, $fromObjID, $meshIndex);
     *
     * @param int $objID Идентификатор нового объекта
     * @param int $fromObjID Идентификатор объекта, содержащего сетку для копирования
     * @param int $meshIndex Индекс сетки для копирования
     * @return mixed
     */
    function CreateObjectFromObjectMesh(int...$args): mixed
    {
    }

    /**
     * Создает соединение мыши между точкой и спрайтом. Это обычно используется при перетаскивании фигуры указателем
     * мыши и попытке переместить спрайт в заданную точку с помощью силы до максимального заданного значения. Укажите
     * точку привязки в мировых координатах, которая будет выступать в качестве начальной точки удержания спрайта.
     * Любое дальнейшее изменение в целевом положении будет пытаться переместить эту точку спрайта в новое место.
     * Используйте SetJointMouseTarget для изменения местоположения целевой позиции.
     *
     * Пример вызова:
     * 
     * int CreateMouseJoint($iSpriteIndex, $x, $y, $maxForce);
     * void CreateMouseJoint($iJointIndex, $iSpriteIndex, $x, $y, $maxForce);
     * 
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex Идентификатор спрайта для перемещения.
     * @param float $x Координата x начальной точки привязки на спрайте.
     * @param float $y Координата y начальной точки привязки на спрайте.
     * @param float $maxForce Максимальное усилие, которое сустав может использовать для перемещения спрайта.
     * @return mixed
     */
    function CreateMouseJoint(mixed...$args): mixed
    {
    }
    
    /**
     * Создает сетевое сообщение, которое может быть отправлено на другое сетевое устройство. Он возвращает
     * идентификатор, который можно использовать для взаимодействия с сообщением. Сообщения, созданные таким образом,
     * могут быть только добавлены, а не прочитаны. После передачи в сеть идентификатор сообщения уничтожается и
     * обрабатывается фоновым сетевым кодом.
     *
     * @return int
     */
    function CreateNetworkMessage()
    {
    }


    /**
     * Создает memblock из сетки объектов. Объект может содержать одну или несколько сеток, индексы сетки находятся в
     * диапазоне от 1 до GetObjectNumMeshes включительно. Сетка копируется в memblock, поэтому любые изменения в
     * memblock не влияют сразу на сетку, вы должны использовать одну из других команд, таких как
     * SetObjectMeshFromMemblock, чтобы скопировать memblock обратно в сетку. Первые 4 байта memblock представляют
     * количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом
     * случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число
     * индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между
     * многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта
     * представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные
     * атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все
     * остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по
     * атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете
     * легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет.
     * После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают,
     * как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута
     * существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X
     * байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего,
     * например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество
     * компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2
     * компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4
     * компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных
     * unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг
     * нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда будет кратен
     * 4, чтобы упростить проблемы выравнивания, сама строка может иметь немного меньше символов и быть дополнена
     * нулевыми терминаторами, но прочитайте все указанные байты, и вы получите правильную строку длины. Строка имени
     * атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, -
     * "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы
     * можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же
     * именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта,
     * то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные
     * вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X,
     * 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута,
     * указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4
     * байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам,
     * используя размер вершины, указанный выше, и индекс вершины, например so
     * offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый
     * индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три
     * индекса представляют собой многоугольник. Если вы планируете регулярно вносить изменения в сетку, вы должны
     * сохранить memblock после использования SetObjectMeshFromMemblock вместо того, чтобы регенерировать его из
     * объекта каждый раз, когда вы хотите внести изменения. Затем снова вызовите SetObjectMeshFromMemblock, когда вы
     * хотите перенести свои новые изменения на объект.
     *
     * Пример вызова:
     *
     * int CreateMemblockFromObjectMesh($objID, $meshIndex);
     *
     * void CreateMemblockFromObjectMesh($memID, $objID, $meshIndex);
     * @param int $memID Идентификатор нового memblock
     * @param int $objID Идентификатор объекта, содержащего сетку для чтения
     * @param int $meshIndex Индекс сетки для копирования в memblock
     * @return mixed
     */
    function CreateMemblockFromObjectMesh(int...$args): mixed
    {
    }

    /**
     * Создает memblock из загруженного изображения, субизображения atlas не поддерживаются. Изображение должно
     * существовать и не подвержено влиянию этой команды. Первые 4 байта memlbock хранят ширину изображения, следующие
     * 4 байта хранят высоту изображения, следующие 4 байта хранят битовую глубину, в настоящее время это всегда будет 32
     * 32. После этого необработанные данные изображения начинаются в формате RGBA, причем каждый компонент хранится в
     * одном байте, поэтому каждый пиксель занимает 4 байта. Размер данных изображения может быть вычислен по
     * ширине*высоте*4 байта (на данный момент битовая глубина может быть принята равной 32 битам = 4 байтам). Обратите
     * внимание, что из-за малого формата endian чтение данных изображения с байтами вернет смещения 0=R, 1=G, 2=B,
     * 3=A, но чтение их всех как одного целого числа приведет к значению с A как наиболее значимым байтом, за которым
     * следует B, затем G, затем R как наименее значимый байт. Пиксельные данные начинаются в верхнем левом углу
     * изображения и продолжаются слева направо, а затем сверху вниз, в результате чего изображение сохраняется в виде
     * последовательности строк, заканчивающихся в правом нижнем углу. Возвращает идентификатор, который можно
     * использовать для ссылки на этот memblock в других командах.
     *
     * Пример вызова:
     *
     * int CreateMemblockFromImage($imageID);
     *
     * void CreateMemblockFromImage($memID, $imageID);
     * @param int $memID Идентификатор создаваемого мемблока.
     * @param int $imageID Идентификатор изображения для чтения.
     * @return mixed
     */
    function CreateMemblockFromImage(int...$args): mixed
    {
    }


    /**
     * Создает memblock из файла без какой-либо обработки данных файла, memblock будет байт за байтом копией файла.
     * Возвращает идентификатор, который может быть использован для ссылки на этот memblock позже. Вы можете
     * использовать относительные пути в имени файла для чтения из вложенных папок или использовать SetFolder для
     * первого просмотра. Вы можете использовать абсолютные пути, добавив косую черту в начало имени файла, в этом
     * случае папка, установленная с помощью SetFolder, игнорируется. Например /media/file.txt будет читать его из
     * папки media, даже если SetFolder был использован для перехода к /media/somefolder
     *
     * Пример вызова:
     *
     * int CreateMemblockFromFile($filename);
     *
     * void CreateMemblockFromFile($memID, $filename);
     * @param int $memID Идентификатор создаваемого мемблока.
     * @param string $filename Имя файла для чтения, если он не существует, это не удастся.
     * @return mixed
     */
    function CreateMemblockFromFile(mixed...$args): mixed
    {
    }

    /**
     * Создает раздел памяти заданного размера для доступа на чтение или запись. Содержимое памяти не определено, пока
     * вы не запишете в нее. Memblock не должен уже существовать с выбранным вами memID.
     *
     * Пример вызова:
     *
     * int CreateMemblock($size);
     *
     * void CreateMemblock($memID, $size);
     *
     * @param int $memID Идентификатор мемблока, который вы хотите использовать.
     * @param int $size Размер мемблока в байтах. максимум 100 000 000.
     * @return mixed
     */
    function CreateMemblock(int...$args): mixed
    {
    }

    /**
     * Создает соединение линий между двумя спрайтами. Соединение линий позволяет спрайтам двигаться только вдоль
     * заданной оси относительно друг друга, свободно вращаясь на обоих концах. Он похож на призматический шарнир, за
     * исключением того, что допускается относительное вращение. Укажите единственную опорную точку в мировых
     * координатах со спрайтами уже в нужном относительном положении, на минимальном расстоянии поршня. С этого момента
     * спрайтам будет позволено разделиться вдоль заданной оси относительно друг друга. Точка привязки может быть
     * смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для ссылки на это соединение
     * позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален.
     * Это соединение поддерживает двигатели и ограничения. Box2D переименовал это соединение в Колесное соединение, и
     * теперь оно содержит пружинный компонент для имитации колеса автомобиля. Имя команды AGK останется прежним для
     * обратной совместимости, однако функциональность может измениться
     *
     * Пример вызова:
     *
     * int CreateLineJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $vx, $vy, $colConnected);
     *
     * void CreateLineJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $vx, $vy, $colConnected);
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param float $vx Компонент x оси.
     * @param float $vy Компонент y оси.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом,
     *     0=нет, 1=да.
     * @return mixed
     */
    function CreateLineJoint(mixed...$args): mixed
    {
    }

    /**
     * Создает изображение из memblock. Мемблок должен существовать, если образ существует, он будет перезаписан, если
     * нет, то будет создан. Memblock должен содержать допустимый PNG-файл, например загруженный
     * CreateMemblockFromFile(memID, "image.png")
     *
     * Пример вызова:
     *
     * int CreateImageFromPNGMemblock($memID);
     *
     * void CreateImageFromPNGMemblock($imageID, $memID);
     * @param int $imageID Идентификатор создаваемого изображения.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return mixed
     */
    function CreateImageFromPNGMemblock(int...$args): mixed
    {
    }

    /**
     * Создает HTTP - соединение, готовое к использованию позже. Возвращает идентификатор, используемый для ссылки на
     * него позже.
     *
     * @return int
     */
    function CreateHTTPConnection()
    {
    }

    /**
     * Создает изображение размером 1x1 пиксель заданного цвета. Это может быть использовано для текстурирования любого
     * объекта или спрайта сплошным цветом.
     *
     * Пример вызова:
     *
     * int CreateImageColor($red, $green, $blue, $alpha);
     *
     * void CreateImageColor($imageID, $red, $green, $blue, $alpha);
     * @param int $imageID Идентификатор изображения, используемый для этого изображения.
     * @param int $red Красная составляющая изображения (от 0 до 255)
     * @param int $green Зеленая составляющая изображения (от 0 до 255)
     * @param int $blue Синяя составляющая изображения (от 0 до 255)
     * @param int $alpha Альфа
     * @return mixed
     */
    function CreateImageColor(int...$args):mixed
    {
    }

    /**
     * Создает музыкальную сущность из мемблока. Мемблок должен существовать. Это создаст новый идентификатор музыки и
     * вернет его memblock должен содержать допустимый файл OGG, например загруженный с CreateMemblockFromFile(memID,
     * "music.ogg")
     *
     * Пример вызова:
     *
     * int CreateMusicFromOGGMemblock($memID);
     *
     * void CreateMusicFromOGGMemblock($musicID, $memID);
     * @param int $musicID Идентификатор создаваемой музыки.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return mixed
     */
    function CreateMusicFromOGGMemblock(int...$args): mixed
    {
    }

    /**
     * Создает memblock из загруженного звукового файла. Звуковой файл должен быть загружен с помощью LoadSound и не
     * подвержен влиянию этой команды. Первые 2 байта memlbock хранят количество каналов (1 или 2 поддерживаемых),
     * следующие 2 байта хранят биты на выборку (8 или 16 поддерживаемых), следующие 4 байта хранят выборки в секунду,
     * например 44100. Следующие 4 байта-это количество кадров в звуковых данных, размер звуковых данных в байтах можно
     * вычислить из этого с помощью формулы numFrames*(BitsPerSample/8)*channels. В 2-канальном звуке кадр содержит 2
     * сэмпла, по одному для каждого канала. В моно-звуке кадр содержит 1 образец. Остальная часть memblock-это
     * необработанные звуковые данные, например, в 8-битном стереозвуке с 3 кадрами необработанные данные будут
     * выглядеть так. смещение байта 0 = Кадр 1, смещение байта данных левого канала 1 = Кадр 1, Смещение байта данных
     * правого канала 2 = Кадр 2, Смещение байта данных левого канала 3 = Кадр 2, смещение байта данных правого канала
     * 4 = Кадр 3, смещение байта данных левого канала 5 = Кадр 3, данные правого канала Продолжительность звука может
     * быть рассчитана по следующей формуле: numFrames/samplesPerSecond. Эта команда не работает с идентификаторами
     * звуковых экземпляров, а только с идентификаторами звуковых файлов. Возвращает идентификатор, который может быть
     * использован для ссылки на этот memblock в других командах.
     *
     * Пример вызова:
     *
     * int CreateMemblockFromSound($soundID);
     *
     * void CreateMemblockFromSound($memID, $soundID);
     * @param int $memID Идентификатор создаваемого мемблока.
     * @param int $soundID Идентификатор звука для чтения.
     * @return mixed
     */
    function CreateMemblockFromSound(int...$args): mixed
    {
    }

    /**
     * Эта команда устарела, вместо нее следует использовать ShowFullscreenAdvertAdMob, ShowFullscreenAdvertChartboost
     * или ShowFullscreenAdvertAmazon. Создает полноэкранную (интерстициальную) рекламу для получения дохода. Перед
     * вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью одной из других команд,
     * таких как SetAdMobDetails, SetChartboostDetails или SetAmazonAdDetails Не все платформы поддерживают всех
     * поставщиков рекламы, поэтому установка как можно большего количества данных учетной записи позволит AGK выбрать
     * подходящее объявление для этой платформы. И iOS, и Android используют кэширование для предварительной загрузки
     * рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться
     * немедленно, в противном случае эта команда ничего не сделает. Сбой в загрузке объявления может быть вызван тем,
     * что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить,
     * ждет ли объявление показа для конкретного поставщика с помощью GetFullscreenAdvertLoadedAdMob,
     * GetFullscreenAdvertLoadedChartboost или GetFullscreenAdvertLoadedAmazon. Ваше приложение будет приостановлено,
     * когда появится объявление, и возобновится, когда оно будет отклонено.
     *
     * @return void
     */
    function CreateFullscreenAdvert()
    {
    }

    /**
     * Создает файл из memblock без какой-либо обработки данных memblock, файл будет байт за байтом копией данных
     * memblock. Вы можете использовать относительные пути в имени файла для записи в подпапки или использовать
     * SetFolder для просмотра там в первую очередь. Вы можете использовать абсолютные пути, добавив косую черту в
     * начало имени файла, в этом случае папка, установленная с помощью SetFolder, игнорируется. Например
     * /media/file.txt поместит его в папку media, даже если SetFolder был использован для перехода к /media/somefolder
     *
     * @param string $filename Имя создаваемого файла, если он уже существует, будет перезаписано.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return void
     */
    function CreateFileFromMemblock($filename, $memID)
    {
    }


    /**
     * Создайте поле редактирования, которое можно расположить в любом месте экрана. Он возвращает идентификатор,
     * используемый для ссылки на это поле редактирования позже.
     *
     * Пример вызова:
     *
     * int CreateEditBox();
     *
     * void CreateEditBox($index);
     *
     * @param int|null $index Идентификатор, используемый для этого поля редактирования.
     * @return mixed
     */
    function CreateEditBox(int $index = null): mixed
    {
    }

    /**
     * Создает спрайт в заданном идентификаторе спрайта, возвращает используемый идентификатор спрайта. Фиктивные
     * спрайты ведут себя как обычные спрайты, но не имеют никакого изображения или другого визуального аспекта. Они не
     * будут нарисованы, даже если им присвоено изображение. Они полезны для добавления физических объектов в сцену без
     * необходимости визуального сопровождения физической формы. При желании вы можете использовать команды физического
     * контакта и обратной связи, чтобы выяснить, что поразило эти скрытые физические формы. Если вам не нужно знать,
     * что попало в ваши скрытые фигуры, то вы можете добавить их все в один фиктивный спрайт, используя команды
     * AddSpriteShape для лучшей производительности. SetSpriteShape не будет работать с фиктивными спрайтами, так как у
     * них нет изображения для вычисления фигуры, фигуры должны быть определены вручную с помощью SetSpriteShapeBox,
     * SetSpriteShapeCircle или SetSpriteShapePolygon. Фиктивные спрайты не будут обновлять свой сохраненный угол и
     * положение с помощью последних версий физики, поэтому вызовы GetSpriteX, GetSpriteY или GetSpriteAngle вернут
     * последнее заданное вами значение. Установка положения спрайта обновит физическое тело до заданного вами
     * положения.
     *
     * Пример вызова:
     *
     * int CreateDummySprite();
     *
     * void CreateDummySprite($iSpriteIndex);
     *
     * @param int|null $iSpriteIndex Идентификатор, используемый для этого спрайта.
     * @return mixed
     */
    function CreateDummySprite(int $iSpriteIndex = null): mixed
    {
    }


    /**
     * Создает дистанционное соединение между двумя спрайтами. Дистанционное соединение удерживает спрайты на
     * определенном расстоянии друг от друга, позволяя им свободно вращаться вокруг опорных точек. Укажите две опорные
     * точки в мировых координатах, чтобы спрайты уже находились на нужном расстоянии друг от друга. Опорные точки
     * могут быть смещены от позиций спрайтов. Соединение может быть удалено системой, если какой-либо из спрайтов,
     * которые он соединяет, будет удален.
     *
     * Пример вызова:
     *
     * void CreateDistanceJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $x2, $y2, $colConnected);
     *
     * int CreateDistanceJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $x2, $y2, $colConnected);
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки спрайта 1.
     * @param float $y Координата y якорной точки спрайта 1.
     * @param float $x2 Координата x опорной точки спрайта 2.
     * @param float $y2 Координата y опорной точки спрайта 2.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом,
     *     0=нет, 1=да.
     * @return mixed
     */
    function CreateDistanceJoint(mixed...$args): mixed
    {
    }

    /**
     * Широковещательные передачи являются специальными сетевыми коммуникациями, поскольку они не используют адрес
     * назначения и вместо этого принимаются всеми устройствами в сети. Широковещательные пакеты не пересылаются
     * маршрутизаторами, поэтому могут использоваться только в локальной сети или, точнее, в локальной подсети. Это
     * может быть полезно для обнаружения устройств, поскольку одно устройство может отправить широковещательный пакет,
     * содержащий его IP-адрес, а другое устройство может принять его, прочитать IP-адрес и подключиться обратно к
     * первому устройству, чтобы создать двустороннее соединение. Сети AGK транслируются таким образом на порт 45631 и
     * отправляют пакет, содержащий имя сети, которая была размещена другим устройством AGK. С помощью
     * широковещательного прослушивателя вы можете получать эти сообщения, извлекать имена сетей и отображать их
     * пользователю, чтобы он мог выбрать, к какой сети он хочет подключиться. Если устройство находится в сети IPv6,
     * то эти правила немного меняются. CreateBroadcastListener должен быть вызван с многоадресным адресом, который
     * начинается с ff, например ff02::1, и широковещательный прослушиватель будет принимать только пакеты,
     * отправленные на этот многоадресный адрес. Если адрес не указан, то вещатель будет получать только
     * широковещательные передачи IPv4. Если вы передадите адрес "anyip6", то широковещательный прослушиватель будет
     * прослушивать многоадресный адрес AGK "FF02::41:474B", который используется для обнаружения именованной сети на
     * порту 45631. Возвращает идентификатор, который можно использовать для взаимодействия с этим широковещательным
     * слушателем.
     * Пример вызова:
     *
     * int CreateBroadcastListener($szIP, $port);
     *
     * int CreateBroadcastListener($port);
     * @param string $szIP Многоадресный IP-адрес для прослушивания применяется только к сетям IPv6, если оставить его
     * пустым, то он будет прослушивать широковещательные передачи IPv4.
     * @param int $port Порт, на который транслируются сообщения, в случае сетей AGK это будет порт 45631.
     * @return int
     */
    function CreateBroadcastListener(mixed...$args): int
    {
    }

    /**
     * Создает рекламу для получения дохода. Перед вызовом этой функции вы должны задать данные своего рекламного
     * аккаунта с помощью одной из других команд, таких как SetAdMobDetails. Не все платформы поддерживают всех
     * поставщиков рекламы, поэтому установка как можно большего количества реквизитов учетной записи позволит AGK
     * выбрать подходящее объявление для этой платформы. Эта реклама обычно представляет собой баннер размером 320х50,
     * отображаемый где-то на краю вашего приложения. Создание объявления, когда оно уже существует, заменит
     * существующее объявление. Это расширенная версия команды CreateAdvert, которая принимает необязательные значения
     * смещения для позиционирования объявления. Параметр type можно использовать для выбора размера баннера:
     * 0=Banner(320x50), 1=LargeBanner, 2=MediumRectangle, 3=FullBanner, 4=Leaderboard, 5=SmartBanner, 6=FluidBanner
     *
     * @param int $type Размер создаваемого баннера
     * @param int $horz Горизонтальное положение объявления: 0=слева, 1=в центре, 2=справа
     * @param int $vert Вертикальное положение объявления, 0=верх, 1=центр, 2=низ
     * @param int $test Установите значение 1, чтобы получить неоплачиваемое тестовое объявление, и 0, чтобы получить
     *     реальное объявление.
     * @param float $offsetx когда horz равен 0 или 2 это значение смещает объявление от указанного края
     * @param float $offsety когда vert равен 0 или 2 это значение смещает объявление от указанного края
     * @return void
     */
    function CreateAdvertEx($type, $horz, $vert, $test, $offsetx, $offsety)
    {
    }

    /**
     * Создает изображение из memblock. Мемблок должен существовать, если образ существует, он будет перезаписан, если
     * нет, то будет создан. Первые 4 байта memlbock хранят ширину изображения, следующие 4 байта хранят высоту
     * изображения, следующие 4 байта хранят битовую глубину, в настоящее время это должно быть 32. После этого
     * необработанные данные изображения начинаются в формате RGBA, причем каждый компонент хранится в одном байте,
     * поэтому каждый пиксель занимает 4 байта. Размер данных изображения может быть вычислен по ширине*высоте*4 байта
     * (на данный момент битовая глубина может быть принята равной 32 битам = 4 байтам). Обратите внимание, что из-за
     * малого формата endian запись данных изображения байтами приведет к смещениям 0=R, 1=G, 2=B, 3=A, но запись их
     * всех в виде одного целого числа будет интерпретироваться как значение с A как наиболее значимым байтом, за
     * которым следует B, затем G, затем R как наименее значимый байт. Пиксельные данные начинаются в верхнем левом
     * углу изображения и продолжаются слева направо, а затем сверху вниз, в результате чего изображение сохраняется в
     * виде последовательности строк, заканчивающихся в правом нижнем углу. Эта команда использует большую пропускную
     * способность графического процессора, поэтому не рекомендуется вызывать эту команду каждый кадр на больших
     * изображениях.
     *
     * Пример вызова:
     *
     * void CreateImageFromMemblock($imageID, $memID);
     *
     * int CreateImageFromMemblock($memID);
     * @param int $imageID Идентификатор создаваемого или изменяемого изображения.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return mixed
     */
    function CreateImageFromMemblock(int...$args):mixed
    {
    }

    /**
     * Создает рекламу для получения дохода. Перед вызовом этой функции вы должны задать данные своего рекламного
     * аккаунта с помощью одной из других команд, таких как SetAdMobDetails. Не все платформы поддерживают всех
     * поставщиков рекламы, поэтому установка как можно большего количества реквизитов учетной записи позволит AGK
     * выбрать подходящее объявление для этой платформы. Эта реклама обычно представляет собой баннер размером 320х50,
     * отображаемый где-то на краю вашего приложения. Создание объявления, когда оно уже существует, заменит
     * существующее объявление. Параметр type можно использовать для выбора размера баннера: 0=Banner(320x50),
     * 1=LargeBanner, 2=MediumRectangle, 3=FullBanner, 4=Leaderboard, 5=SmartBanner, 6=FluidBanner
     *
     * @param int $type Размер создаваемого баннера
     * @param int $horz Горизонтальное положение объявления, 0=слева, 1=в центре, 2=справа
     * @param int $vert Вертикальное положение объявления, 0=верх, 1=центр, 2=низ
     * @param int $test Установите значение 1, чтобы получить неоплачиваемое тестовое объявление, и 0, чтобы получить
     *     реальное объявление.
     * @return void
     */
    function CreateAdvert($type, $horz, $vert, $test)
    {
    }

    /**
     * Вы должны создать физический мир, прежде чем вызывать какие-либо другие физические команды. Create3DPhysicsWorld
     * Создает физический мир, используя масштабный коэффициент по умолчанию 40. Эта функция создаст физический мир с
     * другим масштабным коэффициентом. Масштаб-это не размер мира, это фактор, с помощью которого все передаваемые
     * данные уменьшаются, чтобы преобразовать их в шкалу физики Пули для физических вычислений. Затем данные из Bullet
     * масштабируются до того, как они будут переданы в AGK 3D world. Масштабный коэффициент по умолчанию будет
     * правильным, если ваш средний размер символа составляет 72 единицы AGK. Тогда гравитация по умолчанию -10,0 метра
     * в секунду на оси Y даст правильный визуальный результат. Решатель физики пуль имеет минимальный размер для
     * объектов. Объекты ниже этого размера вызовут нестабильность в работе решателя. При масштабном коэффициенте по
     * умолчанию 40 наименьший размер, который может обрабатывать решатель, составляет около 3,5 единиц AGK. Чтобы
     * вычислить масштабный коэффициент, сначала определите рост вашего персонажа в метрах, символ высотой 72 единицы
     * будет равен 1,8288 метра (или 6 футов). Затем разделите высоту персонажа в единицах на высоту символов в метрах,
     * для этого примера масштабный коэффициент будет равен (72 / 1.8) = 40.
     *
     * @param float|null $scaleFactor Масштабный коэффициент по умолчанию равен 40.
     * @return void
     */
    function Create3DPhysicsWorld(float $scaleFactor = null)
    {
    }

    /**
     * Создает статическую плоскость. Возвращает статический идентификатор плоскости
     *
     * @param float $normalX x значение вектора нормали.
     * @param float $normalY значение y вектора нормали.
     * @param float $normalZ z-значение вектора нормали.
     * @param float $offsetPosition Насколько самолет будет смещен от своего мирового положения.
     * @return int
     */
    function Create3DPhysicsStaticPlane(float $normalX, float $normalY, float $normalZ, float $offsetPosition)
    {
    }

    /**
     * Удаляет существующее физическое тело и создает статическую форму столкновения треугольной сетки и физическое
     * тело для объекта.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Create3DPhysicsStaticBody($objID)
    {
    }

    /**
     * Создает зубчатое соединение между двумя существующими соединениями. Зубчатое соединение позволяет внешнему виду
     * двух существующих соединений быть зафиксированными вместе в идеальном трении. Спрайты, которые будут соединены,
     * будут спрайтом 2 на обоих суставах, спрайт 1 на обоих суставах должен быть статическим спрайтом. Идентификатор
     * соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если
     * какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение должно быть удалено до того, как
     * будут удалены все соединения, от которых оно зависит.
     *
     * Пример вызова:
     *
     * int CreateGearJoint($iJoint1, $iJoint2, $ratio);
     *
     * void CreateGearJoint($iJointIndex, $iJoint1, $iJoint2, $ratio);
     * @param int $iJointIndex Идентификационный номер зубчатого соединения.
     * @param int $iJoint1 Идентификатор первого соединения, к которому нужно присоединиться.
     * @param int $iJoint2 Идентификатор второго соединения для соединения.
     * @param float $ratio Передаточное число, используемое при перемещении одного шарнира от другого.
     * @return mixed
     */
    function CreateGearJoint(mixed...$args) : mixed
    {
    }

    /**
     * Возвращает идентификатор созданного луча.
     *
     * @return int
     */
    function Create3DPhysicsRay()
    {
    }

    /**
     * Создает соединение ползунков между объектами a и b. Параметр rotationVec3 должен быть осью в виде (0,1,0) для
     * вертикали, (1,0,0) для горизонтали вдоль оси X, (0,0,1) для горизонтали вдоль оси Z или любой их комбинации.
     * Вектор вращения не нуждается в нормализации. Возвращает идентификатор соединения.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $positionVec3 векторный ИДЕНТИФИКАТОР
     * @param int $rotationVec3 векторный ИДЕНТИФИКАТОР
     * @return int
     */
    function Create3DPhysicsSliderJoint($objA, $objB, $positionVec3, $rotationVec3)
    {
    }

    /**
     * Начинается создание физической тряпичной куклы для объекта. Вы должны добавить по крайней мере одну кость к
     * ragdoll, прежде чем вызывать Finalize3DPhysicsRagDoll(). Кости моделей должны иметь нулевое вращение в положении
     * по умолчанию/первом кадре анимации.
     *
     * @param int $objID идентификатор объекта
     * @param float $objTotalWeight Общий вес в фунтах. Этот вес делится между костями тряпичной куклы в зависимости от
     *     объема костей.
     * @return void
     */
    function Create3DPhysicsRagDoll($objID, $objTotalWeight)
    {
    }

    /**
     * Возвращает идентификатор соединения
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора положения
     * @return int
     */
    function Create3DPhysicsPickJoint($objID, $positionVec3)
    {
    }

    /**
     * Удаляет существующее физическое тело и создает форму столкновения коробки и кинематическое физическое тело для
     * объекта. Кинематическое тело может быть перемещено с помощью команд agk для позиционирования и вращения
     * объектов. Примечание: Кинематическое тело может взаимодействовать только с динамическим телом и будет проходить
     * через статическое тело.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Create3DPhysicsKinematicBody($objID)
    {
    }

    /**
     * Создает шарнирное соединение между объектами a и b. Параметр rotationVec3 должен быть осью в виде (0,1,0) для
     * вертикали, (1,0,0) для горизонтали вдоль оси X, (0,0,1) для горизонтали вдоль оси Z или любой их комбинации.
     * Вектор вращения не нуждается в нормализации. Возвращает идентификатор соединения.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $positionVec3 векторный ИДЕНТИФИКАТОР
     * @param int $rotationVec3 векторный ИДЕНТИФИКАТОР
     * @param int $disableCollisions 1 = коллизии будут отключены между связанными объектами, 0 коллизий будут включены
     *     между связанными объектами.
     * @return int
     */
    function Create3DPhysicsHingeJoint($objA, $objB, $positionVec3, $rotationVec3, $disableCollisions)
    {
    }

    /**
     * Создает фиксированное соединение между объектами a и b. Возвращает идентификатор соединения.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $positionVec3 векторный ИДЕНТИФИКАТОР
     * @return int
     */
    function Create3DPhysicsFixedJoint($objA, $objB, $positionVec3)
    {
    }

    /**
     * Создает 3D-физический контроллер символов для модели. Контроллер символов может быть создан на оси X, Y или Z.
     * Например, стоящий символ будет находиться на оси Y. Лежащий персонаж может быть на X или Z. Если модель имеет
     * смещение от начала координат, objOffsetVec3 необходим для выравнивания символьного контроллера с объектом. Если
     * объект не обращен лицом вниз к положительной оси Z, используйте objOrientationVec3 для настройки. Шкала
     * приседания регулирует размер капсулы приседания в соответствии с высотой вашей модели приседания.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 = Ось X, 1= ось Y, 2 = ось Z,
     * @param int $objOffsetVec3 Этот вектор составляет половину суммы, которую модель смещает от начала координат.
     * @param int $objOrientationVec3 Этот вектор используется для выравнивания вращения вашей модели с контроллером
     *     символов.
     * @param float $crouchScale Процентная величина для масштабирования скорченной капсулы в соответствии с согнутой
     *     моделью.
     * @return void
     */
    function Create3DPhysicsCharacterController($objID, $axis, $objOffsetVec3, $objOrientationVec3, $crouchScale)
    {
    }

    /**
     * Удаляет существующее физическое тело и создает динамическое тело для объекта с коробчатой формой столкновения и
     * массой 5,0 В зависимости от размера объекта.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Create3DPhysicsDynamicBody($objID)
    {
    }

    /**
     * Создает конусообразное скручивающее соединение между объектами а и в. Параметр rotationVec3 должен быть осью в
     * виде (0,1,0) для вертикали, (1,0,0) для горизонтали вдоль оси X, (0,0,1) для горизонтали вдоль оси Z или любой
     * их комбинации. Вектор вращения не нуждается в нормализации. Шарнир будет вращаться вдоль заданной оси и свободно
     * вращаться внутри конуса вдоль этой оси. Пределы конуса можно задать с помощью Set3DPhysicsJointConeTwistLimits.
     * Возвращает идентификатор соединения.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $positionVec3 векторный ИДЕНТИФИКАТОР
     * @param int $rotationVec3 векторный ИДЕНТИФИКАТОР
     * @param int $disableCollisions 1 = коллизии будут отключены между связанными объектами, 0 коллизий будут включены
     *     между связанными объектами.
     * @return int
     */
    function Create3DPhysicsConeTwistJoint($objA, $objB, $positionVec3, $rotationVec3, $disableCollisions)
    {
    }

    /**
     * Создает соединение 6 степеней свободы между объектами a и b. Возвращает идентификатор соединения.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $positionVec3 векторный ИДЕНТИФИКАТОР
     * @param float $rotationVec3 векторный ИДЕНТИФИКАТОР
     * @return int
     */
    function Create3DPhysics6DOFJoint($objA, $objB, $positionVec3, $rotationVec3)
    {
    }

    /**
     * Создает излучатель частиц с заданным идентификатором и заданным местоположением в мировых координатах.
     * Излучатели частиц создают поток маленьких спрайтов, которые длятся фиксированное количество времени, прежде чем
     * исчезнуть. Частицы могут подвергаться воздействию сил в течение своей жизни с помощью Add3DParticlesForce. Они
     * также могут менять цвет с течением времени с помощью Add3DParticleColorKeyFrame. Частицы не могут быть изменены
     * по отдельности и вести себя как группа, используя одну и ту же текстуру. Это позволяет AGK рисовать их более
     * эффективно, чем аналогичное количество обычных объектов.
     *
     * Пример вызова:
     *
     * int Create3DParticles($x, $y, $z);
     *
     * void Create3DParticles($ID, $x, $y, $z);
     * @param int $ID Идентификатор, используемый при ссылке на этот 3D-излучатель частиц.
     * @param float $x Координата x для позиционирования этого излучателя.
     * @param float $y Координата y для позиционирования этого излучателя.
     * @param float $z Координата z для позиционирования этого излучателя.
     * @return mixed
     */
    function Create3DParticles(mixed...$args) : mixed
    {
    }

    /**
     * Подсчитывает количество токенов, разделенных указанным разделителем, например строка, содержащая
     * "first:second:third", имеет три токена, разделенных ":". Аналогично CountStringTokens, за исключением того, что
     * эта команда принимает только один символ в качестве разделителя и распознает пустые поля. Например,
     * "first:second::fourth" имеет четыре токена, а третий-пустую строку.
     *
     * @param string $str Строка для проверки.
     * @param string $delimiter Символ, который ограничивает строку
     * @return int
     */
    function CountStringTokens2($str, $delimiter)
    {
    }

    /**
     * Возвращает количество дисков, доступных в данный момент на этих устройствах, применяется только к Windows.
     * Другие платформы вернут 0.
     *
     * @return int
     */
    function CountWindowsDrives()
    {
    }

    /**
     * Подсчитывает количество токенов, разделенных заданным набором разделителей, например строка, содержащая
     * "first:second:third", имеет три токена, разделенных ":" и "first:second;third", имеет три токена, разделенных
     * разделителями ":;". Вы можете иметь несколько разделителей между каждым токеном, например "first:;second:third"
     * является допустимым и имеет три токена. Эта команда полезна для разделения слов в предложении, которое может
     * быть разделено как пробелом, так и пунктуацией.
     *
     * @param string $str Строка для проверки.
     * @param string $delimiters Набор символов, разделяющих строку
     * @return int
     */
    function CountStringTokens($str, $delimiters)
    {
    }

    /**
     * Возвращает косинус значения в радианах.
     *
     * @param float $a Значение, которое нужно передать в функцию косинуса.
     * @return float
     */
    function CosRad($a)
    {
    }

    /**
     * Возвращает косинус значения в градусах.
     *
     * @param float $a Значение, которое нужно передать в функцию косинуса.
     * @return float
     */
    function Cos($a)
    {
    }

    /**
     * Копирует часть данного изображения в новое изображение. Значения x, y, width, height выражены в пикселях и
     * представляют собой часть изображения, которую вы хотите скопировать в новое изображение. Новое изображение будет
     * иметь тот же размер, что и заданные значения ширины и высоты. Если изображение уже существует с заданным новым
     * идентификатором, его необходимо удалить перед вызовом этой команды. Это медленная команда, и ее не следует
     * вызывать каждый кадр.
     *
     * Пример вызова:
     *
     * void CopyImage($newImage, $fromImage, $x, $y, $width, $height);
     *
     * int CopyImage($fromImage, $x, $y, $width, $height);
     *
     * @param int $newImage Идентификатор создаваемого нового образа, этот образ не должен существовать
     * @param int $fromImage Идентификатор изображения для копирования
     * @param int $x Координата x верхнего левого угла поля для копирования
     * @param int $y Координата y верхнего левого угла поля для копирования
     * @param int $width Ширина коробки для копирования
     * @param int $height Высота коробки для копирования
     * @return mixed
     */
    function CopyImage(int...$args) : mixed
    {
    }


    /**
     * Создает сетевое сообщение, которое является копией существующего сообщения. Он возвращает идентификатор, который
     * можно использовать для взаимодействия с сообщением. Сообщения, созданные таким образом, могут быть прочитаны с
     * самого начала или добавлены, и источником сообщения может быть либо созданное вами сообщение, либо полученное
     * вами. Новое сообщение становится полностью независимым от исходного сообщения и может быть отправлено с помощью
     * SendNetworkMessage, не затрагивая оригинал.
     *
     * @param int $iFromMsgID Идентификатор сообщения для копирования
     * @return int
     */
    function CopyNetworkMessage($iFromMsgID)
    {
    }

    /**
     * Копирует часть одного мемблока в другой. Оба memblocks должны существовать и могут быть разных размеров.
     *
     * @param int $memSrcID Идентификатор memblock для копирования.
     * @param int $memDstID Идентификатор memblock для копирования.
     * @param int $srcOffset Смещение в исходном memblock для начала копирования.
     * @param int $dstOffset Смещение целевого мемблока для копирования.
     * @param int $size Количество байтов для копирования.
     * @return void
     */
    function CopyMemblock($memSrcID, $memDstID, $srcOffset, $dstOffset, $size)
    {
    }

    /**
     * Создает сокет и пытается подключиться к указанному IP-адресу. Это создаст TCP-соединение, которое затем можно
     * будет использовать для отправки и получения данных. Эта команда немедленно вернется и подключится в фоновом
     * режиме, вы должны использовать GetSocketConnected, чтобы проверить, успешно ли подключается сокет или нет. Вы
     * должны указать значение тайм-аута, достаточное для подключения сокета, обычно 3000 миллисекунд-это хорошее
     * значение, но для соединений с высокой задержкой может потребоваться больше времени. Если время ожидания
     * соединения истекло, то эта команда вернет 0. Номер порта должен совпадать с портом прослушивания устройства, к
     * которому вы подключаетесь. Это работает немного по-другому при экспорте в HTML5, он использует WebSocket,
     * который отправляет заголовок стиля HTTP и требует ответа стиля HTTP для подключения.
     *
     * Пример вызова:
     *
     * int ConnectSocket($socketID, $szIP, $port, $timeout);
     *
     * int ConnectSocket($szIP, $port, $timeout);
     *
     * @param int $socketID Идентификатор, который будет использоваться для ссылки на этот сокет позже
     * @param string $szIP IP-адрес для подключения, это может быть IPv4 или IPv6
     * @param int $port TCP-порт для подключения в диапазоне от 1025 до 65535
     * @param int $timeout Время в миллисекундах ожидания перед прерыванием попытки подключения
     * @return int
     */
    function ConnectSocket(mixed...$args): int
    {
    }

    /**
     * Ждет завершения обнаружения физических джойстиков, в некоторых системах это может занять несколько секунд,
     * поэтому запускается в отдельном потоке вдоль основного приложения. Если вы не используете ни одну из реальных
     * команд джойстика (включая джойстик AGK), вы можете игнорировать эту команду и позволить обнаружению джойстика
     * завершиться, когда ему заблагорассудится. Однако если вы хотите использовать команды джойстика в своем
     * приложении, вы должны вызвать эту команду, чтобы убедиться, что общее количество подключенных джойстиков
     * найдено. После этого первоначального процесса обнаружения подключение дополнительных джойстиков не будет
     * обнаружено.
     *
     * @return void
     */
    function CompleteRawJoystickDetection()
    {
    }


    /**
     * Возвращает 1, если две строки равны друг другу, в противном случае возвращает 0. По умолчанию этот параметр не
     * чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру. Используйте
     * параметр maxChars, чтобы указать максимальное количество символов для проверки, если строки совпадают после
     * того, как было проверено много символов, то они считаются равными. Используйте значение -1 для проверки всех
     * символов независимо от длины.
     *
     * @param string $str Первая строка для проверки
     * @param string $str2 Вторая строка для проверки
     * @param null $ignoreCase 1-игнорировать регистр при сравнении, 0
     * @param null $maxChars Количество символов для проверки, минус 1 для всех
     * @return int
     */
    function CompareString(string $str, string $str2, $ignoreCase = null, $maxChars = null) : int
    {
    }

    /**
     * Закрывает zip-файл, открытый с помощью CreateZip. Это завершает работу zip-файла и позволяет открыть его для
     * извлечения.
     *
     * @param int $zipID Идентификатор zip-файла, который нужно закрыть.
     * @return void
     */
    function CloseZip($zipID)
    {
    }

    /**
     * Закрывает ранее открытую папку и освобождает список файлов, который был сгенерирован для нее. Фактические
     * изменения файловой системы не производятся, то есть папка не удерживается открытой в файловой системе. Папка
     * читается полностью во время OpenRawFolder, поэтому она не должна существовать в файловой системе после вызова
     * этой команды.
     *
     * @param int $ID Идентификатор папки для закрытия
     * @return void
     */
    function CloseRawFolder($ID)
    {
    }

    /**
     * Отключается от указанной сети. Идентификатор освобождается и больше не может использоваться в других сетевых
     * командах.
     *
     * @param int $iNetID Идентификатор сети, от которой требуется отключиться.
     * @return void
     */
    function CloseNetwork($iNetID)
    {
    }

    /**
     * Закрывает соединение с сервером, дальнейшие соединения могут быть созданы, если вы снова вызовете SetHTTPHost.
     *
     * @param int $iHTTP Идентификатор соединения для закрытия.
     * @return void
     */
    function CloseHTTPConnection($iHTTP)
    {
    }

    /**
     * Закрывает файл и очищает идентификатор, используемый для его создания, никакие другие команды файла не могут
     * быть вызваны с этим идентификатором.
     *
     * @param int $iFileID Идентификатор файла для закрытия
     * @return void
     */
    function CloseFile($iFileID)
    {
    }

    /**
     * Клонирует спрайт в заданный идентификатор спрайта. Новый спрайт будет находиться точно в том же положении, что и
     * оригинал. Любые физические значения или формы, присвоенные спрайту, не будут скопированы. Новый спрайт не будет
     * настроен на физику.
     *
     * Пример вызова:
     *
     * int CloneSprite($iOtherSprite); - вернет ID клона спрайта.
     *
     * void CloneSprite($iSpriteIndex, $iOtherSprite); - задаем ID клона спрайта.
     *
     * @param int $iSpriteIndex Идентификатор, который будет использоваться для нового спрайта.
     * @param int $iOtherSprite Идентификатор спрайта для копирования.
     * @return mixed
     */
    function CloneSprite(int...$SpriteId) : mixed
    {
    }


    /**
     * Копирует объект в новый идентификатор, новый объект полностью отделен от исходного объекта. Клонирование
     * экземпляра объекта приведет к созданию другого экземпляра, который совместно использует данные вершин с исходным
     * объектом.
     *
     * Пример вызова:
     *
     * int CloneObject($objID); - вернет ID нового глона.
     *
     * void CloneObject($objID, $objID); - задаем ID нового клона.
     *
     *
     * @param int ...$objID Идентификатор нового объекта либо идентификатор объекта для копирования.
     * @return mixed
     */
    function CloneObject(int ...$objID) : mixed
    {
    }

    /**
     * Очищает сохраненный в данный момент текст схемы URL - адреса, чтобы вы могли сигнализировать о том, что
     * действовали в соответствии с ним. Это не обязательно, но может сделать ваш код проще, если вам не нужно помнить,
     * что вы имели дело с событием схемы URL.
     *
     * @return void
     */
    function ClearURLSchemeText()
    {
    }

    /**
     * Опустошает цепочку всех подростков и останавливает тех, кто бежал. Любые подростки, которые были добавлены к
     * нему, не затрагиваются и могут быть использованы в будущих цепочках.
     *
     * @param int $chainID Идентификатор цепочки твинов для очистки
     * @return void
     */
    function ClearTweenChain(int $chainID)
    {
    }

    /**
     * Удаляет все дополнительные фигуры, примененные к спрайту, и сохраняет только базовую фигуру в shapeID 1.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @return void
     */
    function ClearSpriteShapes(int $iSpriteIndex)
    {
    }

    /**
     * Удаляет все анимационные кадры из спрайта, возвращая его в один спрайт изображения. Если вы добавили изображения
     * по отдельности в спрайт с помощью AddSpriteAnimationFrame, то изображение спрайта будет неопределенным, и
     * рекомендуется назначить ему новое изображение.
     *
     * @param int $iSpriteIndex Идентификатор спрайта нужно очистить.
     * @return void
     */
    function ClearSpriteAnimationFrames(int $iSpriteIndex)
    {
    }

    /**
     * Очищает все модификаторы размера, которые были назначены эмиттеру, частицы будут поддерживать любой размер,
     * который они в настоящее время имеют.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function ClearParticlesScales(int $ID)
    {
    }

    /**
     * Очищает все силы, назначенные этому излучателю. Все силы немедленно перестанут влиять на частицы.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function ClearParticlesForces(int $ID)
    {
    }

    /**
     * Очищает все цвета, которые были назначены излучателю, частицы будут поддерживать любой цвет, который они имеют в
     * данный момент.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function ClearParticlesColors(int $ID)
    {
    }

    /**
     * Очищает все силы, назначенные этому излучателю. Все силы немедленно перестанут влиять на частицы.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function Clear3DParticlesForces(int $ID)
    {
    }

    /**
     * Очищает все модификаторы размера, которые были назначены эмиттеру, частицы будут поддерживать любой размер,
     * который они в настоящее время имеют.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function Clear3DParticlesScales(int $ID)
    {
    }

    /**
     * Возвращает строку переданного значения Unicode.
     *
     * @param int $unicodevalue Строка для измерения длины
     * @return string
     */
    function Chr($unicodevalue)
    {
    }

    /**
     * Очищает все цвета, которые были назначены излучателю, частицы будут поддерживать любой цвет, который они имеют в
     * данный момент.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function Clear3DParticlesColors($ID)
    {
    }

    /**
     * Удаляет все точечные огни.
     *
     * @return void
     */
    function ClearPointLights()
    {
    }

    /**
     * Очищает задний буфер и буфер глубины всего рисунка и заполняет его выбранным прозрачным цветом, установленным
     * SetClearColor. Это не влияет на то, что видно на экране, если только Swap не вызывается для отображения заднего
     * буфера на экран. Это позволяет вам нарисовать некоторые вещи в backbuffer, использовать getImage для хранения
     * результата, а затем ClearScreen для рисования чего-то еще.
     *
     * @return void
     */
    function ClearScreen()
    {
    }


    /**
     * Предоставляет пользователю возможность выбрать файл, хранящийся на его текущей платформе (только для
     * Windows/Mac), например фото или звуковой файл. Если пользователь отменит операцию, будет возвращена пустая
     * строка, в противном случае файл будет скопирован в текущий каталог приложений и возвращено имя файла, чтобы его
     * можно было использовать в вашем приложении. Вы можете указать дополнительный фильтр расширений, чтобы ограничить
     * типы файлов, которые пользователь будет видеть при просмотре. Например, использование фильтра расширения "*.wav"
     * ограничит пользователя выбором файлов .wav. Для нескольких расширений разделите их точкой с запятой, например
     * "*.wav;*.mp3;*.png". Если эта команда используется в tier 2, возвращаемая строка должна быть удалена, когда вы
     * закончите с ней, даже если это пустая строка. Нулевая строка не будет возвращена. Если вы установите
     * returnFullPath равным 1, то файл не будет скопирован в папку записи, вместо этого вам будет возвращен полный
     * путь, и вы можете загрузить его с помощью префикса "raw:" с обычными файловыми командами.
     *
     * @param string $ext Расширения, позволяющие
     * @param int|null $returnFullPath 1, чтобы вернуть полный путь, 0, чтобы скопировать его в папку записи и вернуть путь
     *     к папке записи
     * @return string
     */
    function ChooseRawFile(string $ext, int $returnFullPath = null): string
    {
    }

    /**
     * Только для Android все остальные платформы вернут 1 и ничего не сделают. Проверяет, предоставил ли пользователь
     * вашему приложению указанное разрешение на использование определенных команд Android. Разрешения следующие:
     * "writeExternal" - используется командами SaveSharedVariable и любыми путями "raw:", которые обращаются к
     * SD-карте. "Location" - используется командами GPS "Camera" - используется командой SetDeviceCameraToImage
     * "RecordAudio" - используется командой StartScreenRecording и для канала AR camera Эта команда вернет 0, если у
     * вас нет разрешения и пользователя еще не спросили, вы должны вызвать requestPermission, если вам это нужно. Эта
     * команда возвращает 1 если пользователь находится в процессе запроса разрешения, вы должны дождаться ответа,
     * продолжая вызывать эту команду. Он вернет -1, если пользователь отклонил разрешение, или 2, если пользователь
     * предоставил разрешение. Если пользователь отклоняет ваш запрос, вы можете спросить еще раз, но сначала вы должны
     * объяснить, почему ваше приложение нуждается в нем, чтобы они могли сделать осознанный выбор. Если они все еще
     * отвергают его, вы обычно не должны спрашивать в третий раз. После первой попытки Android предоставит
     * пользователю возможность никогда не разрешать это разрешение. В этом случае эта команда всегда будет возвращать
     * -1, а requestPermission ничего не сделает. Пользователю придется зайти в настройки приложения устройства, чтобы
     * отменить это решение. Любое разрешение, не указанное здесь, не требует от вас запроса разрешения пользователя,
     * оно будет автоматически предоставлено при установке, если ваше приложение этого требует. Все разрешения, которые
     * использует ваше приложение, даже те, которые требуют запроса, должны быть указаны в диалоговом окне экспорта
     * APK, установив соответствующие флажки.
     *
     * @param string $szPermission Разрешение на проверку
     * @return int
     */
    function CheckPermission($szPermission)
    {
    }

    /**
     * Округляет поплавок до следующего по величине целого числа. Это отличается от Trunc при использовании
     * положительных чисел, Trunc( 1.6 ) равен 1, а Ceil( 1.6 ) равен 2.
     *
     * @param float $a Значение для округления.
     * @return int
     */
    function Ceil($a)
    {
    }

    /**
     * Останавливает любое асинхронное извлечение zip-файла, которое выполняется в данный момент, это может занять
     * некоторое время, чтобы закончить текущий файл, а затем он остановится. Как только он завершится,
     * GetZipExtractComplete вернет 1, а GetZipExtractProgress останется на том же значении, на котором он был в данный
     * момент.
     *
     * @return void
     */
    function CancelZipExtract()
    {
    }

    /**
     * Отменяет уведомление, запланированное этим приложением
     *
     * @param int $iID ИДЕНТИФИКАТОР уведомления об отмене
     * @return void
     */
    function CancelLocalNotification($iID)
    {
    }

    /**
     * Очищает буфер глубины всех объектов. Это очистит буфер, даже если очистка глубины была отключена с помощью
     * EnableClearDepth.
     *
     * @return void
     */
    function ClearDepthBuffer()
    {
    }

    /**
     * Пересчитывает COM на основе фигур, прикрепленных к спрайту, если вы переопределили COM, это вернет его обратно в
     * местоположение, определенное AGK. Если COM сильно отличается от точки смещения, спрайт может показаться
     * нестабильным, так как он будет вести себя как несбалансированный волчок.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @return void
     */
    function CalculateSpritePhysicsCOM($iSpriteIndex)
    {
    }

    /**
     * Кэширует полноэкранную видеорекламу награды для последующего отображения с помощью Chartboost. Перед вызовом
     * этой функции вы должны установить данные своего рекламного аккаунта с помощью SetChartboostDetails. И iOS, и
     * Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление уже
     * было кэшировано, то это ничего не даст. В отличие от AdMob, reward videos не будет автоматически запускать
     * кэширование с помощью Chartboost, если вы не вызовете эту команду. Это связано с тем, что Chartboost использует
     * одни и те же детали как для интерстициальных, так и для наградных видео, поэтому AGK не может заранее знать,
     * какие именно вы используете. Поскольку видеореклама может использовать много мобильных данных, процесс их
     * кэширования не будет запущен автоматически. Вам нужно сделать это только один раз, после того как видеореклама с
     * вознаграждением будет показана, новая будет автоматически кэширована. Сбой в загрузке объявления может быть
     * вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете
     * проверить, ждет ли объявление показа с помощью GetRewardAdLoadedChartboost.
     *
     * @return void
     */
    function CacheRewardAdChartboost()
    {
    }

    /**
     * Преобразует целочисленное значение в строку, содержащую его двоичное представление. Например, Bin(7) вернет
     * строку, содержащую "111". Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы
     * закончите с ней.
     *
     * @param int $i Значение Inegert для преобразования в двоичную строку
     * @return string
     */
    function Bin($i)
    {
    }

    /**
     * Возвращает количество байтов в данной строке. Обратите внимание, что для строк, закодированных в UTF-8, это
     * может быть не равно количеству символов в строке, так как каждый символ может использовать до 4 байт. Чтобы
     * определить количество символов в строке, используйте команду Len.
     *
     * @param string $strin Строка для измерения длины
     * @return int
     */
    function ByteLen($strin)
    {
    }

    /**
     * Добавляет локальный файл в zip-файл. Переменная path-это путь к локальному файлу, переменная ZipPath-это путь,
     * который будет использоваться внутри zip-файла, это единственный способ добавить папки в zip-файл (добавив файл с
     * ZipPath, например "folder1/myfile.txt"). Локальный путь к файлу находится относительно текущего каталога,
     * установленного с помощью SetFolder, если только вы не начинаете путь с прямой косой черты, и в этом случае путь
     * будет относительно корня каталога записи на текущей платформе.
     *
     * @param int $zipID Идентификатор zip-файла для добавления.
     * @param string $path Путь к добавляемому файлу.
     * @param string $zipPath Путь к файлу внутри zip-файла.
     * @return void
     */
    function AddZipEntry($zipID, $path, $zipPath)
    {
    }

    /**
     * Преобразует одну символьную строку в значение Unicode, которое она представляет.
     *
     * @param string $strin Строковый символ для преобразования в значение Unicode
     * @return int
     */
    function Asc($strin)
    {
    }

    /**
     * Создает экранный джойстик, которым можно управлять с помощью сенсорного экрана, мыши или другого указательного
     * устройства. Они отделены от физических джойстиков, так что у вас может быть виртуальный джойстик с
     * идентификатором 1 и реальный джойстик с идентификатором 1. У вас может быть до 4 виртуальных джойстиков на
     * экране одновременно. Если виртуальный джойстик находится на экране и при нажатии или касании джойстик захватит
     * это событие, а GetRawMouseLeftState вернет 0 (вверх), и событие касания не будет сгенерировано для этого
     * действия.
     *
     * @param int $index Идентификатор создаваемого виртуального джойстика должен находиться в диапазоне от 1 до 4.
     * @param float $x x-положение центра джойстика в экранных координатах.
     * @param float $y Положение y центра джойстика в экранных координатах.
     * @param float $size Диаметр джойстика в экранных координатах.
     * @return void
     */
    function AddVirtualJoystick($index, $x, $y, $size)
    {
    }

    /**
     * Применяет данный идентификатор анимации к заданному идентификатору текстового объекта с необязательной задержкой
     * и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким текстовым объектам одновременно,
     * просто вызовите эту команду снова с другим идентификатором текстового объекта. Текстовый объект не будет изменен
     * до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего
     * анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации.
     * Если конечное значение анимации изменяется во время воспроизведения анимации на текстовом объекте, текст будет
     * соответствующим образом корректировать свою интерполяцию. Изменение продолжительности во время игры не
     * определено и не совместимо с цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param int $textID ИДЕНТИФИКАТОР текста для изменения
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainText($chainID, $tweenID, $textID, $delay)
    {
    }

    /**
     * Применяет данный идентификатор анимации к заданному идентификатору спрайта с необязательной задержкой и
     * добавляет его в конец цепочки. Анимация может быть добавлена к нескольким спрайтам одновременно, просто вызовите
     * эту команду снова с другим идентификатором спрайта. Спрайт не будет изменен до тех пор, пока все предыдущие
     * подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных
     * значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное
     * значение анимации изменяется во время воспроизведения анимации на спрайте, то спрайт соответствующим образом
     * скорректирует свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с
     * цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param int $spriteID Идентификатор изменяемого спрайта
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainSprite($chainID, $tweenID, $spriteID, $delay)
    {
    }

    /**
     * Применяет данный идентификатор анимации к заданному идентификатору объекта с необязательной задержкой и
     * добавляет его в конец цепочки. Анимация может быть добавлена к нескольким объектам одновременно, просто вызовите
     * эту команду снова с другим идентификатором объекта. Объект не будет изменен до тех пор, пока все предыдущие
     * подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных
     * значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации
     * изменяется во время воспроизведения анимации на объекте, объект соответствующим образом настраивает свою
     * интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param int $objectID ИДЕНТИФИКАТОР объекта для изменения
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainObject($chainID, $tweenID, $objectID, $delay)
    {
    }

    /**
     * Добавляет данный пользовательский идентификатор анимации в конец цепочки с необязательной задержкой. Анимация не
     * начнется до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после
     * чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей
     * продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации, она
     * соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и
     * не совместимо с цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainCustom($chainID, $tweenID, $delay)
    {
    }

    /**
     * Применяет заданный идентификатор анимации к заданному символу в текстовом объекте с необязательной задержкой и
     * добавляет его в конец цепочки. Анимация может быть добавлена к нескольким символам одновременно, просто вызовите
     * эту команду снова с другим символом или текстовым идентификатором. Символ не будет изменен до тех пор, пока все
     * предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с
     * начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если
     * конечное значение анимации изменяется во время воспроизведения анимации на символе, то символ соответствующим
     * образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с
     * цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param int $textID Идентификатор текстового объекта, содержащего символ
     * @param int $charID Индекс изменяемого символа, индексы начинаются с 0
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainChar($chainID, $tweenID, $textID, $charID, $delay)
    {
    }

    /**
     * Добавляет новую форму к спрайту в дополнение к уже имеющимся. Эти дополнительные фигуры применимы только к
     * физическим спрайтам и должны быть добавлены после того, как спрайт был настроен на использование физики. Полигон
     * определяется набором точек (от 2 до 12) относительно смещения текущего спрайта. Например, точка 0,0 будет
     * центрирована на точке смещения спрайта, любое другое значение будет смещено от этой точки. Точки определяются по
     * одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен
     * numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете определять
     * точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой
     * фигуры. Это приведет к пересчету значений массы и центра масс спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $numPoints Количество точек, используемых в полигоне, не менее 2, не более 12.
     * @param int $index Индекс для точек, поэтому вы можете указать индекс 0, 1, 2 и т. Д.
     * @param float $x Положение X для указанной точки.
     * @param float $y Положение Y для указанной точки.
     * @return void
     */
    function AddSpriteShapePolygon($iSpriteIndex, $numPoints, $index, $x, $y)
    {
    }

    /**
     * Добавляет новую форму к спрайту в дополнение к уже имеющимся. Эти дополнительные фигуры применимы только к
     * физическим спрайтам и должны быть добавлены после того, как спрайт был настроен на использование физики.
     * Окружность определяется путем указания ее центральной точки относительно текущего смещения спрайта и радиуса.
     * Например, если круг должен быть центрирован в точке смещения спрайта, он будет указан в позиции 0,0. Любое
     * другое значение будет смещать круг от спрайта. Радиус определяется в координатах x, поскольку мировые координаты
     * не обязательно представляют размер элементов на экране (например, 10 единиц в X могут быть не такими же видимыми
     * размерами, как 10 единиц в Y). Это приведет к пересчету значений массы и центра масс спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата X центра окружности в спрайтовом пространстве.
     * @param float $y Координата Y центра окружности в спрайтовом пространстве.
     * @param float $radius Радиус окружности.
     * @return void
     */
    function AddSpriteShapeCircle($iSpriteIndex, $x, $y, $radius)
    {
    }

    /**
     * Добавляет новую форму к спрайту в дополнение к уже имеющимся. Фигуры могут быть добавлены, даже если спрайт не
     * настроен на физику. Цепочка определяется набором точек (не менее 2) относительно смещения текущего спрайта.
     * Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено от этой
     * точки. Цепи являются жесткими и могут быть использованы для создания полых вогнутых полигонов или 2D-ландшафтов.
     * Установите параметр loop равным 1, чтобы соединить два конца цепочки вместе, создав полый многоугольник. Точки
     * определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс
     * равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете
     * определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для
     * любой другой фигуры. Это приведет к пересчету значений массы и центра масс спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $numPoints Количество точек для использования в цепочке, минимум 2, максимум нет.
     * @param int $index Индекс точки для установки, если он равен numPoints-1, то будет создана фигура
     * @param int $loop 1=соедините это обратно с первой точкой, создавая петлю, 0=оставьте эту точку висеть на конце
     *     (по умолчанию)
     * @param float $x Положение X для указанной точки.
     * @param float $y Положение Y для указанной точки.
     * @return void
     */
    function AddSpriteShapeChain($iSpriteIndex, $numPoints, $index, $loop, $x, $y)
    {
    }

    /**
     * Создает экранную кнопку, которой можно управлять с помощью сенсорного экрана, мыши или другого указательного
     * устройства. Они отделены от физических кнопок джойстика или клавиш клавиатуры, так что у вас может быть
     * виртуальная кнопка с идентификатором 1 и реальная кнопка джойстика с идентификатором 1. У вас может быть до 100
     * виртуальных кнопок на экране одновременно. Если виртуальная кнопка находится на экране и нажата или тронута, то
     * кнопка захватит это событие, а GetRawMouseLeftState вернет 0 (вверх), и событие касания не будет сгенерировано
     * для этого действия.
     *
     * @param int $index Идентификатор виртуальной кнопки, которую нужно создать, должен находиться в диапазоне от 1 до
     *     100.
     * @param float $x x-положение центра кнопки в координатах экрана.
     * @param float $y Положение y центра кнопки в координатах экрана.
     * @param float $size Диаметр кнопки в экранных координатах.
     * @return void
     */
    function AddVirtualButton($index, $x, $y, $size)
    {
    }

    /**
     * Добавляет новую форму к спрайту в дополнение к уже имеющимся. Эти дополнительные фигуры применимы только к
     * физическим спрайтам и должны быть добавлены после того, как спрайт был настроен на использование физики. Поле
     * определяется путем указания его верхних левых и нижних правых координат в пространстве спрайтов относительно его
     * текущего смещения. Например, если текущее смещение спрайта равно 0,0, то верхний левый угол коробки будет равен
     * 0,0, но если смещение спрайта равно середине спрайта (по умолчанию), то верхний левый угол будет
     * равен-width/2,-height/2. Вы также можете указать угол смещения коробки относительно текущего поворота спрайта.
     * Это приведет к пересчету значений массы и центра масс спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата X верхнего левого угла нового окна в пространстве спрайтов.
     * @param float $y Координата Y верхнего левого угла нового окна в пространстве спрайтов.
     * @param float $x2 Координата X в правом нижнем углу нового окна в пространстве спрайтов.
     * @param float $y2 Координата Y в правом нижнем углу нового окна в пространстве спрайтов.
     * @param float $angle Угол коробки в радианах.
     * @return void
     */
    function AddSpriteShapeBox($iSpriteIndex, $x, $y, $x2, $y2, $angle)
    {
    }

    /**
     * Добавляет изменение размера в определенный момент жизни частицы. Значения шкалы относительны к значению,
     * заданному SetParticlesSize, поэтому шкала 2 означает удвоение ее нормального размера, а 0,5-половину ее
     * нормального размера. Масштаб, добавленный со временем=1, сделает частицу равной заданному размеру, когда она
     * была жива в течение 1 секунды. Частица постепенно преобразуется из своего текущего размера в следующий.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время, за которое частицы должны стать такого размера.
     * @param float $scale Масштаб относительно нормального размера частиц должен быть больше или равен 0.
     * @return void
     */
    function AddParticlesScaleKeyFrame($ID, $time, $scale)
    {
    }

    /**
     * Добавляет изображение в спрайт в качестве нового анимационного кадра. Индексы фреймов начинаются с 1 и
     * постепенно увеличиваются. Это изображение может быть совместно использовано несколькими спрайтами либо в виде
     * отдельных изображений, либо в виде анимационных кадров, а также может быть частью текстуры атласа. В качестве
     * альтернативы, если у вас есть все ваши анимационные кадры на одном изображении, вы можете использовать более
     * быстрый SetSpriteAnimation, который позволяет избежать изменений изображения во время рендеринга, изменяя
     * UV-координаты для изменения кадра.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно установить для анимации.
     * @param int $iImageIndex Идентификатор добавляемого изображения.
     * @return void
     */
    function AddSpriteAnimationFrame($iSpriteIndex, $iImageIndex)
    {
    }

    /**
     * Добавляет силу, которая будет действовать в данный момент в жизни каждой частицы. Например, сила, установленная
     * для начала в момент времени 2 и окончания в момент времени 3, начнет воздействовать на частицы, когда они будут
     * живы в течение 2 секунд. Он будет продолжать действовать на эти частицы до тех пор, пока они не оживут в течение
     * 3 секунд. Влияние силы определяется величинами x и y, которые представляют ускорение в единицах в секунду.
     * Например, сила с x=5 будет регулировать горизонтальную скорость частицы, добавляя 5 единиц за каждую секунду,
     * когда сила активна, если сила активна только в течение 0,5 секунды, то частица будет двигаться на 2,5 единицы в
     * секунду быстрее вправо. Несколько сил могут действовать на частицу одновременно, если их временные интервалы
     * перекрываются.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $starttime Время в жизни частицы, в которое эта сила должна начать действовать.
     * @param float $endtime Время в жизни частицы, в которое эта сила должна прекратить свое действие.
     * @param float $x х-составляющая влияния силы на скорость частицы в единицах в секунду.
     * @param float $y y-составляющая влияния силы на скорость частицы в единицах в секунду.
     * @return void
     */
    function AddParticlesForce($ID, $starttime, $endtime, $x, $y)
    {
    }

    /**
     * Добавляет изменение цвета в определенный момент жизни частицы. Например, цвет, добавленный со временем=1,
     * сделает частицу равной данному цвету, когда она была жива в течение 1 секунды. Если цветовая интерполяция
     * включена с помощью SetParticlesColorInterpolation, частица постепенно преобразуется из своего текущего цвета в
     * следующий. Например, если вы добавите три цвета: красный, когда время=1, зеленый, когда время=2, и синий, когда
     * время=3, то частица начнет свою жизнь как красный (поскольку это ближайший цвет) и останется полностью красной,
     * пока ей не исполнится 1 секунда. Когда частице от 1 до 2 секунд, она будет постепенно меняться с красного на
     * зеленый, пока ей не исполнится 2 секунды, в этот момент она полностью зеленая. Когда частице от 2 до 3 секунд,
     * она будет постепенно меняться от зеленого до синего, пока ей не исполнится 3 секунды, в этот момент она
     * полностью синяя. Частица останется полностью синей до конца своей жизни, так как никакие другие цвета не были
     * добавлены.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время, когда частицы должны стать такого цвета.
     * @param int $red Красная составляющая нового цвета.
     * @param int $green Зеленая составляющая нового цвета.
     * @param int $blue Синий компонент нового цвета.
     * @param int $alpha Альфа-компонент нового цвета.
     * @return void
     */
    function AddParticlesColorKeyFrame($ID, $time, $red, $green, $blue, $alpha)
    {
    }

    /**
     * Добавляет форму столкновения сфер к составной форме. Сначала установите форму объектов в составную форму
     * столкновения с помощью SetObjectShapeCompound().
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора вектора с мировым положением для центра фигуры.
     * @param float $diameter размер формы сферы
     * @return void
     */
    function AddObjectShapeSphere($objID, $positionVec3, $diameter)
    {
    }

    /**
     * Добавляет форму столкновения цилиндров к сложной форме. Сначала установите форму объектов в составную форму
     * столкновения с помощью SetObjectShapeCompound().
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора вектора с мировым положением для центра фигуры.
     * @param int $rotationVec3 Вектор ID вектора с мировым вращением фигуры.
     * @param int $sizeVec3 Идентификатор вектора вектора с размером фигуры.
     * @param int $axis 0 = ось X, 1 = ось Y, 2 = ось Z.
     * @return void
     */
    function AddObjectShapeCylinder($objID, $positionVec3, $rotationVec3, $sizeVec3, $axis)
    {
    }

    /**
     * Добавляет форму столкновения конуса к сложной форме. Сначала установите форму объектов в составную форму
     * столкновения с помощью SetObjectShapeCompound().
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора вектора с мировым положением для центра фигуры.
     * @param int $rotationVec3 Вектор ID вектора с мировым вращением фигуры.
     * @param int $sizeVec3 Идентификатор вектора вектора с размером фигуры.
     * @param int $axis 0 = ось X, 1 = ось Y, 2 = ось Z.
     * @return void
     */
    function AddObjectShapeCone($objID, $positionVec3, $rotationVec3, $sizeVec3, $axis)
    {
    }

    /**
     * Добавляет форму столкновения капсул к сложной форме. Сначала установите форму объектов в составную форму
     * столкновения с помощью SetObjectShapeCompound().
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора вектора с мировым положением для центра фигуры.
     * @param int $rotationVec3 Вектор ID вектора с мировым вращением фигуры.
     * @param int $sizeVec3 Идентификатор вектора вектора с размером фигуры.
     * @param int $axis 0 = ось X, 1 = ось Y, 2 = ось Z.
     * @return void
     */
    function AddObjectShapeCapsule($objID, $positionVec3, $rotationVec3, $sizeVec3, $axis)
    {
    }

    /**
     * Применяет данный идентификатор анимации к данному идентификатору камеры с дополнительной задержкой и добавляет
     * его в конец цепочки. Анимация может быть добавлена к нескольким камерам одновременно, просто вызовите эту
     * команду еще раз с другим идентификатором камеры. Камера не будет изменена до тех пор, пока все предыдущие
     * подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных
     * значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное
     * значение анимации изменяется во время воспроизведения анимации на камере, камера соответствующим образом
     * настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с
     * цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param int $cameraID Идентификатор камеры для изменения
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainCamera($chainID, $tweenID, $cameraID, $delay)
    {
    }

    /**
     * Добавляет форму столкновения коробок к составной форме. Сначала установите форму объектов в составную форму
     * столкновения с помощью SetObjectShapeCompound().
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора вектора с мировым положением для центра фигуры.
     * @param int $rotationVec3 Вектор ID вектора с мировым вращением фигуры.
     * @param int $sizeVec3 Идентификатор вектора вектора с размером фигуры.
     * @return void
     */
    function AddObjectShapeBox($objID, $positionVec3, $rotationVec3, $sizeVec3)
    {
    }

    /**
     * Добавляет новую сетку к объекту, построенному из данного memblock. Первые 4 байта memblock представляют
     * количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом
     * случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число
     * индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между
     * многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта
     * представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные
     * атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все
     * остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по
     * атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете
     * легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет.
     * После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают,
     * как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута
     * существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X
     * байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего,
     * например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество
     * компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2
     * компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4
     * компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных
     * unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг
     * нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда должен быть
     * кратен 4 по соображениям выравнивания, сама строка может иметь немного меньше символов, но всегда округляется до
     * ближайшего кратного 4 для значения длины строки. например, строка длины 5 должна иметь значение длины строки 8.
     * Обратите внимание, что строка из 4 символов имеет нулевой терминатор на конце, что делает ее длиной 5, поэтому,
     * даже если она уже имеет кратное 4 символам значение длины, она должна использовать значение длины 8 из-за
     * нулевого терминатора. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена
     * атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1",
     * "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы
     * пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого
     * полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За
     * атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция".
     * Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции
     * Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые
     * данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы
     * можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины,
     * например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются.
     * Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые
     * три индекса представляют собой многоугольник.
     *
     * @param int $objID Идентификатор объекта для изменения
     * @param int $memID Индекс memblock, который будет использоваться для создания новой сетки
     * @return void
     */
    function AddObjectMeshFromMemblock($objID, $memID)
    {
    }

    /**
     * Добавляет строку к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных
     * CreateNetworkMessage, или для сообщений, полученных из сети.
     *
     * @param int $iMsgID Идентификатор сообщения для изменения.
     * @param string $value Строка для добавления в сообщение.
     * @return void
     */
    function AddNetworkMessageString($iMsgID, $value)
    {
    }

    /**
     * Добавляет поплавок к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных
     * CreateNetworkMessage, или для сообщений, полученных из сети.
     *
     * @param int $iMsgID Идентификатор сообщения для изменения.
     * @param float $value Значение, которое нужно добавить к сообщению.
     * @return void
     */
    function AddNetworkMessageFloat($iMsgID, $value)
    {
    }

    /**
     * Добавляет байт без знака к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных
     * CreateNetworkMessage, или для сообщений, полученных из сети.
     *
     * @param int $iMsgID Идентификатор сообщения для изменения.
     * @param int $value Значение, которое нужно добавить к сообщению.
     * @return void
     */
    function AddNetworkMessageByte($iMsgID, $value)
    {
    }

    /**
     * Добавляет указанный заголовок ко всем будущим запросам. Если заголовок уже существует, то его значение будет
     * перезаписано новым значением. Если заголовок является стандартным заголовком, который обычно присутствует, то
     * его значение будет перезаписано значением, которое вы даете. Если заголовок является стандартным заголовком,
     * который обычно присутствует, а значение, которое вы даете, является пустой строкой, то стандартный заголовок
     * будет удален. Не добавляйте двоеточие ни в одно из полей, оно будет добавлено автоматически между ними. Обратите
     * внимание, что эта команда не работает в версии HTML5.
     *
     * @param int $iHTTP Идентификатор соединения для изменения.
     * @param string $headerName Имя устанавливаемого заголовка, например "Content-Type"
     * @param string $headerValue Новое значение для заголовка
     * @return void
     */
    function AddHTTPHeader($iHTTP, $headerName, $headerValue)
    {
    }

    /**
     * Добавляет целое число к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных
     * CreateNetworkMessage, или для сообщений, полученных из сети.
     *
     * @param int $iMsgID Идентификатор сообщения для изменения.
     * @param int $value Значение, которое нужно добавить к сообщению.
     * @return void
     */
    function AddNetworkMessageInteger($iMsgID, $value)
    {
    }

    /**
     * Добавляет силу, которая будет действовать в данный момент в жизни каждой частицы. Например, сила, установленная
     * для начала в момент времени 2 и окончания в момент времени 3, начнет воздействовать на частицы, когда они будут
     * живы в течение 2 секунд. Он будет продолжать действовать на эти частицы до тех пор, пока они не оживут в течение
     * 3 секунд. Влияние силы определяется величинами x, y и z, которые представляют ускорение в единицах в секунду.
     * Например, сила с x=5 будет регулировать горизонтальную скорость частицы, добавляя 5 единиц за каждую секунду,
     * когда сила активна, если сила активна только в течение 0,5 секунды, то частица будет двигаться на 2,5 единицы в
     * секунду быстрее в направлении X. Несколько сил могут действовать на частицу одновременно, если их временные
     * интервалы перекрываются.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $starttime Время в жизни частицы, в которое эта сила должна начать действовать.
     * @param float $endtime Время в жизни частицы, в которое эта сила должна прекратить свое действие.
     * @param float $x х-составляющая влияния силы на скорость частицы в единицах в секунду.
     * @param float $y y-составляющая влияния силы на скорость частицы в единицах в секунду.
     * @param float $z z-составляющая влияния силы на скорость частицы в единицах в секунду.
     * @return void
     */
    function Add3DParticlesForce($ID, $starttime, $endtime, $x, $y, $z)
    {
    }

    /**
     * Добавляет изменение цвета в определенный момент жизни частицы. Например, цвет, добавленный со временем=1,
     * сделает частицу равной данному цвету, когда она была жива в течение 1 секунды. Если цветовая интерполяция
     * включена с помощью Set3DParticlesColorInterpolation, частица постепенно преобразуется из своего текущего цвета в
     * следующий. Например, если вы добавите три цвета: красный, когда время=1, зеленый, когда время=2, и синий, когда
     * время=3, то частица начнет свою жизнь как красный (поскольку это ближайший цвет) и останется полностью красной,
     * пока ей не исполнится 1 секунда. Когда частице от 1 до 2 секунд, она будет постепенно меняться с красного на
     * зеленый, пока ей не исполнится 2 секунды, в этот момент она полностью зеленая. Когда частице от 2 до 3 секунд,
     * она будет постепенно меняться от зеленого до синего, пока ей не исполнится 3 секунды, в этот момент она
     * полностью синяя. Частица останется полностью синей до конца своей жизни, так как никакие другие цвета не были
     * добавлены.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время, когда частицы должны стать такого цвета.
     * @param int $red Красная составляющая нового цвета.
     * @param int $green Зеленая составляющая нового цвета.
     * @param int $blue Синий компонент нового цвета.
     * @param int $alpha Альфа-компонент нового цвета.
     * @return void
     */
    function Add3DParticlesColorKeyFrame($ID, $time, $red, $green, $blue, $alpha)
    {
    }

    /**
     * Попытка подключения к смарт-часам, подключенным к текущему устройству. Он будет пытаться поддерживать это
     * соединение в течение всего срока службы приложения, например, если часы непарные, а затем отремонтированы, то
     * ваше приложение автоматически подключится к часам. Таким образом, вам нужно только один раз вызвать эту команду
     * в начале вашего приложения.  В настоящее время работает только на iOS. Чтобы создать приложение watch, вам нужно
     * будет использовать Tier 2 project interpreter_ios и добавить в него приложение watch.
     *
     * @param string $szReserved Зарезервированная для будущего использования, должна быть пустой строкой
     * @return void
     */
    function ActivateSmartWatch($szReserved)
    {
    }

    /**
     * Возвращает абсолютное значение, то есть положительную версию числа.
     *
     * @param float $a Значение для преобразования.
     * @return float
     */
    function Abs($a)
    {
    }

    /**
     * Возвращает арктангенс значения в радианах в диапазоне от pi/2 до pi/2.
     *
     * @param float $a Значение, передаваемое в функцию арктангенса.
     * @return float
     */
    function ATanRad($a)
    {
    }

    /**
     * Создает костную капсулу тряпичной куклы между начальным и конечным расположением костей объектов. Возвращает
     * идентификатор кости рэгдолла. Если эта команда не сможет создать кость, она вернет значение -1.
     *
     * @param int $startBoneID объекты bone ID
     * @param int $endBoneID объекты bone ID
     * @param float $diameter размер капсулы, которая будет костью тряпичной куклы.
     * @param int $collisionGroup группа столкновений, к которой принадлежит и этот физический объект.
     * @param int $collisionMask группы столкновений, которые вы хотите замаскировать от столкновения.
     * @return int
     */
    function Add3DPhysicsRagDollBone($startBoneID, $endBoneID, $diameter, $collisionGroup, $collisionMask)
    {
    }

    /**
     * Добавляет изменение размера в определенный момент жизни частицы. Значения шкалы относятся к значению, заданному
     * Set3DParticlesSize, поэтому шкала 2 означает удвоение ее нормального размера, а 0,5-половину ее нормального
     * размера. Масштаб, добавленный со временем=1, заставит частицу постепенно трансформироваться в заданную, пока она
     * не будет жива в течение 1 секунды, когда она будет соответствовать заданному размеру. Затем частица постепенно
     * преобразуется из этого размера в следующий (если следующий размер существует).
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время, за которое частицы должны стать такого размера.
     * @param float $scale Масштаб относительно нормального размера частиц должен быть больше или равен 0.
     * @return void
     */
    function Add3DParticlesScaleKeyFrame($ID, $time, $scale)
    {
    }

    /**
     * Возвращает угол в градусах между x=0 y=-1 (вверх) и заданным вектором по часовой стрелке. Возвращает значение от
     * 0 до 360. Эта команда является собственностью AGK и полезна в 2D-ситуациях. Если вы ищете эквивалент atan2 в
     * C++, используйте вместо этого команду AGK ATan2.
     *
     * @param float $x X компонент вектора для проверки
     * @param float $y Компонент y вектора для проверки
     * @return float
     */
    function ATanFull($x, $y)
    {
    }

    /**
     * Возвращает угол вектора x,y в радианах в диапазоне от pi до pi. Это точно соответствует функции C++ atan2.
     *
     * @param float $y Значение y для передачи в atan2
     * @param float $x Значение x для передачи в atan2
     * @return float
     */
    function ATan2Rad($y, $x)
    {
    }

    /**
     * Возвращает арктангенс значения в градусах в диапазоне от -90 до 90.
     *
     * @param float $a Значение, передаваемое в функцию арктангенса.
     * @return float
     */
    function ATan($a)
    {
    }

    /**
     * Возвращает арксин значения в градусах.
     *
     * @param float $a Значение, передаваемое в функцию arcsine.
     * @return float
     */
    function ASin($a)
    {
    }

    /**
     * Доступно только на iOS и Android. Эта команда настраивает функции AR устройства, если они доступны. Используйте
     * команду ARGetStatus, чтобы проверить, было ли это успешно. Эта команда должна быть вызвана перед любыми другими
     * командами AR, если установка не удалась, вы можете вызвать эту команду снова, чтобы попытаться выполнить
     * установку снова.  Настройка AR возьмет на себя управление 3D-камерой, включая проекционную матрицу, поэтому
     * любые изменения, внесенные вами в положение камеры, поворот, FOV, будут перезаписаны системой AR при вызове
     * рендеринга или синхронизации. Однако вы все еще можете управлять ближними и дальними значениями камеры с помощью
     * SetCameraRange, который будет сохраняться в системе AR.  При использовании AR и размещении или калибровке 3D -
     * объектов система координат 1 единица AGK равна 1 метру.
     *
     * @return void
     */
    function ARSetup()
    {
    }

    /**
     * Устанавливает режим обнаружения плоскости для AR, по умолчанию он включен. Обнаруженные самолеты можно
     * обнаружить с помощью команды ARGetPlanes.
     *
     * @param int $mode 1=Включить обнаружение плоскости, 0=Выключить обнаружение плоскости
     * @return void
     */
    function ARSetPlaneDetectionMode($mode)
    {
    }

    /**
     * Устанавливает режим оценки освещенности для AR, по умолчанию он включен. Это попытка выработать окружающий свет
     * в реальном мире, чтобы вы могли правильно освещать свои виртуальные объекты.
     *
     * @param int $mode 1=Включить оценку освещенности, 0=Выключить оценку освещенности
     * @return void
     */
    function ARSetLightEstimationMode($mode)
    {
    }

    /**
     * Возвращает угол в радианах между x=0 y=-1 (вверх) и заданным вектором по часовой стрелке. Возвращает значение от
     * 0 до 2*PI. Эта команда является собственностью AGK и полезна в 2D-ситуациях. Если вы ищете эквивалент atan2 в
     * C++, используйте вместо этого команду AGK ATan2Rad.
     *
     * @param float $x X компонент вектора для проверки
     * @param float $y Компонент y вектора для проверки
     * @return float
     */
    function ATanFullRad($x, $y)
    {
    }

    /**
     * Очищает ресурсы, используемые во время тестирования хитов, это должно быть вызвано, когда вы закончите проверку
     * результатов теста хитов. Если вы не вызовете его, то он будет вызван автоматически, когда вы выполните еще один
     * тест попадания или уничтожите сеанс AR.
     *
     * @return void
     */
    function ARHitTestFinish()
    {
    }

    /**
     * Бросает луч в реальный мир и обнаруживает любые попадания с самолетов или точек слежения, обнаруженных в мире.
     * Возвращает количество обнаруженных хитов, хиты будут упорядочены с ближайшим первым. Координаты должны
     * находиться в пространстве экрана, например значения, возвращаемые из GetPointerX и GetPointerY. Когда вы
     * закончите проверку результатов этого теста попадания, вы должны вызвать ARHitTestFinish, чтобы освободить все
     * использованные ресурсы. Если нет, то это будет сделано автоматически при следующем вызове ARHitTest.
     *
     * @param float $screenX Компонент X координаты экрана
     * @param float $screenY Компонент Y координаты экрана
     * @return int
     */
    function ARHitTest($screenX, $screenY)
    {
    }

    /**
     * Возвращает угол вектора x,y в градусах в диапазоне от -180 до 180. Это точно соответствует функции C++ atan2 с
     * градусами.
     *
     * @param float $y Значение y для передачи в atan2
     * @param float $x Значение x для передачи в atan2
     * @return float
     */
    function ATan2($y, $x)
    {
    }

    /**
     * Возвращает арксин значения в радианах.
     *
     * @param float $a Значение, передаваемое в функцию arcsine.
     * @return float
     */
    function ASinRad($a)
    {
    }

    /**
     * Очищает все ресурсы, используемые при вызове ARGetPlanes, вы должны вызвать его, когда закончите проверку
     * результатов. Если нет, то он будет вызван автоматически при следующем вызове ARGetPlanes или уничтожении сеанса
     * AR.
     *
     * @return void
     */
    function ARGetPlanesFinish()
    {
    }

    /**
     * Запрашивает сеанс AR для всех самолетов, отслеживаемых в настоящее время в мире, они обнаруживаются с течением
     * времени, если включен режим ARSetPlaneDetectionMode. Возвращает количество найденных плоскостей. Это может быть
     * использовано для отображения обнаруженных плоскостей пользователю путем создания некоторых плоских объектов с
     * помощью CreateObjectPlane и размещения их в заданном положении, с заданным поворотом и размером. Когда вы
     * закончите проверку результатов, вам следует вызвать ARGetPlanesFinish, чтобы очистить все ресурсы, используемые
     * при проверке.
     *
     * @param int $reserved зарезервировано для будущего использования, должно быть 0
     * @return int
     */
    function ARGetPlanes($reserved)
    {
    }

    /**
     * Возвращает Z-компоненту центра данной плоскости. Эта точка может со временем смещаться относительно реальной
     * картины мира, поэтому ее следует регулярно проверять и обновлять, если вы используете ее для отображения
     * видимого представления плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneZ($index)
    {
    }

    /**
     * Возвращает Y-компоненту центра данной плоскости. Эта точка может со временем смещаться относительно реальной
     * картины мира, поэтому ее следует регулярно проверять и обновлять, если вы используете ее для отображения
     * видимого представления плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneY($index)
    {
    }

    /**
     * Возвращает Z-компоненту размера данной плоскости. Это может быть использовано для масштабирования 3D-объекта в
     * соответствии с визуальным представлением обнаруженной плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneSizeZ($index)
    {
    }

    /**
     * Возвращает компонент X размера данной плоскости. Это может быть использовано для масштабирования 3D-объекта в
     * соответствии с визуальным представлением обнаруженной плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneSizeX($index)
    {
    }

    /**
     * Возвращает Z-компоненту вращения данной плоскости. Это может быть использовано для поворота 3D-объекта в
     * соответствии с визуальным представлением обнаруженной плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneAngleZ($index)
    {
    }

    /**
     * Возвращает Y-компоненту вращения данной плоскости. Это может быть использовано для поворота 3D-объекта в
     * соответствии с визуальным представлением обнаруженной плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneAngleY($index)
    {
    }

    /**
     * Возвращает X-компоненту вращения данной плоскости. Это может быть использовано для поворота 3D-объекта в
     * соответствии с визуальным представлением обнаруженной плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneAngleX($index)
    {
    }

    /**
     * Возвращает текущее состояние процесса настройки AR. 0=ARSetup еще не вызван, -1=AR недоступен на этом устройстве
     * или установка не удалась, -2=Пользователь отклонил установку ARCore, 1=ARCore install in progress, 2=AR setup
     * successful.
     *
     * @return int
     */
    function ARGetStatus()
    {
    }

    /**
     * Возвращает расчетное значение освещенности для текущего кадра, это будет значение от 0.0 до 1.0. Лучше всего
     * использовать это значение для установки цвета окружающего света с помощью SetAmbientColor со значением 1.0,
     * соответствующим значению цвета 255,255,255.
     *
     * @return float
     */
    function ARGetLightEstimate()
    {
    }

    /**
     * Возвращает Z-компоненту заданного результата теста попадания в 3D-пространстве. Результаты теста на попадание
     * упорядочиваются с ближайшим первым, начиная с индекса 1. Эта точка должна использоваться только в течение
     * короткого времени, например, для отображения эффекта частицы, так как она будет дрейфовать относительно
     * реального мира. Если вы планируете использовать эту 3D-точку для позиционирования долгоживущего объекта в мире,
     * то вместо этого вы должны создать якорь из этого результата теста попадания, чтобы он не дрейфовал.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestZ($index)
    {
    }

    /**
     * Возвращает компонент Y данного результата теста попадания в 3D-пространстве. Результаты теста на попадание
     * упорядочиваются с ближайшим первым, начиная с индекса 1. Эта точка должна использоваться только в течение
     * короткого времени, например, для отображения эффекта частицы, так как она будет дрейфовать относительно
     * реального мира. Если вы планируете использовать эту 3D-точку для позиционирования долгоживущего объекта в мире,
     * то вам следует создать якорь из этого результата теста попадания, чтобы он не дрейфовал.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestY($index)
    {
    }

    /**
     * Возвращает тип обнаруженной поверхности: 1=плоскость, обычно горизонтальная, 0=точка, обычно стена или другой
     * объект, -1=неизвестно.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return int
     */
    function ARGetHitTestType($index)
    {
    }

    /**
     * Возвращает X-компоненту центра данной плоскости. Эта точка может со временем смещаться относительно реальной
     * картины мира, поэтому ее следует регулярно проверять и обновлять, если вы используете ее для отображения
     * видимого представления плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneX($index)
    {
    }

    /**
     * Возвращает Z-компоненту нормали данного результата теста попадания в 3D-пространстве. Результаты теста на
     * попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Для плоскостей на земле нормаль будет
     * указывать прямо вверх в трехмерном пространстве, для точек, обнаруженных на стенах или других объектах, нормаль
     * будет указывать в сторону от обнаруженной поверхности.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestNormalZ($index)
    {
    }

    /**
     * Возвращает Y-компоненту нормали данного результата теста попадания в 3D-пространстве. Результаты теста на
     * попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Для плоскостей на земле нормаль будет
     * указывать прямо вверх в трехмерном пространстве, для точек, обнаруженных на стенах или других объектах, нормаль
     * будет указывать в сторону от обнаруженной поверхности.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestNormalY($index)
    {
    }

    /**
     * Прикрепляет объект к якорю таким же образом, как работает FixObjectToObject. Положение и вращение объекта будут
     * добавлены к положению и вращению якоря. Так, например, объект в положении 0,0,0 будет находиться непосредственно
     * над положением якоря, тогда как если бы объект имел положение 0,2,0, то объект был бы расположен на 2 метра выше
     * положения якоря. Нет ограничений на количество объектов, которые могут быть прикреплены к якорю, и объекты все
     * еще могут быть прикреплены к объекту, прикрепленному к якорю. Например, объект 1 может быть закреплен на якоре,
     * а объект 2-на объекте 1. Чтобы удалить объект из якоря, вызовите эту команду с идентификатором якоря 0. Затем
     * объект будет помещен в мир в его заданном положении, например, положение 0,0,0 поместит его в начало мира.
     *
     * @param int $objID Идентификатор объекта для фиксации на якоре
     * @param int $anchorID Идентификатор якоря для использования
     * @return void
     */
    function ARFixObjectToAnchor($objID, $anchorID)
    {
    }

    /**
     * Возвращает текущее состояние отслеживания данного якоря. 0=остановлено, 1=приостановлено, 2=отслеживается, -1=не
     * знаю. Якоря могут перестать отслеживать, если камера теряет связь с миром, это может произойти, если камера не
     * видит достаточно объектов, чтобы понять, как движется сцена. Например, глядя на пустую стену. Когда якорь
     * останавливается или приостанавливает отслеживание, он сохраняет свое текущее положение и вращение, но это больше
     * не коррелирует с мировым положением, которое он отслеживал, поэтому якорь может казаться дрейфующим относительно
     * мира. Когда якорь возобновит слежение, он должен вернуться в свое правильное мировое положение.
     *
     * @param int $anchorID Идентификатор якоря для проверки
     * @return int
     */
    function ARGetAnchorStatus($anchorID)
    {
    }

    /**
     * Удаляет указанный якорь и освобождает все ресурсы, которые он использовал. Если какие-либо объекты были
     * прикреплены к якорю при его удалении, то они вернутся в непривязанное состояние и будут помещены в мировые
     * координаты
     *
     * @param int $anchorID Идентификатор якоря для удаления
     * @return void
     */
    function ARDeleteAnchor($anchorID)
    {
    }

    /**
     * Возвращает компонент X данного результата теста попадания в 3D-пространстве. Результаты теста на попадание
     * упорядочиваются с ближайшим первым, начиная с индекса 1. Эта точка должна использоваться только в течение
     * короткого времени, например, для отображения эффекта частицы, так как она будет дрейфовать относительно
     * реального мира. Если вы планируете использовать эту 3D-точку для позиционирования долгоживущего объекта в мире,
     * то вместо этого вы должны создать якорь из этого результата теста попадания, чтобы он не дрейфовал.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestX($index)
    {
    }

    /**
     * Возвращает X-компоненту нормали данного результата теста попадания в 3D-пространстве. Результаты теста на
     * попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Для плоскостей на земле нормаль будет
     * указывать прямо вверх в трехмерном пространстве, для точек, обнаруженных на стенах или других объектах, нормаль
     * будет указывать в сторону от обнаруженной поверхности.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestNormalX($index)
    {
    }

    /**
     * You must call this command if you want the AR camera feed to be drawn to the screen. If you do not then the
     * camera will still track as if it were moving around the real world but the camera feed will not be seen inside
     * the app. This may be useful if you want to render a purely virtual reality but still use the AR camera tracking
     * functionality. The best time to call this command is just before calling Render or Sync.
     *
     * @return void
     */
    function ARDrawBackground()
    {
    }

    /**
     * Destroys the AR session and any resources allocated during setup. After you can not call any AR commands, except
     * ARGetStatus and ARSetup. You may call ARSetup to recreate an AR session. There is no limit on the number of
     * times you can create and destroy the AR session.  Currently on Android this command may take up to 5 seconds,
     * apparently this will be improved ina future version of Google's ARCore.
     *
     * @return void
     */
    function ARDestroy()
    {
    }
}
