<?php
namespace fibonaccifox;

/**
 * Класс описания методов, реализованных в AppGameKit для <b>x64</b> и <b>x86</b>.
 * @author FibonacciFox
 * @version 0.9.1
 */
class AppGameKit
{

    function __construct()
    {
    }

    /**
     * Возвращает преобразованный путь для загрузки файлов в AppGameKit
     * 
     * @param string $fileName путь до файла
     * @return string  преобразованный путь для AppGameKit
     */
    function getPath(string $fileName)
    {
    }

    /**
     * Обновить окно Windows
     * 
     * @return void
     */
    function UpdateWindow()
    {
    }

    /**
     * Показать окно Windows
     * 
     * @return void
     */
    function ShowWindow()
    {
    }

    /**
     * Инициализируем OpenGL и отрисовываем в стороннее окно
     * 
     * @param int $hWnd дескриптор окна
     */
    function InitGL(int $hWnd)
    {
    }

    /**
     * Инициализируем AppGameKit
     * 
     * @return void
     */
    function Init()
    {
    }


    /**
     *Возвращает арккосинус значения в радианах.
     *
     * @param float $a Значение, передаваемое в функцию arccosine.
     * @return float
     */
    function ACosRad($a)
    {
    }

    /**
     *Создает якорь из заданного результата теста попадания, который может быть использован для отслеживания точки в реальном мире с течением времени. Якоря автоматически регулируют свое положение, чтобы попытаться оставаться неподвижными в точке, обнаруженной в реальном мире, это позволяет разместить объект там, не дрейфуя слишком сильно. Возвращает идентификатор, который вы можете использовать для ссылки на этот якорь позже. Результат теста попадания не обязательно должен существовать после создания из него якоря, после этого вы можете безопасно очистить результаты теста попадания. Якорь будет сохраняться и использовать некоторые ресурсы отслеживания до тех пор, пока вы специально не удалите его с помощью ARDeleteAnchor или не уничтожите сеанс AR.
     *
     * @param int $index Индекс результата теста попадания для использования, начиная с индекса 1
     * @return int
     */
    function ARCreateAnchorFromHitTest($index)
    {
    }

    /**
     *Возвращает арккосинус значения в градусах.
     *
     * @param float $a Значение, передаваемое в функцию arccosine.
     * @return float
     */
    function ACos($a)
    {
    }

    /**
     *Создает якорь из центра данной плоскости, который может быть использован для отслеживания точки в реальном мире с течением времени. Якоря автоматически корректируют свое положение, чтобы попытаться оставаться неподвижными в точке, обнаруженной в реальном мире, это позволяет разместить объект там, не дрейфуя слишком сильно. Возвращает идентификатор, который вы можете использовать для ссылки на этот якорь позже. Результат плоскости не обязательно должен существовать после создания из него якоря, после этого вы можете смело вызывать ARGetPlanesFinish. Якорь будет сохраняться и использовать некоторые ресурсы отслеживания до тех пор, пока вы специально не удалите его с помощью ARDeleteAnchor или не уничтожите сеанс AR.
     *
     * @param int $index Индекс используемого самолета, начиная с индекса 1
     * @return int
     */
    function ARCreateAnchorFromPlane($index)
    {
    }

    /**
     *Это необязательная команда, которая сбросит камеру на заданные значения AR. Это может быть полезно, если вы измените положение или поворот камеры, но затем захотите узнать значения AR для этих настроек. Вам не нужно вызывать эту команду, так как значения будут сброшены до значений AR при рендеринге или синхронизации в любом случае.
     *
     * @return void
     */
    function ARControlCamera()
    {
    }

    /**
     *Записывает строку в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут прочитаны с помощью ReadString2. Для создания удобочитаемых файлов используйте WriteLine Это использует другой метод от WriteString, который будет быстрее для чтения AGK позже, но он не совместим с ReadString, вы должны использовать ReadString2 для чтения строк, написанных с помощью WriteString2
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param string $str Строка для записи.
     * @return void
     */
    function WriteString2($iFileID, $str)
    {
    }

    /**
     *Записывает завершенную строку CR(\n) в данный файл, который должен быть открыт для записи.
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param string $str Строка для записи.
     * @return void
     */
    function WriteLine($iFileID, $str)
    {
    }

    /**
     *Записывает строку с нулевым завершением в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут прочитаны с помощью ReadString. Для создания удобочитаемых файлов используйте WriteLine
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param string $str Строка для записи.
     * @return void
     */
    function WriteString($iFileID, $str)
    {
    }

    /**
     *Записывает 4-байтовый поплавок в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут прочитаны с помощью ReadFloat. Для создания удобочитаемых файлов используйте WriteLine
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param float $f Поплавок, чтобы писать.
     * @return void
     */
    function WriteFloat($iFileID, $f)
    {
    }

    /**
     *Записывает 4-байтовое целое число в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут прочитаны с помощью ReadInteger. Для создания удобочитаемых файлов используйте WriteLine
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param int $i Целое число для записи.
     * @return void
     */
    function WriteInteger($iFileID, $i)
    {
    }

    /**
     *Записывает 1-байтовое целое число без знака (0-255) в данный файл, который должен быть открыт для записи. Обратите внимание, что эта команда не предназначена для удобочитаемых файлов и должна использоваться только для файлов, которые позже будут считываться с помощью ReadByte. Для создания удобочитаемых файлов используйте WriteLine
     *
     * @param int $iFileID Идентификатор файла для изменения.
     * @param int $b Байт для записи.
     * @return void
     */
    function WriteByte($iFileID, $b)
    {
    }

    /**
     *Преобразует мировую координату Y в координату экрана Y на основе текущего смещения вида и масштабирования. Когда SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен на 20 пикселей вниз, объект на уровне 0,0 в мире появится на уровне -20 (вне экрана) над экраном.
     *
     * @param float $y Мировая координата Y для преобразования.
     * @return float
     */
    function WorldToScreenY($y)
    {
    }

    /**
     *Открывает данный файл во внешнем приложении, подходящем для его типа файла. Как правило, это приложение по умолчанию, выбранное пользователем. Файл должен быть в вашей папке для чтения или записи, вы должны указать имя файла, как если бы вы загружали файл. В настоящее время это работает только на Windows, iOS и Android.
     *
     * @param string $szFilename Путь к файлу, который нужно открыть
     * @return void
     */
    function ViewFile($szFilename)
    {
    }

    /**
     *Преобразует мировую координату X в координату экрана X на основе текущего смещения вида и масштабирования. Когда SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен на 20 пикселей вправо, объект на 0,0 в мире появится на -20 (вне экрана) слева.
     *
     * @param float $x Мировая координата X для преобразования.
     * @return float
     */
    function WorldToScreenX($x)
    {
    }

    /**
     *Вибрирует устройство в течение заданного количества секунд. Работает на iOS и Android. Обратите внимание, что на iOS значение длины игнорируется и происходит только короткая вибрация, это связано с ограничениями Apple.
     *
     * @param float $seconds Время в секундах для вибрации
     * @return void
     */
    function VibrateDevice($seconds)
    {
    }

    /**
     *Преобразует строку в целое значение. Например, Val("10") вернет значение 10.
     *
     * @param string $str Строка для преобразования в целое число.
     * @return int
     */
    function Val($str)
    {
    }

    /**
     *Преобразует строку в целое значение. Например, Val("10") вернет значение 10.
     *
     * @param string $str Строка для преобразования в целое число.
     * @param int $base База, в которой находится строковый номер.
     * @return int
     */
    function Val($str, $base)
    {
    }

    /**
     *Преобразует строку в значение с плавающей запятой. Например, ValFloat("1.045") вернет значение 1.045
     *
     * @param string $str Строка для преобразования в целое число.
     * @return float
     */
    function ValFloat($str)
    {
    }

    /**
     *Начиная с версии 2.0.20 AGK имеет новую систему шрифтов, которая может отображать больше символов и отображать символы более плавно, однако для сохранения обратной совместимости она по умолчанию отключена. Чтобы использовать новую систему, установите для этой команды значение 1. Это влияет только на шрифт по умолчанию, если вы его сами не установили.
     *
     * @param int $mode 1=использовать новые шрифты по умолчанию, 0=использовать старые шрифты по умолчанию
     * @return void
     */
    function UseNewDefaultFonts($mode)
    {
    }

    /**
     *Преобразует строку в символы верхнего регистра.
     *
     * @param string $strin Строка для преобразования
     * @return string
     */
    function Upper($strin)
    {
    }

    /**
     *Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже запущена на данном спрайте с помощью PlayTweenSprite, иначе ничего не произойдет. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param int $spriteID Идентификатор обновляемого спрайта
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenSprite($tweenID, $spriteID, $fTime)
    {
    }

    /**
     *Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже запущена на данном тексте с помощью PlayTweenText, иначе ничего не произойдет. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param int $textID Идентификатор текста для обновления
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenText($tweenID, $textID, $fTime)
    {
    }

    /**
     *Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Твин должен быть уже запущен на данном персонаже с помощью PlayTweenChar, иначе ничего не произойдет. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param int $textID Идентификатор текста для обновления
     * @param int $charID Индекс символа, индексы начинаются с 0, если он выходит за пределы диапазона, то будет проигнорирован
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenChar($tweenID, $textID, $charID, $fTime)
    {
    }

    /**
     *Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже запущена на данном объекте с помощью PlayTweenObject, иначе ничего не произойдет. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param int $objectID Идентификатор объекта для обновления
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenObject($tweenID, $objectID, $fTime)
    {
    }

    /**
     *Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Анимация должна быть уже запущена на данной камере с помощью PlayTweenCamera, иначе ничего не произойдет. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param int $cameraID Идентификатор объекта для обновления
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenCamera($tweenID, $cameraID, $fTime)
    {
    }

    /**
     *Обновляет определенную анимацию, которая была запущена. Значение time позволяет вам контролировать, как быстро продвигается анимация, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что анимация будет воспроизводиться в обратном порядке, пока не достигнет своей начальной точки, однако она не прекратит воспроизведение, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную. Если вы начали играть много подростков, то обновление каждого твина в отдельности будет намного дороже, чем использование UpdateAllTweens.
     *
     * @param int $tweenID Идентификатор твина для обновления
     * @param float $fTime Время продвигать твин
     * @return void
     */
    function UpdateTweenCustom($tweenID, $fTime)
    {
    }

    /**
     *Обновляет заданную цепочку твинов. Значение времени позволяет вам контролировать, как быстро продвигается цепочка, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что цепочка и подростки, которых она содержит, будут играть в обратном порядке, пока не достигнут начальной точки, однако она не перестанет играть, когда достигнет начала, и вместо этого будет ждать, пока время снова станет положительным, или ждать, пока вы остановите его вручную.
     *
     * @param int $chainID Идентификатор цепочки для обновления
     * @param float $fTime Время для продвижения цепи
     * @return void
     */
    function UpdateTweenChain($chainID, $fTime)
    {
    }

    /**
     *Немедленно опережает излучатель частиц на заданное количество времени. Если вы хотите продвинуть высокочастотный излучатель на большой промежуток времени, такой как 1 секунда, вы должны вызвать эту команду несколько раз с небольшим значением времени, таким как 0,02, чтобы она создавала новые частицы партиями и равномерно распределяла их. Вызов его один раз с большим временным значением 1 секунда создал бы огромную партию частиц сразу и переместил бы их вместе как каплю вместо того, чтобы распространять их.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @param float $time Время в секундах для продвижения излучателя.
     * @return void
     */
    function UpdateParticles($ID, $time)
    {
    }

    /**
     *Если по какой-либо причине размеры устройства могут измениться (например, изменение ориентации приводит к повороту видового пространства на новый размер), вызовите эту функцию для обновления внутренних значений.
     *
     * @param int $w Новая ширина
     * @param int $h Новая высота
     * @return void
     */
    function UpdateDeviceSize($w, $h)
    {
    }

    /**
     *Устанавливает новое положение соединения кирки.
     *
     * @param int $jointID Id соединения
     * @param int $positionVec3 Идентификатор вектора положения
     * @return void
     */
    function Update3DPhysicsPickJoint($jointID, $positionVec3)
    {
    }

    /**
     *Звонил автоматически. Это расширенная команда для управления процессом обновления. Обычно Update вызывает это и Update2D (), чтобы обновить все в мире. Эта команда обновляет только 3D - объекты, такие как 3D-модели.
     *
     * @param float $time время в секундах, чтобы переместить все вперед. Могут быть доли секунды.
     * @return void
     */
    function Update3D($time)
    {
    }

    /**
     *Обновления всех подростков начались на отдельных предметах и цепочках. Значение времени позволяет вам контролировать, как быстро продвигаются подростки, и в большинстве случаев следует использовать результат GetFrameTime. Время может быть установлено отрицательным, так что любые играющие подростки будут играть в обратном порядке, пока не достигнут своих начальных точек, однако они не прекратят играть, когда достигнут начала, и вместо этого будут ждать, пока время снова станет положительным, или ждать, пока вы остановите их вручную.
     *
     * @param float $fTime Время для продвижения подростков
     * @return void
     */
    function UpdateAllTweens($fTime)
    {
    }

    /**
     *Звонил автоматически. Это расширенная команда для управления процессом обновления. Обычно Update вызывает это и Update3D (), чтобы обновить все в мире. Эта команда обновляет только 2D-объекты, такие как спрайты и текст.
     *
     * @param float $time время в секундах, чтобы переместить все вперед. Могут быть доли секунды.
     * @return void
     */
    function Update2D($time)
    {
    }

    /**
     *Использует плавную кривую для перемещения от начала до конца, это позволяет избежать внезапного старта и остановки. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 1.
     *
     * @return int
     */
    function TweenSmooth1()
    {
    }

    /**
     *Использует плавную кривую для перемещения от начала до конца, похожую на TweenSmooth1, но более преувеличенную. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 2.
     *
     * @return int
     */
    function TweenSmooth2()
    {
    }

    /**
     *Обновляет все 2D и 3D объекты в зависимости от заданного времени, анимации, физики и т. Д. Если время равно 0, то для пошагового моделирования используется время последнего кадра. Если вы уже назвали StepPhysics этим фреймом, он не будет вызван снова для этого фрейма. Вызываемый автоматически Sync, вы можете использовать Sync или Update(), Render(), Swap() для ручной синхронизации. Если вы хотите иметь больше контроля, вы можете разбить это дальше, заменив Update на Update2D, Update3D()
     *
     * @param float $time время в секундах, чтобы переместить все вперед. Могут быть доли секунды.
     * @return void
     */
    function Update($time)
    {
    }

    /**
     *Использует эластичный аффект в конце интерполяции. Это единственный метод интерполяции, который превышает заданный диапазон и не подходит для цветов. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 8.
     *
     * @return int
     */
    function TweenOvershoot()
    {
    }

    /**
     *Использует линейную интерполяцию для перемещения от начала к концу, это самая простая форма интерполяции. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 0.
     *
     * @return int
     */
    function TweenLinear()
    {
    }

    /**
     *Использует плавную кривую для движения к концу, похожую на TweenEaseOut1, но более преувеличенную. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 6.
     *
     * @return int
     */
    function TweenEaseOut2()
    {
    }

    /**
     *Использует плавную кривую для перемещения с самого начала, аналогичную TweenEaseIn1, но более преувеличенную. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 4.
     *
     * @return int
     */
    function TweenEaseIn2()
    {
    }

    /**
     *Использует плавную кривую для движения к концу, это позволяет избежать внезапной остановки, но все равно начинается резко. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 5.
     *
     * @return int
     */
    function TweenEaseOut1()
    {
    }

    /**
     *Немедленно опережает излучатель частиц на заданное количество времени. Если вы хотите продвинуть высокочастотный излучатель на большой промежуток времени, такой как 1 секунда, вы должны вызвать эту команду несколько раз с небольшим значением времени, таким как 0,02, чтобы она создавала новые частицы партиями и равномерно распределяла их. Вызов его один раз с большим временным значением 1 секунда создал бы огромную партию частиц сразу и переместил бы их вместе как каплю вместо того, чтобы распространять их.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @param float $time Время в секундах для продвижения излучателя.
     * @return void
     */
    function Update3DParticles($ID, $time)
    {
    }

    /**
     *Использует плавную кривую для движения с самого начала, это позволяет избежать внезапного старта, но все равно резко заканчивается. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 3.
     *
     * @return int
     */
    function TweenEaseIn1()
    {
    }

    /**
     *Возвращает строку со всеми символами, удаленными после заданного символа. Исходная строка не изменяется, и возвращается новая строка с удаленными символами. Это поиск в обратном направлении от конца строки к началу и при первом появлении символа удаляет его и все, что после него. Обратите внимание, что если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы закончите с ней.
     *
     * @param string $str Строка для изменения
     * @param string $character Символ, который нужно искать, должен быть одним символом
     * @return string
     */
    function TruncateString($str, $character)
    {
    }

    /**
     *Возвращает целочисленную часть значения с плавающей запятой без округления в любом случае.
     *
     * @param float $a Значение для усечения.
     * @return int
     */
    function Trunc($a)
    {
    }

    /**
     *Использует эффект отскока в конце интерполяции. Это просто вспомогательная функция, чтобы избежать необходимости запоминать целочисленное значение для этого, которое равно 7.
     *
     * @return int
     */
    function TweenBounce()
    {
    }

    /**
     *Получите количество секунд и долей секунд с момента запуска приложения. Точность до миллисекунд, но из-за неточностей с плавающей запятой чем дольше работает приложение, тем менее точным оно становится. Более конкретно, значение времени имеет около 7 значимых цифр точности, так что по мере увеличения числа секунд количество десятичных знаков уменьшается. Если вам нужно только время до ближайшей секунды, то это значение будет хорошо примерно до 16 000 000 секунд.  Вызов этой команды внутренне вызовет системный вызов, чтобы получить количество прошедшего времени, поэтому он будет меняться каждый раз, когда вы его вызываете.
     *
     * @return float
     */
    function Timer()
    {
    }

    /**
     *Немедленно завершает работу указанного приложения. Это следует использовать только в крайних случаях, так как приложение не имеет возможности очистить или закончить то, что оно делает.
     *
     * @param int $appID Идентификатор приложения для завершения работы, возвращаемый из runApp()
     * @return void
     */
    function TerminateApp($appID)
    {
    }

    /**
     *Инициализирует механизм преобразования текста в речь на устройстве, чтобы он мог воспроизводить звук. Обратите внимание, что это может быть не сразу, вы должны проверить GetTextToSpeechReady, чтобы увидеть, закончил ли он настройку. Вызов других команд преобразования текста в речь, когда он не готов, будет проигнорирован.  В настоящее время работает только на iOS и Android.
     *
     * @return void
     */
    function TextToSpeechSetup()
    {
    }

    /**
     *Возвращает строку со всеми символами в "символах", удаленными из концов строки. Исходная строка не изменяется, и возвращается новая строка с удаленными символами. Это можно использовать для удаления лишних пробелов с концов входной строки. Обратите внимание, что если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы закончите с ней.
     *
     * @param string $str Строка для изменения
     * @param string $chars Символы для удаления
     * @return string
     */
    function TrimString($str, $chars)
    {
    }

    /**
     *Возвращает тангенс значения в радианах.
     *
     * @param float $a Значение, передаваемое в касательную функцию.
     * @return float
     */
    function TanRad($a)
    {
    }

    /**
     *Возвращает тангенс значения в градусах.
     *
     * @param float $a Значение, передаваемое в касательную функцию.
     * @return float
     */
    function Tan($a)
    {
    }

    /**
     *Обновляет сцену с последней информацией, рисует все спрайты, обновляет глобальные объекты и меняет местами backbuffer в поле зрения. Не рисует спрайты, созданные с помощью указателей на уровне 2, вы должны нарисовать их вручную, вызвав функцию рисования спрайта или назначив их менеджеру спрайтов для пакетного рисования.
     *
     * @return void
     */
    function Sync()
    {
    }

    /**
     *Выводит задний буфер на экран и очищает задний буфер для следующего кадра, обновляет глобальные временные переменные. Вызываемый автоматически Sync, вы можете использовать Sync или Update, Render, Swap один за другим для ручной синхронизации.
     *
     * @return void
     */
    function Swap()
    {
    }

    /**
     *Возвращает строку, из которой удалены все символы в "символах". Исходная строка не изменяется, и возвращается новая строка с удаленными символами. Например, StripString("my string", "yn") вернет "m strig". Обратите внимание, что если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы закончите с ней.
     *
     * @param string $str Строка для изменения
     * @param string $chars Символы для удаления
     * @return string
     */
    function StripString($str, $chars)
    {
    }

    /**
     *Преобразует строку UTF-8 в строку Base64. Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.
     *
     * @param string $input Строка для преобразования
     * @return string
     */
    function StringToBase64($input)
    {
    }

    /**
     *Останавливает видео и удаляет его из поля зрения, используя playVideo, чтобы запустить его с самого начала.
     *
     * @return void
     */
    function StopVideo()
    {
    }

    /**
     *Останавливает данный идентификатор анимации, если он воспроизводится на данном текстовом объекте. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если текст был в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @param int $textID Идентификатор текстового объекта для остановки
     * @return void
     */
    function StopTweenText($tweenID, $textID)
    {
    }

    /**
     *Преобразует значение в строку, если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.
     *
     * @param float $valueFloat Значение для преобразования в строку.
     * @return string
     */
    function Str($valueFloat)
    {
    }

    /**
     *Преобразует значение в строку, если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.
     *
     * @param float $valueFloat Значение для преобразования в строку.
     * @param int $decimals Количество мест после десятичной точки для включения.
     * @return string
     */
    function Str($valueFloat, $decimals)
    {
    }

    /**
     *Преобразует значение в строку, если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.
     *
     * @param int $valueInt Значение для преобразования в строку.
     * @return string
     */
    function Str($valueInt)
    {
    }

    /**
     *Останавливает данный идентификатор анимации, если он воспроизводится на данном спрайте. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если спрайт находился в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @param int $spriteID Идентификатор спрайта для остановки
     * @return void
     */
    function StopTweenSprite($tweenID, $spriteID)
    {
    }

    /**
     *Останавливает данный идентификатор анимации, если он воспроизводится на данном объекте. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если объект находился в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @param int $objectID Идентификатор объекта для остановки
     * @return void
     */
    function StopTweenObject($tweenID, $objectID)
    {
    }

    /**
     *Останавливает данную цепь. Если элемент находился в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу. Воспроизведение цепочки снова запустит ее с самого начала.
     *
     * @param int $chainID Идентификатор цепочки для изменения
     * @return void
     */
    function StopTweenChain($chainID)
    {
    }

    /**
     *Останавливает данный пользовательский идентификатор анимации, если он воспроизводится. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если твин был в середине интерполяции, его значения останутся на своих текущих значениях, он не будет переходить к концу или возвращаться к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @return void
     */
    function StopTweenCustom($tweenID)
    {
    }

    /**
     *Останавливает данный идентификатор анимации, если он воспроизводится на заданном символе текстового объекта. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если символ находился в середине интерполяции, он останется в своем текущем положении, он не будет переходить к концу или возвращаться к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @param int $textID Идентификатор текстового объекта, содержащего символ
     * @param int $charID Индекс символа для остановки, индексы начинаются с 0, если он выходит за пределы диапазона, то будет проигнорирован
     * @return void
     */
    function StopTweenChar($tweenID, $textID, $charID)
    {
    }

    /**
     *Останавливает данный идентификатор анимации, если он воспроизводится на данной камере. Если анимация не воспроизводится или закончилась, то эта команда не имеет никакого эффекта. Если камера находилась в середине интерполяции, она останется в своем текущем положении, она не будет переходить к концу или возвращаться к началу.
     *
     * @param int $tweenID Идентификатор анимации для остановки
     * @param int $cameraID Идентификатор камеры для остановки
     * @return void
     */
    function StopTweenCamera($tweenID, $cameraID)
    {
    }

    /**
     *Эта команда останавливает и скрывает любое приглашение ввода текста, ранее запущенное с помощью команды StartTextInput.
     *

     * @return void
     */
    function StopTextInput()
    {
    }

    /**
     *Еще не функционирует.
     *
     * @return void
     */
    function StopSoundRecording()
    {
    }

    /**
     *Останавливает анимацию спрайта, сохраняя значения, используемые для его настройки.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, чтобы остановить анимацию.
     * @return void
     */
    function StopSprite($iSpriteIndex)
    {
    }

    /**
     *Останавливает текущий экземпляр, если он еще этого не сделал. При этом экземпляр удаляется, и его идентификатор больше не может быть использован. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.
     *
     * @param int $iID Идентификатор проверяемого экземпляра
     * @return void
     */
    function StopSoundInstance($iID)
    {
    }

    /**
     *Немедленно останавливает любой произносимый текст и удаляет все элементы из очереди.  В настоящее время работает только на iOS и Android.
     *
     * @return void
     */
    function StopSpeaking()
    {
    }

    /**
     *Остановите звук, воспроизводимый в данный момент на указанном звуковом номере.
     *
     * @param int $iID Звук, по-видимому, прекратился.
     * @return void
     */
    function StopSound($iID)
    {
    }

    /**
     *Останавливает любую текущую запись экрана. Если запись уже остановлена, то это не имеет никакого эффекта. В iOS это предложит пользователю отредактировать и/или сохранить видео, а также отказаться от него. На Android пользователь не видит никаких изменений, и видео молча сохраняется в фоновом режиме.
     *
     * @return void
     */
    function StopScreenRecording()
    {
    }

    /**
     *Останавливает любую анимацию, которая в данный момент воспроизводится на объекте, и оставляет кости в их текущем положении. Если объект в данный момент находится в подростковом возрасте, то анимация также будет остановлена с костями, оставленными в середине анимации.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @return void
     */
    function StopObjectAnimation($objID)
    {
    }

    /**
     *Остановите оживление скелета
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @return void
     */
    function StopSkeleton2DAnimation($iSkeleton)
    {
    }

    /**
     *Останавливает любое воспроизведение музыки, после чего музыка может быть перезапущена только вызовом PlayMusic.
     *

     * @return void
     */
    function StopMusic()
    {
    }

    /**
     *Вызовите перед командой Sync() в нижней части цикла. Это шагнет в мир физики. Сохраняет физику постоянной независимо от частоты кадров. Не вызывая эту команду, вы приостановите действие физического мира.
     *
     * @return void
     */
    function Step3DPhysicsWorld()
    {
    }

    /**
     *Шагает физическое моделирование на определенное количество времени. Это значение времени выражается в секундах и может включать доли секунд. Шаговое моделирование физики на большое значение времени (больше, чем, скажем, 0,1) может привести к неопределенному поведению и движению физических объектов друг через друга. Не требуется, чтобы вы вызывали эту команду в своем игровом цикле, если вы ее не вызываете, Sync или Update вызовут ее для вас с последним временем кадра, чтобы позволить физическому моделированию догнать вас в реальном времени. Если вы действительно вызываете StepPhysics, то он не будет вызван для вас синхронизацией или обновлением для этого кадра, это позволяет вам сделать свой собственный физический хронометраж, если вы предпочитаете. При использовании фиксированного временного шага каждый кадр ваша физика будет работать точно так же на всех устройствах и во всех частотах кадров, но снижение fps приведет к тому, что физика будет идти медленнее, так как она всегда будет шагать одно и то же количество времени, независимо от того, был ли кадр быстрым или медленным. Использование переменного шага для каждого кадра позволит физике двигаться с одинаковой скоростью независимо от частоты кадров, но она больше не будет детерминированной между устройствами и различными частотами кадров. Например, если ваша игра зависит от физического объекта, падающего и подпрыгивающего на одну и ту же высоту каждый раз, когда он запускается, то вы должны использовать фиксированный временной шаг. Если положение физических объектов не важно для вашей игровой логики, то переменный временной шаг может быть лучшим.
     *
     * @param float $time Время шага в секундах
     * @return void
     */
    function StepPhysics($time)
    {
    }

    /**
     *Останавливает музыкальный файл и сбрасывает его положение в начало файла.
     *
     * @param int $musicID Идентификатор музыкального файла для остановки
     * @return void
     */
    function StopMusicOGG($musicID)
    {
    }

    /**
     *Останавливает обновление местоположения GPS, используйте это для экономии заряда батареи, когда вам больше не нужно местоположение.
     *
     * @return void
     */
    function StopGPSTracking()
    {
    }

    /**
     *Эта команда выводит текстовое приглашение ввода над вашим приложением, в то время как ваше приложение продолжает работать в фоновом режиме. Допустимыми символами являются значения ASCII в диапазоне от 32 до 126 включительно, если только вы не активировали новые шрифты по умолчанию с помощью UseNewDefaultFonts, и в этом случае можно использовать любые символы Unicode. Если для ввода текста на этом устройстве требуется виртуальная клавиатура, то она будет отображаться поверх вашего приложения. Вы не можете предполагать, что какая-либо часть вашего приложения будет видна во время ввода текста, хотя ваш код будет продолжать работать. Когда пользователь закончит ввод текста, GetTextInputCompleted вернет 1, а GetTextInputCancelled сообщит вам, завершил ли он ввод текста или отменил его. На клавиатурных устройствах отмена производится с помощью клавиши escape, а завершение-с помощью клавиши enter. В случае успеха вы можете получить введенный текст с помощью GetTextInput.
     *
     * @param string $initial Начальная строка для отображения пользователю, которую он может редактировать.
     * @return void
     */
    function StartTextInput($initial)
    {
    }

    /**
     *Эта команда выводит текстовое приглашение ввода над вашим приложением, в то время как ваше приложение продолжает работать в фоновом режиме. Допустимыми символами являются значения ASCII в диапазоне от 32 до 126 включительно, если только вы не активировали новые шрифты по умолчанию с помощью UseNewDefaultFonts, и в этом случае можно использовать любые символы Unicode. Если для ввода текста на этом устройстве требуется виртуальная клавиатура, то она будет отображаться поверх вашего приложения. Вы не можете предполагать, что какая-либо часть вашего приложения будет видна во время ввода текста, хотя ваш код будет продолжать работать. Когда пользователь закончит ввод текста, GetTextInputCompleted вернет 1, а GetTextInputCancelled сообщит вам, завершил ли он ввод текста или отменил его. На клавиатурных устройствах отмена производится с помощью клавиши escape, а завершение-с помощью клавиши enter. В случае успеха вы можете получить введенный текст с помощью GetTextInput.
     *

     * @return void
     */
    function StartTextInput()
    {
    }

    /**
     *Начинает запись экрана и сохранение его в файл. В настоящее время поддерживается только на iOS 9.0 и выше и Android 5.0 и выше. В iOS имя файла игнорируется, так как устройство всегда сохраняет запись в фотопленке. На Android параметр микрофона может быть установлен в 1 для записи звука с микрофона устройства во время записи. Значение 0 приведет к созданию бесшумного видео, так как Android не поддерживает запись звука непосредственно из приложения. Однако аудиовыход из приложения может быть слышен через микрофон при использовании режима 1. Запись через микрофон требует, чтобы вы включили разрешение "RecordAudio" при экспорте вашего APK.  В iOS значение микрофона 1 будет записывать как аудиовыход приложения, так и микрофон, а значение 0 будет записывать только звук приложения. На Android 6 и ниже запись может прекратиться в любое время, например, если приложение отправлено в фоновый режим или активировано другое действие, например покупка в приложении. На Android 7 и выше запись будет приостановлена, когда приложение находится в фоновом режиме, и возобновлена, когда приложение возобновится. На iOS запись будет продолжаться после таких перерывов до тех пор, пока не будет вызвана функция StopScreenRecording.
     *
     * @param string $szFilename Путь для сохранения видео, который должен заканчиваться в формате .mp4, может быть путем к файлу "raw:".
     * @param int $microphone 1 для записи с микрофона, 0 для записи с устройства
     * @return void
     */
    function StartScreenRecording($szFilename, $microphone)
    {
    }

    /**
     *Возвращает квадратный корень из значения с плавающей запятой.
     *
     * @param float $a Значение квадратного корня.
     * @return float
     */
    function Sqrt($a)
    {
    }

    /**
     *Бросает луч через определенный спрайт (может быть физический или не физический) и сохраняет результат любого пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Эта функция уникальна тем, что она также работает со всеми спрайтами, даже с теми, у которых не включена физика, но спрайту должна быть назначена форма с помощью одной из команд sprite shape. Возвращает 1, если произошло столкновение, и 0, если нет.
     *
     * @param int $sprite Идентификатор спрайта для проверки пересечения с лучом.
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function SpriteRayCastSingle($sprite, $x, $y, $x2, $y2)
    {
    }

    /**
     *Бросает луч через все спрайты, которые имеют форму (включая физические спрайты), и сохраняет результат любого пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Физические спрайты будут использовать только основную форму, назначенную спрайту с помощью SetSpriteShape, чтобы проверить, что составные формы используют PhysicsRayCast. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Спрайтам должна быть назначена форма с помощью одной из команд sprite shape, иначе она не будет включена в результаты столкновения. Эта функция медленнее, чем физические лучи, поскольку она не может использовать оптимизированные структуры, которые представляют, где находятся спрайты в мире относительно луча. Эта функция фильтрует проверяемые спрайты, поэтому проверяются только спрайты определенной группы. По умолчанию спрайты создаются в группе 0. Эта функция может отслеживать только спрайты, созданные с помощью CreateSprite, если вы вручную выделили память для спрайтов, вам нужно будет циклически просматривать список спрайтов с помощью SpriteRayCastSingle или использовать физическую версию. Возвращает 1, если произошло столкновение, и 0, если нет.
     *
     * @param int $group Идентификатор группы, проверяемый на пересечение с лучом, может быть отрицательным.
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function SpriteRayCastGroup($group, $x, $y, $x2, $y2)
    {
    }

    /**
     *Запускает процесс получения местоположения GPS, если это возможно, на текущем устройстве. Это может вызвать запрос разрешения на некоторых платформах при первом вызове. Если пользователь отказывает в разрешении, то GetGPSSensorExists может вернуть 0 с этого момента. Вы должны вызывать эту команду только тогда, когда пользователь выполняет действие, которое, как он знает, потребует определения местоположения, в противном случае он может отклонить его и никогда больше не получить запрос (ему придется войти в настройки своего устройства, чтобы включить его). Эта команда будет потреблять много энергии батареи, поэтому используйте StopGPSTracking, когда вам больше не нужно местоположение. Эта команда работает на iOS, Android, Mac и Windows 7 и выше. Вызов этой команды может занять некоторое время, чтобы получить точное местоположение от GetRawGPSLatitude и GetRawGPSLongitude.
     *
     * @return void
     */
    function StartGPSTracking()
    {
    }

    /**
     *Бросает луч через все спрайты, имеющие форму (включая физические спрайты), и сохраняет результат любого пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Физические спрайты будут использовать только основную форму, назначенную спрайту с помощью SetSpriteShape, чтобы проверить, что составные формы используют PhysicsRayCast. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Спрайтам должна быть назначена форма с помощью одной из команд sprite shape, иначе она не будет включена в результаты столкновения. Эта функция медленнее, чем физика только лучей, поскольку она не может использовать оптимизированные структуры, которые представляют, где находятся спрайты в мире относительно луча. Эта функция может отслеживать только спрайты, созданные с помощью CreateSprite, если вы вручную выделили память для спрайтов, вам нужно будет циклически просматривать список спрайтов с помощью SpriteRayCastSingle или использовать физическую версию. Возвращает 1, если произошло столкновение, и 0, если нет.
     *
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function SpriteRayCast($x, $y, $x2, $y2)
    {
    }

    /**
     *Отбрасывает форму столкновения сфер по длине луча. Возвращает 1, если указанный объект был поражен, и 0, если он не был поражен.
     *
     * @param int $objID идентификатор объекта
     * @param int $rayID Идентификатор луча, который возвращается вызовом Create3DPhysicsRay().
     * @param int $fromVec3ID Идентификатор вектора, удерживающего начальную точку
     * @param int $toVec3ID Идентификатор вектора, удерживающего конечную точку
     * @param float $radius Радиус сферы
     * @return int
     */
    function SphereCast3DPhysicsObject($objID, $rayID, $fromVec3ID, $toVec3ID, $radius)
    {
    }

    /**
     *Отбрасывает форму столкновения сфер по длине луча.
     *
     * @param int $rayID Идентификатор луча, который возвращается вызовом Create3DPhysicsRay().
     * @param int $fromVec3ID Идентификатор вектора, удерживающего начальную точку
     * @param int $toVec3ID Идентификатор вектора, удерживающего конечную точку
     * @param float $radius Радиус сферы
     * @return void
     */
    function SphereCast3DPhysics($rayID, $fromVec3ID, $toVec3ID, $radius)
    {
    }

    /**
     *Ставит данный текст в очередь для произнесения. Если какой - то текст уже произносится, то данный текст будет произнесен после окончания текущей речи. Эта команда может быть вызвана несколько раз в быстрой последовательности, чтобы поставить в очередь много текста. Вы можете вызвать IsSpeaking, чтобы проверить, когда очередь пуста и весь текст был произнесен или отменен. Обратите внимание, что при первом вызове этой команды может возникнуть задержка при установке незнакомого языка с помощью SetSpeechLanguage. Например, использование французского языка на устройстве, настроенном для английского языка, попытается загрузить движок французского языка, прежде чем начать говорить текст.  Если приложение будет отправлено в фоновый режим, то речь остановится, и весь текст будет удален из очереди.  Вы можете указать необязательную задержку в миллисекундах, чтобы устройство подождало, прежде чем начать произносить текст.  В настоящее время работает только на iOS и Android.
     *
     * @param string $text Текст для выступления
     * @return void
     */
    function Speak($text)
    {
    }

    /**
     *Ставит данный текст в очередь для произнесения. Если какой - то текст уже произносится, то данный текст будет произнесен после окончания текущей речи. Эта команда может быть вызвана несколько раз в быстрой последовательности, чтобы поставить в очередь много текста. Вы можете вызвать IsSpeaking, чтобы проверить, когда очередь пуста и весь текст был произнесен или отменен. Обратите внимание, что при первом вызове этой команды может возникнуть задержка при установке незнакомого языка с помощью SetSpeechLanguage. Например, использование французского языка на устройстве, настроенном для английского языка, попытается загрузить движок французского языка, прежде чем начать говорить текст.  Если приложение будет отправлено в фоновый режим, то речь остановится, и весь текст будет удален из очереди.  Вы можете указать необязательную задержку в миллисекундах, чтобы устройство подождало, прежде чем начать произносить текст.  В настоящее время работает только на iOS и Android.
     *
     * @param string $text Текст для выступления
     * @param int $delay Количество времени в миллисекундах ожидания перед запуском речевого вывода
     * @return void
     */
    function Speak($text, $delay)
    {
    }

    /**
     *Бросает луч через все спрайты, которые имеют форму (включая физические спрайты), и сохраняет результат любого пересечения. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Физические спрайты будут использовать только основную форму, назначенную спрайту с помощью SetSpriteShape, чтобы проверить, что составные формы используют PhysicsRayCast. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Спрайтам должна быть назначена форма с помощью одной из команд sprite shape, иначе она не будет включена в результаты столкновения. Эта функция медленнее, чем физические лучи, поскольку она не может использовать оптимизированные структуры, которые представляют, где находятся спрайты в мире относительно луча. Эта функция фильтрует проверяемые спрайты, поэтому проверяются только спрайты определенных категорий. Параметр category - это побитовое поле, которое использует младшие 16 битов для представления каждой из возможных 16 категорий, используемых при настройке спрайта. Значение по умолчанию all 1s означает, что все категории будут включены, тогда как значение all 0s означает, что никакие категории не будут включены. Вы можете установить отдельные биты, чтобы установить, какие из них должны быть проверены. Эта функция может отслеживать только спрайты, созданные с помощью CreateSprite, если вы вручную выделили память для спрайтов, вам нужно будет циклически просматривать список спрайтов с помощью SpriteRayCastSingle или использовать физическую версию. Возвращает 1, если произошло столкновение, и 0, если нет.
     *
     * @param int $category Категории для проверки на пересечение с лучом, побитовое поле с использованием самых нижних 16 бит.
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function SpriteRayCastCategory($category, $x, $y, $x2, $y2)
    {
    }

    /**
     *Стоит контроллер
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Stand3DPhysicsCharacterController($objID)
    {
    }

    /**
     *Приостановите работу приложения на определенное количество миллисекунд. Не рекомендуется использовать эту команду для приостановки приложения более чем на один кадр (примерно 17 миллисекунд).
     *
     * @param int $milliseconds Количество миллисекунд сна.
     * @return void
     */
    function Sleep($milliseconds)
    {
    }

    /**
     *Возвращает синус значения в градусах.
     *
     * @param float $a Значение, которое нужно передать в синусоидальную функцию.
     * @return float
     */
    function Sin($a)
    {
    }

    /**
     *Создает строку пробелов, равную переданной длине.
     *
     * @param int $length Длина строки пробелов для создания
     * @return string
     */
    function Spaces($length)
    {
    }

    /**
     *Создает полноэкранную видеорекламу вознаграждения для получения дохода с помощью Chartboost. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetChartboostDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается загрузить объявление при следующем вызове этой команды. Для Chartboost вы должны запустить процесс кэширования вручную с помощью CacheRewardAdChartboost, вам нужно только вызвать его один раз. После показа видеорекламы с вознаграждением новая видеореклама будет автоматически кэширована. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetRewardAdLoadedChartboost. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено. Проверьте GetRewardAdRewardedChartboost, чтобы узнать, завершил ли пользователь просмотр объявления о вознаграждении и должен ли он быть вознагражден. Он будет установлен в 0, когда вы вызовете эту команду, а затем установлен в 1, когда они закончат просмотр
     *
     * @return void
     */
    function ShowRewardAdChartboost()
    {
    }

    /**
     *Возвращает синус значения в радианах.
     *
     * @param float $a Значение, которое нужно передать в синусоидальную функцию.
     * @return float
     */
    function SinRad($a)
    {
    }

    /**
     *Удаляет любые вхождения ../ or ..\ и соответствующим образом сокращает путь, удаляя папки. Также заменяет все задние косые черты на передние косые черты, так как передние косые черты будут работать на любой платформе. Это работает как с относительными, так и с абсолютными путями, если путь абсолютен, то все вхождения ../ будут удалены, даже если их слишком много. Если путь относителен, то любые вхождения../, которые запускают путь, не будут удалены. Например, относительный путь "../../MyFile.txt" не может быть упрощено далее, в то время как "C:/../../MyFile.txt" будет преобразован в "C:/MyFile.txt". Путь может начинаться с префикса "raw:" или нет, принимаются оба варианта. Если вы используете эту функцию в Tier 2, то вы должны удалить возвращаемую строку с помощью agk::DeleteString (), когда закончите с ней.
     *
     * @param string $szPath Путь к упрощению
     * @return string
     */
    function SimplifyPath($szPath)
    {
    }

    /**
     *Создает полноэкранную видеорекламу вознаграждения для получения дохода с помощью AdMob. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetAdMobRewardAdDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetRewardAdLoadedAdMob. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено. Проверьте GetRewardAdRewardedAdMob, чтобы узнать, завершил ли пользователь просмотр объявления о вознаграждении и должен ли он быть вознагражден. Он будет установлен в 0, когда вы вызовете эту команду, а затем установлен в 1, когда они закончат просмотр
     *
     * @return void
     */
    function ShowRewardAdAdMob()
    {
    }

    /**
     *Эта функция устарела, вместо нее используйте SetDeviceCameraToImage. Предоставляет пользователю возможность сделать снимок с помощью камеры устройства, если таковая имеется. Если устройство не имеет камеры или иным образом не может быть использовано, это вернет 0, и ваше приложение будет продолжать работать в обычном режиме. Это не сразу захватывает изображение, в зависимости от платформы ваше приложение может продолжать работать в фоновом режиме, пока пользователь делает снимок, или оно может приостановить выполнение во время съемки. В любом случае вы должны предположить, что ваше приложение продолжает работать, но больше не видно, используйте IsCapturingImage, чтобы проверить, когда пользователь возвращается из процесса захвата изображения, и GetCapturedImage, чтобы обнаружить результат этого процесса. В настоящее время это не работает на Mac.
     *
     * @return int
     */
    function ShowImageCaptureScreen()
    {
    }

    /**
     *Создает полноэкранную (интерстициальную) рекламу для получения дохода с помощью Amazon Ads. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetAmazonAdDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetFullscreenAdvertLoadedAmazon. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено.
     *
     * @return void
     */
    function ShowFullscreenAdvertAmazon()
    {
    }

    /**
     *Создает полноэкранную (интерстициальную) рекламу для получения дохода с помощью Chartboost. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetChartboostDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetFullscreenAdvertLoadedChartboost. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено.
     *
     * @return void
     */
    function ShowFullscreenAdvertChartboost()
    {
    }

    /**
     *Создает полноэкранную (интерстициальную) рекламу для получения дохода с помощью AdMob. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetAdMobDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае оно попытается загрузить объявление при следующем вызове этой команды. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetFullscreenAdvertLoadedAdMob. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено.
     *
     * @return void
     */
    function ShowFullscreenAdvertAdMob()
    {
    }

    /**
     *Предоставляет пользователю возможность выбрать изображение, хранящееся на его текущей платформе, например фотографию на телефоне или изображение, сохраненное на ПК. Это не сразу захватывает изображение, в зависимости от платформы ваше приложение может продолжать работать в фоновом режиме, пока пользователь выбирает изображение, или оно может приостановить выполнение, пока выбирается изображение. В любом случае вы должны предположить, что ваше приложение продолжает работать, но больше не видно, использовать IsChoosingImage, чтобы проверить, когда пользователь возвращается из процесса выбора изображения, и GetChosenImage, чтобы обнаружить результат этого процесса. Эта функция возвращает 1, если ей удалось отобразить экран выбора, и 0 в противном случае.
     *
     * @return int
     */
    function ShowChooseImageScreen()
    {
    }

    /**
     *Отправляет данный текст в операционную систему, которая затем спросит пользователя, как он хочет поделиться этим текстом, например, через Facebook, Twitter и т. Д. Это работает только на iOS и Android.
     *
     * @param string $szText Текст для обмена
     * @return void
     */
    function ShareText($szText)
    {
    }

    /**
     *Отправляет указанное изображение в приложение SnapChat на текущем устройстве вместе с дополнительным файлом стикера, подписью и URL-адресом. Затем пользователь может изменить изображение с помощью приложения SnapChat и решить, стоит ли делиться им с друзьями. Если у пользователя не установлено приложение SnapChat, то вместо него на странице приложения SnapChat будет открыт магазин приложений. Эта команда будет работать только на Android и iOS 10 или выше
     *
     * @param string $imageFile Путь к изображению, которым вы хотите поделиться
     * @param string $stickerFile Путь к изображению стикера, чтобы добавить его к изображению, может быть пустой строкой
     * @param string $caption Подпись, которую нужно добавить к изображению, может быть пустой строкой
     * @param string $url URL-адрес, который нужно добавить к изображению, может быть пустой строкой
     * @return void
     */
    function ShareSnapChatImage($imageFile, $stickerFile, $caption, $url)
    {
    }

    /**
     *Отправляет данное изображение в операционную систему, которая затем спросит пользователя, как он хочет поделиться этим изображением, например, через Facebook, Twitter и т. Д. Файл должен быть в вашей папке для чтения или записи, или вы можете использовать путь "raw:" для загрузки из любого места, вы должны указать имя файла, как если бы вы загружали файл. Это работает только на iOS и Android.
     *
     * @param string $szFilename Имя файла изображения для совместного использования
     * @return void
     */
    function ShareImage($szFilename)
    {
    }

    /**
     *Отправляет данный файл в операционную систему, которая затем спросит пользователя, как он хочет поделиться им, например, по электронной почте, NFC и т. Д. Файл может находиться в вашей папке для чтения или записи, или вы можете использовать путь "raw:" для загрузки из любого места, вы должны указать имя файла, как если бы вы загружали файл. Это работает только на iOS и Android.
     *
     * @param string $szFilename Путь к файлу для совместного использования
     * @return void
     */
    function ShareFile($szFilename)
    {
    }

    /**
     *Отправляет данное изображение и текст в операционную систему, которая затем спросит пользователя, как он хочет поделиться текстом, например, через Facebook, Twitter и т. Д. Файл изображения должен находиться в вашей папке для чтения или записи, или вы можете использовать путь "raw:" для загрузки из любого места, вы должны указать имя файла, как если бы вы загружали файл. Это работает только на iOS и Android.
     *
     * @param string $szFilename Имя файла изображения для совместного использования
     * @param string $szText Текст для обмена
     * @return void
     */
    function ShareImageAndText($szFilename, $szText)
    {
    }

    /**
     *Хэширует строку с помощью алгоритма SHA512 для получения 64-символьной шестнадцатеричной строки. Это односторонняя хэш-функция, которая может использоваться с солением (добавлением секретной строки) для паролей или обнаружения несанкционированного доступа к параметрам, передаваемым серверу. Если вы вызываете эту функцию из уровня 2, то вы должны удалить возвращаемую строку с помощью agk::DeleteString, когда закончите с ней.
     *
     * @param string $str Строка для хэширования
     * @return string
     */
    function Sha512($str)
    {
    }

    /**
     *Хэширует строку с помощью алгоритма SHA256 для получения 32-символьной шестнадцатеричной строки. Это односторонняя хэш-функция, которая может использоваться с солением (добавлением секретной строки) для паролей или обнаружения несанкционированного доступа к параметрам, передаваемым серверу. Если вы вызываете эту функцию из уровня 2, то вы должны удалить возвращаемую строку с помощью agk::DeleteString, когда закончите с ней.
     *
     * @param string $str Строка для хэширования
     * @return string
     */
    function Sha256($str)
    {
    }

    /**
     *Хэширует строку с помощью алгоритма SHA1 для получения 40-символьной шестнадцатеричной строки. Это односторонняя хэш-функция, которая может использоваться с солением (добавлением секретной строки) для паролей или обнаружения несанкционированного доступа к параметрам, передаваемым серверу. Если вы вызываете эту функцию из уровня 2, то вы должны удалить возвращаемую строку с помощью agk::DeleteString с помощью DeleteString (), когда закончите с ней.
     *
     * @param string $str Строка для хэширования
     * @return string
     */
    function Sha1($str)
    {
    }

    /**
     *Настраивает устройство на использование облачных данных на совместимых платформах, в настоящее время эту функцию поддерживают только Android и iOS. Облачные данные можно использовать для совместного использования настроек на нескольких устройствах, работающих под управлением одного и того же приложения. Например, сохранение некоторых настроек приложения или прогресса на одном устройстве с помощью команд облачных данных сделает их доступными (через короткий промежуток времени) на всех других устройствах на той же платформе. Обратите внимание, что данные не пересекаются с платформами, поэтому данные, сохраненные на iOS, недоступны на Android, а данные, сохраненные на Android, недоступны на iOS.  В iOS это использует iCloud Drive для хранения данных, поэтому пользователь должен войти в iCloud и включить iCloud Drive, вы можете определить, были ли они сделаны с помощью GetCloudDataAllowed. Вы также должны добавить iCloud в свой профиль подготовки, но вам не нужно создавать какие-либо контейнеры. Этот профиль подготовки необходимо использовать при экспорте приложения. На iOS вы ограничены 1 МБ памяти.  На Android это использует Android Drive AppData, поэтому пользователь должен войти в систему с учетной записью Google на устройстве. Вы также должны добавить проект Google API для вашего приложения здесь https: console.developers.google.com и создайте идентификатор клиента OAuth в разделе учетные данные. Скажите ему, что запрос исходит от Android, дайте ему имя по вашему выбору и назовите имя пакета вашего приложения. Вам нужно будет дать ему SHA-1 fignerprint файла хранилища ключей, который вы будете использовать для подписи вашего APK, это делается для того, чтобы он мог проверить, что только APKS, подписанные вами, могут использовать сгенерированный идентификатор клиента OAuth. Программа "keytool" является частью Java Development Kit (JDK). После создания вам не нужно ничего делать с токеном OAuth, он будет использоваться автоматически при вызове команд облачных данных. На Android любые данные, которые вы храните, будут засчитываться в лимит хранения Google Диска пользователя, они не могут получить доступ к файлам, хранящимся в вашем приложении, но они могут очистить данные приложения в настройках своего диска.  Широковещательные приложения будут использовать хранилище данных AGK Player и совместно использовать переменные во всех ваших широковещательных приложениях, поэтому будьте осторожны с перезаписью значений, если два ваших приложения имеют одно и то же имя переменной. Данные, которые вы храните в хранилище данных AGK Player, будут видны только вам и вашим устройствам.  Эта команда должна быть вызвана перед любыми другими командами облачных данных, кроме GetCloudDataAllowed, которые могут быть вызваны в любое время. На Android вы должны спросить пользователя, хочет ли он хранить данные на своем диске, прежде чем вызывать setup, так как эта команда может попросить пользователя войти в свой аккаунт Google.
     *
     * @param string $reserved Зарезервировано, должно быть пустой строкой
     * @return void
     */
    function SetupCloudData($reserved)
    {
    }

    /**
     *Задает заголовок окна для тех платформ, которые работают в окне (например, Windows, Mac).
     *
     * @param string $szTitle Текст, используемый для заголовка окна.
     * @return void
     */
    function SetWindowTitle($szTitle)
    {
    }

    /**
     *Это устанавливает размер окна для платформ, которые его поддерживают, таких как Windows и Mac. Это не повлияет на мобильные устройства. В полноэкранном режиме ширина и высота будут игнорироваться, а разрешение рабочего стола будет использоваться. По умолчанию размер окна будет отрегулирован таким образом, чтобы он всегда помещался на экране, в том числе освобождая место для панели задач в Windows. Это означает, что ваш конечный размер окна может быть немного меньше, чем выбранный вами размер. Вы можете переопределить это, установив параметр allowOverSized равным 1, который удалит все проверки границ и позволит вам создавать окна размером больше текущего экрана. Если параметр fullscreen установлен в 1, то параметр allowOverSized не имеет никакого эффекта.
     *
     * @param int $width Желаемая ширина окна в пикселях.
     * @param int $height Желаемая высота окна в пикселях.
     * @param int $fullscreen 1 для использования полноэкранного режима, 0 для обычного окна.
     * @param int $allowOverSized 1, чтобы размер окна превышал видимый экран, 0, чтобы уменьшить его до нужного размера
     * @return void
     */
    function SetWindowSize($width, $height, $fullscreen, $allowOverSized)
    {
    }

    /**
     *Это устанавливает размер окна для платформ, которые его поддерживают, таких как Windows и Mac. Это не повлияет на мобильные устройства. В полноэкранном режиме ширина и высота будут игнорироваться, а разрешение рабочего стола будет использоваться. По умолчанию размер окна будет отрегулирован таким образом, чтобы он всегда помещался на экране, в том числе освобождая место для панели задач в Windows. Это означает, что ваш конечный размер окна может быть немного меньше, чем выбранный вами размер. Вы можете переопределить это, установив параметр allowOverSized равным 1, который удалит все проверки границ и позволит вам создавать окна размером больше текущего экрана. Если параметр fullscreen установлен в 1, то параметр allowOverSized не имеет никакого эффекта.
     *
     * @param int $width Желаемая ширина окна в пикселях.
     * @param int $height Желаемая высота окна в пикселях.
     * @param int $fullscreen 1 для использования полноэкранного режима, 0 для обычного окна.
     * @return void
     */
    function SetWindowSize($width, $height, $fullscreen)
    {
    }

    /**
     *Это устанавливает положение окна для платформ, которые его поддерживают, таких как Windows и Mac. Если окно в данный момент полноэкранное, то это никак не повлияет. Это не повлияет на мобильные устройства.
     *
     * @param int $x Желаемое положение X окна в пикселях.
     * @param int $y Желаемое положение Y окна в пикселях.
     * @return void
     */
    function SetWindowPosition($x, $y)
    {
    }

    /**
     *Подход по умолчанию для системы координат в AGK заключается в использовании процентной системы, где 0,0 представляет верхний левый угол, а 100,100-нижний правый. Альтернативный подход заключается в обработке платформы с фиксированным разрешением, например 320 x 480. Любые платформы, которые не соответствуют этому разрешению, будут масштабированы, чтобы максимально соответствовать черным границам, где это необходимо.
     *
     * @param int $iWidth количество единиц измерения, используемых по ширине области рендеринга
     * @param int $iHeight количество единиц измерения, используемых по высоте области рендеринга
     * @return void
     */
    function SetVirtualResolution($iWidth, $iHeight)
    {
    }

    /**
     *Это устанавливает окно устанавливает, разрешено ли пользователю изменять размер окна, по умолчанию это значение равно 0
     *
     * @param int $mode 0-отключить изменение размера, 1-разрешить изменение размера
     * @return void
     */
    function SetWindowAllowResize($mode)
    {
    }

    /**
     *Устанавливает, виден ли джойстик на экране, это не влияет на его способность принимать ввод, используйте SetVirtualJoystickActive, чтобы повлиять на то, будет ли виртуальный джойстик принимать ввод. Невидимый джойстик все еще может быть активен.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param int $visible 1 для отображения джойстика, 0 для его скрытия.
     * @return void
     */
    function SetVirtualJoystickVisible($index, $visible)
    {
    }

    /**
     *Задает диаметр виртуального джойстика в экранных координатах. Изменение размера виртуального джойстика во время его использования изменит текущие возвращаемые значения X и Y.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param float $size Новый диаметр джойстика в экранных координатах.
     * @return void
     */
    function SetVirtualJoystickSize($index, $size)
    {
    }

    /**
     *Задает положение виртуального джойстика в экранных координатах. Вы можете использовать GetVirtualWidth и GetVirtualHeight, чтобы найти текущие границы экрана. Джойстик будет центрирован в заданном положении x и y. Перемещение виртуального джойстика во время его использования изменит текущие возвращаемые значения X и Y.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param float $x Координата x новой позиции.
     * @param float $y Координата y новой позиции.
     * @return void
     */
    function SetVirtualJoystickPosition($index, $x, $y)
    {
    }

    /**
     *Устанавливает изображение, используемое внутренней (подвижной) частью джойстика. Вы можете использовать идентификатор изображения 0, чтобы вернуть его к изображению по умолчанию.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param int $imageID Идентификатор изображения, используемый для этого джойстика.
     * @return void
     */
    function SetVirtualJoystickImageInner($index, $imageID)
    {
    }

    /**
     *Устанавливает мертвую зону для всех виртуальных джойстиков так, чтобы любое значение X или Y ниже заданного порога возвращало 0. Это значение должно быть между 0 и 1, по умолчанию оно равно 0,15.
     *
     * @param float $threshold Значение, ниже которого будет возвращено 0.
     * @return void
     */
    function SetVirtualJoystickDeadZone($threshold)
    {
    }

    /**
     *Устанавливает изображение, используемое внешней (фиксированной) частью джойстика. Вы можете использовать идентификатор изображения 0, чтобы вернуть его к изображению по умолчанию.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param int $imageID Идентификатор изображения, используемый для этого джойстика.
     * @return void
     */
    function SetVirtualJoystickImageOuter($index, $imageID)
    {
    }

    /**
     *Устанавливает прозрачность виртуального джойстика на экране. Виртуальный джойстик состоит из двух частей: внутренней подвижной части и внешней статической части. Alpha1 устанавливает прозрачность внешней части в диапазоне 0-255, при этом 255 полностью непрозрачны. Alpha2 устанавливает прозрачность внутренней части в диапазоне 0-255.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param int $alpha1 Альфа-значение внешней части джойстика.
     * @param int $alpha2 Альфа-значение внутренней части джойстика.
     * @return void
     */
    function SetVirtualJoystickAlpha($index, $alpha1, $alpha2)
    {
    }

    /**
     *Устанавливает, будет ли джойстик захватывать события мыши и касания. Если установлено значение 0, то он не будет захватывать входные данные и не будет обновлять свои значения X и Y, они вернутся к 0. Это не повлияет на видимость виртуального джойстика, используйте SetVirtualJoystickVisible, чтобы изменить его видимость.
     *
     * @param int $index Идентификатор виртуального джойстика для установки.
     * @param int $active 1, чтобы разрешить ввод, 0, чтобы отключить его.
     * @return void
     */
    function SetVirtualJoystickActive($index, $active)
    {
    }

    /**
     *Устанавливает текст, отображаемый в центре кнопки.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param string $str Текст для отображения.
     * @return void
     */
    function SetVirtualButtonText($index, $str)
    {
    }

    /**
     *Устанавливает, виден ли виртуальный объект на экране, это не влияет на его способность принимать ввод, используйте SetVirtualButtonActive, чтобы повлиять на то, будет ли виртуальная кнопка принимать ввод. Невидимая кнопка все еще может быть активна.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $visible 1, чтобы показать кнопку, 0, чтобы скрыть ее.
     * @return void
     */
    function SetVirtualButtonVisible($index, $visible)
    {
    }

    /**
     *Задает размер виртуальной кнопки в координатах экрана.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param float $sizeX Новый размер X кнопки в координатах экрана.
     * @param float $sizeY Новый размер кнопки Y в координатах экрана.
     * @return void
     */
    function SetVirtualButtonSize($index, $sizeX, $sizeY)
    {
    }

    /**
     *Задает размер виртуальной кнопки в координатах экрана.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param float $size Новый диаметр кнопки в экранных координатах.
     * @return void
     */
    function SetVirtualButtonSize($index, $size)
    {
    }

    /**
     *Устанавливает изображение, используемое кнопкой, когда она не нажата. Вы можете использовать идентификатор изображения 0, чтобы вернуть его к изображению по умолчанию.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $imageID Идентификатор изображения, используемый для этой кнопки.
     * @return void
     */
    function SetVirtualButtonImageUp($index, $imageID)
    {
    }

    /**
     *Устанавливает изображение, используемое кнопкой при ее нажатии. Вы можете использовать идентификатор изображения 0, чтобы вернуть его к изображению по умолчанию.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $imageID Идентификатор изображения, используемый для этой кнопки.
     * @return void
     */
    function SetVirtualButtonImageDown($index, $imageID)
    {
    }

    /**
     *Устанавливает цвет виртуальной кнопки по заданному индексу. По умолчанию кнопки имеют оттенки серого, так что они могут принимать различные цвета. Цвета должны быть указаны в диапазоне 0-255.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $red Красная составляющая нового цвета.
     * @param int $green Зеленая составляющая нового цвета.
     * @param int $blue Синий компонент нового цвета.
     * @return void
     */
    function SetVirtualButtonColor($index, $red, $green, $blue)
    {
    }

    /**
     *Задает положение виртуальной кнопки в координатах экрана. Вы можете использовать GetVirtualWidth и GetVirtualHeight, чтобы найти текущие границы экрана. Кнопка будет центрирована по заданным координатам x и y.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param float $x Координата x новой позиции в координатах экрана.
     * @param float $y Координата y новой позиции в координатах экрана.
     * @return void
     */
    function SetVirtualButtonPosition($index, $x, $y)
    {
    }

    /**
     *Устанавливает прозрачность виртуальной кнопки по заданному индексу. Альфа-значение должно находиться в диапазоне 0-255, где 255 полностью непрозрачно.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $alpha Новое альфа-значение для этой кнопки.
     * @return void
     */
    function SetVirtualButtonAlpha($index, $alpha)
    {
    }

    /**
     *Устанавливает, будет ли виртуальный захватывать события мыши и касания. Если установлено значение 0, он не будет захватывать входные данные и не будет обновлять свое нажатое состояние, он вернется к 0 (вверх). Это не повлияет на видимость виртуальной кнопки, используйте SetVirtualButtonVisible, чтобы изменить ее видимость.
     *
     * @param int $index Идентификатор виртуальной кнопки для установки.
     * @param int $active 1 для принятия ввода, 0 для его деактивации.
     * @return void
     */
    function SetVirtualButtonActive($index, $active)
    {
    }

    /**
     *Устанавливает режим масштабирования из верхнего левого угла или по центру. По умолчанию вид масштабируется из левого верхнего угла, сохраняя смещение видов в мировых координатах. Например, вид со смещением 20,20 будет сохранять свой верхний левый угол на уровне 20,20 в мировых координатах независимо от того, какое значение масштабирования задано. Однако центрированный зум сохраняет центр вида неподвижным, одновременно масштабируя все остальное вокруг него, что затрудняет оценку значения смещения. В этом режиме верхний левый угол будет находиться только на уровне 20,20, когда значение масштабирования равно 1,0, для других значений масштабирования верхний левый угол будет масштабирован в сторону от точки смещения. Например, предположим, что размер мира составляет 100 100 единиц, уровень масштабирования-1,0, а смещение вида-0,0. Вид будет отображать мировые координаты от 0,0 (в верхнем левом углу) до 100,100 (в нижнем правом углу), со значением масштабирования 2,0 и верхним левым масштабированием вид теперь будет показывать мировые координаты от 0,0 до 50,50 в том же пространстве, что делает все больше. При центрированном масштабировании вид вместо этого будет показывать от 25,25 до 75,75, сохраняя центр вида над точкой 50,50 в мировых координатах.
     *
     * @param int $mode 0=вверху слева, 1=по центру
     * @return void
     */
    function SetViewZoomMode($mode)
    {
    }

    /**
     *Масштабирование видового экрана относительно окружающего мира, например, масштабирование вида 2.0 удвоит размер всего, что в данный момент находится в поле зрения. Значение 1.0 возвращает все к нормальному размеру. Использование этой команды автоматически отключит четыре физические стены, окружающие экран. Вы также можете зафиксировать спрайты на экране, чтобы они не меняли размер, используя FixSpriteToScreen. Эта команда может масштабироваться либо в направлении верхнего левого угла вида, либо в направлении центра вида, см.
     *
     * @param float $zoom Уровень масштабирования для прокрутки спрайтов
     * @return void
     */
    function SetViewZoom($zoom)
    {
    }

    /**
     *Устанавливает громкость видео от 0 (приглушенный звук) до 100 (полная громкость)
     *
     * @param float $volume Громкость видео в диапазоне 0-100.
     * @return void
     */
    function SetVideoVolume($volume)
    {
    }

    /**
     *Ищет видео в заданной позиции. Это не гарантирует 100% точности, устройство может выбрать поиск ближайшего ключевого кадра, который может быть до 10 секунд до или после выбранного вами времени.
     *
     * @param float $seconds Позиция в видео к которой нужно стремиться
     * @return void
     */
    function SetVideoPosition($seconds)
    {
    }

    /**
     *Смещение видового экрана относительно окружающего мира, например, смещение вида 0,20 переместит экран вниз на 20 пикселей, показывая любой спрайт, который ранее был расположен чуть ниже нижней части экрана. Это может быть полезно для прокрутки игр, где вы хотите переместить вид через уровень. Использование этой команды автоматически отключит четыре физические стены, окружающие экран. Вы также можете закрепить спрайты на экране так, чтобы они двигались вместе с ним, используя FixSpriteToScreen. Значения смещения вида позиционируют верхний левый угол вида в мире, в то время как SetViewZoom определяет, какую часть мира может видеть вид.
     *
     * @param float $x Смещение x для вида
     * @param float $y Смещение y для вида
     * @return void
     */
    function SetViewOffset($x, $y)
    {
    }

    /**
     *Устанавливает ширину, высоту и положение видео во время его воспроизведения. Может быть вызван до или во время воспроизведения. Координаты находятся в координатах экрана AGK, основанных на выбранном вами виртуальном разрешении. Соотношение сторон не сохраняется и будет растянуто в соответствии с выбранными вами размерами. Чтобы найти фактический размер видео в пикселях, используйте GetVideoWidth и GetVideoHeight. Исключением из этого правила являются окна, которые всегда сохраняют соотношение сторон исходного видео и добавляют черные границы там, где это необходимо.
     *
     * @param float $x Координата x для позиционирования верхнего левого угла видео
     * @param float $y Координата y для позиционирования верхнего левого угла видео
     * @param float $width Ширина для отображения видео
     * @param float $height Высота для отображения видео
     * @return void
     */
    function SetVideoDimensions($x, $y, $width, $height)
    {
    }

    /**
     *Заполняет указанный вектор.
     *
     * @param int $vectorID Идентификатор вектора
     * @param float $x x компонент вектора
     * @param float $y Компонент y вектора
     * @param float $z z компонент вектора
     * @return void
     */
    function SetVector3($vectorID, $x, $y, $z)
    {
    }

    /**
     *Устанавливает, следует ли включать или выключать вертикальную синхронизацию. Это предпочтительный метод ограничения частоты кадров, поскольку он будет связывать частоту кадров с частотой обновления монитора и избегать разрыва или заикания. Использование этой команды с режимом 1 переопределит любую заданную в данный момент частоту обновления из SetSyncRate, в противном случае эти две команды будут бороться друг с другом за контроль частоты кадров, вместо этого AGK будет использовать частоту обновления VSync, которая обычно составляет 60 кадров в секунду, но зависит от монитора. В Linux, Mac и HTML5 вы можете использовать значение больше 1 для пропуска обновлений, например, если частота обновления монитора составляет 60 Гц, то значение режима 1 ограничит приложение до 60 кадров в секунду, но значение режима 2 пропустит каждое другое обновление, которое ограничит приложение до 30 кадров в секунду.
     *
     * @param int $mode 1, чтобы включить vsync, 0, чтобы выключить его.
     * @return void
     */
    function SetVSync($mode)
    {
    }

    /**
     *Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для текста, текст будет расположен здесь, когда начнется воспроизведение
     * @param float $endY Конечное значение Y для текста, текст будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении текста от начала к концу
     * @return void
     */
    function SetTweenTextY($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     *Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для текста, текст будет расположен здесь, когда начнется воспроизведение
     * @param float $endX Конечное значение X для текста, текст будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при перемещении текста от beginX к EndX
     * @return void
     */
    function SetTweenTextX($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     *Задает параметр Размера заданного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginS Начальное значение размера текста, текст будет иметь этот размер при запуске воспроизведения
     * @param float $endS Значение конечного размера для текста, текст будет иметь этот размер, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении текста от начала к концу
     * @return void
     */
    function SetTweenTextSize($tweenID, $beginS, $endS, $interpolation)
    {
    }

    /**
     *Задает параметр Интервала для заданного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSP Начальное значение интервала для текста, текст будет иметь этот интервал при запуске воспроизведения
     * @param float $endSP Значение конечного интервала для текста, текст будет иметь этот интервал при завершении воспроизведения
     * @param int $interpolation Метод интерполяции при перемещении текста из beginSP в endSP
     * @return void
     */
    function SetTweenTextSpacing($tweenID, $beginSP, $endSP, $interpolation)
    {
    }

    /**
     *Задает красный параметр заданного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginR Начальный красный цвет для текста, текст будет этого цвета, когда начнется воспроизведение
     * @param int $endR Конец Красный цвет для текста, текст будет этот цвет, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при перемещении текста от beginR к EndR
     * @return void
     */
    function SetTweenTextRed($tweenID, $beginR, $endR, $interpolation)
    {
    }

    /**
     *Устанавливает синий параметр данного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginB Начальный синий цвет для текста, текст будет этого цвета, когда начнется воспроизведение
     * @param int $endB Конец синий цвет для текста, текст будет этот цвет, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при перемещении текста из beginB в endB
     * @return void
     */
    function SetTweenTextBlue($tweenID, $beginB, $endB, $interpolation)
    {
    }

    /**
     *Задает параметр межстрочного интервала для данного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginLSP Начальное значение межстрочного интервала для текста, текст будет иметь этот интервал при запуске воспроизведения
     * @param float $endLSP Конечное значение межстрочного интервала для текста, текст будет иметь этот интервал при завершении воспроизведения
     * @param int $interpolation Метод интерполяции при перемещении текста из beginLSP в endLSP
     * @return void
     */
    function SetTweenTextLineSpacing($tweenID, $beginLSP, $endLSP, $interpolation)
    {
    }

    /**
     *Задает зеленый параметр заданного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginG Начальный зеленый цвет для текста, текст будет этого цвета, когда начнется воспроизведение
     * @param int $endG Конец Зеленый цвет для текста, текст будет этот цвет, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении текста от начала к концу
     * @return void
     */
    function SetTweenTextGreen($tweenID, $beginG, $endG, $interpolation)
    {
    }

    /**
     *Задает параметр угла заданного идентификатора анимации. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginA Начальное значение угла для текста, текст будет повернут на этот угол при начале воспроизведения
     * @param float $endA Значение конечного угла для текста, текст будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении текста от начала к концу
     * @return void
     */
    function SetTweenTextAngle($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     *Задает альфа - параметр данного идентификатора tween ID. Анимация может изменять несколько параметров текстового объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим текстовым объектам или цепочкам одновременно с помощью PlayTweenText или AddTweenChainText. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginA Начальный альфа-цвет для текста, текст будет этого цвета, когда начнется воспроизведение
     * @param int $endA Конечный альфа-цвет для текста, текст будет этого цвета, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении текста от начала к концу
     * @return void
     */
    function SetTweenTextAlpha($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     *Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Это изменяет положение спрайта, используя его точку смещения, обычно центр спрайта. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для спрайта, спрайт будет расположен здесь, когда начнется воспроизведение
     * @param float $endY Конечное значение Y для спрайта, спрайт будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от начала к концу
     * @return void
     */
    function SetTweenSpriteYByOffset($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     *Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Это изменяет положение спрайта, используя его верхний левый угол. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для спрайта, спрайт будет расположен здесь, когда начнется воспроизведение
     * @param float $endY Конечное значение Y для спрайта, спрайт будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от начала к концу
     * @return void
     */
    function SetTweenSpriteY($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     *Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Это изменяет положение спрайта, используя его точку смещения, обычно центр спрайта. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для спрайта, спрайт будет расположен здесь, когда начнется воспроизведение
     * @param float $endX Конечное значение X для спрайта, спрайт будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginX к EndX
     * @return void
     */
    function SetTweenSpriteXByOffset($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     *Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Это изменяет положение спрайта, используя его верхний левый угол. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для спрайта, спрайт будет расположен здесь, когда начнется воспроизведение
     * @param float $endX Конечное значение X для спрайта, спрайт будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginX к EndX
     * @return void
     */
    function SetTweenSpriteX($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     *Задает параметр sizeY для данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSY Начальное значение sizeY для спрайта, спрайт будет иметь этот размер при запуске игры
     * @param float $endSY Значение end sizeY для спрайта, спрайт будет иметь этот размер, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginSX к endSX
     * @return void
     */
    function SetTweenSpriteSizeY($tweenID, $beginSY, $endSY, $interpolation)
    {
    }

    /**
     *Задает красный параметр заданного идентификатора анимации. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Tween-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginR Начальный красный цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда начнется игра
     * @param int $endR Конечный красный цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginR к EndR
     * @return void
     */
    function SetTweenSpriteRed($tweenID, $beginR, $endR, $interpolation)
    {
    }

    /**
     *Задает параметр sizeX для данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSX Начальное значение sizeX для спрайта, спрайт будет иметь этот размер при запуске воспроизведения
     * @param float $endSX Значение end sizeX для спрайта, спрайт будет иметь этот размер, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginSX к endSX
     * @return void
     */
    function SetTweenSpriteSizeX($tweenID, $beginSX, $endSX, $interpolation)
    {
    }

    /**
     *Задает зеленый параметр заданного идентификатора анимации. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginG Стартовый зеленый цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда начнется игра
     * @param int $endG Конечный зеленый цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от начала к концу
     * @return void
     */
    function SetTweenSpriteGreen($tweenID, $beginG, $endG, $interpolation)
    {
    }

    /**
     *Устанавливает синий параметр данного идентификатора анимации. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginB Начальный синий цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда начнется игра
     * @param int $endB Конечный синий цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от beginB к endB
     * @return void
     */
    function SetTweenSpriteBlue($tweenID, $beginB, $endB, $interpolation)
    {
    }

    /**
     *Задает параметр угла заданного идентификатора анимации. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginA Начальное значение угла для спрайта, спрайт будет повернут на этот угол при запуске игры
     * @param float $endA Значение конечного угла для спрайта, спрайт будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт вращается от начала до конца
     * @return void
     */
    function SetTweenSpriteAngle($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     *Задает альфа - параметр данного идентификатора tween ID. Анимация может изменять несколько параметров спрайта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим спрайтам или цепочкам одновременно с помощью PlayTweenSprite или AddTweenChainSprite. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginA Начальный альфа-цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда начнется воспроизведение
     * @param int $endA Конечный альфа-цвет для спрайта (от 0 до 255), спрайт будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как спрайт движется от начала к концу
     * @return void
     */
    function SetTweenSpriteAlpha($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     *Задает параметр Z заданного идентификатора tween ID. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginZ Начальное значение Z для объекта, объект будет расположен здесь, когда начнется воспроизведение
     * @param float $endZ Конечное значение Z для объекта, объект будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginZ к endZ
     * @return void
     */
    function SetTweenObjectZ($tweenID, $beginZ, $endZ, $interpolation)
    {
    }

    /**
     *Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для объекта, объект будет расположен здесь, когда начнется воспроизведение
     * @param float $endY Конечное значение Y для объекта, объект будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от начала к концу
     * @return void
     */
    function SetTweenObjectY($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     *Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для объекта, объект будет расположен здесь, когда начнется воспроизведение
     * @param float $endX Конечное значение X для объекта, объект будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginX к EndX
     * @return void
     */
    function SetTweenObjectX($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     *Задает параметр scaleZ для данного идентификатора tween ID. Шкала абсолютна, поэтому значение 1.0 будет нормальным размером, в то время как 2.0 будет в два раза больше. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSZ Начальное значение масштаба для объекта, объект будет повернут на этот угол при запуске воспроизведения
     * @param float $endSZ Конечное значение масштаба для объекта, объект будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginSZ к endSZ
     * @return void
     */
    function SetTweenObjectScaleZ($tweenID, $beginSZ, $endSZ, $interpolation)
    {
    }

    /**
     *Задает параметр scaleY для данного идентификатора tween ID. Шкала абсолютна, поэтому значение 1.0 будет нормальным размером, в то время как 2.0 будет в два раза больше. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSY Начальное значение масштаба для объекта, объект будет повернут на этот угол при запуске воспроизведения
     * @param float $endSY Конечное значение масштаба для объекта, объект будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от начала к концу
     * @return void
     */
    function SetTweenObjectScaleY($tweenID, $beginSY, $endSY, $interpolation)
    {
    }

    /**
     *Задает параметр scaleX для данного идентификатора tween ID. Шкала абсолютна, поэтому значение 1.0 будет нормальным размером, в то время как 2.0 будет в два раза больше. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginSX Начальное значение scaleX для объекта, объект будет повернут на этот угол при запуске воспроизведения
     * @param float $endSX Конечное значение scaleX для объекта, объект будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginSX к endSX
     * @return void
     */
    function SetTweenObjectScaleX($tweenID, $beginSX, $endSX, $interpolation)
    {
    }

    /**
     *Устанавливает красный параметр данного идентификатора анимации в диапазоне от 0 до 255. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginR Начальный красный цвет для объекта, объект будет этого цвета, когда начнется игра
     * @param int $endR Конечный красный цвет для объекта, объект будет этого цвета, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении объекта от beginR к EndR
     * @return void
     */
    function SetTweenObjectRed($tweenID, $beginR, $endR, $interpolation)
    {
    }

    /**
     *Устанавливает зеленый параметр данного идентификатора анимации в диапазоне от 0 до 255. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginG Стартовый зеленый цвет для объекта, объект будет этого цвета, когда начнется игра
     * @param int $endG Конечный зеленый цвет для объекта, объект будет этого цвета, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении объекта от начала к концу
     * @return void
     */
    function SetTweenObjectGreen($tweenID, $beginG, $endG, $interpolation)
    {
    }

    /**
     *Устанавливает синий параметр данного идентификатора анимации в диапазоне от 0 до 255. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginB Начальный синий цвет для объекта, объект будет этого цвета, когда начнется игра
     * @param int $endB Конечный синий цвет для объекта, объект будет этого цвета, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении объекта от beginB к endB
     * @return void
     */
    function SetTweenObjectBlue($tweenID, $beginB, $endB, $interpolation)
    {
    }

    /**
     *Задает параметр Euler AngleZ заданного идентификатора tween ID. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAZ Начальное значение AngleZ для объекта, объект будет повернут на этот угол при запуске игры
     * @param float $endAZ Значение end AngleZ для объекта, объект будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginAZ к endAZ
     * @return void
     */
    function SetTweenObjectAngleZ($tweenID, $beginAZ, $endAZ, $interpolation)
    {
    }

    /**
     *Задает параметр Euler angleY данного идентификатора tween. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAY Начальное значение угла для объекта, объект будет повернут на этот угол, когда начнется игра
     * @param float $endAY Значение конечного угла для объекта, объект будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от начала до конца
     * @return void
     */
    function SetTweenObjectAngleY($tweenID, $beginAY, $endAY, $interpolation)
    {
    }

    /**
     *Задает параметр Euler AngleX заданного идентификатора tween ID. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAX Начальное значение AngleX для объекта, объект будет повернут на этот угол при запуске игры
     * @param float $endAX Значение end AngleX для объекта, объект будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении объекта от beginAX к endAX
     * @return void
     */
    function SetTweenObjectAngleX($tweenID, $beginAX, $endAX, $interpolation)
    {
    }

    /**
     *Устанавливает альфа - параметр данного идентификатора tween ID в диапазоне от 0 до 255. Анимация может изменять несколько параметров объекта одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим объектам или цепочкам одновременно с помощью PlayTweenObject или AddTweenChainObject. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginA Начальный альфа-цвет для объекта, объект будет этого цвета, когда начнется воспроизведение
     * @param int $endA Конечный альфа-цвет для объекта, объект будет этого цвета, когда игра заканчивается
     * @param int $interpolation Метод интерполяции при движении объекта от начала к концу
     * @return void
     */
    function SetTweenObjectAlpha($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     *Изменяет продолжительность анимации после ее создания. Если анимация выполняется в данный момент или является частью цепочки, которая выполняется в данный момент, то изменение ее продолжительности может привести к неожиданным результатам.
     *
     * @param int $tweenID Идентификатор твина, который нужно изменить, может быть любым типом твина
     * @param float $duration Новая продолжительность использования в секундах
     * @return void
     */
    function SetTweenDuration($tweenID, $duration)
    {
    }

    /**
     *Задает третье целочисленное значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $begin Отправная точка для этого значения
     * @param int $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomInteger3($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     *Задает четвертое целочисленное значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $begin Отправная точка для этого значения
     * @param int $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomInteger4($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     *Задает второе целочисленное значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $begin Отправная точка для этого значения
     * @param int $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomInteger2($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     *Задает первое целочисленное значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $begin Отправная точка для этого значения
     * @param int $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomInteger1($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     *Устанавливает четвертое плавающее значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $begin Отправная точка для этого значения
     * @param float $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomFloat4($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     *Устанавливает второе плавающее значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $begin Отправная точка для этого значения
     * @param float $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomFloat2($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     *Устанавливает третье плавающее значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $begin Отправная точка для этого значения
     * @param float $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomFloat3($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     *Устанавливает первое плавающее значение заданного пользовательского идентификатора анимации. Анимация может изменять несколько параметров одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $begin Отправная точка для этого значения
     * @param float $end Конечная точка для этого значения
     * @param int $interpolation Метод интерполяции при движении значения от начала к концу
     * @return void
     */
    function SetTweenCustomFloat1($tweenID, $begin, $end, $interpolation)
    {
    }

    /**
     *Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Позиции символов ar относительно родительского текстового объекта. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для персонажа, символ будет расположен здесь, когда начнется игра
     * @param float $endY Конечное значение Y для символа, символ будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как символ движется от начала к концу
     * @return void
     */
    function SetTweenCharY($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     *Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Позиции символов ar относительно родительского текстового объекта. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для персонажа, персонаж будет расположен здесь, когда начнется игра
     * @param float $endX Конечное значение X для персонажа, персонаж будет расположен здесь, когда игра закончится
     * @param int $interpolation Метод интерполяции при перемещении символа из beginX в EndX
     * @return void
     */
    function SetTweenCharX($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     *Задает зеленый параметр заданного идентификатора анимации. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginG Начальное зеленое значение для персонажа, персонаж будет этого цвета, когда начнется игра
     * @param int $endG Конечное зеленое значение для персонажа, персонаж будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как символ движется от начала к концу
     * @return void
     */
    function SetTweenCharGreen($tweenID, $beginG, $endG, $interpolation)
    {
    }

    /**
     *Устанавливает синий параметр данного идентификатора анимации. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginB Начальное синее значение для персонажа, персонаж будет этого цвета, когда начнется игра
     * @param int $endB Конечное синее значение для персонажа, персонаж будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции при перемещении символа из beginB в endB
     * @return void
     */
    function SetTweenCharBlue($tweenID, $beginB, $endB, $interpolation)
    {
    }

    /**
     *Задает красный параметр заданного идентификатора анимации. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginR Начальное красное значение для персонажа, персонаж будет этого цвета, когда начнется игра
     * @param int $endR Конечное красное значение для персонажа, персонаж будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции при перемещении символа из beginR в EndR
     * @return void
     */
    function SetTweenCharRed($tweenID, $beginR, $endR, $interpolation)
    {
    }

    /**
     *Задает параметр угла заданного идентификатора анимации. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginA Начальное значение угла для персонажа, персонаж будет повернут на этот угол, когда начнется игра
     * @param float $endA Значение конечного угла для персонажа, персонаж будет повернут на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как символ движется от начала к концу
     * @return void
     */
    function SetTweenCharAngle($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     *Задает альфа - параметр данного идентификатора tween ID. Анимация может изменять несколько параметров персонажа одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим символам или цепочкам одновременно, в том числе из разных текстовых объектов, с помощью PlayTweenChar или AddTweenChainChar. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param int $beginA Начальное альфа-значение для персонажа, персонаж будет этого цвета, когда начнется игра
     * @param int $endA Конечное альфа-значение для персонажа, персонаж будет этого цвета, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как символ движется от начала к концу
     * @return void
     */
    function SetTweenCharAlpha($tweenID, $beginA, $endA, $interpolation)
    {
    }

    /**
     *Перескакивает цепочку твинов в заданное положение в своей временной линии. Если в данный момент воспроизводится цепочка твинов, то интерполяция оценит заданное значение времени и обновит необходимые объекты. Если цепочка tween не воспроизводится, то эта команда не имеет никакого эффекта, так как вызов PlayTweenChain сбрасывает время до 0. Если время случайно падает на задержку между подростками, то интерполяция останется неизменной до тех пор, пока задержка не будет пройдена.
     *
     * @param int $chainID Идентификатор цепочки для изменения
     * @param float $time Время в секундах для перехода в цепочку tween
     * @return void
     */
    function SetTweenChainTime($chainID, $time)
    {
    }

    /**
     *Задает параметр Z заданного идентификатора tween ID. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginZ Начальное значение Z для камеры, камера будет расположена здесь, когда начнется воспроизведение
     * @param float $endZ Конечное значение Z для камеры, камера будет расположена здесь, когда воспроизведение закончится
     * @param int $interpolation Метод интерполяции при движении камеры от beginZ к endZ
     * @return void
     */
    function SetTweenCameraZ($tweenID, $beginZ, $endZ, $interpolation)
    {
    }

    /**
     *Задает параметр X данного идентификатора tween ID. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginX Начальное значение X для камеры, камера будет расположена здесь, когда начнется воспроизведение
     * @param float $endX Конечное значение X для камеры, камера будет расположена здесь, когда воспроизведение закончится
     * @param int $interpolation Метод интерполяции при движении камеры от beginX к EndX
     * @return void
     */
    function SetTweenCameraX($tweenID, $beginX, $endX, $interpolation)
    {
    }

    /**
     *Задает параметр Y данного идентификатора tween ID. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginY Начальное значение Y для камеры, камера будет расположена здесь, когда начнется воспроизведение
     * @param float $endY Конечное значение Y для камеры, камера будет расположена здесь, когда воспроизведение закончится
     * @param int $interpolation Метод интерполяции в то время как камера движется от начала к концу
     * @return void
     */
    function SetTweenCameraY($tweenID, $beginY, $endY, $interpolation)
    {
    }

    /**
     *Задает параметр Поля зрения заданного идентификатора анимации. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginF Начальное значение FOV для камеры, камера будет иметь это значение FOV при запуске воспроизведения
     * @param float $endF Конечное значение FOV для камеры, камера будет иметь это значение FOV, когда воспроизведение закончится
     * @param int $interpolation Метод интерполяции при движении камеры от beginF к endF
     * @return void
     */
    function SetTweenCameraFOV($tweenID, $beginF, $endF, $interpolation)
    {
    }

    /**
     *Задает параметр Euler AngleZ заданного идентификатора tween ID. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAZ Начальное значение угла Эйлера для камеры, камера будет повернута на этот угол при запуске воспроизведения
     * @param float $endAZ Конечное значение угла Эйлера для камеры, камера будет повернута на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции в то время как камера движется от beginAZ к endAZ
     * @return void
     */
    function SetTweenCameraAngleZ($tweenID, $beginAZ, $endAZ, $interpolation)
    {
    }

    /**
     *Задает параметр Euler angleY данного идентификатора tween. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAY Начальное значение угла Эйлера для камеры, камера будет повернута на этот угол, когда начнется воспроизведение
     * @param float $endAY Конечное значение угла Эйлера для камеры, камера будет повернута на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции во время движения камеры от начала до конца
     * @return void
     */
    function SetTweenCameraAngleY($tweenID, $beginAY, $endAY, $interpolation)
    {
    }

    /**
     *Задает параметр Euler AngleX заданного идентификатора tween ID. Анимация может изменять несколько параметров камеры одновременно. Установите начальное значение и конечное значение, а также метод интерполяции. Твин-это просто шаблон, который может быть применен ко многим камерам или цепочкам одновременно с помощью PlayTweenCamera или AddTweenChainCamera. Доступные методы интерполяции: TweenLinear(), TweenSmooth1(), TweenSmooth2(), TweenEaseIn1(), TweenEaseIn2(), TweenEaseOut1(), TweenEaseOut2(), TweenBounce(), TweenOvershoot() Используйте метод интерполяции -1, чтобы отключить интерполяцию по этому значению
     *
     * @param int $tweenID Идентификатор твина для изменения
     * @param float $beginAX Начальное значение угла Эйлера для камеры, камера будет повернута на этот угол при запуске воспроизведения
     * @param float $endAX Конечное значение угла Эйлера для камеры, камера будет повернута на этот угол, когда игра закончится
     * @param int $interpolation Метод интерполяции при движении камеры от beginAX к endAX
     * @return void
     */
    function SetTweenCameraAngleX($tweenID, $beginAX, $endAX, $interpolation)
    {
    }

    /**
     *Эта команда устарела, переходы ориентации теперь контролируются устройством.
     *
     * @param int $mode переходный режим для использования.
     * @return void
     */
    function SetTransitionMode($mode)
    {
    }

    /**
     *Обновляет положение X текстового объекта в мировых координатах, по умолчанию текст позиционируется с помощью его верхнего левого угла. При использовании выравнивания по правому краю текст позиционируется с помощью его верхнего правого угла. При использовании выравнивания по центру текст позиционируется с помощью точки на полпути вдоль его верхнего края.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fX Новая позиция X.
     * @return void
     */
    function SetTextX($iTextIndex, $fX)
    {
    }

    /**
     *Обновляет положение Y текстового объекта в мировых координатах, по умолчанию текст позиционируется с помощью его верхнего левого угла. При использовании выравнивания по правому краю текст позиционируется с помощью его верхнего правого угла. При использовании выравнивания по центру текст позиционируется с помощью точки на полпути вдоль его верхнего края.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fY Новая позиция Y.
     * @return void
     */
    function SetTextY($iTextIndex, $fY)
    {
    }

    /**
     *Задает, будет ли текст отрисовываться во время обновления экрана.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $bVisible 1, чтобы нарисовать этот текст, 0, чтобы скрыть его.
     * @return void
     */
    function SetTextVisible($iTextIndex, $bVisible)
    {
    }

    /**
     *Установите прозрачность текста на определенную настройку с выбором без прозрачности, альфа-прозрачности и аддитивного смешивания. По умолчанию текст создается с альфа-прозрачностью.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $mode Режим прозрачности для этого текста: 0=выкл., 1=альфа-прозрачность, 2=аддитивное смешивание
     * @return void
     */
    function SetTextTransparency($iTextIndex, $mode)
    {
    }

    /**
     *Обновляет строку текстового объекта, новый текст будет отображаться при следующем обновлении экрана.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param string $string Новая строка для использования.
     * @return void
     */
    function SetTextString($iTextIndex, $string)
    {
    }

    /**
     *Устанавливает интервал между буквами. Значение 0 не создает зазора между ограничивающими буквами, положительное значение увеличивает этот зазор, отрицательное значение перекрывает буквы. Если каждый символ построен с некоторым пробелом по обе стороны от него в изображении шрифта, то это значение интервала по умолчанию, и эта команда будет увеличивать или уменьшать расстояние от него.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fSpacing Новый интервал для использования.
     * @return void
     */
    function SetTextSpacing($iTextIndex, $fSpacing)
    {
    }

    /**
     *Устанавливает размер текстового объекта, по умолчанию 4. Это значение представляет высоту каждого символа в мировых единицах. Ширина каждого символа зависит от шрифта и рассчитывается в соответствии с заданным размером.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fSize Новый размер текста.
     * @return void
     */
    function SetTextSize($iTextIndex, $fSize)
    {
    }

    /**
     *При рисовании текст привязывается к указанным мировым координатам. Используйте значения 0,0,0,0 для отключения текстовых ножниц
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param float $x Координата x верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $y Координата y верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $x2 Координата x в правом нижнем углу окна для использования в качестве границы клипа.
     * @param float $y2 Координата y в правом нижнем углу окна для использования в качестве границы клипа.
     * @return void
     */
    function SetTextScissor($iTextIndex, $x, $y, $x2, $y2)
    {
    }

    /**
     *Задает максимальную ширину, которую текстовый объект будет использовать для рисования, любые символы, выходящие за пределы этого значения, будут переноситься на новую строку.
     *
     * @param int $iTextIndex Идентификатор изменяемого текстового объекта
     * @param float $width Максимальная ширина, которую будет использовать текст
     * @return void
     */
    function SetTextMaxWidth($iTextIndex, $width)
    {
    }

    /**
     *Обновляет положение текстового объекта в мировых координатах, по умолчанию текст позиционируется с помощью его верхнего левого угла. При использовании выравнивания по правому краю текст позиционируется с помощью его верхнего правого угла. При использовании выравнивания по центру текст позиционируется с помощью точки на полпути вдоль его верхнего края.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fX Новая позиция X.
     * @param float $fY Новая позиция Y.
     * @return void
     */
    function SetTextPosition($iTextIndex, $fX, $fY)
    {
    }

    /**
     *Задает интервал между строками текста. Значение 0 не создает зазора между линиями, положительное значение увеличивает этот зазор, отрицательное значение перекрывает линии. Если каждый символ построен с некоторым пробелом над и под ним в изображении шрифта, то это значение интервала по умолчанию, и эта команда увеличит или уменьшит расстояние от него.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fSpacing Новый интервал для использования.
     * @return void
     */
    function SetTextLineSpacing($iTextIndex, $fSpacing)
    {
    }

    /**
     *Задает максимальное количество символов, которое может быть введено в полноэкранное поле редактирования. Используйте 0 для неограниченного количества.
     *
     * @param int $max Максимальное количество символов.
     * @return void
     */
    function SetTextInputMaxChars($max)
    {
    }

    /**
     *Задает расширенный шрифт, используемый для этого текстового объекта. Расширенный шрифт предназначен для нестандартных символов выше значения ascii 127 и может быть установлен отдельно для стандартных символов, так что вы можете иметь несколько изображений для расширенного набора и базовое изображение для обычных символов шрифта. AGK имеет встроенный расширенный шрифт, который он использует для текстовых объектов с символами от 128 до 255, эта команда позволяет переопределить его. Если вы устанавливаете все свои текстовые объекты на один и тот же расширенный шрифт, вам следует использовать вместо этого SetTextDefaultExtendedFontImage, так как это сэкономит некоторое время обработки. Изображение должно содержать все белые символы, окруженные прозрачным альфа-каналом. Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB. Изображение шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины изображение шрифта должно быть выложено в сетку из 16 символов поперек и 8 символов вниз, начиная с символа ascii 32 (пробел) в левом верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 127 (DEL) в правом нижнем углу. Ширина изображения должна быть кратна 16, а высота изображения-6. Для переменной ширины изображение должно быть текстурой атласа, сопровождаемой subimages.txt файл, в котором указано расположение каждого символа на изображении. AGK будет искать изображения "32" до "127" включительно в файле подизображений, и любые не найденные будут по умолчанию использовать символ пробела (32). Символы переменной высоты не поддерживаются, и все символы должны быть одинаковой высоты с любым необходимым заполнением, включенным в изображение шрифта. Если этот текстовый объект использует шрифт TrueType, то эта команда не влияет, шрифт TrueType обрабатывает как обычные, так и расширенные символы (unicode).
     *
     * @param int $iTextIndex Идентификатор изменяемого текстового объекта
     * @param int $iImageID Изображение, содержащее новый шрифт.
     * @return void
     */
    function SetTextExtendedFontImage($iTextIndex, $iImageID)
    {
    }

    /**
     *Задает шрифт TrueType, используемый для этого текстового объекта. Шрифт должен быть загружен с помощью LoadFont из файла шрифтов TrueType. Это отличается от старых растровых шрифтов тем, что он поддерживает символы юникода, и символы обычно появляются более четкими на экране всех размеров.  Обратите внимание, что изменение размера текстового объекта, использующего шрифт TrueType, приведет к перерисовке всех символов из файла шрифта на изображение для рисования, для больших размеров текста с использованием сотен различных символов юникода это может быть медленным процессом, но при нормальном использовании он обычно не заметен.  Недавно использованные размеры сохраняются в течение короткого периода времени, поэтому, если вы часто переключаетесь между двумя или тремя размерами текста, вам не нужно будет перерисовывать его, и это будет быстрее.  Используйте идентификатор шрифта 0, чтобы использовать встроенный шрифт TrueType, поддерживающий широкий диапазон символов unicode.
     *
     * @param int $iTextIndex Идентификатор изменяемого текстового объекта.
     * @param int $iFontID Идентификатор используемого шрифта.
     * @return void
     */
    function SetTextFont($iTextIndex, $iFontID)
    {
    }

    /**
     *Устанавливает шрифт, используемый для этого текстового объекта. AGK имеет встроенный шрифт, который он использует для текстовых объектов, это позволяет вам переопределить его. Если вы устанавливаете все свои текстовые объекты на один и тот же шрифт, вам следует использовать вместо этого SetTextDefaultFontImage, так как это сэкономит некоторое время обработки. Изображение должно содержать все белые символы, окруженные прозрачным альфа-каналом. Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB. Изображение шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины изображение шрифта должно быть выложено в сетку из 16 символов поперек и 6 символов вниз, начиная с символа ascii 32 (пробел) в левом верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 127 (DEL) в правом нижнем углу. Ширина изображения должна быть кратна 16, а высота изображения-6. Для переменной ширины изображение должно быть текстурой атласа, сопровождаемой subimages.txt файл, в котором указано расположение каждого символа на изображении. AGK будет искать изображения "32" до "127" включительно в файле подизображений, и любые не найденные будут по умолчанию использовать символ пробела (32). Символы переменной высоты не поддерживаются, и все символы должны быть одинаковой высоты с любым необходимым заполнением, включенным в изображение шрифта. Начиная с версии 2.0.20 вы можете использовать SetTextFont для использования шрифтов TrueType вместо растровых шрифтов. Вы должны выбрать один или другой, установка растрового шрифта удалит шрифт Truetype, а установка шрифта TrueType удалит растровый шрифт.
     *
     * @param int $iTextIndex Идентификатор изменяемого текстового объекта
     * @param int $iImageID Изображение, содержащее новый шрифт.
     * @return void
     */
    function SetTextFontImage($iTextIndex, $iImageID)
    {
    }

    /**
     *Устанавливает порядок рисования текста между 0-10000, 0 - передняя часть экрана, 10000 - задняя. Все, что больше 10000, приведет к тому, что текст будет вырезан из поля зрения. По умолчанию текст установлен на глубину 9 и отображается выше всех других спрайтов в сцене, установка большей глубины приведет к сортировке текста в прозрачный список порядка рисования, что может снизить производительность. Используйте глубину 0 для достижения наилучшей производительности.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iDepth На какой глубине должен быть нарисован этот текст.
     * @return void
     */
    function SetTextDepth($iTextIndex, $iDepth)
    {
    }

    /**
     *Устанавливает фильтр изображений для всех текстовых объектов и функций печати, использующих шрифт по умолчанию, когда текстовое изображение больше занимаемого им пространства экрана. Ближайшая фильтрация выбирает ближайший пиксель для отображения и может выглядеть блочной. Линейная фильтрация смешивает 4 ближайших пикселя и может выглядеть размытой.
     *
     * @param int $mode Используемый режим фильтрации: 0=ближайший, 1=линейный
     * @return void
     */
    function SetTextDefaultMagFilter($mode)
    {
    }

    /**
     *Устанавливает фильтр изображения для всех текстовых объектов и функций печати, использующих шрифт по умолчанию, когда текстовое изображение меньше занимаемого им пространства экрана. Ближайшая фильтрация выбирает ближайший пиксель для отображения и может выглядеть блочной. Линейная фильтрация смешивает 4 ближайших пикселя и может выглядеть размытой.
     *
     * @param int $mode Используемый режим фильтрации: 0=ближайший, 1=линейный
     * @return void
     */
    function SetTextDefaultMinFilter($mode)
    {
    }

    /**
     *Устанавливает расширенный шрифт по умолчанию для текстовых объектов. Расширенный шрифт предназначен для нестандартных символов выше значения ascii 127 и может быть установлен отдельно для стандартных символов, так что вы можете иметь несколько изображений для расширенного набора и базовое изображение для обычных символов шрифта. AGK имеет встроенный расширенный шрифт для символов от 128 до 255, который он использует для текстовых объектов, что позволяет переопределить его. Если вы решите переопределить его, вы должны сделать это перед созданием любых текстовых объектов. Вы можете установить шрифт для каждого текста с помощью Settextendedfontimage. Изображение должно содержать все белые символы, окруженные прозрачным альфа-каналом. Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB. Расширенное изображение шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины изображение шрифта должно быть выложено в сетку из 16 символов поперек и 8 символов вниз, начиная с символа ascii 128 в левом верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 255 в правом нижнем углу. Ширина изображения должна быть кратна 16, а высота-8. Для переменной ширины изображение должно быть текстурой атласа, сопровождаемой subimages.txt файл, в котором указано расположение каждого символа на изображении. AGK будет искать изображения "128" до "255" включительно в файле подизображений, а любые не найденные будут по умолчанию использовать символ пробела (32).
     *
     * @param int $iImageID Изображение, содержащее новый шрифт.
     * @return void
     */
    function SetTextDefaultExtendedFontImage($iImageID)
    {
    }

    /**
     *Устанавливает шрифт по умолчанию для текстовых объектов. AGK имеет встроенный шрифт, который он использует для текстовых объектов, это позволяет вам переопределить его. Если вы решите переопределить его, вы должны сделать это перед созданием любых текстовых объектов. Вы можете установить шрифт для каждого текста с помощью SetTextFontImage. Изображение должно содержать все белые символы, окруженные прозрачным альфа-каналом. Полностью прозрачные пиксели также должны содержать белый цвет в своих компонентах RGB. Изображение шрифта может быть либо фиксированной ширины, либо переменной ширины. Для фиксированной ширины изображение шрифта должно быть выложено в сетку из 16 символов поперек и 6 символов вниз, начиная с символа ascii 32 (пробел) в левом верхнем углу и продолжая слева направо, сверху вниз, заканчивая символом ascii 127 (DEL) в правом нижнем углу. Ширина изображения должна быть кратна 16, а высота изображения-6. Для переменной ширины изображение должно быть текстурой атласа, сопровождаемой subimages.txt файл, в котором указано расположение каждого символа на изображении. AGK будет искать изображения "32" до "127" включительно в файле подизображений, и любые не найденные будут по умолчанию использовать символ пробела (32).
     *
     * @param int $iImageID Изображение, содержащее новый шрифт.
     * @return void
     */
    function SetTextDefaultFontImage($iImageID)
    {
    }

    /**
     *Установите зеленый компонент цвета текста. Значение должно находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iGreen Зеленая составляющая цвета.
     * @return void
     */
    function SetTextColorGreen($iTextIndex, $iGreen)
    {
    }

    /**
     *Установите красный компонент цвета текста. Значение должно находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iRed Красная составляющая цвета.
     * @return void
     */
    function SetTextColorRed($iTextIndex, $iRed)
    {
    }

    /**
     *Установите синий компонент цвета текста. Значение должно находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iBlue Синяя составляющая цвета.
     * @return void
     */
    function SetTextColorBlue($iTextIndex, $iBlue)
    {
    }

    /**
     *Установите альфа-компонент цвета текста. Значение должно находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iAlpha Альфа-компонент цвета.
     * @return void
     */
    function SetTextColorAlpha($iTextIndex, $iAlpha)
    {
    }

    /**
     *Установите цвет текста, значения должны быть в диапазоне 0-255. Это приведет к тому, что все символы в тексте будут иметь этот цвет. Вы можете установить отдельные символы с помощью SetTextCharColor.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iRed Красная составляющая цвета.
     * @param int $iGreen Зеленая составляющая цвета.
     * @param int $iBlue Синяя составляющая цвета.
     * @param int $iAlpha Альфа-компонент цвета.
     * @return void
     */
    function SetTextColor($iTextIndex, $iRed, $iGreen, $iBlue, $iAlpha)
    {
    }

    /**
     *Установите положение X отдельного символа относительно позиции текста, установленной ранее. Символ будет расположен в верхнем левом углу. При вызове любой из следующих команд положение всех символов будет сброшено на прямую линию: SetTextPosition, SetTextX, SetTextY, setTextSize, SetTextSpacing, SetTextAlignment. Позиционирование символов внутри текстового объекта более эффективно, чем позиционирование множества небольших текстовых объектов, каждый из которых содержит символ, поскольку все символы могут быть нарисованы в одном вызове рисования.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iCharIndex Индекс символа для изменения, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param float $x Новая позиция X символа относительно текущей позиции текста.
     * @return void
     */
    function SetTextCharX($iTextIndex, $iCharIndex, $x)
    {
    }

    /**
     *Установите положение Y отдельного символа относительно позиции текста, установленной ранее. Символ будет расположен в верхнем левом углу. При вызове любой из следующих команд положение всех символов будет сброшено на прямую линию: SetTextPosition, SetTextX, SetTextY, setTextSize, SetTextSpacing, SetTextAlignment. Позиционирование символов внутри текстового объекта более эффективно, чем позиционирование множества небольших текстовых объектов, каждый из которых содержит символ, поскольку все символы могут быть нарисованы в одном вызове рисования.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iCharIndex Индекс символа для изменения, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param float $y Новая позиция символа Y относительно текущей позиции текста.
     * @return void
     */
    function SetTextCharY($iTextIndex, $iCharIndex, $y)
    {
    }

    /**
     *Задает красный компонент заданного цвета символов. Использование команды SetTextColor переопределит это. Значения должны находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param int $red Новое красное значение для использования
     * @return void
     */
    function SetTextCharColorRed($iTextIndex, $iCharIndex, $red)
    {
    }

    /**
     *Установите положение отдельного символа относительно позиции текста, заданной ранее. Символ будет расположен в верхнем левом углу. При вызове любой из следующих команд положение всех символов будет сброшено на прямую линию: SetTextPosition, SetTextX, SetTextY, setTextSize, SetTextSpacing, SetTextAlignment. Позиционирование символов внутри текстового объекта более эффективно, чем позиционирование множества небольших текстовых объектов, каждый из которых содержит символ, поскольку все символы могут быть нарисованы в одном вызове рисования.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iCharIndex Индекс символа для изменения, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param float $x Новая позиция X символа относительно текущей позиции текста.
     * @param float $y Новая позиция символа Y относительно текущей позиции текста.
     * @return void
     */
    function SetTextCharPosition($iTextIndex, $iCharIndex, $x, $y)
    {
    }

    /**
     *Устанавливает зеленый компонент цвета указанного символа. Использование команды SetTextColor переопределит это. Значения должны находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param int $green Новое зеленое значение для использования
     * @return void
     */
    function SetTextCharColorGreen($iTextIndex, $iCharIndex, $green)
    {
    }

    /**
     *Устанавливает синий компонент цвета указанного символа. Использование команды SetTextColor переопределит это. Значения должны находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param int $blue Новое синее значение для использования
     * @return void
     */
    function SetTextCharColorBlue($iTextIndex, $iCharIndex, $blue)
    {
    }

    /**
     *Задает цвет указанного символа. Использование команды SetTextColor переопределит это. Значения должны находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param int $red красная составляющая нового цвета.
     * @param int $green зеленая составляющая нового цвета.
     * @param int $blue синий компонент нового цвета.
     * @param int $alpha альфа-компонент нового цвета.
     * @return void
     */
    function SetTextCharColor($iTextIndex, $iCharIndex, $red, $green, $blue, $alpha)
    {
    }

    /**
     *Задает альфа-компонент цвета указанного символа. Использование команды SetTextColor переопределит это. Значения должны находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param int $alpha Новое альфа-значение для использования
     * @return void
     */
    function SetTextCharColorAlpha($iTextIndex, $iCharIndex, $alpha)
    {
    }

    /**
     *Установите угол отдельного символа в радианах по часовой стрелке. Персонаж будет вращаться вокруг своего центра. Если какая - либо из следующих команд будет вызвана, то вращение всех символов будет сброшено: SetTextPosition, SetTextX, Settextty, setTextSize, SetTextSpacing, SetTextAlignment.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iCharIndex Индекс символа для изменения, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param float $angle Новый угол в радианах.
     * @return void
     */
    function SetTextCharAngleRad($iTextIndex, $iCharIndex, $angle)
    {
    }

    /**
     *Задает символу полужирный стиль. Это применимо только в том случае, если текст использует шрифт TrueType, установленный с помощью SetTextFont. Если вы используете SetTextString, то этот параметр будет сброшен на 0. Вы можете использовать SetTextBold, чтобы установить всю строку жирным шрифтом.
     *
     * @param int $iTextIndex Идентификатор устанавливаемого текстового объекта.
     * @param int $iCharIndex Индекс устанавливаемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param int $bold 1, чтобы установить символ как жирный, 0, чтобы установить его как нормальный вес (по умолчанию)
     * @return void
     */
    function SetTextCharBold($iTextIndex, $iCharIndex, $bold)
    {
    }

    /**
     *Установите угол наклона отдельного символа в градусах по часовой стрелке. Персонаж будет вращаться вокруг своего центра. Если какая - либо из следующих команд будет вызвана, то вращение всех символов будет сброшено: SetTextPosition, SetTextX, Settextty, setTextSize, SetTextSpacing, SetTextAlignment.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $iCharIndex Индекс символа для изменения, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @param float $angle Новый угол в градусах.
     * @return void
     */
    function SetTextCharAngle($iTextIndex, $iCharIndex, $angle)
    {
    }

    /**
     *Обновляет угол наклона текста. Если текст выровнен по левому краю, то он будет вращаться вокруг своего верхнего левого угла. При использовании выравнивания по центру он будет вращаться вокруг точки на полпути вдоль своего верхнего края. При использовании правого выравнивания он будет вращаться вокруг своего верхнего восьмого угла.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fAngleRad Новый угол в радианах.
     * @return void
     */
    function SetTextAngleRad($iTextIndex, $fAngleRad)
    {
    }

    /**
     *Устанавливает все символы в тексте полужирным шрифтом независимо от текущего состояния SetTextCharBold. Этот параметр будет оставаться активным до тех пор, пока он не будет изменен, установка новой текстовой строки не изменит его.
     *
     * @param int $iTextIndex Идентификатор текста для изменения.
     * @param int $bold 1
     * @return void
     */
    function SetTextBold($iTextIndex, $bold)
    {
    }

    /**
     *Обновляет угол наклона текста. Если текст выровнен по левому краю, то он будет вращаться вокруг своего верхнего левого угла. При использовании выравнивания по центру он будет вращаться вокруг точки на полпути вдоль своего верхнего края. При использовании правого выравнивания он будет вращаться вокруг своего верхнего восьмого угла.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param float $fAngle Новый угол в градусах.
     * @return void
     */
    function SetTextAngle($iTextIndex, $fAngle)
    {
    }

    /**
     *Устанавливает, как текст должен быть расположен на экране. Выравнивание по левому краю позиционирует текст, используя его верхний левый угол, выравнивание по правому краю позиционирует его, используя его верхний правый угол, а центр позиционирует его, используя точку на полпути вдоль его верхнего края.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для обновления.
     * @param int $iMode Режим выравнивания для использования. 0=слева, 1=в центре, 2=справа
     * @return void
     */
    function SetTextAlignment($iTextIndex, $iMode)
    {
    }

    /**
     *Устанавливает желаемую скорость, с которой кадры будут выводиться на экран, в кадрах в секунду (fps). Кроме того, есть два режима на выбор, которые могут ограничить процессор, первый (mode=0) спит приложение между кадрами, чтобы сэкономить процессор и время автономной работы, где это возможно. Второй (mode=1) использует непрерывный цикл для проверки времени перед следующим кадром, который может быть более точным, но перегружает процессор. Предпочтительным методом ограничения частоты кадров является SetVSync (), который устанавливает частоту обновления на частоту обновления монитора и предотвращает разрыв экрана или заикание. Использование SetSyncRate автоматически отключит VSync, так как две команды будут бороться друг с другом за контроль частоты кадров. Используйте fps 0, чтобы удалить все ограничения и нарисовать кадры как можно быстрее. Это может быть до тысячи кадров в секунду на самых мощных видеокартах. Обратите внимание, что в HTML5 использование SetSyncRate крайне не рекомендуется, так как он использует функцию Javascript setTimeout для синхронизации, что может привести к неточной частоте кадров и заиканию. В HTML5 предпочтительным методом управления частотой кадров является SetVSync.
     *
     * @param float $fps Желаемая частота кадров в кадрах в секунду, 0 для неограниченного числа.
     * @param int $mode 1 для использования, возможно, более точного, но интенсивного метода работы с процессором, 0 (по умолчанию) для экономии процессора и батареи.
     * @return void
     */
    function SetSyncRate($fps, $mode)
    {
    }

    /**
     *Устанавливает новый цвет для глобального направленного света. Значения должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать свет.
     *
     * @param int $red Красная составляющая нового цвета.
     * @param int $green Зеленая составляющая нового цвета.
     * @param int $blue Синий компонент нового цвета.
     * @return void
     */
    function SetSunColor($red, $green, $blue)
    {
    }

    /**
     *Задает направление для глобального направленного света.
     *
     * @param float $vx X-компонент нового направления.
     * @param float $vy Y-компонент нового направления.
     * @param float $vz Z-компонент нового направления.
     * @return void
     */
    function SetSunDirection($vx, $vy, $vz)
    {
    }

    /**
     *Устанавливает, светит ли глобальный направленный свет или нет.
     *
     * @param int $active 1, чтобы активировать его, 0, чтобы деактивировать
     * @return void
     */
    function SetSunActive($active)
    {
    }

    /**
     *Немедленно позиционирует указанный спрайт в заданные мировые координаты Y. Мировая система координат по умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно изменить с помощью SetVirtualResolution). Эта команда позиционирует спрайт в верхнем левом углу.
     *
     * @param int $iSpriteIndex Идентификатор спрайта в позиции
     * @param float $fY Координата Y для позиционирования спрайта может использовать десятичные значения.
     * @return void
     */
    function SetSpriteY($iSpriteIndex, $fY)
    {
    }

    /**
     *Немедленно помещает указанный спрайт в заданные мировые координаты X. Мировая система координат по умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно изменить с помощью SetVirtualResolution). Эта команда позиционирует спрайт в верхнем левом углу.
     *
     * @param int $iSpriteIndex Идентификатор спрайта в позиции
     * @param float $fX Координата X для позиционирования спрайта может использовать десятичные значения.
     * @return void
     */
    function SetSpriteX($iSpriteIndex, $fX)
    {
    }

    /**
     *Масштабирует УФ-координаты спрайтов на заданную величину. Спрайт с УФ-масштабированием на 2 сделает его текстуру вдвое больше обычной. УФ-шкала не влияет на УФ-смещение, выбранное с помощью SetSpriteUVOffset, так что смещение 0,5 в направлении U всегда будет начинать выборку на полпути по текстуре, шкала определяет, как далеко спрайт продолжает выборку. Таким образом, при смещении 0,5 шкала 2 сделает выборку спрайта от 0,5 до 1 вместо 0,5 до 1,5. По умолчанию спрайт настроен на использование УФ-координат от 0,0 до 1,1, используя полное доступное ему изображение. Однако есть несколько случаев, когда это изменяется AGK, чтобы скрыть определенные ограничения. Если текстура, назначенная спрайту, не имеет степени 2 ширины или высоты, изображение увеличивается в размере до тех пор, пока оно не станет степенью 2 размера, а УФ-координаты для спрайта уменьшаются так, что спрайт использует только ту часть текстуры, которая содержит исходное изображение. Это происходит потому, что большинство мобильных платформ не поддерживают текстуры, которые не являются силой 2 ширины или высоты. Поэтому смещение УФ-координат спрайта в этом случае сместит использование спрайтом текстуры в неопределенную часть, которая используется в качестве отступа. Кроме того, если спрайт использует изображение, принадлежащее текстуре атласа, УФ-координаты спрайта будут установлены таким образом, чтобы он использовал только ту часть текстуры, которая содержит назначенное ему изображение. Смещение УФ-координат в этом случае сместит использование спрайтом текстуры на другие изображения, которые являются частью текстуры атласа. То же самое можно сказать и о спрайтах, использующих анимацию, содержащуюся в одной текстуре, используя SetSpriteAnimation. Из-за этих возможностей рекомендуется изменять УФ-координаты только на спрайтах, использующих целые изображения (а не текстуры атласа) и имеющих степень 2 размера как по ширине, так и по высоте. С этими ограничениями можно использовать УФ-значения вне 0-1 для успешного зажима или повторения текстуры.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения
     * @param float $scaleU Сумма для масштабирования в направлении U.
     * @param float $scaleV Сумма для масштабирования в направлении V.
     * @return void
     */
    function SetSpriteUVScale($iSpriteIndex, $scaleU, $scaleV)
    {
    }

    /**
     *Задает, виден ли этот спрайт во время рисования. Он все еще может обновлять свою анимацию и физику, которые управляются SetSpriteActive.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $bVisible Видимость этого спрайта, 1 для видимого, 0 для невидимого.
     * @return void
     */
    function SetSpriteVisible($iSpriteIndex, $bVisible)
    {
    }

    /**
     *Смещает УФ - координаты спрайтов на заданную величину. Например, смещение на 0,5 в направлении U заставит спрайт начать выборку текстуры посередине верхней части текстуры, а не в верхнем левом углу, как обычно. Значения UV вне диапазона 0,0 (вверху слева) и 1,1 (внизу справа) могут либо обернуть, либо зажать текстуру, что определяется изображением, назначенным спрайту с помощью SetImageWrapU и SetImageWrapV. Зажим или обертывание не могут быть установлены на основе каждого спрайта. По умолчанию спрайт настроен на использование УФ-координат от 0,0 до 1,1, используя полное доступное ему изображение. Однако есть несколько случаев, когда это изменяется AGK, чтобы скрыть определенные ограничения. Если текстура, назначенная спрайту, не имеет степени 2 ширины или высоты, изображение увеличивается в размере до тех пор, пока оно не станет степенью 2 размера, а УФ-координаты для спрайта уменьшаются так, что спрайт использует только ту часть текстуры, которая содержит исходное изображение. Это происходит потому, что большинство мобильных платформ не поддерживают текстуры, которые не являются силой 2 ширины или высоты. Поэтому смещение УФ-координат спрайта в этом случае сместит использование спрайтом текстуры в неопределенную часть, которая используется в качестве отступа. Кроме того, если спрайт использует изображение, принадлежащее текстуре атласа, УФ-координаты спрайта будут установлены таким образом, чтобы он использовал только ту часть текстуры, которая содержит назначенное ему изображение. Смещение УФ-координат в этом случае сместит использование спрайтом текстуры на другие изображения, которые являются частью текстуры атласа. То же самое можно сказать и о спрайтах, использующих анимацию, содержащуюся в одной текстуре, используя SetSpriteAnimation. Из-за этих возможностей рекомендуется изменять УФ-координаты только на спрайтах, использующих целые изображения (а не текстуры атласа) и имеющих степень 2 размера как по ширине, так и по высоте. С этими ограничениями можно использовать УФ-значения вне 0-1 для успешного зажима или повторения текстуры.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения
     * @param float $u Величина смещения UV-координат в направлении U.
     * @param float $v Величина смещения UV-координат в направлении V.
     * @return void
     */
    function SetSpriteUVOffset($iSpriteIndex, $u, $v)
    {
    }

    /**
     *Настраивает УФ-координаты спрайта для создания границы, которая перемещает край спрайта внутрь, подальше от края примененного к нему изображения. Это может быть полезно для субизображений, загруженных из текстуры атласа, где изображения могут быть упакованы очень близко друг к другу. Использование границы гарантирует, что спрайт случайно не возьмет образец из соседнего изображения, вы также можете исправить это, добавив пространство между изображениями в текстуре атласа. По умолчанию спрайт использует границу в 0,5 пикселя, когда его изображение является субизображением, и границу в 0 пикселей, когда оно имеет нормальное изображение. Если вы сами компенсировали это, добавив интервал к изображению атласа, то установка границы на 0 удаляет смещение по умолчанию и создает пиксельное идеальное воспроизведение субизображения. Вы также можете увеличить эту границу, установив границу больше 0,5 пикселя.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $border 0=нет границы, 0,5=смещение на половину пикселя, 1=смещение на один пиксель и т. Д.
     * @return void
     */
    function SetSpriteUVBorder($iSpriteIndex, $border)
    {
    }

    /**
     *Эта команда переопределяет обычные УФ-вычисления спрайтов и позволяет устанавливать их непосредственно для каждой вершины. Обратите внимание, что анимация с использованием листов спрайта или текстур атласа не будет работать при использовании этой команды, а функции УФ-смещения и масштабирования не будут иметь никакого эффекта. У вас есть полный контроль над УФ-координатами. Чтобы отменить это, используйте ResetSpriteUV для возврата к вычисленным UV-координатам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $u1 U-координата верхней левой вершины.
     * @param float $v1 V-координата верхней левой вершины.
     * @param float $u2 U-координата нижней левой вершины.
     * @param float $v2 V-координата нижней левой вершины.
     * @param float $u3 U-координата верхней правой вершины.
     * @param float $v3 V-координата верхней правой вершины.
     * @param float $u4 U-координата нижней правой вершины.
     * @param float $v4 V-координата нижней правой вершины.
     * @return void
     */
    function SetSpriteUV($iSpriteIndex, $u1, $v1, $u2, $v2, $u3, $v3, $u4, $v4)
    {
    }

    /**
     *Устанавливает анимацию спрайта на заданную скорость, может использоваться во время работы анимации. Можно установить значение 0, чтобы временно приостановить анимацию.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $fFps скорость, с которой спрайт должен обновляться, кадры спрайта будут пропущены, если частота кадров спрайта слишком высока по сравнению с частотой кадров игры.
     * @return void
     */
    function SetSpriteSpeed($iSpriteIndex, $fFps)
    {
    }

    /**
     *Устанавливает спрайту новую ширину и высоту. В системе координат по умолчанию ширина и высота 100 100 будут заполнять весь рисуемый экран (это можно изменить с помощью SetVirtualResolution). Если задано значение width или height, а другое значение равно -1, то значение -1 будет пересчитано для поддержания соотношения сторон изображения, чтобы оно не выглядело растянутым. Если и ширина, и высота равны -1, то спрайт возьмет ширину назначенного изображения и вычислит его высоту, чтобы оно не растягивалось. Эта функция пересчитывает форму столкновения спрайта, что может быть дорогостоящим процессом для круговых и полигональных фигур. Более эффективный способ изменить размер спрайта - масштабировать его с помощью функции SetSpriteScale. Эта функция сбрасывает масштаб спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения.
     * @param float $width ширина, используемая для спрайта, используйте минус 1, чтобы вычислить это значение.
     * @param float $height высота, используемая для спрайта, используйте минус 1, чтобы вычислить это значение.
     * @return void
     */
    function SetSpriteSize($iSpriteIndex, $width, $height)
    {
    }

    /**
     *Включает специальный режим рендеринга, который удерживает спрайт только на целых пикселях, чтобы он не рисовал себя через границы пикселей, что может вызвать мерцание при перемещении спрайта по экрану. Как следствие, это может привести к тому, что спрайт будет прыгать с одного пикселя на другой, а не плавно перемещаться по экрану. Если спрайт имеет альфа-смешанные пиксели вдоль своего края, то привязка не требуется и может быть отключена. По умолчанию эта функция отключена.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $snap 1, чтобы включить привязку, 0, чтобы выключить ее
     * @return void
     */
    function SetSpriteSnap($iSpriteIndex, $snap)
    {
    }

    /**
     *Установите прозрачность спрайта на определенную настройку с выбором без прозрачности, альфа-прозрачности и аддитивного смешивания. По умолчанию спрайты создаются с альфа-прозрачностью, но если вам это не нужно, рекомендуется отключить прозрачность для повышения производительности.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $mode Режим прозрачности для этого спрайта: 0=выкл., 1=альфа-прозрачность, 2=аддитивное смешивание
     * @return void
     */
    function SetSpriteTransparency($iSpriteIndex, $mode)
    {
    }

    /**
     *Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений, тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Полигон определяется набором точек (от 2 до 12) относительно смещения текущего спрайта. Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено от этой точки. Точки определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой фигуры. По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $numPoints Количество точек, используемых в полигоне, не менее 2, не более 12.
     * @param int $index Индекс точки для установки, если он равен numPoints-1, то будет создана фигура
     * @param float $x X координата добавляемого полигона
     * @param float $y Y координата добавляемого полигона
     * @return void
     */
    function SetSpriteShapePolygon($iSpriteIndex, $numPoints, $index, $x, $y)
    {
    }

    /**
     *Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений, тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Полигон определяется набором точек (от 2 до 12) относительно смещения текущего спрайта. Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено от этой точки. Точки определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой фигуры. По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $numPoints Количество точек, используемых в полигоне, не менее 2, не более 12.
     * @param int $index Индекс точки для установки, если он равен numPoints-1, то будет создана фигура
     * @param float $x X координата добавляемого полигона
     * @param float $y Y координата добавляемого полигона
     * @param int $shapeID Идентификатор изменяемой фигуры, первая фигура-ID 1, 0=удалить существующие фигуры и заменить их этой новой
     * @return void
     */
    function SetSpriteShapePolygon($iSpriteIndex, $numPoints, $index, $x, $y, $shapeID)
    {
    }

    /**
     *Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений, тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Окружность определяется путем указания ее центральной точки относительно текущего смещения спрайта и радиуса. Например, если круг должен быть центрирован в точке смещения спрайта, он будет указан в позиции 0,0. Любое другое значение будет смещать круг от спрайта. Радиус определяется в координатах x, поскольку мировые координаты не обязательно представляют размер элементов на экране (например, 10 единиц в X могут быть не такими же видимыми размерами, как 10 единиц в Y). По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Координата X центра окружности в спрайтовом пространстве.
     * @param float $y Координата Y центра окружности в спрайтовом пространстве.
     * @param float $radius Радиус окружности.
     * @return void
     */
    function SetSpriteShapeCircle($iSpriteIndex, $x, $y, $radius)
    {
    }

    /**
     *Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений, тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Окружность определяется путем указания ее центральной точки относительно текущего смещения спрайта и радиуса. Например, если круг должен быть центрирован в точке смещения спрайта, он будет указан в позиции 0,0. Любое другое значение будет смещать круг от спрайта. Радиус определяется в координатах x, поскольку мировые координаты не обязательно представляют размер элементов на экране (например, 10 единиц в X могут быть не такими же видимыми размерами, как 10 единиц в Y). По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Координата X центра окружности в спрайтовом пространстве.
     * @param float $y Координата Y центра окружности в спрайтовом пространстве.
     * @param float $radius Радиус окружности.
     * @param int $shapeID Идентификатор изменяемой фигуры, первая фигура-ID 1, 0=удалить существующие фигуры и заменить их этой новой
     * @return void
     */
    function SetSpriteShapeCircle($iSpriteIndex, $x, $y, $radius, $shapeID)
    {
    }

    /**
     *Переопределяет текущую автоматически сгенерированную форму для использования в физике. Обычное тестирование столкновений и попаданий спрайтов не работает с формой цепи, это только для физики. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Цепочка определяется набором точек (не менее 2) относительно смещения текущего спрайта. Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено от этой точки. Цепи являются жесткими и могут быть использованы для создания полых вогнутых полигонов или 2D-ландшафтов. Установите параметр loop равным 1, чтобы соединить два конца цепочки вместе, создав полый многоугольник. Точки определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой фигуры. Использование shapeID 0 удаляет все другие фигуры, назначенные спрайту, и заменяет его этим. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $numPoints Количество точек для использования в цепочке, мин 2, не более.
     * @param int $index Индекс точки для установки, если он равен numPoints-1, то будет создана фигура
     * @param int $loop 1, чтобы соединить два конца цепи вместе, 0, чтобы оставить их несвязанными
     * @param float $x X координата добавляемого полигона
     * @param float $y Y координата добавляемого полигона
     * @param int $shapeID Идентификатор изменяемой фигуры, первая фигура-ID 1, 0=удалить существующие фигуры и заменить их этой новой
     * @return void
     */
    function SetSpriteShapeChain($iSpriteIndex, $numPoints, $index, $loop, $x, $y, $shapeID)
    {
    }

    /**
     *Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений, тестировании ударов и физике. Фигуру можно задать без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Поле определяется путем указания его верхних левых и нижних правых координат в пространстве спрайта относительно смещения спрайта, по умолчанию это центр спрайта. Например, если текущее смещение спрайта равно 0,0, то верхний левый угол коробки будет равен 0,0, но если смещение спрайта равно середине спрайта (по умолчанию), то верхний левый угол будет равен-width/2,-height/2. Вы также можете указать угол смещения коробки относительно текущего поворота спрайта. По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата X верхнего левого угла нового окна в пространстве спрайтов.
     * @param float $y Координата Y верхнего левого угла нового окна в пространстве спрайтов.
     * @param float $x2 Координата X в правом нижнем углу нового окна в пространстве спрайтов.
     * @param float $y2 Координата Y в правом нижнем углу нового окна в пространстве спрайтов.
     * @param float $angle Угол коробки в радианах.
     * @param int $shapeID Идентификатор изменяемой фигуры, первая фигура-ID 1, 0=удалить существующие фигуры и заменить их этой новой
     * @return void
     */
    function SetSpriteShapeBox($iSpriteIndex, $x, $y, $x2, $y2, $angle, $shapeID)
    {
    }

    /**
     *Переопределяет текущую автоматически сгенерированную форму для использования в обнаружении столкновений, тестировании ударов и физике. Фигуру можно задать без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Поле определяется путем указания его верхних левых и нижних правых координат в пространстве спрайта относительно смещения спрайта, по умолчанию это центр спрайта. Например, если текущее смещение спрайта равно 0,0, то верхний левый угол коробки будет равен 0,0, но если смещение спрайта равно середине спрайта (по умолчанию), то верхний левый угол будет равен-width/2,-height/2. Вы также можете указать угол смещения коробки относительно текущего поворота спрайта. По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата X верхнего левого угла нового окна в пространстве спрайтов.
     * @param float $y Координата Y верхнего левого угла нового окна в пространстве спрайтов.
     * @param float $x2 Координата X в правом нижнем углу нового окна в пространстве спрайтов.
     * @param float $y2 Координата Y в правом нижнем углу нового окна в пространстве спрайтов.
     * @param float $angle Угол коробки в радианах.
     * @return void
     */
    function SetSpriteShapeBox($iSpriteIndex, $x, $y, $x2, $y2, $angle)
    {
    }

    /**
     *Задает текущую форму для использования в обнаружении столкновений, тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Если вы выберете no shape (0), то любая существующая фигура будет удалена, а при тестировании хита вместо нее будут использоваться размеры спрайта. Команды, требующие формы, такие как GetspriteCollision, будут генерировать прямоугольную форму для спрайта, если она не существует. Параметр shape позволяет определить, какой тип ограничительной рамки должна использовать система для обнаружения коллизий. Круг создаст идеальный круг, центрированный в точке вращения спрайта и достаточно большой, чтобы охватить видимые пиксели спрайта. Box создаст прямоугольник по краям спрайта, независимо от того, видны пиксели или нет. Полигон создаст плотно прилегающий выпуклый полигон вокруг видимых пикселей спрайта, причем видимый пиксель будет определен как один с альфа-значением больше 128. Эта функция не будет работать с фиктивными спрайтами, так как при вычислении фигуры нет изображения, в этих случаях фигуры должны быть заданы вручную с помощью SetSpriteShapeBox, SetSpriteShapeCircle или SetSpriteShapePolygon. По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $shape Форма, используемая для этого спрайта, 0=нет формы, 1=круг, 2=коробка, 3=многоугольник
     * @param int $shapeID Идентификатор изменяемой фигуры, первая фигура-ID 1, 0=удалить существующие фигуры и заменить их этой новой
     * @return void
     */
    function SetSpriteShape($iSpriteIndex, $shape, $shapeID)
    {
    }

    /**
     *Задает текущую форму для использования в обнаружении столкновений, тестировании ударов и физике. Форма может быть установлена без включения физики, и по умолчанию все спрайты настроены на использование формы коробки, которая является самой быстрой для настройки. Если вы выберете no shape (0), то любая существующая фигура будет удалена, а при тестировании хита вместо нее будут использоваться размеры спрайта. Команды, требующие формы, такие как GetspriteCollision, будут генерировать прямоугольную форму для спрайта, если она не существует. Параметр shape позволяет определить, какой тип ограничительной рамки должна использовать система для обнаружения коллизий. Круг создаст идеальный круг, центрированный в точке вращения спрайта и достаточно большой, чтобы охватить видимые пиксели спрайта. Box создаст прямоугольник по краям спрайта, независимо от того, видны пиксели или нет. Полигон создаст плотно прилегающий выпуклый полигон вокруг видимых пикселей спрайта, причем видимый пиксель будет определен как один с альфа-значением больше 128. Эта функция не будет работать с фиктивными спрайтами, так как при вычислении фигуры нет изображения, в этих случаях фигуры должны быть заданы вручную с помощью SetSpriteShapeBox, SetSpriteShapeCircle или SetSpriteShapePolygon. По умолчанию установка фигуры удаляет все другие фигуры, назначенные спрайту, и заменяет его этой. Вы можете установить фигуры по отдельности, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает удаление всех существующих фигур перед созданием новой с идентификатором 1. Эта команда изменяет только существующие фигуры, по умолчанию все спрайты имеют базовую форму с идентификатором 1. Вы можете добавить дополнительные фигуры с помощью команд AddSpriteShape.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $shape Форма, используемая для этого спрайта, 0=нет формы, 1=круг, 2=коробка, 3=многоугольник
     * @return void
     */
    function SetSpriteShape($iSpriteIndex, $shape)
    {
    }

    /**
     *Устанавливает шейдер, используемый для рисования этого спрайта, загруженный с помощью LoadSpriteShader или LoadShader. По умолчанию спрайтам присваивается внутренний шейдер, который может обрабатывать 1 текстуру и цвет. Если вы используете идентификатор шейдера 0, спрайту присваивается внутренний шейдер.
     *
     * @param int $spriteID Идентификатор спрайта для изменения.
     * @param int $shaderID Идентификатор используемого шейдера.
     * @return void
     */
    function SetSpriteShader($spriteID, $shaderID)
    {
    }

    /**
     *Устанавливает масштаб спрайта как абсолютное кратное его исходному размеру. Например, значение масштаба 2 удвоит размер спрайта, в то время как значение 1 вернет его к исходному размеру. Эта функция масштабируется от центра вращения спрайта (его текущей точки смещения), поэтому любое увеличение размера будет держать точку смещения неподвижной, в то время как все четыре стороны расширяются от нее. Для масштабирования из верхнего левого угла используйте SetSpriteScale.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Значение для масштабирования спрайта в направлении X.
     * @param float $y Значение для масштабирования спрайта в направлении Y.
     * @return void
     */
    function SetSpriteScaleByOffset($iSpriteIndex, $x, $y)
    {
    }

    /**
     *При рисовании спрайт привязывается к указанным мировым координатам. Используйте значения 0,0,0,0, чтобы отключить ножницы спрайта
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Координата x верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $y Координата y верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $x2 Координата x в правом нижнем углу окна для использования в качестве границы клипа.
     * @param float $y2 Координата y в правом нижнем углу окна для использования в качестве границы клипа.
     * @return void
     */
    function SetSpriteScissor($iSpriteIndex, $x, $y, $x2, $y2)
    {
    }

    /**
     *Устанавливает масштаб спрайта как абсолютное кратное его исходному размеру. Например, значение масштаба 2 удвоит размер спрайта, в то время как значение 1 вернет его к исходному размеру. Эта функция масштабируется из верхнего левого угла, поэтому любое увеличение размера будет держать верхнюю и левую стороны неподвижными, в то время как нижняя и правая стороны движутся. Центр вращения спрайтов (его текущая точка смещения) будет масштабироваться вместе со спрайтом. Для масштабирования от точки смещения используйте SetSpriteScaleByOffset.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Значение для масштабирования спрайта в направлении X.
     * @param float $y Значение для масштабирования спрайта в направлении Y.
     * @return void
     */
    function SetSpriteScale($iSpriteIndex, $x, $y)
    {
    }

    /**
     *Сразу же позиционирует указанный спрайт в заданные мировые координаты X,Y. Мировая система координат по умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно изменить с помощью SetVirtualResolution). Эта функция всегда позиционирует спрайт, используя его текущее смещение. Например, если текущее смещение является центром спрайта, эта команда поместит центр спрайта в заданные координаты.
     *
     * @param int $iSpriteIndex Идентификатор спрайта в позиции
     * @param float $fX Координата X для позиционирования спрайта может использовать десятичные значения.
     * @param float $fY координата Y для позиционирования спрайта может использовать десятичные значения.
     * @return void
     */
    function SetSpritePositionByOffset($iSpriteIndex, $fX, $fY)
    {
    }

    /**
     *Сразу же позиционирует указанный спрайт в заданные мировые координаты X,Y. Мировая система координат по умолчанию имеет 0,0 в качестве верхнего левого угла и 100,100 в качестве нижнего правого угла экрана (это можно изменить с помощью SetVirtualResolution). Эта функция всегда позиционирует спрайт, используя его верхний левый угол, независимо от текущего смещения спрайта. Верхний левый угол, используемый для позиционирования спрайта, не вращается вместе со спрайтом, например, когда спрайт вращается вокруг своего центра, воображаемый верхний левый угол остается фиксированным, и значение положения спрайта не меняется.
     *
     * @param int $iSpriteIndex Идентификатор спрайта в позиции
     * @param float $fX Координата X для позиционирования спрайта может использовать десятичные значения.
     * @param float $fY координата Y для позиционирования спрайта может использовать десятичные значения.
     * @return void
     */
    function SetSpritePosition($iSpriteIndex, $fX, $fY)
    {
    }

    /**
     *Немедленно устанавливает скорость спрайта в заданном направлении. Это резкое изменение, которое может показаться неправильным во время физического моделирования, силы и импульсы являются предпочтительным подходом к влиянию на скорость.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $vx x-компонент новой скорости.
     * @param float $vy y-составляющая новой скорости.
     * @return void
     */
    function SetSpritePhysicsVelocity($iSpriteIndex, $vx, $vy)
    {
    }

    /**
     *Прикладывает крутящий момент к вращению спрайта, подобно тому, как прикладывает силу к его движению. Если спрайт ограничен окружающими объектами, он не может вращаться, если крутящий момент не достаточно велик, чтобы переместить и эти объекты. Крутящий момент будет длиться только для этого кадра, чтобы продолжать применять этот крутящий момент, вы должны продолжать вызывать эту функцию. Реакция на крутящий момент зависит от размера объекта, большие объекты будут вращаться медленнее, чем маленькие объекты при том же крутящем моменте.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $torque Размер силы, приложенной к вращению спрайта. может быть отрицательным.
     * @return void
     */
    function SetSpritePhysicsTorque($iSpriteIndex, $torque)
    {
    }

    /**
     *Устанавливает значение реституции (bounciness), которое будет использоваться для этого спрайта во время физических вычислений. Должно быть в диапазоне от 0 до 1. Значения больше 1 приведут к тому, что спрайт наберет энергию от столкновений, которые могут привести к нестабильному результату. По умолчанию это устанавливает все фигуры, назначенные этому спрайту, в одно и то же значение, вместо этого вы можете установить его для каждой фигуры, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает, что они применяются ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $restitution Новая реституционная стоимость.
     * @return void
     */
    function SetSpritePhysicsRestitution($iSpriteIndex, $restitution)
    {
    }

    /**
     *Устанавливает значение реституции (bounciness), которое будет использоваться для этого спрайта во время физических вычислений. Должно быть в диапазоне от 0 до 1. Значения больше 1 приведут к тому, что спрайт наберет энергию от столкновений, которые могут привести к нестабильному результату. По умолчанию это устанавливает все фигуры, назначенные этому спрайту, в одно и то же значение, вместо этого вы можете установить его для каждой фигуры, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает, что они применяются ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $restitution Новая реституционная стоимость.
     * @param int $shapeID Идентификатор изменяемой фигуры, 0 для применения значения ко всем фигурам
     * @return void
     */
    function SetSpritePhysicsRestitution($iSpriteIndex, $restitution, $shapeID)
    {
    }

    /**
     *Настраивает спрайт на автоматическое столкновение с помощью встроенной физической системы. После того как вы настроили спрайт на управление физикой, вы должны использовать SetSpritePosition и SetSpriteAngle экономно, так как они будут прерывать физическое движение спрайта. Вы также можете использовать SetSpritePhysicsVelocity и SetSpritePhysicsAngularVelocity для изменения скорости и направления спрайта, но опять же они будут мешать физическому движению спрайта. Если вы хотите повлиять на положение или вращение физического спрайта, вы должны использовать функции силы и крутящего момента (вращательной силы) там, где это возможно, они будут поддерживать плавное физическое движение. Параметр mode позволяет выбрать, как спрайт должен вести себя в физическом мире. Статическое означает, что он никогда не будет двигаться или вращаться, динамическое означает, что он будет реагировать на все столкновения и силы, с которыми он сталкивается, включая гравитацию и столкновения со статическими объектами. Кинематика-это особый случай, который можно рассматривать как движущееся статическое тело, оно не будет реагировать на столкновения или силы и будет продолжать двигаться с заданной скоростью вечно, но динамические элементы будут реагировать на него и эффективно выталкиваться с пути. Используемая физическая форма определяется командой SetSpriteShape, которая должна быть вызвана перед этой командой и дорого изменяется для круговых и полигональных форм, поскольку они восстанавливают форму из пикселей изображения спрайта. После того как вы вызвали эту команду для определения режима спрайта, дальнейшие вызовы будут игнорировать значения режима и она будет только повторно активировать спрайт, который был выключен, так как режим не может быть изменен, пока спрайт находится в физической системе. Если вы хотите изменить режим спрайта, вызовите SetSpritePhysicsDelete, который удалит все его физические настройки, а затем вызовите SetSpritePhysicsOn с новым режимом. Но делать это слишком часто будет замедлять работу системы. Все физические спрайты должны быть мировыми спрайтами (не фиксированными на экране), если только SetViewOffset не установлен на 0,0, и в этом случае это не имеет значения. В противном случае отладочные фигуры не будут выстраиваться в линию, а спрайты из разных пространств просмотра не будут взаимодействовать должным образом.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $mode Физический режим, используемый для этого спрайта, 1=статический, 2=динамический, 3=кинематический
     * @return void
     */
    function SetSpritePhysicsOn($iSpriteIndex, $mode)
    {
    }

    /**
     *Эта команда переопределяет вычисленную массу для этого спрайта и устанавливает ее в выбранное вами значение в килограммах. Установка этого значения слишком низко или слишком высоко может привести к нестабильной симуляции, особенно если очень легкий объект встречается с очень тяжелым. Диапазон значений, который вы должны использовать, зависит от выбранной вами шкалы физики. Внутренне масса по умолчанию для каждого объекта вычисляется на основе его размера. Коробка размером 1 х 1 м будет весить 1 кг, поэтому из-за стандартной шкалы физики 5 коробка размером 5 х 5 в виртуальных единицах весит 1 кг.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $mass Новое массовое значение.
     * @return void
     */
    function SetSpritePhysicsMass($iSpriteIndex, $mass)
    {
    }

    /**
     *Временно отключив физику для этого спрайта, он больше не будет двигаться и реагировать на столкновения или силы. Используйте SetSpritePhysicsOn для реактивации спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @return void
     */
    function SetSpritePhysicsOff($iSpriteIndex)
    {
    }

    /**
     *Установите это значение в true, если спрайт, скорее всего, будет двигаться очень быстро, как пуля, так как затем он будет более тщательно проверяться на столкновение с другими динамическими спрайтами, использование которых без необходимости повлияет на производительность. Это называется непрерывным обнаружением столкновений (CCD) и автоматически применяется к проверке столкновений между этим спрайтом и статическими объектами. Эта команда включает CCD для проверки коллизий между этим спрайтом и динамическими объектами. Это не сработает, если global CCD будет отключен с помощью SetPhysicsCCD.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $bullet 1, чтобы установить этот спрайт в качестве пули, 0, чтобы выключить его.
     * @return void
     */
    function SetSpritePhysicsIsBullet($iSpriteIndex, $bullet)
    {
    }

    /**
     *Установите это значение равным 1, чтобы сделать спрайт сенсорным объектом. Физические датчики обнаруживают столкновения и контакты, но не реагируют на них, они также не влияют ни на что, что попадает в них. Их единственная цель-обнаружение столкновений. Если вы примените это к динамическому телу, оно ни с чем не столкнется и, скорее всего, провалится сквозь пол и будет падать вечно, на него все еще действуют силы. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $sensor 1, чтобы установить этот спрайт в качестве датчика, 0, чтобы сделать его нормальным физическим объектом.
     * @return void
     */
    function SetSpritePhysicsIsSensor($iSpriteIndex, $sensor)
    {
    }

    /**
     *Установите это значение равным 1, чтобы сделать спрайт сенсорным объектом. Физические датчики обнаруживают столкновения и контакты, но не реагируют на них, они также не влияют ни на что, что попадает в них. Их единственная цель-обнаружение столкновений. Если вы примените это к динамическому телу, оно ни с чем не столкнется и, скорее всего, провалится сквозь пол и будет падать вечно, на него все еще действуют силы. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $sensor 1, чтобы установить этот спрайт в качестве датчика, 0, чтобы сделать его нормальным физическим объектом.
     * @param int $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * @return void
     */
    function SetSpritePhysicsIsSensor($iSpriteIndex, $sensor, $shapeID)
    {
    }

    /**
     *Похоже на силу, но применяется только один раз. В то время как силы прилагаются непрерывно в течение долгого времени, постепенно влияя на скорость спрайта, импульс имитирует внезапное попадание спрайта и немедленно изменяет скорость с эквивалентной силой аналогичной силы, приложенной в течение 1 секунды. Импульс состоит из точки в мировых координатах и направления, если точка и направление не совпадают с точкой смещения спрайта, то это приведет к вращению спрайта по мере его перемещения импульсом. Длина вектора импульса определяет его силу. Если спрайт ограничен окружающими объектами, он передаст импульс этим объектам и не сможет двигаться сам. Импульсы придают ускорение объекту относительно его массы, тяжелые объекты будут двигаться меньше, чем легкие объекты с тем же импульсом, приложенным к ним.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param float $x Координата X положения импульса в мировых координатах.
     * @param float $y Координата Y положения импульса в мировых координатах.
     * @param float $vx X-составляющая направления импульса.
     * @param float $vy Y-составляющая направления импульса.
     * @return void
     */
    function SetSpritePhysicsImpulse($iSpriteIndex, $x, $y, $vx, $vy)
    {
    }

    /**
     *Устанавливает значение трения, которое будет использоваться для этого спрайта во время физических вычислений. Должно быть в диапазоне от 0 до 1. По умолчанию это устанавливает все фигуры, назначенные этому спрайту, в одно и то же значение, вместо этого вы можете установить его для каждой фигуры, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает, что они применяются ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $friction Новое значение трения.
     * @return void
     */
    function SetSpritePhysicsFriction($iSpriteIndex, $friction)
    {
    }

    /**
     *Устанавливает значение трения, которое будет использоваться для этого спрайта во время физических вычислений. Должно быть в диапазоне от 0 до 1. По умолчанию это устанавливает все фигуры, назначенные этому спрайту, в одно и то же значение, вместо этого вы можете установить его для каждой фигуры, указав shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а 0 означает, что они применяются ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $friction Новое значение трения.
     * @param int $shapeID Идентификатор изменяемой фигуры, 0 для применения значения ко всем фигурам
     * @return void
     */
    function SetSpritePhysicsFriction($iSpriteIndex, $friction, $shapeID)
    {
    }

    /**
     *Применяет силу к спрайту, которая будет длиться только для этого кадра, чтобы продолжать применять эту силу, вы должны продолжать вызывать эту функцию. Сила состоит из точки в мировых координатах и направления, если точка и направление не совпадают с точкой смещения спрайта, то это приведет к вращению спрайта при его перемещении силой. Длина вектора силы определяет его силу. Если спрайт ограничен окружающими объектами, он не может двигаться, если сила не достаточно велика, чтобы переместить и эти объекты. Силы прилагают ускорение к объекту относительно его массы, тяжелые объекты будут двигаться меньше, чем легкие объекты с той же силой, приложенной к ним.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата X положения силы в мировых координатах.
     * @param float $y Координата Y положения силы в мировых координатах.
     * @param float $vx X-составляющая направления силы.
     * @param float $vy Y-составляющая направления силы.
     * @return void
     */
    function SetSpritePhysicsForce($iSpriteIndex, $x, $y, $vx, $vy)
    {
    }

    /**
     *Отключает физику для этого спрайта и удаляет все связанные с ним физические настройки для этого спрайта. Вы можете использовать это для изменения режима или формы спрайта, но регулярное выполнение этого может повлиять на производительность приложения.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @return void
     */
    function SetSpritePhysicsDelete($iSpriteIndex)
    {
    }

    /**
     *Задает значение плотности, которое будет использоваться для данной формы спрайта во время физических вычислений. Значение по умолчанию равно 1.0. Это влияет на расчет массы для данного размера спрайта. Эта команда пересчитает массу и центр масс для этого спрайта. Используйте shapeID 0, чтобы применить эту плотность ко всем фигурам, или укажите идентификатор фигуры больше 0, чтобы применить ее только к этой фигуре. Идентификаторы фигур начинаются с 1 для первой фигуры.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения
     * @param float $density Новое значение плотности по умолчанию равно 1.0
     * @param int $shapeID Идентификатор изменяемой фигуры, 0 для применения значения ко всем фигурам
     * @return void
     */
    function SetSpritePhysicsDensity($iSpriteIndex, $density, $shapeID)
    {
    }

    /**
     *Устанавливает некоторое демпфирование линейного движения спрайта, которое может имитировать что-то вроде сопротивления ветру. Значение 0 означает отсутствие демпфирования, значение 0,75 будет уменьшать вектор скорости наполовину каждую секунду при работе со скоростью 60 кадров в секунду. Более высокие значения приведут к более быстрому снижению скорости.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $damp Новое значение демпфирования.
     * @return void
     */
    function SetSpritePhysicsDamping($iSpriteIndex, $damp)
    {
    }

    /**
     *Задает, разрешено ли физическому моделированию вращать спрайт.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $rotate 1, чтобы разрешить вращение, 0, чтобы предотвратить его.
     * @return void
     */
    function SetSpritePhysicsCanRotate($iSpriteIndex, $rotate)
    {
    }

    /**
     *Устанавливает центр масс (COM) относительно смещения спрайта. По умолчанию AGK вычисляет наилучшее местоположение для COM на основе размера и расположения всех фигур, прикрепленных к спрайту. Установка его на 0,0 поставит COM на точку смещения спрайта (и центр вращения). Если COM сильно отличается от точки смещения, спрайт может показаться нестабильным, так как он будет вести себя как несбалансированный волчок.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата x центра масс.
     * @param float $y Координата y центра масс.
     * @return void
     */
    function SetSpritePhysicsCOM($iSpriteIndex, $x, $y)
    {
    }

    /**
     *Аналогично силе крутящего момента, но приложенной только один раз. В то время как силы прилагаются непрерывно в течение долгого времени, постепенно влияя на скорость спрайта, импульс имитирует внезапное попадание спрайта и немедленно изменяет угловую скорость с эквивалентной мощностью аналогичной силы крутящего момента, приложенной в течение 1 секунды. Если спрайт ограничен окружающими объектами, он не может вращаться, если импульс не достаточно велик, чтобы переместить и эти объекты.  Реакция на импульс зависит от размера объекта, большие объекты будут вращаться медленнее, чем маленькие объекты, получившие тот же импульс.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $impulse Размер силы, приложенной к вращению спрайта. может быть отрицательным.
     * @return void
     */
    function SetSpritePhysicsAngularImpulse($iSpriteIndex, $impulse)
    {
    }

    /**
     *Немедленно устанавливает скорость вращения спрайта в заданном направлении. Это резкое изменение, которое может показаться неправильным во время физического моделирования, крутящий момент и угловые импульсы являются предпочтительным подходом к влиянию на угловую скорость.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $va Новая угловая скорость.
     * @return void
     */
    function SetSpritePhysicsAngularVelocity($iSpriteIndex, $va)
    {
    }

    /**
     *Устанавливает некоторое демпфирование углового движения спрайта, которое может имитировать что-то вроде сопротивления ветру. Значение 0 означает отсутствие демпфирования, значение 0,75 будет уменьшать вектор угловой скорости наполовину каждую секунду при работе со скоростью 60 кадров в секунду. Более высокие значения уменьшат вращение быстрее.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $damp Новое значение демпфирования.
     * @return void
     */
    function SetSpritePhysicsAngularDamping($iSpriteIndex, $damp)
    {
    }

    /**
     *Точка смещения-это точка, вокруг которой будет вращаться спрайт,причем (0,0) - верхний левый угол, а (ширина, высота) - нижний правый угол. Смещение также можно использовать для позиционирования спрайта с помощью SetSpritePositionByOffset, в то время как SetSpritePosition всегда будет позиционировать спрайт с помощью его верхнего левого угла. Если спрайт масштабируется, не забудьте принять во внимание масштаб,спрайт, созданный как 10 на 10 единиц в ширину, масштабированный на 0,5, будет иметь нижний правый угол на уровне 5,5, поэтому расположить смещение в центре означало бы поместить его на 2,5, 2,5, когда спрайт масштабируется обратно, точка смещения будет масштабироваться вместе с ним, чтобы сохранить свое относительное положение. Эта команда вызывает пересчет формы спрайта из-за новой центральной точки, дополнительные формы не пересчитываются, поэтому будут искажены от их первоначального определения. Не рекомендуется вызывать эту команду на спрайте, уже настроенном для физики. Измените смещение перед применением физики или дополнительных фигур.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Расстояние X от верхнего левого угла для смещения точки вращения.
     * @param float $y Расстояние Y от верхнего левого угла до смещения точки поворота.
     * @return void
     */
    function SetSpriteOffset($iSpriteIndex, $x, $y)
    {
    }

    /**
     *Измените изображение спрайта на новое загруженное изображение. Если новое изображение имеет другой размер или форму, чем старое, спрайт может выглядеть искаженным в результате, вы можете исправить это, сбросив размеры спрайта с помощью SetSpriteSize. Если спрайт анимирован, вам также может потребоваться снова вызвать SetSpriteAnimation. В случае круговых и полигональных спрайтов вы можете установить, использует ли спрайт это новое изображение для изменения своей формы столкновения. На форму коробки изменения изображения не влияют. Использование этой команды очистит все анимационные кадры, которые вы установили с помощью любой из команд sprite animation.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iImageIndex Идентификатор изображения, которое будет использоваться для этого спрайта.
     * @param int $bUpdateShape Задает, следует ли изменить форму столкновения этого спрайта в соответствии с новым изображением. ( 1 или 0 )
     * @return void
     */
    function SetSpriteImage($iSpriteIndex, $iImageIndex, $bUpdateShape)
    {
    }

    /**
     *Измените изображение спрайта на новое загруженное изображение. Если новое изображение имеет другой размер или форму, чем старое, спрайт может выглядеть искаженным в результате, вы можете исправить это, сбросив размеры спрайта с помощью SetSpriteSize. Если спрайт анимирован, вам также может потребоваться снова вызвать SetSpriteAnimation. В случае круговых и полигональных спрайтов вы можете установить, использует ли спрайт это новое изображение для изменения своей формы столкновения. На форму коробки изменения изображения не влияют. Использование этой команды очистит все анимационные кадры, которые вы установили с помощью любой из команд sprite animation.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iImageIndex Идентификатор изображения, которое будет использоваться для этого спрайта.
     * @return void
     */
    function SetSpriteImage($iSpriteIndex, $iImageIndex)
    {
    }

    /**
     *Назначает этот спрайт группе для фильтрации коллизий (физических или нефизических). В физике спрайты с одним и тем же положительным идентификатором группы всегда будут сталкиваться, в то время как те, которые имеют один и тот же отрицательный идентификатор группы, никогда не будут сталкиваться. Те, у кого идентификатор группы равен нулю (по умолчанию), или отличающиеся идентификаторы групп переходят к проверке фильтра категорий. Если спрайт не настроен на физику, этот тест будет применяться только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $group Идентификатор группы, назначаемый этому спрайту.
     * @param int $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * @return void
     */
    function SetSpriteGroup($iSpriteIndex, $group, $shapeID)
    {
    }

    /**
     *Назначает этот спрайт группе для фильтрации коллизий (физических или нефизических). В физике спрайты с одним и тем же положительным идентификатором группы всегда будут сталкиваться, в то время как те, которые имеют один и тот же отрицательный идентификатор группы, никогда не будут сталкиваться. Те, у кого идентификатор группы равен нулю (по умолчанию), или отличающиеся идентификаторы групп переходят к проверке фильтра категорий. Если спрайт не настроен на физику, этот тест будет применяться только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $group Идентификатор группы, назначаемый этому спрайту.
     * @return void
     */
    function SetSpriteGroup($iSpriteIndex, $group)
    {
    }

    /**
     *Устанавливает спрайт на определенный кадр, кадры начинаются с 1 и заканчиваются на GetSpriteFrameCount
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iFrame Идентификатор кадра, на который должен измениться этот спрайт, имеет немедленный эффект.
     * @return void
     */
    function SetSpriteFrame($iSpriteIndex, $iFrame)
    {
    }

    /**
     *Переворачивает спрайт либо по горизонтали, либо по вертикали (или и то, и другое). Это просто изменяет УФ-координаты так, чтобы спрайт выглядел перевернутым, он не регулирует значения положения или угла. Обратите внимание, что переворачивание как в горизонтальном, так и в вертикальном направлениях одновременно дает видимость поворота на 180 градусов.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $horz 1, чтобы перевернуть спрайт горизонтально слева направо, 0, чтобы сохранить спрайт нормальным.
     * @param int $vert 1, чтобы перевернуть спрайт вертикально сверху вниз, 0, чтобы сохранить спрайт нормальным.
     * @return void
     */
    function SetSpriteFlip($iSpriteIndex, $horz, $vert)
    {
    }

    /**
     *Устанавливает порядок рисования спрайта между 0-10000, 0 - передняя часть экрана, 10000 - задняя. Все, что выше 10000, приведет к тому, что спрайт будет вырезан из поля зрения. По умолчанию спрайты находятся на глубине 10. Если два спрайта занимают одну и ту же глубину, то порядок их рисования не определен, если только SetSortCreated не используется в значении true, и в этом случае спрайты на одной и той же глубине будут нарисованы в том порядке, в котором они были созданы. Для максимальной производительности рекомендуется, чтобы каждый спрайт имел свое собственное значение глубины, если только порядок их рисования не имеет значения, например, физические спрайты, которые обычно не перекрываются. Обратите внимание, что если вы не используете КАКИЕ-либо 3D-объекты и используете глубину спрайта больше 5000, вы должны использовать SetGlobal3DDepth до 10000 для повышения производительности (по существу, выводя все спрайты на переднюю панель 3D-рендера).
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iDepth Глубина, на которой должен быть нарисован этот спрайт.
     * @return void
     */
    function SetSpriteDepth($iSpriteIndex, $iDepth)
    {
    }

    /**
     *Установите синий компонент спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $iBlue Синяя составляющая цвета. Допустимый диапазон-от 0 до 255.
     * @return void
     */
    function SetSpriteColorBlue($iSpriteIndex, $iBlue)
    {
    }

    /**
     *Установите зеленый компонент спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iGreen Зеленая составляющая цвета. Допустимый диапазон-от 0 до 255.
     * @return void
     */
    function SetSpriteColorGreen($iSpriteIndex, $iGreen)
    {
    }

    /**
     *Установите красный компонент спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iRed Красная составляющая цвета. Допустимый диапазон-от 0 до 255.
     * @return void
     */
    function SetSpriteColorRed($iSpriteIndex, $iRed)
    {
    }

    /**
     *Установите альфа-компонент спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iAlpha Альфа-компонент цвета. Допустимый диапазон-от 0 до 255. При использовании значения 0 спрайт будет невидим. При использовании значения 255 спрайт будет полностью непрозрачным.
     * @return void
     */
    function SetSpriteColorAlpha($iSpriteIndex, $iAlpha)
    {
    }

    /**
     *Установите цвет спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iRed Красная составляющая цвета.
     * @param int $iGreen Зеленая составляющая цвета.
     * @param int $iBlue Синяя составляющая цвета.
     * @param int $iAlpha Альфа-компонент цвета. Допустимый диапазон-от 0 до 255. При использовании значения 0 спрайт будет невидим. При использовании значения 255 спрайт будет полностью непрозрачным.
     * @return void
     */
    function SetSpriteColor($iSpriteIndex, $iRed, $iGreen, $iBlue, $iAlpha)
    {
    }

    /**
     *Использует побитовую маску, чтобы определить, с какими категориями спрайтов этот спрайт может столкнуться. Спрайты назначаются категориям с помощью SetSpriteCategoryBits. Существует 16 категорий, каждая из которых представлена одним битом в параметре "маска", значение 1 для бита означает, что этот спрайт столкнется со спрайтами из этой категории, и 0-что он не столкнется с этой категорией, независимо от того, к какой категории принадлежит сам этот спрайт. По умолчанию все спрайты принадлежат к категории 1 (0x0001 самый правый бит) и сталкиваются со всеми категориями (0xffff). Если спрайт не настроен на физику, этот тест будет применяться только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $mask Побитовая маска категорий, с которой этот спрайт может столкнуться во время физических вычислений.
     * @return void
     */
    function SetSpriteCollideBits($iSpriteIndex, $mask)
    {
    }

    /**
     *Использует побитовую маску, чтобы определить, с какими категориями спрайтов этот спрайт может столкнуться. Спрайты назначаются категориям с помощью SetSpriteCategoryBits. Существует 16 категорий, каждая из которых представлена одним битом в параметре "маска", значение 1 для бита означает, что этот спрайт столкнется со спрайтами из этой категории, и 0-что он не столкнется с этой категорией, независимо от того, к какой категории принадлежит сам этот спрайт. По умолчанию все спрайты принадлежат к категории 1 (0x0001 самый правый бит) и сталкиваются со всеми категориями (0xffff). Если спрайт не настроен на физику, этот тест будет применяться только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $mask Побитовая маска категорий, с которой этот спрайт может столкнуться во время физических вычислений.
     * @param int $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * @return void
     */
    function SetSpriteCollideBits($iSpriteIndex, $mask, $shapeID)
    {
    }

    /**
     *Присваивает спрайту ноль или более категорий для фильтрации столкновений (физические и нефизические). Существует 16 категорий, каждая из которых представлена одним битом в параметре "категории", значение 1 для бита означает, что этот спрайт является частью этой категории, а 0-что он не принадлежит к этой категории. Затем спрайты могут быть настроены на столкновение с определенными категориями с помощью SetSpriteCollideBits независимо от того, к каким категориям они сами принадлежат. По умолчанию все спрайты относятся к категории 1 (0x0001 самый правый бит) и сталкиваются со всеми категориями (0xffff). Если спрайт не настроен на физику, этот тест будет применяться только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $categories Побитовое поле категорий, назначаемое этому спрайту.
     * @param int $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * @return void
     */
    function SetSpriteCategoryBits($iSpriteIndex, $categories, $shapeID)
    {
    }

    /**
     *Присваивает спрайту ноль или более категорий для фильтрации столкновений (физические и нефизические). Существует 16 категорий, каждая из которых представлена одним битом в параметре "категории", значение 1 для бита означает, что этот спрайт является частью этой категории, а 0-что он не принадлежит к этой категории. Затем спрайты могут быть настроены на столкновение с определенными категориями с помощью SetSpriteCollideBits независимо от того, к каким категориям они сами принадлежат. По умолчанию все спрайты относятся к категории 1 (0x0001 самый правый бит) и сталкиваются со всеми категориями (0xffff). Если спрайт не настроен на физику, этот тест будет применяться только к базовой фигуре в shapeID 1. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $categories Побитовое поле категорий, назначаемое этому спрайту.
     * @return void
     */
    function SetSpriteCategoryBits($iSpriteIndex, $categories)
    {
    }

    /**
     *Устанавливает или удаляет категорию, с которой может столкнуться этот спрайт. Спрайтам присваиваются категории с помощью SetSpriteCategoryBit. Существует 16 категорий, значение 1 для этой категории означает, что этот спрайт столкнется со спрайтами из этой категории, а 0-что он не столкнется с этой категорией, независимо от того, к какой категории принадлежит сам этот спрайт. По умолчанию все спрайты относятся к категории 1 и сталкиваются со всеми категориями. Эта команда похожа на SetSpriteCategoryBits, за исключением того, что эта команда устанавливает одну категорию за раз, в то время как эта команда устанавливает их все сразу, используя битовую маску. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $category Категория, включающая или выключающая столкновение для этого спрайта, должна быть от 1 до 16 включительно.
     * @param int $flag 1, чтобы включить столкновение, 0, чтобы выключить его для этого спрайта.
     * @param int $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * @return void
     */
    function SetSpriteCollideBit($iSpriteIndex, $category, $flag, $shapeID)
    {
    }

    /**
     *Устанавливает или удаляет категорию, с которой может столкнуться этот спрайт. Спрайтам присваиваются категории с помощью SetSpriteCategoryBit. Существует 16 категорий, значение 1 для этой категории означает, что этот спрайт столкнется со спрайтами из этой категории, а 0-что он не столкнется с этой категорией, независимо от того, к какой категории принадлежит сам этот спрайт. По умолчанию все спрайты относятся к категории 1 и сталкиваются со всеми категориями. Эта команда похожа на SetSpriteCategoryBits, за исключением того, что эта команда устанавливает одну категорию за раз, в то время как эта команда устанавливает их все сразу, используя битовую маску. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $category Категория, включающая или выключающая столкновение для этого спрайта, должна быть от 1 до 16 включительно.
     * @param int $flag 1, чтобы включить столкновение, 0, чтобы выключить его для этого спрайта.
     * @return void
     */
    function SetSpriteCollideBit($iSpriteIndex, $category, $flag)
    {
    }

    /**
     *Назначает или удаляет спрайт из определенной категории. Существует 16 категорий, к которым может принадлежать спрайт, и спрайт может принадлежать к любому числу сразу. Эта команда похожа на SetSpriteCategoryBits, за исключением того, что эта команда устанавливает одну категорию за раз, в то время как эта команда устанавливает их все сразу, используя битовую маску. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $category Категория, которую нужно изменить, должна быть от 1 до 16 включительно.
     * @param int $flag 1, чтобы сделать спрайт частью этой категории, 0, чтобы удалить его.
     * @return void
     */
    function SetSpriteCategoryBit($iSpriteIndex, $category, $flag)
    {
    }

    /**
     *Назначает или удаляет спрайт из определенной категории. Существует 16 категорий, к которым может принадлежать спрайт, и спрайт может принадлежать к любому числу сразу. Эта команда похожа на SetSpriteCategoryBits, за исключением того, что эта команда устанавливает одну категорию за раз, в то время как эта команда устанавливает их все сразу, используя битовую маску. По умолчанию это устанавливает все фигуры в одно и то же значение, вы можете установить это значение для каждой фигуры, указав значение shapeID больше 0. Идентификаторы фигур начинаются с 1 для первой фигуры, а shapeID 0 означает применить его ко всем фигурам.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $category Категория, которую нужно изменить, должна быть от 1 до 16 включительно.
     * @param int $flag 1, чтобы сделать спрайт частью этой категории, 0, чтобы удалить его.
     * @param int $shapeID идентификатор изменяемой фигуры, 0 для установки всех фигур спрайта на это значение
     * @return void
     */
    function SetSpriteCategoryBit($iSpriteIndex, $category, $flag, $shapeID)
    {
    }

    /**
     *Инициализирует анимацию спрайта кадрами из назначенного ему изображения на основе ширины и высоты кадра. Спрайт будет использовать ширину и высоту кадра для извлечения изображений этого размера из назначенного ему изображения, начиная с верхнего левого угла и перемещаясь слева направо. Когда он достигнет правой части изображения, он снова начнет двигаться на одну строку вниз, снова двигаясь слева направо, пока не будет достигнуто количество кадров или не закончится место на изображении для поиска кадров. Поддерживается сохранение анимационного изображения на текстуре атласа. Эта функция является предпочтительным методом назначения анимации спрайту, поскольку она позволяет избежать дорогостоящих изменений изображения во время рендеринга. Однако если все ваши анимационные кадры являются отдельными изображениями, вы можете использовать AddSpriteAnimationFrame для добавления кадров из изображений по отдельности. Использование SetSpriteImage очистит все анимационные кадры, которые вы установили здесь.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно установить для анимации.
     * @param int $iFrameWidth Ширина кадров в пикселях на изображении.
     * @param int $iFrameHeight Высота кадров в пикселях на изображении.
     * @param int $iFrameCount Количество кадров, которые спрайт должен попытаться извлечь из изображения.
     * @return void
     */
    function SetSpriteAnimation($iSpriteIndex, $iFrameWidth, $iFrameHeight, $iFrameCount)
    {
    }

    /**
     *Немедленно поворачивает указанный спрайт на заданный угол в радианах. По умолчанию спрайты вращаются вокруг своего центра, см. SetSpriteOffset, чтобы изменить это.
     *
     * @param int $iSpriteIndex Идентификатор вращаемого спрайта.
     * @param float $fAng Угол установки спрайта в радианах.
     * @return void
     */
    function SetSpriteAngleRad($iSpriteIndex, $fAng)
    {
    }

    /**
     *Немедленно поворачивает указанный спрайт на заданный угол в градусах. По умолчанию спрайты вращаются вокруг своего центра, см. SetSpriteOffset, чтобы изменить это.
     *
     * @param int $iSpriteIndex Идентификатор вращаемого спрайта.
     * @param float $fAng Угол установки спрайта в градусах.
     * @return void
     */
    function SetSpriteAngle($iSpriteIndex, $fAng)
    {
    }

    /**
     *Добавляет в спрайт дополнительные изображения, которые можно использовать с шейдерами. Набор изображений с помощью SetSpriteImage используется в качестве этапа текстуры 0, и эта команда позволит вам установить этапы от 1 до 7. Эти дополнительные изображения не играют никакой роли в анимации или вычислениях формы. Обратите внимание, что спрайт будет иметь одинаковые УФ-координаты для каждой текстуры, поэтому рекомендуется, чтобы изображения имели одинаковые размеры или использовали мощность 2 изображений, чтобы избежать УФ-преобразования на мобильных устройствах, где изображения могут быть масштабированы.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $iImageIndex Идентификатор изображения, которое будет использоваться для этого спрайта.
     * @param int $iStage Индекс используемой стадии текстуры находится в диапазоне от 1 до 7.
     * @return void
     */
    function SetSpriteAdditionalImage($iSpriteIndex, $iImageIndex, $iStage)
    {
    }

    /**
     *Устанавливает, обновляет ли этот спрайт свою анимацию и физику каждый кадр, спрайт может быть видимым или нет, что контролируется SetSpriteVisible.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $bActive Установите значение 1, если этот спрайт должен быть обновлен, и 0, если нет.
     * @return void
     */
    function SetSpriteActive($iSpriteIndex, $bActive)
    {
    }

    /**
     *Устанавливает скорость речи, где 1.0-нормальная скорость, 2.0-двойная скорость, 0.5-половинная скорость и так далее.  В настоящее время работает только на iOS и Android.
     *
     * @param float $rate Скорость произнесения текста по умолчанию равна 1,0
     * @return void
     */
    function SetSpeechRate($rate)
    {
    }

    /**
     *Задает язык, используемый при произнесении текста по голосовому идентификатору. Идентификатор можно найти с помощью GetSpeechVoiceID и необходим, когда несколько голосов имеют один и тот же язык, но с разными акцентами.
     *
     * @param string $sID Язык, используемый для произнесения текста, по умолчанию является текущим языком устройства.
     * @return void
     */
    function SetSpeechLanguageByID($sID)
    {
    }

    /**
     *Задает язык, используемый при произнесении текста, например "en_GB" для британского английского, "en_US" для американского английского, "fr_FR" для французского и т. Д. Если языковой движок в данный момент не находится на устройстве, то устройство попытается загрузить его при следующем вызове Speak, что может привести к задержке перед произнесением этого текста. Если загрузка завершится неудачно или подключение к Интернету будет недоступно, то будет использоваться языковой движок по умолчанию для текущего устройства.  В настоящее время работает только на iOS и Android.
     *
     * @param string $lang Язык, используемый для произнесения текста, по умолчанию является текущим языком устройства.
     * @return void
     */
    function SetSpeechLanguage($lang)
    {
    }

    /**
     *Устанавливает основную громкость звука для всех звуков. Отдельные объемы звука останутся нетронутыми, но все объемы умножаются на основную громкость звука, позволяя использовать такие функции, как затухание.
     *
     * @param int $iVol Основная громкость звука для всех звуков.
     * @return void
     */
    function SetSoundSystemVolume($iVol)
    {
    }

    /**
     *Устанавливает текущий объем указанного экземпляра в диапазоне от 0 до 100. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.
     *
     * @param int $iID Идентификатор экземпляра для изменения
     * @param int $vol Новый том экземпляра, от 0 до 100
     * @return void
     */
    function SetSoundInstanceVolume($iID, $vol)
    {
    }

    /**
     *Устанавливает текущую скорость воспроизведения указанного экземпляра, где 1.0-нормальная скорость, 2.0 - двойная скорость и так далее. Не все устройства гарантированно поддерживают изменение скорости воспроизведения. Используйте GetSoundMaxRate и GetSoundMinRate для проверки допустимых диапазонов для текущего устройства, любые значения вне этого диапазона будут зажаты. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.
     *
     * @param int $iID Идентификатор экземпляра для изменения
     * @param float $rate Новая скорость воспроизведения экземпляра
     * @return void
     */
    function SetSoundInstanceRate($iID, $rate)
    {
    }

    /**
     *Устанавливает текущий баланс указанного экземпляра, при этом 0 находится по центру, -1.0-все на левом динамике, а 1.0-все на правом динамике, любые значения вне этого диапазона будут зажаты. Это лучше всего работает с моно-звуками, но может быть применено и к стереозвукам. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.
     *
     * @param int $iID Идентификатор экземпляра для изменения
     * @param float $balance Новый баланс экземпляра
     * @return void
     */
    function SetSoundInstanceBalance($iID, $balance)
    {
    }

    /**
     *Устанавливает, будет ли приложение разрешать фоновую музыку из других приложений продолжать воспроизведение (режим=0) или отключать другие приложения, пока это приложение активно (режим=1). Обратите внимание, что в режиме 0 устройство считает звук вашего приложения несущественным, поэтому будет отключено, если звонок устройства установлен в бесшумное состояние. Это работает только на iOS.
     *
     * @param int $mode Используемый звуковой режим (по умолчанию=0)
     * @return void
     */
    function SetSoundDeviceMode($mode)
    {
    }

    /**
     *Задает, должен ли AGK сортировать прозрачные спрайты по глубине при рисовании. Это сначала рисует спрайты в задней части экрана, чтобы достичь правильного результата смешивания, когда прозрачные спрайты перекрываются. Он включен по умолчанию, но если ваши прозрачные спрайты гарантированно не перекрываются, вы можете отключить его, чтобы повысить производительность. Эта команда устарела, сортировка теперь обрабатывается автоматически.
     *
     * @param int $sort Установите значение 1 для сортировки прозрачных спрайтов по глубине, 0-для отключения прозрачной сортировки.
     * @return void
     */
    function SetSortTransparentDepth($sort)
    {
    }

    /**
     *Задает, должен ли AGK сортировать спрайты по текстуре при рисовании, чтобы ограничить количество изменений текстуры. Это улучшит производительность на устройствах, которые плохо справляются с частыми изменениями состояния, но может снизить производительность, если текстуры на спрайтах часто меняются. По умолчанию он выключен, но если вы не меняете текстуры спрайтов или используете текстуры атласа, рекомендуется включить его. Эта команда устарела, сортировка теперь обрабатывается автоматически.
     *
     * @param int $sort Установите значение 1 для сортировки спрайтов по текстуре. по умолчанию=0
     * @return void
     */
    function SetSortTextures($sort)
    {
    }

    /**
     *Задает, должен ли AGK сортировать непрозрачные спрайты по глубине при рисовании. Это сначала рисует спрайты в передней части экрана, которые заполняют буфер глубины, так что более поздние спрайты позади могут быть пропущены. Это улучшит производительность на устройствах с ограниченной скоростью заполнения, где вы рисуете много перекрывающихся непрозрачных спрайтов. По умолчанию он выключен, но если вы не часто меняете глубину спрайта, рекомендуется включить его. Это не относится к прозрачным спрайтам, которые имеют свои собственные требования к сортировке. Эта команда устарела, сортировка теперь обрабатывается автоматически.
     *
     * @param int $sort Установите значение 1 для сортировки непрозрачных спрайтов по глубине. по умолчанию=0
     * @return void
     */
    function SetSortDepth($sort)
    {
    }

    /**
     *Если два спрайта занимают одну и ту же глубину, то порядок их рисования не определен, если только эта функция не установлена в 1, и в этом случае спрайты на одной и той же глубине будут нарисованы в том порядке, в котором они были созданы. Для максимальной производительности рекомендуется, чтобы каждый спрайт имел свое собственное значение глубины с этой командой, установленной в 0. Если порядок их рисования не важен, например, физические спрайты, которые обычно не перекрываются, то вы можете использовать спрайты на одной и той же глубине, не устанавливая эту команду в 1.
     *
     * @param int $sort Установите значение 1, чтобы отсортировать спрайты с одинаковой глубиной по порядку их создания, и 0, чтобы отключить его.
     * @return void
     */
    function SetSortCreated($sort)
    {
    }

    /**
     *Устанавливает, должно ли устройство спать, когда ваше приложение находится в режиме ожидания. По умолчанию он выключен, но если он активирован, то будет использовать настройки устройства, чтобы определить, как долго оно должно простаивать перед сном.
     *
     * @param int $mode 1 для включения спящего режима, 0 для его выключения (по умолчанию)
     * @return void
     */
    function SetSleepMode($mode)
    {
    }

    /**
     *Задает свойства для любых изображений наклеек, добавляемых в будущие вызовы ShareSnapChatImage. Параметры X и Y должны находиться в диапазоне от 0.0 до 1.0, например, в направлении X 1.0-это крайняя правая часть изображения, а 0.0-крайняя левая часть изображения.
     *
     * @param float $x Положение X наклейки, по умолчанию 0,5
     * @param float $y Положение наклейки Y, по умолчанию 0,5
     * @param int $width Ширина наклейки, по умолчанию 250
     * @param int $height Высота наклейки, по умолчанию 250
     * @param float $angle Угол наклона наклейки, по умолчанию 0
     * @return void
     */
    function SetSnapChatStickerSettings($x, $y, $width, $height, $angle)
    {
    }

    /**
     *Устанавливает, виден ли объект sky box или нет. По умолчанию он не виден. Поле неба всегда будет появляться позади всех других 3D-объектов и будет нарисовано в максимальном видимом диапазоне обзора, который задается с помощью SetCameraRange. В поле sky есть дополнительное солнце, которое будет нарисовано в соответствии с текущим направлением света, установленным с помощью SetSunDirection. Однако он не будет использовать направленный световой цвет, поэтому вы можете иметь направленный свет как один цвет, а небо и солнце-как другой цвет.
     *
     * @param int $active 1, чтобы показать скайбокс, 0, чтобы скрыть его
     * @return void
     */
    function SetSkyBoxVisible($active)
    {
    }

    /**
     *Устанавливает, будет ли небесная коробка рисовать солнце в месте текущего направленного света. Его положение можно установить с помощью SetSunDirection, но он не будет использовать направленный светлый цвет, вы можете установить его отдельно с помощью SetSkyBoxSunColor. Обратите внимание, что установка видимого солнца изменяет расчеты чертежа небесного ящика, делая их более сложными, что может повлиять на производительность.
     *
     * @param int $visible 1, чтобы нарисовать солнце, 0, чтобы скрыть его
     * @return void
     */
    function SetSkyBoxSunVisible($visible)
    {
    }

    /**
     *Устанавливает размер солнца и его ореола, если он виден. Значения размера не относятся ни к каким мировым единицам измерения и должны находиться в диапазоне от 1,0 до 100,0. Значения по умолчанию-5,0 для солнца и 50,0 для гало.
     *
     * @param float $sun Размер солнца
     * @param float $halo Размер гало вокруг солнца
     * @return void
     */
    function SetSkyBoxSunSize($sun, $halo)
    {
    }

    /**
     *Устанавливает цвет солнца, если он виден. По умолчанию это 255,230,179. Цвета должны находиться в диапазоне от 0 до 255, хотя это не ограничено и значения за пределами этого диапазона будут приниматься, включая отрицательные значения. Обратите внимание, что из-за того, как цвет солнца добавляется к цвету неба, цвета солнца темнее, чем цвет неба, могут привести к неожиданному цвету солнца, когда один или несколько цветовых компонентов полностью отсутствуют. Если это произойдет, то масштабирование цвета солнца, поднимаясь выше 255, если это необходимо, удалит его. Цвет солнца оказывает некоторое влияние на размер солнца в дополнение к SetSkyBoxSunSize, причем более яркие цвета делают его больше.
     *
     * @param int $red Красная составляющая цвета неба
     * @param int $green Зеленая составляющая цвета неба
     * @param int $blue Голубая составляющая цвета неба
     * @return void
     */
    function SetSkyBoxSunColor($red, $green, $blue)
    {
    }

    /**
     *Задает цвет, который заполнит большую часть неба. По умолчанию это 161 183 209. Цвета должны находиться в диапазоне от 0 до 255, хотя это не ограничено и значения за пределами этого диапазона будут приниматься, включая отрицательные значения.
     *
     * @param int $red Красная составляющая цвета неба
     * @param int $green Зеленая составляющая цвета неба
     * @param int $blue Голубая составляющая цвета неба
     * @return void
     */
    function SetSkyBoxSkyColor($red, $green, $blue)
    {
    }

    /**
     *Устанавливает размер и высоту горизонта. По умолчанию размер равен 4.0, а высота-0.0. Это влияет на то, как высоко простирается цвет горизонта, прежде чем стать цветом неба. Значение высоты находится в мировых координатах, и все, что находится на этой высоте или ниже нее, будет иметь цвет горизонта. Выше этой высоты горизонт сливается с цветом неба, пока в какой-то момент не остается только цвет неба. Горизонт всегда будет находиться на заданной высоте в мире, даже если камера движется вверх и вниз. Значение размера не относится ни к каким мировым единицам и должно быть установлено по вашему вкусу, тогда эффективный диапазон составляет от 0,1 до примерно 50,0, но может быть установлен и выше. Если диапазон обзора мал, то значение высоты будет иметь больший эффект, поскольку небесный ящик приближается к камере ближе, чем если бы диапазон обзора был больше. Например, высота горизонта 100 с небольшим диапазоном обзора будет казаться очень высокой, но когда диапазон обзора больше, камера просматривает горизонт с гораздо большего расстояния, поэтому изменение высоты на 100 единиц будет иметь меньший эффект.
     *
     * @param float $size Размер горизонта над высотой горизонта
     * @param float $height Высота, с которой начинается горизонт
     * @return void
     */
    function SetSkyBoxHorizonSize($size, $height)
    {
    }

    /**
     *Задает цвет, который будет отображаться на горизонте. По умолчанию это 255,255,255. Цвета должны находиться в диапазоне от 0 до 255, хотя это не ограничено и значения за пределами этого диапазона будут приниматься, включая отрицательные значения.
     *
     * @param int $red Красная составляющая цвета неба
     * @param int $green Зеленая составляющая цвета неба
     * @param int $blue Голубая составляющая цвета неба
     * @return void
     */
    function SetSkyBoxHorizonColor($red, $green, $blue)
    {
    }

    /**
     *Устанавливает, является ли указанный скелет видимым или нет. AGK автоматически скроет скелет, когда он переместится за пределы экрана, чтобы повысить производительность, поэтому вам нужно сделать это только в том случае, если вы хотите скрыть его, пока он находится на экране. Когда скелет спрятан, он все равно оживет.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $mode 1, чтобы сделать его видимым, 0, чтобы скрыть его
     * @return void
     */
    function SetSkeleton2DVisible($iSkeleton, $mode)
    {
    }

    /**
     *Устанавливает угол корня скелета, углы костей будут относительно этого угла.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param float $r Угол использования в градусах
     * @return void
     */
    function SetSkeleton2DRotation($iSkeleton, $r)
    {
    }

    /**
     *Устанавливает положение корня скелета, положение костей будет относительно этого места. Это может быть использовано для перемещения скелета во время его анимации, чтобы сделать его похожим на ходьбу.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param float $x Положение X скелета
     * @param float $y Положение Y скелета
     * @return void
     */
    function SetSkeleton2DPosition($iSkeleton, $x, $y)
    {
    }

    /**
     *Устанавливает горизонтальный и вертикальный режим переворота скелета, это будет переворачивать все кости и спрайты вдоль горизонтальной или вертикальной оси (или и то, и другое).
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $flipH 1-перевернуть скелет по горизонтальной оси, 0-не перевернуть.
     * @param int $flipV 1-перевернуть скелет по вертикальной оси, 0-не перевернуть.
     * @return void
     */
    function SetSkeleton2DFlip($iSkeleton, $flipH, $flipV)
    {
    }

    /**
     *Устанавливает глубину этого скелета в диапазоне 0-10000 с 0 - вершиной.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $depth Значение глубины для использования
     * @return void
     */
    function SetSkeleton2DDepth($iSkeleton, $depth)
    {
    }

    /**
     *Установите исходную шкалу кости. Анимация переопределит это значение.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $bone Идентификатор кости для модификации
     * @param float $sx Новое значение шкалы X для использования
     * @param float $sy Новое значение шкалы Y для использования
     * @return void
     */
    function SetSkeleton2DBoneScale($iSkeleton, $bone, $sx, $sy)
    {
    }

    /**
     *Установка исходного положения кости относительно ее родителя также известна как установочная поза. Вся анимация будет находиться относительно этой позиции, она может быть изменена во время воспроизведения анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $bone Идентификатор кости для изменения
     * @param float $x Новая позиция X для использования
     * @param float $y Новая позиция Y для использования
     * @return void
     */
    function SetSkeleton2DBonePosition($iSkeleton, $bone, $x, $y)
    {
    }

    /**
     *Устанавливает, может ли кость оживать или она остается неподвижной. Вы все еще можете изменить положение кости, угол наклона и масштаб вручную.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $bone Идентификатор кости для модификации
     * @param int $mode 1, чтобы позволить кости оживать, 0, чтобы остановить ее
     * @return void
     */
    function SetSkeleton2DBoneMode($iSkeleton, $bone, $mode)
    {
    }

    /**
     *Устанавливает скорость анимации (по умолчанию 1.0), отрицательные значения разрешены для реверса анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param float $speed Скорость анимации с 1.0 является нормальной скоростью
     * @return void
     */
    function SetSkeleton2DAnimationSpeed($iSkeleton, $speed)
    {
    }

    /**
     *Установите исходный угол кости относительно ее родителя. Вся анимация будет относительно этого угла, он может быть изменен во время воспроизведения анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $bone Идентификатор кости для модификации
     * @param float $r Новый угол для использования
     * @return void
     */
    function SetSkeleton2DBoneAngle($iSkeleton, $bone, $r)
    {
    }

    /**
     *Устанавливает скелет в определенную точку анимации в зависимости от времени, с дополнительным временем твиннинга. Время анимации будет плавно интерполировать скелет из его текущего состояния в выбранный кадр указанной анимации, чтобы не было резкого перехода.
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param string $anim Имя используемой анимации
     * @param float $time Смещение времени, используемое для установки каркаса скелета
     * @param float $tweentime Количество секунд для перехода из текущего состояния в заданный кадр
     * @return void
     */
    function SetSkeleton2DAnimationFrame($iSkeleton, $anim, $time, $tweentime)
    {
    }

    /**
     *Только для iOS. Сообщает AGK, какую группу приложений вы используете для обмена данными между приложениями. Например, group.com.mycompany.mygroup.myvariables создается на портале разработчиков Apple и должен быть добавлен к каждому идентификатору приложения, к которому вы хотите получить доступ к этим переменным. Вам нужно будет заново создать профиль подготовки для каждого приложения после добавления группы приложений к его идентификатору приложения.
     *
     * @param string $group Имя, используемое для идентификации этой переменной
     * @return void
     */
    function SetSharedVariableAppGroup($group)
    {
    }

    /**
     *Включает или выключает отображение теней, по умолчанию это выключено. Тени генерируются только глобальным направленным светом, которым можно управлять с помощью команды SetSunDirection. Обратите внимание, что это не гарантировано поддерживается на всех устройствах, вы можете проверить наличие текущего устройства, вызвав GetShadowMappingSupported. В настоящее время существует три режима теней, которые можно использовать, режим 1 использует равномерное отображение теней, которое имеет более низкое, но стабильное качество. Режим 2 использует Light Space Perspective shadow mapping (LiPSM), который в большинстве случаев имеет более высокое качество, но если камера смотрит в том же направлении, что и свет, то это не лучше, чем Равномерное теневое отображение. Перспектива светлого пространства также страдает от мерцания теней при движении камеры, в то время как Равномерность более стабильна. Оба имеют примерно одинаковую производительность. Режим 3 использует каскадное теневое отображение, которое использует несколько теневых карт для поддержания высокого качества вблизи камеры, в то же время позволяя более низкие качественные тени на расстоянии. Этот метод имеет гораздо более низкую производительность, чем предыдущие два метода, но во всех случаях приводит к более качественным теням. Обратите внимание, что при использовании режимов 1 и 2 этап текстуры 7 на всех объектах, получающих тень, зарезервирован для карты теней. При использовании теневого режима 3 (каскадные тени) для теневых карт зарезервированы этапы текстуры 4, 5, 6 и 7.
     *
     * @param int $mode 0, чтобы выключить его, 1, чтобы использовать Равномерные тени, 2, чтобы использовать тени LiPSM, 3, чтобы использовать каскадные тени
     * @return void
     */
    function SetShadowMappingMode($mode)
    {
    }

    /**
     *Устанавливает режим сглаживания для теневой карты. Режим 0 отключает сглаживание и приводит к самым быстрым теням, но создает жесткие края. Режим 1 немного медленнее, но создает более мягкие тени, многократно пробуя карту теней. Режим 2 использует случайную мультисэмплировку, чтобы избежать полос, создаваемых режимом 1, но еще медленнее.
     *
     * @param int $mode 0
     * @return void
     */
    function SetShadowSmoothing($mode)
    {
    }

    /**
     *Задает разрешение теневой карты в пикселях. Хорошие значения-512x512 или 1024x1024, это не обязательно должна быть степень двух по размеру. Чем выше разрешение, тем лучше качество теней, хотя производительность будет ниже при более высоком разрешении теневых карт.
     *
     * @param int $width Ширина в пикселях, используемая для теневой карты
     * @param int $height Высота в пикселях, используемая для теневой карты
     * @return void
     */
    function SetShadowMapSize($width, $height)
    {
    }

    /**
     *Устанавливает диапазон от камеры, в котором будут нарисованы тени. В идеале это должно быть установлено на дальний диапазон камеры от SetCameraRange, но рисование теней до самой дальней плоскости может отнять некоторое качество у тех теней, которые находятся ближе к камере. Поэтому установка диапазона теней ниже, чем дальний диапазон камеры, может улучшить качество теней за счет удаленных объектов, не имеющих теней. Фактический диапазон теней будет меньшим значением дальнего диапазона камеры и этого диапазона теней, поэтому вы можете безопасно установить его больше, чем дальний диапазон камеры, без какого-либо влияния на качество. Если позже вы отрегулируете дальний диапазон камеры, то диапазон теней не изменится соответствующим образом, вы должны установить его отдельно. Используйте значение -1, чтобы игнорировать это значение, и всегда используйте дальний диапазон камеры для теней. По умолчанию это значение равно -1.
     *
     * @param float $range Расстояние, чтобы остановить рисование теней, -1, чтобы вместо этого использовать дальний диапазон камеры
     * @return void
     */
    function SetShadowRange($range)
    {
    }

    /**
     *Устанавливает смещение для смещения теней так, чтобы поверхности объектов не затеняли сами себя, по умолчанию значение равно 0,001. Это может помочь предотвратить появление теневых артефактов на поверхностях, которые находятся на свету, но также отбрасывают тень позади себя.
     *
     * @param float $bias Расстояние до сдвига теней
     * @return void
     */
    function SetShadowBias($bias)
    {
    }

    /**
     *Ограничивает угол направленного света шагами заданного размера, а не непрерывным значением. Это может предотвратить мерцание тени, если направленный свет медленно меняет свой угол, например, солнце движется по небу. По умолчанию это значение равно 0, что отключает размер шага и сохраняет угол как непрерывное значение. Значения в диапазоне от 0,1 до 2,0, по-видимому, работают лучше всего. Это применимо только в том случае, если SetShadowMappingMode имеет значение Uniform.
     *
     * @param float $step Размер шага угла освещения в градусах
     * @return void
     */
    function SetShadowLightStepSize($step)
    {
    }

    /**
     *При использовании cascade shadow maps (SetShadowMappingMode 3) эта команда устанавливает диапазон, который будет охватывать каждая каскадная карта. Всего существует 4 каскадных теневых карты, четвертая всегда охватывает всю затененную область (cascade4 = 1.0), по умолчанию третий каскад охватывает половину затененной области (cascade3 = 0.5), второй каскад охватывает четверть затененной области (cascade2 = 0.25), а первый каскад охватывает одну восьмую затененной области (cascade1 = 0.125). Поскольку все каскадные теневые карты используют одинаковое разрешение, чем меньше площадь, которую они покрывают, тем больше деталей тени будет в этой области. Каскадные теневые карты упорядочены таким образом, что самая маленькая из них находится ближе всего к камере, а самая большая-дальше всего. Таким образом, тени вблизи камеры должны иметь высокую детализацию, в то время как самые дальние, которые менее заметны, будут иметь более низкую детализацию. Обратите внимание, что, хотя использование меньшей площади для конкретного каскада увеличит качество тени, это уменьшит площадь, которую этот каскад покрывает, поэтому качество тени упадет на следующий уровень раньше, чем расстояние от камеры увеличится.   Каскадные уровни должны находиться в диапазоне от 0.0 до 1.0, и каждый уровень должен быть больше предыдущего уровня, то есть каскад2 должен быть больше каскада1 и так далее. Если эти правила нарушены, то эта команда ничего не сделает.
     *
     * @param float $cascade1 Наименьший уровень каскада, должен быть меньше, чем cascade2, должен быть больше, чем 0.0
     * @param float $cascade2 Второй каскадный уровень, должен быть меньше, чем cascade3
     * @param float $cascade3 Третий каскадный уровень, должен быть меньше 1,0
     * @return void
     */
    function SetShadowCascadeValues($cascade1, $cascade2, $cascade3)
    {
    }

    /**
     *Задает индекс массива констант шейдера по имени, константа должна быть помечена как "однородная" в источнике шейдера. Индексы массива начинаются с 0, если индекс массива находится за пределами границ, то он будет проигнорирован и никакие изменения не будут внесены. Это повлияет на все объекты, нарисованные с помощью этого шейдера. Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4 значения и отбрасывает все, которые не используются именованной переменной.
     *
     * @param int $shaderID Идентификатор шейдера для изменения.
     * @param string $szName Имя изменяемой константы, как определено в исходном файле шейдера.
     * @param int $arrayIndex Индекс элемента в массиве для изменения.
     * @param float $value1 Компонент X или R нового значения, это значение всегда будет использоваться.
     * @param float $value2 Компонент Y или G нового значения, если константа использует только 1 компонент, это значение отбрасывается.
     * @param float $value3 Компонент Z или B нового значения, если константа использует только 2 компонента, это значение отбрасывается.
     * @param float $value4 W или компонент нового значения, если константа использует только 3 компонента, это значение отбрасывается.
     * @return void
     */
    function SetShaderConstantArrayByName($shaderID, $szName, $arrayIndex, $value1, $value2, $value3, $value4)
    {
    }

    /**
     *Задает константу шейдера по имени, константа должна быть помечена как "однородная" в источнике шейдера. Это повлияет на все объекты, нарисованные с помощью этого шейдера. Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4 значения и отбрасывает все, которые не используются именованной переменной.
     *
     * @param int $shaderID Идентификатор шейдера для изменения.
     * @param string $szName Имя изменяемой константы, как определено в исходном файле шейдера.
     * @param float $value1 Компонент X или R нового значения, это значение всегда будет использоваться.
     * @param float $value2 Компонент Y или G нового значения, если константа использует только 1 компонент, это значение отбрасывается.
     * @param float $value3 Компонент Z или B нового значения, если константа использует только 2 компонента, это значение отбрасывается.
     * @param float $value4 W или компонент нового значения, если константа использует только 3 компонента, это значение отбрасывается.
     * @return void
     */
    function SetShaderConstantByName($shaderID, $szName, $value1, $value2, $value3, $value4)
    {
    }

    /**
     *Устанавливает разрешение заднего буфера там, где это возможно. Если выбранное вами разрешение больше, чем может отображать устройство, чем устройство будет использовать свое максимально возможное разрешение, вы можете использовать GetDeviceWidth и GetDeviceHeight, чтобы узнать, что было использовано. На мобильных устройствах использование разрешения экрана с другим соотношением сторон, чем на устройстве, приведет к растяжению. Вы можете проверить соотношение сторон устройства с помощью GetMaxDeviceWidth и GetMaxDeviceHeight. Не рекомендуется разрешать как портретную, так и альбомную ориентацию при использовании этой команды, так как AGK не может предотвратить растяжение без отмены желаемого разрешения экрана, поэтому он этого не сделает. Если вы хотите, чтобы все ориентации были без растяжения, вам нужно будет следить за изменениями GetMaxDeviceWidth и GetMaxDeviceHeight и установить соответствующее разрешение замены с помощью SetScreenResolution, чтобы оно соответствовало новому соотношению сторон. Использование разрешения 0 в любом направлении приведет к сбросу разрешения экрана до максимального разрешения, поддерживаемого на устройстве. Обратите внимание, что в Windows и Mac размер backbuffer изменяется путем изменения размера окна, поэтому он будет перезаписывать любые настройки из SetWindowSize. Это может быть не так в будущем, и AGK может иметь отдельные размеры окон и размеры backbuffer в будущей версии.
     *
     * @param int $width Желаемая ширина экрана в пикселях.
     * @param int $height Желаемая высота экрана в пикселях.
     * @return void
     */
    function SetScreenResolution($width, $height)
    {
    }

    /**
     *Эта функция задает область экрана, которая будет отображаться в последующих командах Sync() или Render (). Область определяется двумя точками, представляющими верхний левый и нижний правый углы прямоугольника, который будет новой областью рисования. По умолчанию это значение равно вашему виртуальному разрешению, поэтому все, что находится за пределами этого разрешения, не будет видно. Использование SetScissor(0,0,0,0) - это особый случай, который отключит все отсечения и сделает весь экран пригодным для отображения вещей. Это может быть полезно при создании приложения, которое работает с различными соотношениями сторон. Например, использование виртуального разрешения 1024х768 на устройстве с экраном 1280х800 будет соответствовать области 1024х768 как можно ближе в центре экрана, с черными границами по обе стороны. SetScissor(0,0,0,0) помещает область 1024x768 в одно и то же место, но там нет черных границ, поэтому размещение чего-то в отрицательном положении X все равно будет видно до тех пор, пока экран все еще может поместиться. В то время как размещение чего-то в отрицательном положении на устройстве с экраном 1024x768 (который идеально подходит для вашего виртуального разрешения) приведет к тому, что этот элемент исчезнет с края экрана. Вы можете использовать это с помощью команд GetScreenBoundsLeft, GetScreenBoundsRight, GetScreenBoundsTop и GetScreenBoundsBottom, чтобы найти фактический край экрана в выбранном вами разрешении. Это позволяет размещать элементы по краю экрана на всех устройствах независимо от его соотношения сторон.
     *
     * @param float $x x-компонент первой координаты.
     * @param float $y Компонент y первой координаты.
     * @param float $x2 x-компонент второй координаты.
     * @param float $y2 Компонент y второй координаты.
     * @return void
     */
    function SetScissor($x, $y, $x2, $y2)
    {
    }

    /**
     *Некоторые платформы имеют экраны с высоким разрешением, такие как iPad, эта функция определяет, как эти платформы отображают свой контент. У вас есть выбор mode=1, который будет использовать буфер кадров полного разрешения, который будет выглядеть лучше, или mode=0, который будет использовать буфер кадров меньшего разрешения (обычно половинного размера), который затем масштабируется по размеру экрана и будет работать быстрее. Это не влияет на устройства с низким разрешением, которые всегда будут использовать буфер кадров с низким разрешением.
     *
     * @param int $mode 1 для использования высокого (собственного) разрешения, 0 для использования низкого (масштабированного) разрешения
     * @return void
     */
    function SetResolutionMode($mode)
    {
    }

    /**
     *Эта команда устанавливает конвейер рендеринга для вывода любых будущих вызовов рисования на экран. Это режим по умолчанию, поэтому вам нужно вызвать его только в том случае, если вы ранее перенаправили рисунок на изображение с помощью SetRenderToImage.
     *
     * @return void
     */
    function SetRenderToScreen()
    {
    }

    /**
     *Перенаправляет все будущие вызовы рисования на изображение, а не на экран. Затем указанное изображение может быть применено к объекту или спрайту. Будьте осторожны, чтобы не применять к объекту или спрайту одновременно с его рисованием, так как это может привести к ошибке. Вы также можете выбрать визуализацию информации о глубине для изображения, которое вы можете использовать позже, или визуализацию без буфера глубины, если ваша сцена в нем не нуждается. Вы также можете использовать идентификатор изображения глубины, равный -1, для рендеринга буфера глубины без захвата его в изображение. Обратите внимание, что некоторые устройства (особенно Android) не поддерживают рендеринг глубины изображения, в этих случаях единственными допустимыми значениями идентификатора глубины являются 0 и -1. Вы можете проверить, поддерживает ли текущее устройство текстуры глубины, используя IsSupportedDepthTexture. Рендеринг изображений может быть любого размера, и не обязательно должен быть в степени 2 по ширине или высоте. Для более подробного объяснения, когда вы визуализируете изображение, оно будет рисовать на изображении именно то, что оно нарисовало бы на экране. Например, если ваше виртуальное разрешение составляет 1024x768 и требует границ, то оно будет рисовать границы на изображении рендеринга. Это означает, что если вы посмотрите на полученное изображение рендеринга в его родной форме, например 1024x1024, оно будет выглядеть так, как будто вы взяли окно 1024х768 и растянули его вертикально в квадрат. В результате, если вы возьмете это квадратное изображение и растянете его обратно в 1024х768, текстурируя спрайт или квадроцикл размером 1024х768, то оно снова будет выглядеть нормально. Это означает, что вы можете визуализировать окно 1024x768 в изображение любого размера, скажем 64x512, и растянуть его до 1024x768, и оно должно выглядеть правильно с точки зрения соотношения сторон, конечно, в нем будут отсутствовать некоторые детали. Затем вы можете получить более продвинутый результат, изменив виртуальное разрешение после установки изображения рендеринга и изменив его обратно при рендеринге на экран, или используя SetCameraAspect для изменения соотношения сторон 3D, если изображение рендеринга будет использоваться для чего-то другого, чем представление экрана 1:1. При рендеринге изображения очень важно, чтобы изображение было очищено с помощью ClearScreen (), прежде чем рисовать на нем новую сцену. Это делается для того, чтобы графический процессор знал, что он может отбросить предыдущее содержимое. Если изображение не очищается и вещи продолжают притягиваться к нему, то производительность некоторых графических процессоров со временем ухудшится.
     *
     * @param int $colorImage Идентификатор изображения, которое будет использоваться в качестве цветового буфера, 0, чтобы не отображать цвет
     * @param int $depthImage Идентификатор изображения, используемого в качестве буфера глубины, 0-чтобы не отображать глубину, -1-чтобы использовать буфер глубины без изображения
     * @return void
     */
    function SetRenderToImage($colorImage, $depthImage)
    {
    }

    /**
     *Задает папку, в которой будут храниться файлы, созданные AGK. Это никак не влияет на iOS, так как она не может писать вне своей папки приложения. Вы можете установить его на любой абсолютный путь на устройстве, однако некоторые места, такие как папка Program Files в Windows, потребуют прав администратора для записи в них. Некоторые места будут защищены операционной системой, SetRawWritePath позволит вам установить путь к этим местам, но любая попытка записи в них потерпит неудачу. Вы можете использовать GetDocumentsPath, чтобы получить системную папку документов для текущего пользователя или папку sdcard на Android, которая гарантированно разрешит доступ на запись. Эта команда теперь устарела. Предпочтительным способом доступа к файлам за пределами обычной папки записи является использование команд OpenRawFolder и путей к файлам "raw:".
     *
     * @param string $str Путь для использования в качестве папки записи
     * @return void
     */
    function SetRawWritePath($str)
    {
    }

    /**
     *Задает расстояние, на которое должно переместиться событие касания, прежде чем оно будет классифицировано как событие перетаскивания. По умолчанию это значение равно 6.
     *
     * @param int $distance Расстояние, на которое событие касания должно переместиться в виртуальных координатах
     * @return void
     */
    function SetRawTouchMoveSensitivity($distance)
    {
    }

    /**
     *Пытается скрыть или показать любой указатель мыши, используемый на этой платформе. Не гарантируется работа на всех платформах.
     *
     * @param int $visible 1, чтобы сделать его видимым, 0, чтобы скрыть его.
     * @return void
     */
    function SetRawMouseVisible($visible)
    {
    }

    /**
     *Позволяет вам установить некоторые пользовательские данные для хранения в этом событии, которые вы можете получить позже. Это может быть значение или указатель.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @param int $value Значение для хранения с этим событием.
     * @return void
     */
    function SetRawTouchValue($iIndex, $value)
    {
    }

    /**
     *Пытается расположить любой указатель мыши, используемый на этой платформе. Не гарантируется работа на всех платформах. Будет работать только тогда, когда окно вашего приложения имеет фокус.
     *
     * @param float $x Компонент X новой позиции мыши.
     * @param float $y Компонент Y новой позиции мыши.
     * @return void
     */
    function SetRawMousePosition($x, $y)
    {
    }

    /**
     *Устанавливает мертвую зону для всех реальных джойстиков так, чтобы любое значение X или Y ниже заданного порога возвращало 0. Это значение должно быть между 0 и 1, по умолчанию оно равно 0,15.
     *
     * @param float $threshold Значение, ниже которого будет возвращено 0.
     * @return void
     */
    function SetRawJoystickDeadZone($threshold)
    {
    }

    /**
     *Задает начальное значение для генератора случайных чисел. Два приложения AGK, использующие одно и то же начальное значение, будут генерировать одну и ту же последовательность случайных чисел. По умолчанию начальное значение устанавливается на текущее время при запуске, так что каждый запуск приложения будет генерировать другую последовательность чисел.
     *
     * @param int $seed Начальное значение, между 1 и 2^32
     * @return void
     */
    function SetRandomSeed2($seed)
    {
    }

    /**
     *Задает начальное значение для генератора случайных чисел. Два приложения AGK, использующие одно и то же начальное значение, будут генерировать одну и ту же последовательность случайных чисел. По умолчанию начальное значение устанавливается на текущее время при запуске, так что каждый запуск приложения будет генерировать другую последовательность чисел.
     *
     * @param int $seed Начальное значение, между 1 и 2^32
     * @return void
     */
    function SetRandomSeed($seed)
    {
    }

    /**
     *Эта команда используется на Android для установки SenderID, используемого проектом Firebase. В настоящее время keyName должно быть установлено в "SenderID" (с учетом регистра), а KeyValue должно быть установлено в значение SenderID, которое можно найти в настройках проекта Firebase на вкладке Облачные сообщения.
     *
     * @param string $keyName Ключ к набору
     * @param string $keyValue Ключевое значение
     * @return void
     */
    function SetPushNotificationKeys($keyName, $keyValue)
    {
    }

    /**
     *Устанавливает интервал между буквами. Значение 0 не создает зазора между ограничивающими буквами, положительное значение увеличивает этот зазор, отрицательное значение перекрывает буквы. Это глобальная команда, которая будет влиять на весь печатный текст при следующем вызове синхронизации. Для управления интервалом на основе каждой строки используйте текстовые команды.
     *
     * @param float $fSpacing Интервал между буквами для использования.
     * @return void
     */
    function SetPrintSpacing($fSpacing)
    {
    }

    /**
     *Задает размер печатного текста, который будет отображаться на экране. Это глобальная команда, которая будет влиять на весь печатный текст при следующем вызове синхронизации. Для управления размером на основе каждой строки используйте текстовые команды.
     *
     * @param float $fSize Размер текста в пикселях виртуального разрешения.
     * @return void
     */
    function SetPrintSize($fSize)
    {
    }

    /**
     *Устанавливает шрифт для использования для всего печатного текста, шрифт должен быть предварительно загружен с помощью LoadFont. Используйте идентификатор шрифта 0, чтобы использовать шрифт AGK по умолчанию.
     *
     * @param int $fontID Идентификатор шрифта, используемый для печати текста
     * @return void
     */
    function SetPrintFont($fontID)
    {
    }

    /**
     *Задает цвет печатного текста. Это глобальная команда, которая будет влиять на весь печатный текст при следующем вызове синхронизации. Для управления цветом на основе каждой строки используйте текстовые команды. Эта версия устанавливает альфа-код на 255, полностью непрозрачный.
     *
     * @param int $iRed Красная составляющая цвета.
     * @param int $iGreen Зеленая составляющая цвета.
     * @param int $iBlue Синяя составляющая цвета.
     * @return void
     */
    function SetPrintColor($iRed, $iGreen, $iBlue)
    {
    }

    /**
     *Задает цвет печатного текста. Это глобальная команда, которая будет влиять на весь печатный текст при следующем вызове синхронизации. Для управления цветом на основе каждой строки используйте текстовые команды. Эта версия устанавливает альфа-код на 255, полностью непрозрачный.
     *
     * @param int $iRed Красная составляющая цвета.
     * @param int $iGreen Зеленая составляющая цвета.
     * @param int $iBlue Синяя составляющая цвета.
     * @param int $iAlpha Альфа-компонент цвета.
     * @return void
     */
    function SetPrintColor($iRed, $iGreen, $iBlue, $iAlpha)
    {
    }

    /**
     *Изменяет точечный свет на новый радиус воздействия. Объекты, находящиеся на большем расстоянии от источника света, будут получать от него нулевой свет.
     *
     * @param int $lightID Идентификатор света для изменения.
     * @param float $radius Расстояние, на которое может повлиять свет.
     * @return void
     */
    function SetPointLightRadius($lightID, $radius)
    {
    }

    /**
     *Помещает точечный свет в новое положение.
     *
     * @param int $lightID Идентификатор света для изменения.
     * @param float $x X-компонент новой позиции.
     * @param float $y Y-компонент новой позиции.
     * @param float $z Z-компонент новой позиции.
     * @return void
     */
    function SetPointLightPosition($lightID, $x, $y, $z)
    {
    }

    /**
     *Устанавливает точечный свет в режим вершины или пикселя. Вершинный режим быстрее, но пиксельный режим имеет лучшее качество. По умолчанию огни создаются в режиме вершин. Сетка может быть освещена до 8 вершинными огнями и 4 пиксельными огнями одновременно, если вы добавите больше огней, чем это, то самые близкие огни будут использоваться сеткой.
     *
     * @param int $lightID Идентификатор света для изменения.
     * @param int $mode 0 для вершины, 1 для пиксельного режима.
     * @return void
     */
    function SetPointLightMode($lightID, $mode)
    {
    }

    /**
     *Меняет точечный свет на новый цвет. Значения должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать свет.
     *
     * @param int $lightID Идентификатор света для изменения.
     * @param int $red Красная составляющая светлого цвета.
     * @param int $green Зеленая составляющая светлого цвета.
     * @param int $blue Синяя составляющая светлого цвета.
     * @return void
     */
    function SetPointLightColor($lightID, $red, $green, $blue)
    {
    }

    /**
     *Переключает существование физической стены в верхней части экрана, чтобы физические объекты не покидали экран в этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с ним, они фиксированы к миру, поэтому они будут отключены автоматически.
     *
     * @param int $mode 0=выкл., 1=вкл.
     * @return void
     */
    function SetPhysicsWallTop($mode)
    {
    }

    /**
     *Переключает существование физической стены справа от экрана, чтобы физические объекты не покидали экран в этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с ним, они фиксированы к миру, поэтому они будут отключены автоматически.
     *
     * @param int $mode 0=выкл., 1=вкл.
     * @return void
     */
    function SetPhysicsWallRight($mode)
    {
    }

    /**
     *Переключает существование физической стены в левой части экрана, чтобы физические объекты не покидали экран в этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с ним, они фиксированы к миру, поэтому они будут отключены автоматически.
     *
     * @param int $mode 0=выкл., 1=вкл.
     * @return void
     */
    function SetPhysicsWallLeft($mode)
    {
    }

    /**
     *Задает количество потоков для использования во время физики. Значение 0 или 1 отключает многопоточность, значение минус 1 выбирает значение, соответствующее количеству процессоров в устройстве для лучшей производительности. Использование значения, превышающего количество процессоров в устройстве, скорее всего, повредит производительности. По умолчанию-минус 1.
     *
     * @param int $threads Количество используемых нитей минус 1 для автоматического выбора числа, подходящего для данного устройства
     * @return void
     */
    function SetPhysicsThreading($threads)
    {
    }

    /**
     *Переключает существование физической стены в нижней части экрана, чтобы физические объекты не покидали экран в этом направлении. Если у вас есть физические объекты за краем экрана, например, в платформенной игре, вы должны отключить эту функцию. Если вы измените смещение вида с помощью SetViewOffset, стены не будут двигаться вместе с ним, они фиксированы к миру, поэтому они будут отключены автоматически.
     *
     * @param int $mode 0=выкл., 1=вкл.
     * @return void
     */
    function SetPhysicsWallBottom($mode)
    {
    }

    /**
     *Устанавливает шкалу, используемую физической системой, по сравнению с мировыми координатами. По замыслу физическая система настроена на использование 1 единицы измерения, равной 1 метру, что в случае стандартных мировых координат (100 100) означало бы, что экран в физическом моделировании равен 100 на 100 метров. Однако по своей конструкции физическая система предназначена для лучшей работы с динамическими объектами размером от 0,1 метра до 10 метров и со статическими объектами размером до 50 метров, поэтому экран масштабируется при отправке в физическую систему, по умолчанию масштаб равен 0,2, поэтому в физическом мире экран составляет 20 метров на 20 метров. Это делается исключительно для того, чтобы позволить физической системе работать в своем разработанном масштабе, позволяя использовать мировые координаты в качестве параметров, а AGK выполняет все необходимое масштабирование за кулисами. Эта функция позволяет вам изменить масштабный коэффициент, если ваше виртуальное разрешение будет отличаться от 100,100. Эта функция должна вызываться перед любыми другими физическими функциями и не должна вызываться после запуска физической системы.
     *
     * @param float $scale Новое значение шкалы для использования для всех значений экрана к физике и наоборот.
     * @return void
     */
    function SetPhysicsScale($scale)
    {
    }

    /**
     *Устанавливает способность динамических тел спать, когда они не двигаются, это значительно улучшает производительность, когда динамические тела расположились в своих конечных положениях. Выключение его полезно только для бенчмаркинга, когда вы хотите, чтобы процессор постоянно обрабатывал все тела. По умолчанию включено.
     *
     * @param int $mode 0, чтобы отключить спящий режим, 1, чтобы включить его
     * @return void
     */
    function SetPhysicsSleeping($mode)
    {
    }

    /**
     *Задает максимальное количество точек, которые будут сгенерированы в будущих полигональных физических фигурах, не влияет на уже сгенерированные фигуры, может вызываться несколько раз. Влияет только на формы, генерируемые AGK через SetSpriteShape. Должно быть от 2 до 12. Значение по умолчанию-8.
     *
     * @param int $points Максимальное количество точек, разрешенных в новых многоугольниках.
     * @return void
     */
    function SetPhysicsMaxPolygonPoints($points)
    {
    }

    /**
     *Задает вектор гравитации для всех спрайтов с помощью физики. Значения x и y будут масштабироваться в физическом пространстве, поэтому будут представлять только метры в секунду в квадрате, когда масштаб = 1,0, в мировом пространстве значения представляют пиксели в секунду в квадрате. Например, в шкале по умолчанию 0,2 значение SetPhysicsGravity 0,50 будет представлять 10 метров в секунду в квадрате. Гравитация-это постоянное ускорение, приложенное ко всем физическим объектам одинаково, независимо от массы. В то время как сила прилагает ускорение, пропорциональное массе объектов. Чтобы противодействовать гравитации с помощью силы, потребуется учет массы.
     *
     * @param float $x X-компонент вектора силы тяжести.
     * @param float $y Y-компонент вектора силы тяжести.
     * @return void
     */
    function SetPhysicsGravity($x, $y)
    {
    }

    /**
     *Изменяет диапазон действия глобальной силы. Спрайты, находящиеся на большем расстоянии от положения силы, не почувствуют ее воздействия. Диапазон меньше нуля равен бесконечному диапазону.
     *
     * @param int $iForceIndex Идентификатор силы для изменения.
     * @param float $range Новый диапазон силы.
     * @return void
     */
    function SetPhysicsForceRange($iForceIndex, $range)
    {
    }

    /**
     *Изменяет положение глобальной силы в мировых координатах.
     *
     * @param int $iForceIndex Идентификатор силы для изменения.
     * @param float $x x-компонент новой позиции.
     * @param float $y y-компонент новой позиции.
     * @return void
     */
    function SetPhysicsForcePosition($iForceIndex, $x, $y)
    {
    }

    /**
     *Изменяет силу глобальной силы. Для сил, которые исчезают, это будет сила в 1 единице от положения силы. Эта сила выражена в Ньютонах и по своим размерам похожа на гравитацию, за исключением того, что на нее влияет масса объекта. Например, для объекта массой 1 кг и силой 10 ньютонов будет воздействовать на объект так же, как гравитация, установленная на 10 м/с^2. Для массы 2 кг двигаться труднее, поэтому сила в 10 Ньютонов будет вдвое эффективнее при перемещении объекта, чем сила тяжести при 10 м/с^2.
     *
     * @param int $iForceIndex Идентификатор силы для изменения.
     * @param float $power Новая сила силы.
     * @return void
     */
    function SetPhysicsForcePower($iForceIndex, $power)
    {
    }

    /**
     *Позволяет рисовать внутренние физические фигуры на экране. Если вы установили значение viewoffset на что-то отличное от 0,0, убедитесь, что ни один из ваших физических спрайтов не закреплен на экране с помощью FixSpriteToScreen, иначе отладочные фигуры не выстроятся в линию. Отладочные контуры рисуются как мировые спрайты. Отладочный вывод будет рисовать форму каждого набора физических спрайтов с помощью SetSpritePhysicsOn и всех нефизических спрайтов, которым назначена форма для команд столкновения нефизических спрайтов. Фигуры будут нарисованы в следующих цветах: Кремовый=Динамический физический объект, Зеленый=Статический физический объект, Темно-синий=Кинематический физический объект, Светло-Голубой=нефизический объект. Серый=Спящий динамический физический объект. Кроме того, физические объекты будут нарисованы как затененные контуром, нефизические объекты будут только контуром.
     *
     * @return void
     */
    function SetPhysicsDebugOn()
    {
    }

    /**
     *Включает и выключает непрерывное обнаружение столкновений. Это предотвращает туннелирование быстро движущихся объектов через статические тела. Чтобы предотвратить прохождение быстро движущихся объектов друг через друга, используйте SetSpritePhysicsIsBullet, когда у вас есть большое количество динамических тел, которые могут быть узким местом в физическом движке, особенно когда резьба включена, так как эта часть в настоящее время не имеет резьбы. По умолчанию он выключен.
     *
     * @param int $mode 0, чтобы отключить CCD, 1, чтобы включить его
     * @return void
     */
    function SetPhysicsCCD($mode)
    {
    }

    /**
     *Отключает рисование внутренних физических фигур на экране.
     *
     * @return void
     */
    function SetPhysicsDebugOff()
    {
    }

    /**
     *Устанавливает, рисуются ли испускаемые частицы. Установите значение 1, чтобы показать частицы, и 0, чтобы скрыть их. Частицы все равно будут обновляться, пока они скрыты, вы можете остановить обновление частиц с помощью SetParticlesActive
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $visible 1=показать, 0=скрыть
     * @return void
     */
    function SetParticlesVisible($ID, $visible)
    {
    }

    /**
     *Устанавливает минимальный и максимальный множитель, который будет влиять на испускаемые частицы. Это может быть использовано для того, чтобы гарантировать, что при испускании частиц будут наблюдаться некоторые изменения.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $v1 Минимальный множитель скорости.
     * @param float $v2 Множитель максимальной скорости.
     * @return void
     */
    function SetParticlesVelocityRange($ID, $v1, $v2)
    {
    }

    /**
     *Установите прозрачность частиц на определенную настройку с выбором без прозрачности, альфа-прозрачности и аддитивного смешивания. По умолчанию частицы создаются с альфа-прозрачностью.
     *
     * @param int $ID Идентификатор излучателя частиц для изменения.
     * @param int $mode Режим прозрачности для этих частиц: 0=выкл., 1=альфа-прозрачность, 2=аддитивное смешивание
     * @return void
     */
    function SetParticlesTransparency($ID, $mode)
    {
    }

    /**
     *Задает область вокруг излучателя, в которой могут появиться новые частицы. Эти значения относятся к положению эмиттера, например, зона 0,0,0,0 будет означать, что все частицы начинаются в точке положения эмиттера. Зона -10 в x и +10 x, где y равно 0 (-10,0,10,0), создаст линию, центрированную на положении излучателя, вдоль которой будут случайным образом появляться частицы. Зона коробки, где и x, и y имеют ненулевые размеры, означала бы, что частицы могут начинаться в любой точке внутри коробки.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x1 Координата x верхнего левого угла стартовой зоны.
     * @param float $y1 Координата y верхнего левого угла стартовой зоны.
     * @param float $x2 Координата x в правом нижнем углу стартовой зоны.
     * @param float $y2 Координата y в правом нижнем углу стартовой зоны.
     * @return void
     */
    function SetParticlesStartZone($ID, $x1, $y1, $x2, $y2)
    {
    }

    /**
     *Задает размер всех частиц в мировых координатах. Установка большого количества частиц на большой размер будет плохо работать на мобильных устройствах с низкой скоростью заполнения (количество пикселей, которые он может нарисовать в секунду).
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $size Размер частиц
     * @return void
     */
    function SetParticlesSize($ID, $size)
    {
    }

    /**
     *Задает диапазон вращения в радианах, который частица может иметь в течение своей жизни. Когда частица создается, она начинается под углом 0 и выбирает случайную скорость вращения между углом 1 и углом 2. Затем частица будет вращаться с выбранной скоростью в течение всей своей жизни. Используйте отрицательные значения для вращения против часовой стрелки и положительные для вращения по часовой стрелке.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $angle1 Минимальный угол дальности в радианах в секунду.
     * @param float $angle2 Максимальный угол дальности в радианах в секунду.
     * @return void
     */
    function SetParticlesRotationRangeRad($ID, $angle1, $angle2)
    {
    }

    /**
     *Задает диапазон вращения в радианах, который частица может иметь в течение своей жизни. Когда частица создается, она начинается под углом 0 и выбирает случайную скорость вращения между углом 1 и углом 2. Затем частица будет вращаться с выбранной скоростью в течение всей своей жизни. Используйте отрицательные значения для вращения против часовой стрелки и положительные для вращения по часовой стрелке.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $angle1 Минимальный угол диапазона в градусах в секунду.
     * @param float $angle2 Максимальный угол диапазона в градусах в секунду.
     * @return void
     */
    function SetParticlesRotationRange($ID, $angle1, $angle2)
    {
    }

    /**
     *Устанавливает положение излучателя частиц. Это положение, из которого будут появляться новые частицы, и не влияет на частицы, которые уже видны.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x Новая координата x для излучателя в мировых координатах.
     * @param float $y Новая координата y для излучателя в мировых координатах.
     * @return void
     */
    function SetParticlesPosition($ID, $x, $y)
    {
    }

    /**
     *Устанавливает максимальное количество частиц, которые будут испускаться. Если это значение равно -1, то число бесконечно. Излучатель будет вести подсчет количества частиц, которые он испускает, и остановится, когда будет достигнут предел. Чтобы проверить, достиг ли излучатель своего предела, используйте GetParticlesMaxReached. Чтобы сбросить счетчик и заставить его снова начать излучать, используйте ResetParticleCount.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $max Максимальное количество испускаемых частиц
     * @return void
     */
    function SetParticlesMax($ID, $max)
    {
    }

    /**
     *Задает время жизни частиц после их испускания в секундах. После того, как частицы будут живы в течение заданного количества секунд, они исчезнут. Это одно из двух значений, влияющих на количество генерируемых частиц, другое-SetParticlesFrequency. Максимальное количество частиц, которое может быть на экране в любой момент времени, - это freq*life, причем freq-это количество частиц, испускаемых в секунду. Это значение не зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время в секундах, в течение которого частица видна.
     * @return void
     */
    function SetParticlesLife($ID, $time)
    {
    }

    /**
     *Устанавливает изображение, которое будет использоваться для каждой частицы. Начиная с 1083 изображений, которые могут быть загружены из субизображений, содержащихся в текстурах атласа.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $imageID Идентификатор изображения, используемого для испускаемых частиц.
     * @return void
     */
    function SetParticlesImage($ID, $imageID)
    {
    }

    /**
     *Задает частоту генерации новых частиц. Значение freq указывает, сколько частиц должно быть произведено в секунду, это не зависит от частоты кадров. Это одно из двух значений, влияющих на количество генерируемых частиц, другое-SetParticlesLife. Максимальное количество частиц, которое может быть на экране в любой момент времени, - это freq*life, причем жизнь-это количество секунд, в течение которых частица живет, прежде чем исчезнуть. Это значение не зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $freq Скорость образования новых частиц в частицах в секунду.
     * @return void
     */
    function SetParticlesFrequency($ID, $freq)
    {
    }

    /**
     *Позволяет частицам вращаться в том направлении, в котором они движутся. Это переопределяет любое использование SetParticlesRotationRange для изменения скорости вращения частиц. Вместо этого частицы всегда будут вращаться лицом к направлению своего движения.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $mode 1, чтобы заставить частицы вращаться в том направлении, в котором они движутся, 0, чтобы использовать нормальное вращение.
     * @return void
     */
    function SetParticlesFaceDirection($ID, $mode)
    {
    }

    /**
     *Задает начальное направление новых частиц, когда они выходят из излучателя. Это можно использовать вместе с командой SetParticlesAngle, чтобы установить диапазон изменения от этого начального направления, которое могут выбрать новые частицы. Это также устанавливает начальную скорость частиц, принимая длину вектора за единицы в секунду. Например, если начальное направление vx=10, vy=-15, частицы начнут двигаться вправо со скоростью 10 единиц в секунду и вверх со скоростью 15 единиц в секунду и будут продолжать эту скорость движения в течение всей своей жизни, если на них не будут влиять силы, добавленные с помощью AddParticlesForce.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $vx Направление x, в котором частицы будут двигаться изначально.
     * @param float $vy Направление y, в котором частицы будут двигаться изначально.
     * @return void
     */
    function SetParticlesDirection($ID, $vx, $vy)
    {
    }

    /**
     *Задает глубину излучателя частиц. Это касается всех частиц, даже тех, которые уже видны. Все частицы рисуются на той же глубине, что и излучатель, так что AGK может сгруппировать их в один вызов рисования для более быстрого рисования. Глубина должна быть между 0 и 10000, причем 0-это передняя часть экрана.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $depth Новое значение глубины частиц.
     * @return void
     */
    function SetParticlesDepth($ID, $depth)
    {
    }

    /**
     *Устанавливает режим интерполяции для изменения цвета. Цвета могут быть установлены в определенные моменты жизни частицы с помощью AddParticlesColorKeyFrame, и частица либо смешается между этими цветами, либо быстро изменится, когда достигнет следующего изменения цвета.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $mode 1=плавная интерполяция, 0=отсутствие интерполяции
     * @return void
     */
    function SetParticlesColorInterpolation($ID, $mode)
    {
    }

    /**
     *Задает диапазон направления в радианах, который частица может выбрать при первом запуске. Это берет базовое направление, заданное с помощью SetParticlesDirection, и регулирует его на случайную величину от 0 до угла/2 радиана. Например, угол 0 будет означать, что все новые частицы следуют точно в указанном ранее направлении. Угол 2*PI будет означать, что частицы могут появиться, двигаясь в любом направлении, а угол PI/2 будет означать, что частицы будут двигаться наружу в конусе радианов PI/2 от их начального положения с центром конуса в данном направлении.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $angle Диапазон изменения, который частица может выбрать из направления излучателя.
     * @return void
     */
    function SetParticlesAngleRad($ID, $angle)
    {
    }

    /**
     *Задает диапазон направления в градусах, который частица может выбрать при первом запуске. Это берет базовое направление, заданное с помощью SetParticlesDirection, и регулирует его на случайную величину между 0 и углом/2 градуса. Например, угол 0 будет означать, что все новые частицы следуют точно в указанном ранее направлении. Угол 360 будет означать, что частицы могут появиться, двигаясь в любом направлении, а угол 90 будет означать, что частицы будут двигаться наружу в конусе 90 градусов от их начального положения с центром конуса в данном направлении.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $angle Диапазон изменения, который частица может выбрать из направления излучателя.
     * @return void
     */
    function SetParticlesAngle($ID, $angle)
    {
    }

    /**
     *Устанавливает, обновляются ли испускаемые частицы каждый кадр. Установите значение 1, чтобы обновить частицы как обычно, и 0, чтобы приостановить их. Частицы будут продолжать быть видимыми, когда остановятся. Чтобы скрыть частицы, используйте SetParticlesVisible.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $active 1=нормально, 0=пауза
     * @return void
     */
    function SetParticlesActive($ID, $active)
    {
    }

    /**
     *Устанавливает, в какую ориентацию AGK позволит вращаться приложению. Есть две портретные и две пейзажные ориентации, одна для правильного пути вверх, а другая для перевернутого. На платформах, которые не могут вращаться, таких как Windows или Mac, эта команда не имеет никакого эффекта, и приложение всегда будет нарисовано правильно. Значение 1 для каждой ориентации будет определять, будет ли приложение вращаться, когда устройство удерживается в этой ориентации. Значение 0 сохранит приложение в его последней допустимой ориентации. Обратите внимание, что если устройство в данный момент находится в запрещенной ориентации, то AGK попытается повернуть устройство в разрешенную ориентацию, однако это не гарантируется немедленно. Так, например, если вам нужно, чтобы устройство находилось в ландшафтном режиме, и вы вызываете эту команду с разрешенным только ландшафтным режимом, вам следует дождаться, пока GetDeviceWidth вернет больше, чем GetDeviceHeight, что будет сигнализировать о том, что устройство теперь находится в ландшафтном режиме.
     *
     * @param int $portrait Ориентация устройства по умолчанию.
     * @param int $portrait2 Перевернутая портретная ориентация.
     * @param int $landscape Альбомная ориентация при повороте устройства влево от его положения по умолчанию.
     * @param int $landscape2 Альбомная ориентация при повороте устройства вправо от его положения по умолчанию.
     * @return void
     */
    function SetOrientationAllowed($portrait, $portrait2, $landscape, $landscape2)
    {
    }

    /**
     *Устанавливает, является ли этот объект видимым или нет. Он по-прежнему будет участвовать в столкновениях и других невизуальных взаимодействиях.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 1, чтобы сделать этот объект видимым, 0, чтобы скрыть его.
     * @return void
     */
    function SetObjectVisible($objID, $mode)
    {
    }

    /**
     *Изменяет все сетки в объекте для использования указанного УФ-масштаба, см. SetObjectMeshUVScale для получения дополнительной информации.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $textureStage Текстурная стадия UVS для модификации находится в диапазоне от 0 до 7
     * @param float $scaleU Шкала, используемая в направлении U, по умолчанию равна 1
     * @param float $scaleV Шкала, используемая в направлении V, по умолчанию равна 1
     * @return void
     */
    function SetObjectUVScale($objID, $textureStage, $scaleU, $scaleV)
    {
    }

    /**
     *Изменяет все сетки в объекте для использования указанного смещения UV, дополнительные сведения см. в разделе SetObjectMeshUVOffset.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $textureStage Текстурная стадия UVS для модификации находится в диапазоне от 0 до 7
     * @param float $offsetU Смещение, используемое в направлении U, по умолчанию равно 0
     * @param float $offsetV Смещение, используемое в направлении V, по умолчанию равно 0
     * @return void
     */
    function SetObjectUVOffset($objID, $textureStage, $offsetU, $offsetV)
    {
    }

    /**
     *Устанавливает режим прозрачности для этого объекта, 0-непрозрачный, 1-альфа-смешанный, 2-аддитивный смешанный, 3-пользовательский смешанный. Использование значения прозрачности больше 0 замедлит рендеринг, он также не записывает прозрачные объекты в Z-буфер, поэтому может вызвать некоторые проблемы с упорядочением глубины. Существует альтернативная форма прозрачности, называемая альфа-маскировкой, которая полезна, если вам нужны только полностью прозрачные или полностью непрозрачные пиксели, но нет смешивания между ними. Более подробную информацию см. в разделе SetObjectAlphaMask. При использовании режима 3 (custom) значения смешивания должны быть заданы с помощью SetObjectBlendModes, иначе объект не будет прозрачным.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode Режим прозрачности, используемый для этого объекта.
     * @return void
     */
    function SetObjectTransparency($objID, $mode)
    {
    }

    /**
     *Устанавливает форму столкновения объектов в статическую треугольную сетку на основе размера объекта. Объект становится статическим объектом треугольная сетчатая форма не может быть динамической. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function SetObjectShapeStaticPolygon($objID)
    {
    }

    /**
     *Задает форму столкновения в виде сферы в зависимости от размера объекта. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function SetObjectShapeSphere($objID)
    {
    }

    /**
     *Задает форму столкновения в виде сферы в зависимости от размера объекта. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @param float $diameter размер сферы
     * @return void
     */
    function SetObjectShapeSphere($objID, $diameter)
    {
    }

    /**
     *Задает форму столкновения в виде цилиндра в зависимости от размера объекта. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 =Ось X, 1 =ось Y, 2 = ориентация оси Z
     * @return void
     */
    function SetObjectShapeCylinder($objID, $axis)
    {
    }

    /**
     *Задает форму столкновения в виде цилиндра в зависимости от размера объекта. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 =Ось X, 1 =ось Y, 2 = ориентация оси Z
     * @param float $height высота по оси y
     * @param float $diameter диаметр на x и z
     * @return void
     */
    function SetObjectShapeCylinder($objID, $axis, $height, $diameter)
    {
    }

    /**
     *Устанавливает форму столкновения объектов на выпуклую оболочку в зависимости от размера объекта. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function SetObjectShapeConvexHull($objID)
    {
    }

    /**
     *Устанавливает форму столкновения в виде конуса на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена. Возвращает идентификатор фигуры.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 =Ось X, 1 =ось Y, 2 = ориентация оси Z
     * @param float $height высота по оси y
     * @param float $diameter диаметр на x и z
     * @return void
     */
    function SetObjectShapeCone($objID, $axis, $height, $diameter)
    {
    }

    /**
     *Устанавливает форму столкновения в виде конуса на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена. Возвращает идентификатор фигуры.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 =Ось X, 1 =ось Y, 2 = ориентация оси Z
     * @return void
     */
    function SetObjectShapeCone($objID, $axis)
    {
    }

    /**
     *Устанавливает форму столкновения объектов в составную форму, готовую к добавлению новых фигур. Объект должен быть динамическим.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function SetObjectShapeCompound($objID)
    {
    }

    /**
     *Устанавливает форму столкновения в капсулу на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 =Ось X, 1 =ось Y, 2 = ориентация оси Z
     * @param float $sizeX размер по оси x
     * @param float $sizeY размер по оси Y
     * @param float $sizeZ размер по оси Z
     * @return void
     */
    function SetObjectShapeCapsule($objID, $axis, $sizeX, $sizeY, $sizeZ)
    {
    }

    /**
     *Устанавливает форму столкновения в капсулу на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 =Ось X, 1 =ось Y, 2 = ориентация оси Z
     * @return void
     */
    function SetObjectShapeCapsule($objID, $axis)
    {
    }

    /**
     *Устанавливает форму столкновения в капсулу на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 =Ось X, 1 =ось Y, 2 = ориентация оси Z
     * @param int $vectorID Идентификатор вектора измерения.
     * @return void
     */
    function SetObjectShapeCapsule($objID, $axis, $vectorID)
    {
    }

    /**
     *Устанавливает форму столкновения в поле на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @param float $sizeX размер по оси x
     * @param float $sizeY размер по оси Y
     * @param float $sizeZ размер по оси Z
     * @return void
     */
    function SetObjectShapeBox($objID, $sizeX, $sizeY, $sizeZ)
    {
    }

    /**
     *Устанавливает форму столкновения в поле на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @param int $vectorID Идентификатор вектора измерения
     * @return void
     */
    function SetObjectShapeBox($objID, $vectorID)
    {
    }

    /**
     *Устанавливает форму столкновения в поле на основе переданного размера. Сначала вы должны создать физическое тело для объекта, иначе эта команда не будет выполнена.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function SetObjectShapeBox($objID)
    {
    }

    /**
     *Останавливает объект, устанавливающий заданное имя константы в его шейдерах, и с этого момента использует значение шейдера по умолчанию.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param string $szName Имя константы, чтобы перестать меняться.
     * @return void
     */
    function SetObjectShaderConstantDefault($objID, $szName)
    {
    }

    /**
     *Задает константу шейдера для объекта по имени, константа должна быть помечена как "однородная" в источнике шейдера. Объект установит указанную константу в это значение для любого шейдера, к которому он будет применен. Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4 значения и отбрасывает все, которые не используются именованной переменной.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param string $szName Имя изменяемой константы, как определено в исходном файле шейдера.
     * @param float $value1 Компонент X или R нового значения, это значение всегда будет использоваться.
     * @param float $value2 Компонент Y или G нового значения, если константа использует только 1 компонент, это значение отбрасывается.
     * @param float $value3 Компонент Z или B нового значения, если константа использует только 2 компонента, это значение отбрасывается.
     * @param float $value4 W или компонент нового значения, если константа использует только 3 компонента, это значение отбрасывается.
     * @return void
     */
    function SetObjectShaderConstantByName($objID, $szName, $value1, $value2, $value3, $value4)
    {
    }

    /**
     *Задает константу шейдера для объекта по имени, константа должна быть помечена как "однородная" в источнике шейдера. Объект установит указанную константу в это значение для любого шейдера, к которому он будет применен. Индексы массива начинаются с 0, если индекс массива находится за пределами границ, то он будет проигнорирован и никакие изменения не будут внесены. Все значения шейдера имеют от 1 до 4 компонентов, эта команда принимает 4 значения и отбрасывает все, которые не используются именованной переменной.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param string $szName Имя изменяемой константы, как определено в исходном файле шейдера.
     * @param int $arrayIndex Индекс элемента в массиве для изменения.
     * @param float $value1 Компонент X или R нового значения, это значение всегда будет использоваться.
     * @param float $value2 Компонент Y или G нового значения, если константа использует только 1 компонент, это значение отбрасывается.
     * @param float $value3 Компонент Z или B нового значения, если константа использует только 2 компонента, это значение отбрасывается.
     * @param float $value4 W или компонент нового значения, если константа использует только 3 компонента, это значение отбрасывается.
     * @return void
     */
    function SetObjectShaderConstantArrayByName($objID, $szName, $arrayIndex, $value1, $value2, $value3, $value4)
    {
    }

    /**
     *Устанавливает шейдер, используемый для рисования сеток в этом объекте, каждая сетка может иметь свой собственный набор шейдеров с помощью SetObjectMeshShader, эта команда устанавливает все сетки в этом объекте для использования указанного шейдера. Шейдер, должно быть, был загружен LoadShader. Шейдер похож на сценарий, отправленный в графический процессор, чтобы рассказать ему, как объединить полигональные и текстурные данные для отображения их на экране. По умолчанию сеткам присваивается внутренний шейдер, который будет обрабатывать освещение и текстурирование. Если вы используете идентификатор шейдера 0, сеткам присваивается внутренний шейдер.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $shaderID Идентификатор используемого шейдера.
     * @return void
     */
    function SetObjectShader($objID, $shaderID)
    {
    }

    /**
     *Устанавливает, будет ли объект отбракован при его перемещении за пределы экрана. По умолчанию AGK попытается определить, когда объект переместился за пределы экрана, и объекты, которые больше не находятся на экране, больше не будут отправляться в конвейер рендеринга. Если вершинный шейдер изменяет вершины из их нормальных положений, то это должно быть отключено, так как AGK не может заранее знать, где будет нарисован объект.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 0 для отключения отбраковки экрана, 1 для его включения (по умолчанию).
     * @return void
     */
    function SetObjectScreenCulling($objID, $mode)
    {
    }

    /**
     *Изменяет размер объекта в направлениях X, Y и Z. Это изменяет вершины объекта, что делает это постоянное изменение более медленным, чем SetObjectScale. Эта команда не считывает и не влияет на значения,заданные с помощью SetObjectScale,поэтому использование SetObjectScale(ID,2, 2, 2), а затем установка постоянного масштаба 3,3,3 все равно нарисует объект в 2 раза больше обычного, что означает в 6 раз больше, чем при запуске. Эта команда не влияет ни на какие дочерние объекты, которые могли быть загружены вместе с ней, ни на какие объекты, прикрепленные к ней с помощью FixObjectToObject. Эта команда будет работать с костяными анимированными объектами до тех пор, пока масштаб однороден, то есть значения шкалы X, Y и Z одинаковы.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $x Величина для масштабирования объекта по оси X.
     * @param float $y Величина для масштабирования объекта по оси Y.
     * @param float $z Величина для масштабирования объекта по оси Z.
     * @return void
     */
    function SetObjectScalePermanent($objID, $x, $y, $z)
    {
    }

    /**
     *Изменяет размер объекта в направлениях X, Y и Z. Значение масштаба 1,1,1 возвращает объект к его первоначальному размеру, значение масштаба 2 делает объект вдвое больше, 0,5 - вдвое меньше и так далее. Эта команда не складывается, поэтому вызов ее дважды со значением 2 не сделает ее в 4 раза больше, она останется в 2 раза больше. Обратите внимание, что использование различных значений для направлений X, Y и Z, таких как so 1,2,1, называется неоднородной шкалой, в то время как 1.5,1.5,1.5 будет однородной шкалой. Неравномерное масштабирование требует, чтобы любой шейдер, используемый этим объектом, использовал матрицу agk_WorldNormal для любых нормальных преобразований, чтобы выглядеть правильно. Если этот объект был загружен командой LoadObjectWithChildren и имеет дочерние объекты или имеет объекты, прикрепленные к нему с помощью FixObjectToObject, то они также будут масштабироваться на эту величину в дополнение к их собственному масштабированию. Обратите внимание, что это не будет корректно работать с костяными анимированными объектами, вместо этого используйте SetObjectScalePermanent.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $x Величина для масштабирования объекта по оси X.
     * @param float $y Величина для масштабирования объекта по оси Y.
     * @param float $z Величина для масштабирования объекта по оси Z.
     * @return void
     */
    function SetObjectScale($objID, $x, $y, $z)
    {
    }

    /**
     *Задает вращение указанного объекта с помощью кватерниона. В качестве альтернативы вы можете использовать SetObjectRotation для использования углов Эйлера. По умолчанию объекты создаются с кватернионом 1,0,0,0 в порядке w,x,y,z. Кватернион-это 4-мерное представление трехмерного вращения со свойством w^2+x^2+y^2+z^2 = 1, которое позволяет легко интерполировать между двумя вращениями путем линейной интерполяции двух кватернионов и их нормализации. Каждое 3D-вращение представлено ровно 2 кватернионами, w,x,y,z и -w,-x,-y,-z, поэтому любая версия может быть возвращена командами GetObjectQuat. Кватернионы и углы Эйлера могут использоваться одновременно. Например, установка вращения кватерниона будет генерировать эквивалентные значения Эйлера, которые могут быть получены с помощью GetObjectAngleX, GetObjectAngleX и GetObjectAngleZ.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $w W-компонент кватерниона.
     * @param float $x X-компонент кватерниона.
     * @param float $y Y-компонент кватерниона.
     * @param float $z Z-компонент кватерниона.
     * @return void
     */
    function SetObjectRotationQuat($objID, $w, $x, $y, $z)
    {
    }

    /**
     *Задает поворот указанного объекта с помощью углов Эйлера в градусах. В качестве альтернативы вы можете использовать SetObjectRotationQuat для использования кватерниона. По умолчанию объекты создаются с углами 0,0,0 в порядке YXZ. Углы Эйлера-это составные углы, где объект начинается с 0,0,0 и затем поворачивается на заданный угол Y, затем на заданный угол X, а затем катится на заданный угол Z. Каждое 3D-вращение может быть представлено 2 комбинациями углов Эйлера, Y,X,Z и Y-180,X-180,Z-180, поэтому любая версия может быть возвращена командами GetObjectAngle. Кватернионы и углы Эйлера могут использоваться одновременно. Например, установка вращения кватерниона будет генерировать эквивалентные значения Эйлера, которые могут быть получены с помощью GetObjectAngleX, GetObjectAngleX и GetObjectAngleZ.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $angx X-компонент вращения Эйлера.
     * @param float $angy Y-компонент вращения Эйлера.
     * @param float $angz Z-компонент вращения Эйлера.
     * @return void
     */
    function SetObjectRotation($objID, $angx, $angy, $angz)
    {
    }

    /**
     *Задает объект для получения теней от других объектов. По умолчанию это значение равно 1. Объект может быть настроен как на отбрасывание, так и на получение теней.
     *
     * @param int $objID Идентификатор объекта для получения теней
     * @param int $mode 1, чтобы заставить этот объект получать тени, 0, чтобы остановить его получение теней
     * @return void
     */
    function SetObjectReceiveShadow($objID, $mode)
    {
    }

    /**
     *Задает положение указанного объекта. По умолчанию объекты располагаются на уровне 0,0,0
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $x X-компонент позиции.
     * @param float $y Y-компонент позиции.
     * @param float $z Z-компонент позиции.
     * @return void
     */
    function SetObjectPosition($objID, $x, $y, $z)
    {
    }

    /**
     *Масштабирует нормальные координаты карты UV на заданную величину. Это не влияет ни на какую другую текстуру, но накладывается поверх УФ-смещения и масштаба объекта. Значение масштаба 1.0 будет использовать немодифицированный UVS, значение масштаба 2.0 удвоит значение UV и так далее.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $scaleU Сумма для масштабирования карты нормалей в направлении U
     * @param float $scaleV Величина для масштабирования карты нормалей в направлении V
     * @return void
     */
    function SetObjectNormalMapScale($objID, $scaleU, $scaleV)
    {
    }

    /**
     *Устанавливает все сетки в этом объекте для использования указанного изображения в качестве карты нормалей. Вы можете установить нормальную карту для одной сетки с помощью SetObjectMeshNormalMap. Нормальная карта будет помещена в текстурную стадию 2, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который сочетает ее с любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете свой собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму карту нормалей, так как AGK не будет изменять ваш шейдер таким образом. Нормальная карта будет использовать второй набор УФ-координат, если таковой имеется, в противном случае она будет использовать те же УФ-координаты, что и базовая текстура. Если есть также изображение на стадии текстуры 1 (например, световая карта), то нормальная карта всегда будет использовать базовый UVS.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $imageID Идентификатор изображения, которое будет использоваться в качестве обычной карты.
     * @return void
     */
    function SetObjectNormalMap($objID, $imageID)
    {
    }

    /**
     *Изменяет UVS сетки, чтобы масштабировать их на заданную величину. Это может вытолкнуть УФ-координаты за пределы диапазона от 0.0 до 1.0, и в этом случае режим обертывания изображения будет использоваться либо для зажима, либо для повторения текстуры. Используйте SetImageWrapU и SetImageWrapV для установки режима обертывания. Значение масштаба 1 оставит UV-координаты со значениями по умолчанию, в то время как значение масштаба 2.0 удвоит количество раз, когда текстура появляется на сетке (при условии, что режим обертывания установлен на повторение). Обратите внимание, что изображение должно быть размером в 2 степени, чтобы использовать режим повтора.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения.
     * @param int $textureStage Текстурная стадия UVS для модификации находится в диапазоне от 0 до 7
     * @param float $scaleU Шкала, используемая в направлении U, по умолчанию равна 1
     * @param float $scaleV Шкала, используемая в направлении V, по умолчанию равна 1
     * @return void
     */
    function SetObjectMeshUVScale($objID, $meshIndex, $textureStage, $scaleU, $scaleV)
    {
    }

    /**
     *Устанавливает, является ли эта сетка объектов видимой или нет.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для проверки, первая сетка находится в индексе 1.
     * @param int $mode 1, чтобы установить эту сетку объектов как видимую, 0, чтобы скрыть ее.
     * @return void
     */
    function SetObjectMeshVisible($objID, $meshIndex, $mode)
    {
    }

    /**
     *Изменяет UVS сетки, чтобы сдвинуть их на заданное смещение. Это может вытолкнуть УФ-координаты за пределы диапазона от 0.0 до 1.0, и в этом случае режим переноса изображения будет использоваться либо для зажима, либо для повторения текстуры. Используйте SetImageWrapU и SetImageWrapV для установки режима обертывания. Обратите внимание, что изображение должно быть размером в 2 степени, чтобы использовать режим повтора.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения.
     * @param int $textureStage Текстурная стадия UVS для модификации находится в диапазоне от 0 до 7
     * @param float $offsetU Смещение, используемое в направлении U, по умолчанию равно 0
     * @param float $offsetV Смещение, используемое в направлении V, по умолчанию равно 0
     * @return void
     */
    function SetObjectMeshUVOffset($objID, $meshIndex, $textureStage, $offsetU, $offsetV)
    {
    }

    /**
     *Устанавливает шейдер, используемый для рисования этой сетки, шейдер должен быть загружен LoadShader. Шейдер похож на сценарий, отправленный в графический процессор, чтобы рассказать ему, как объединить полигональные и текстурные данные для отображения их на экране. По умолчанию сеткам присваивается внутренний шейдер, который будет обрабатывать освещение и текстурирование. Если вы используете идентификатор шейдера 0, сетке присваивается внутренний шейдер. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения, первая сетка находится в индексе 1.
     * @param int $shaderID Идентификатор используемого шейдера.
     * @return void
     */
    function SetObjectMeshShader($objID, $meshIndex, $shaderID)
    {
    }

    /**
     *Масштабирует нормальные координаты карты UV на заданную величину. Это не влияет ни на какую другую текстуру, но накладывается поверх УФ-смещения и масштаба объекта. Значение масштаба 1.0 будет использовать немодифицированный UVS, значение масштаба 2.0 удвоит значение UV и так далее.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения, первая сетка находится в индексе 1.
     * @param float $scaleU Сумма для масштабирования карты нормалей в направлении U
     * @param float $scaleV Величина для масштабирования карты нормалей в направлении V
     * @return void
     */
    function SetObjectMeshNormalMapScale($objID, $meshIndex, $scaleU, $scaleV)
    {
    }

    /**
     *Устанавливает сетку объекта для использования указанного изображения в качестве карты нормалей. Нормальная карта будет помещена в текстурную стадию 2, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который сочетает ее с любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете свой собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму карту нормалей, так как AGK не будет изменять ваш шейдер таким образом. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения, первая сетка находится в индексе 1.
     * @param int $imageID Идентификатор изображения, которое будет использоваться в качестве обычной карты.
     * @return void
     */
    function SetObjectMeshNormalMap($objID, $meshIndex, $imageID)
    {
    }

    /**
     *Устанавливает сетку объекта для использования указанного изображения в качестве световой карты. Световая карта будет помещена в текстурную стадию 1, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который объединит ее с текстурной стадией 0 и любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете свой собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму световую карту, так как AGK не будет изменять ваш шейдер таким образом. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения, первая сетка находится в индексе 1.
     * @param int $imageID Идентификатор изображения, которое будет использоваться в качестве световой карты.
     * @return void
     */
    function SetObjectMeshLightMap($objID, $meshIndex, $imageID)
    {
    }

    /**
     *Устанавливает сетку объекта для использования этого изображения при рендеринге. Сетка может иметь до 8 изображений, назначенных ей на этапах текстуры от 0 до 7. Если вы не уверены, какой этап текстуры использовать, поместите изображение в этап 0. Стадии текстуры можно использовать для назначения нескольких изображений сетке, например, вы можете поместить базовую (диффузную) текстуру в стадию 0, нормальную карту в стадию 1 и световую карту в стадию 2. Шейдер, используемый для рисования этого объекта, может затем объединить различные текстуры в пиксельное значение для отображения на экране. Использование значения изображения 0 для определенного этапа текстуры удаляет любое назначенное изображение с этого этапа. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения, первая сетка находится в индексе 1.
     * @param int $imageID Идентификатор изображения, назначаемого этому объекту.
     * @param int $textureStage Этап текстуры, используемый для этого изображения.
     * @return void
     */
    function SetObjectMeshImage($objID, $meshIndex, $imageID, $textureStage)
    {
    }

    /**
     *Изменяет сетку объекта на основе предоставленного memblock. Мемблок не обязательно должен иметь такое же количество атрибутов или вершин, как исходная сетка, но он улучшит производительность, если это произойдет. Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда должен быть кратен 4 по соображениям выравнивания, сама строка может иметь немного меньше символов, но всегда округляется до ближайшего кратного 4 для значения длины строки. например, строка длины 5 должна иметь значение длины строки 8. Обратите внимание, что строка из 4 символов имеет нулевой терминатор на конце, что делает ее длиной 5, поэтому, даже если она уже имеет кратное 4 символам значение длины, она должна использовать значение длины 8 из-за нулевого терминатора. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник. Если вы планируете регулярно вносить изменения в сетку, вы должны сохранить memblock после использования SetObjectMeshFromMemblock вместо того, чтобы регенерировать его из объекта каждый раз, когда вы хотите внести изменения. Затем снова вызовите SetObjectMeshFromMemblock, когда вы хотите перенести свои новые изменения на объект.
     *
     * @param int $objID Идентификатор объекта для изменения
     * @param int $meshIndex Индекс сетки для изменения
     * @param int $memID Индекс memblock, используемый для изменения сетки
     * @return void
     */
    function SetObjectMeshFromMemblock($objID, $meshIndex, $memID)
    {
    }

    /**
     *Включает или выключает обнаружение столкновений для одной сетки в объекте.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $meshIndex Индекс сетки для изменения режима Коллисона, первая сетка находится в индексе 1.
     * @param int $mode 0, чтобы выключить столкновение, 1, чтобы включить его.
     * @return void
     */
    function SetObjectMeshCollisionMode($objID, $meshIndex, $mode)
    {
    }

    /**
     *Вращает объект, чтобы посмотреть на определенную точку в пространстве с дополнительным значением крена. "смотреть" определяется как выравнивание локальной оси Z объекта, чтобы указать его положительную сторону в данной точке. Это может быть достигнуто с помощью только углов Y и X в эйлеровой нотации, поэтому вы можете указать дополнительный угол Z в градусах, чтобы перевернуть объект слева направо, всегда глядя на одно и то же место.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $x X-компонент позиции, на которую нужно смотреть.
     * @param float $y Y-компонент позиции, на которую нужно смотреть.
     * @param float $z Z-компонент позиции, на которую нужно смотреть.
     * @param float $roll Угол Z для поворота объекта при взгляде на заданное положение отрицательный-по часовой стрелке.
     * @return void
     */
    function SetObjectLookAt($objID, $x, $y, $z, $roll)
    {
    }

    /**
     *Включает или выключает освещение при рисовании этого объекта.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 0 для выключения освещения, 1 для его включения.
     * @return void
     */
    function SetObjectLightMode($objID, $mode)
    {
    }

    /**
     *Устанавливает все сетки в этом объекте для использования этого изображения при рендеринге. Вы можете установить текстуры отдельно для каждой сетки с помощью SetObjectMeshImage. Каждая сетка может иметь до 8 изображений, назначенных ей на этапах текстуры от 0 до 7. Если вы не уверены, какой этап текстуры использовать, поместите изображение в этап 0. Стадии текстуры можно использовать для назначения нескольких изображений сетке, например, вы можете поместить базовую (диффузную) текстуру в стадию 0, нормальную карту в стадию 1 и световую карту в стадию 2. Шейдер, используемый для рисования этого объекта, может затем объединить различные текстуры в пиксельное значение для отображения на экране. Использование значения изображения 0 для определенного этапа текстуры удаляет любое назначенное изображение с этого этапа.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $imageID Идентификатор изображения, назначаемого этому объекту.
     * @param int $texStage Этап текстуры, используемый для этого изображения.
     * @return void
     */
    function SetObjectImage($objID, $imageID, $texStage)
    {
    }

    /**
     *Устанавливает все сетки в этом объекте для использования указанного изображения в качестве световой карты. Вы можете установить световую карту для одной сетки с помощью SetObjectMeshLightMap. Световая карта будет помещена в текстурную стадию 1, перезаписывая все, что уже есть, и будет сгенерирован шейдер, который объединит ее с текстурной стадией 0 и любым динамическим освещением, чтобы правильно осветить объект. Если вы устанавливаете свой собственный шейдер с помощью SetObjectShader, то ваш шейдер должен будет использовать саму световую карту, так как AGK не будет изменять ваш шейдер таким образом. Световая карта будет использовать второй набор УФ-координат, если он доступен, в противном случае она будет использовать те же УФ-координаты, что и базовая текстура.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $imageID Идентификатор изображения, которое будет использоваться в качестве световой карты.
     * @return void
     */
    function SetObjectLightMap($objID, $imageID)
    {
    }

    /**
     *Включает или выключает туман при рисовании этого объекта. По умолчанию все объекты получают туман, когда он включен с помощью SetFogMode
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 0, чтобы выключить туман, 1, чтобы включить его.
     * @return void
     */
    function SetObjectFogMode($objID, $mode)
    {
    }

    /**
     *Устанавливает режим записи глубины при рисовании этого объекта на экране. Если он проходит тест глубины, объект записывает свое значение глубины в буфер глубины, чтобы остановить что-либо еще позади от прохождения их тестов глубины. По умолчанию только объекты, которые находятся ближе (меньше) текущего значения глубины, будут перезаписывать текущее содержимое экрана. Вы можете отключить эту запись в буфер глубины для этого объекта, это может быть полезно для прозрачных объектов, которые не должны блокировать рисование позади себя. По умолчанию для всех непрозрачных объектов включена запись глубины, а для всех прозрачных объектов-выключена запись глубины.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 0, чтобы отключить списание глубины для этого объекта, 1, чтобы включить его.
     * @return void
     */
    function SetObjectDepthWrite($objID, $mode)
    {
    }

    /**
     *Устанавливает режим чтения глубины при рисовании этого объекта на экране. Объект должен пройти тест глубины, чтобы быть видимым. Доступные варианты: 0=никогда не проходите, 1=меньше, 2=равно, 3=меньше или равно, 4=больше, 5=не равно, 6=больше или равно, 7=всегда проходите. По умолчанию все объекты используют режим 1 (меньше), что означает, что они должны быть ближе, чем любые уже нарисованные объекты, чтобы быть видимыми.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode Режим глубины, используемый для этого объекта.
     * @return void
     */
    function SetObjectDepthReadMode($objID, $mode)
    {
    }

    /**
     *Устанавливает смещение глубины при рисовании этого объекта на экране. Если два объекта находятся очень близко друг к другу, один перед другим, они могут вызвать Z-бой, где они, кажется, мерцают между одним объектом и другим, отображаемым друг перед другом. Например, наклейка на поверхность другого объекта. Смещение Z предназначено для предотвращения этого мерцания, заставляя (смещая) один объект всегда находиться впереди или позади другого. Величина смещения должна быть положительной, чтобы приблизить этот объект к камере, и отрицательной, чтобы отодвинуть его назад. На самом деле это не влияет на положение объекта, только на его воспринимаемое положение, когда система рендеринга проверяет, должен ли объект быть нарисован или нет. Если объект проходит этот тест на смещенную глубину, то он рисуется в исходном положении. Значение смещения кратно наименьшему значению буфера z, поэтому рекомендуемым значением является значение смещения 1. Значения меньше этого вряд ли будут иметь какой-либо эффект, значения больше этого можно попробовать, если значение 1 не работает, попробуйте 1.5, 2.0 и т. Д.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $bias Величина смещения, равная 0, чтобы отключить смещение глубины для этого объекта.
     * @return void
     */
    function SetObjectDepthBias($objID, $bias)
    {
    }

    /**
     *Задает диапазон значений глубины, с которыми сопоставляется этот объект. По умолчанию это от 0 до 1, где 0 - ближняя плоскость, а 1-дальняя. Например, установка диапазона глубины 1,1 приведет к тому, что каждый пиксель в этом объекте будет иметь значение глубины 1 при сравнении и записи в буфер глубины. Значения будут зажаты в диапазоне от 0 до 1, объекты за пределами ближней или дальней плоскостей все равно будут обрезаны. Обратные сопоставления разрешаются установкой near больше, чем far.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $zNear Начало диапазона глубин для этого объекта
     * @param float $zFar Конец диапазона глубин для этого объекта
     * @return void
     */
    function SetObjectDepthRange($objID, $zNear, $zFar)
    {
    }

    /**
     *Задает, должен ли этот объект рисовать свои задние грани при рендеринге. Используйте режим 0=как передние, так и задние нарисованные, 1=только передние грани, 2=только задние грани. По умолчанию рисуются только лицевые грани (режим 1).
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode Режим отбраковки, используемый для этого объекта.
     * @return void
     */
    function SetObjectCullMode($objID, $mode)
    {
    }

    /**
     *Задает эмиссионный цвет, используемый при рисовании этого объекта. Значения должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать объект, а значения меньше 0 будут отнимать свет. Излучающий цвет имитирует свет, генерируемый объектом, поэтому он получит этот цвет, даже если он ничем не освещается. Это не влияет ни на какие окружающие предметы.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $red Красная составляющая цвета.
     * @param int $green Зеленая составляющая цвета.
     * @param int $blue Синяя составляющая цвета.
     * @return void
     */
    function SetObjectColorEmissive($objID, $red, $green, $blue)
    {
    }

    /**
     *Задает диффузный цвет, используемый при рисовании этого объекта. Значения должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать объект, а значения меньше 0 будут отнимать свет.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $red Красная составляющая цвета.
     * @param int $green Зеленая составляющая цвета.
     * @param int $blue Синяя составляющая цвета.
     * @param int $alpha Альфа-компонент цвета.
     * @return void
     */
    function SetObjectColor($objID, $red, $green, $blue, $alpha)
    {
    }

    /**
     *Включает или выключает обнаружение столкновений для этого объекта.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 0, чтобы выключить столкновение, 1, чтобы включить его.
     * @return void
     */
    function SetObjectCollisionMode($objID, $mode)
    {
    }

    /**
     *Задает объект для отбрасывания теней на другие объекты. По умолчанию это значение равно 0. Объект может быть настроен как на отбрасывание, так и на получение теней.
     *
     * @param int $objID Идентификатор объекта для отбрасывания теней
     * @param int $mode 1, чтобы заставить этот объект отбрасывать тени, 0, чтобы остановить его отбрасывание теней
     * @return void
     */
    function SetObjectCastShadow($objID, $mode)
    {
    }

    /**
     *Задает вращение указанной кости относительно ее родителя в виде кватерниона.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param float $w W-компонент вращения.
     * @param float $x X-составляющая вращения.
     * @param float $y Y-составляющая вращения.
     * @param float $z Z-составляющая вращения.
     * @return void
     */
    function SetObjectBoneRotationQuat($objID, $boneIndex, $w, $x, $y, $z)
    {
    }

    /**
     *Задает поворот указанной кости с помощью углов Эйлера в градусах. В качестве альтернативы вы можете использовать SetObjectBoneRotationQuat для использования кватерниона.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости для изменения
     * @param float $angx X-составляющая вращения.
     * @param float $angy Y-составляющая вращения.
     * @param float $angz Z-составляющая вращения.
     * @return void
     */
    function SetObjectBoneRotation($objID, $boneIndex, $angx, $angy, $angz)
    {
    }

    /**
     *Вращает кость, чтобы посмотреть на определенную точку в мировом пространстве с дополнительным значением крена. "смотреть" определяется как выравнивание локальной оси Z кости, чтобы указать ее положительную сторону в данной точке. Это может быть достигнуто с помощью только углов Y и X в эйлеровой нотации, поэтому вы можете указать дополнительный угол Z в градусах, чтобы катить кость слева направо, всегда глядя на одно и то же место.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param float $x X-компонент позиции, на которую нужно смотреть.
     * @param float $y Y-компонент позиции, на которую нужно смотреть.
     * @param float $z Z-компонент позиции, на которую нужно смотреть.
     * @param float $roll Угол Z для перекатывания кости при взгляде на заданное положение отрицательный-по часовой стрелке.
     * @return void
     */
    function SetObjectBoneLookAt($objID, $boneIndex, $x, $y, $z, $roll)
    {
    }

    /**
     *Устанавливает положение указанной кости относительно ее родителя.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости для изменения
     * @param float $x X-компонент позиции.
     * @param float $y Y-компонент позиции.
     * @param float $z Z-компонент позиции.
     * @return void
     */
    function SetObjectBonePosition($objID, $boneIndex, $x, $y, $z)
    {
    }

    /**
     *Задает, управляется ли указанная кость анимацией или управляется вручную. При управлении анимацией ни одна из команд SetObjectBonePosition или аналогичных команд не будет иметь никакого эффекта. При ручном управлении кость будет сохранять свое текущее положение, если вы не измените его.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param int $animate 1, чтобы позволить анимации воздействовать на эту кость, 0, чтобы разрешить ручное управление.
     * @return void
     */
    function SetObjectBoneCanAnimate($objID, $boneIndex, $animate)
    {
    }

    /**
     *Если SetObjectTransparency имеет значение 3, то исходные и целевые значения смешивания можно задать вручную с помощью этой команды. Доступны следующие режимы наложения: 0 = 0 1 = 1 2 = Исходный пиксель Альфа 3 = 1 - Исходный Пиксель Альфа 4 = Целевой Пиксель Альфа 5 = 1 - Целевой Пиксель Альфа 6 = Исходный Пиксель Цвет (действителен только для режима назначения) 7 = 1 - Исходный пиксель Цвет (действителен только для режима назначения) 8 = Целевой пиксель Цвет (действителен только для режима источника) 9 = 1 - Целевой пиксель Цвет (действителен только для режима источника) 10 = Альфа Насыщение (действителен только для режима источника) Исходный пиксель будет умножен на исходный режим, а целевой пиксель будет умножен на целевой режим. Затем они будут сложены вместе, чтобы получить окончательный цвет пикселя. Исходный пиксель-это пиксель, принадлежащий рисуемому объекту, в то время как конечный пиксель-это цвет пикселя, уже находящегося на экране, над которым рисуется текущий объект.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $src Режим наложения, используемый для источника наложения.
     * @param int $dst Режим наложения, используемый для назначения наложения.
     * @return void
     */
    function SetObjectBlendModes($objID, $src, $dst)
    {
    }

    /**
     *Устанавливает скорость анимации для данного объекта как кратную времени по умолчанию, то есть 1.0 будет использовать время из ключевых кадров анимации, 2.0 будет воспроизводить их в два раза быстрее, 0.5-в два раза медленнее и так далее. Вы также можете использовать отрицательные значения для воспроизведения анимации в обратном порядке или 0 для ее приостановки.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $speed Новая скорость анимации, используемая для этого объекта, по умолчанию 1.0
     * @return void
     */
    function SetObjectAnimationSpeed($objID, $speed)
    {
    }

    /**
     *Устанавливает положение костей объекта в соответствии с заданным временем в анимации. Только объекты, загруженные с помощью LoadObjectWithChildren, будут иметь назначенные им анимации. Имена анимаций определяются программой моделирования при создании анимаций вы можете узнать, что это за имена, используя GetObjectAnimationName. Если заданное время попадает между ключевыми кадрами, то позиции костей будут интерполированы между ними. Параметр tweentime можно использовать для интерполяции между текущими позициями костей и заданным временем анимации, чтобы не было резкого скачка в позициях костей. Обратите внимание, что как только эта команда будет вызвана, кости будут управляться анимацией и не могут быть перемещены с помощью SetObjectBonePosition или аналогичных команд. Вы можете восстановить ручное управление отдельными костями, используя SetObjectBoneCanAnimate на нем. Вы можете восстановить контроль над всей костной структурой с помощью ResetObjectAnimation.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param string $animName Название воспроизводимой анимации, определяемое программой моделирования
     * @param float $time Точка в анимации для считывания положения костей, в секундах
     * @param float $tweentime Время в секундах для перехода от текущего состояния объектов к заданному кадру
     * @return void
     */
    function SetObjectAnimationFrame($objID, $animName, $time, $tweentime)
    {
    }

    /**
     *Включает или выключает альфа-маскировку для этого объекта. Это похоже на прозрачность, но производит только полностью прозрачные или полностью непрозрачные пиксели, нет смешанных или полупрозрачных пикселей. Если пиксель имеет альфа - значение меньше 128, он будет проигнорирован, если он больше или равен 128, то он будет нарисован. Это имеет меньше проблем с упорядочением глубины, чем при использовании SetObjectTransparency, но в некоторых случаях может быть немного медленнее. Вы не должны использовать как прозрачность, так и альфа-маскировку на одном и том же объекте одновременно, используйте только одну или другую.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $mode 1=использовать альфа-маскировку, 0=отключить альфа-маскировку.
     * @return void
     */
    function SetObjectAlphaMask($objID, $mode)
    {
    }

    /**
     *Устанавливает пороги спящего режима 3d-физики для объекта.
     *
     * @param int $objID идентификатор объекта
     * @param float $angular угловая скорость
     * @param float $linear линейная скорость
     * @return void
     */
    function SetObject3DPhysicsSleepingThreshold($objID, $angular, $linear)
    {
    }

    /**
     *Задает значение альфа-сигнала, которое будет использоваться при рисовании этого объекта. Это то же самое альфа-значение, которое можно установить в SetObjectColor. Значения должны находиться в диапазоне 0-255, но не ограничиваться им.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param int $alpha Альфа-компонент цвета.
     * @return void
     */
    function SetObjectAlpha($objID, $alpha)
    {
    }

    /**
     *Это установит максимальную линейную скорость для динамического объекта. Это предотвратит движение объектов слишком быстро, чтобы их можно было увидеть на экране.
     *
     * @param int $objID идентификатор объекта
     * @param float $maxLinearVelocity максимальная скорость, которую может достичь объект.
     * @return void
     */
    function SetObject3DPhysicsMaxLinearVelocity($objID, $maxLinearVelocity)
    {
    }

    /**
     *Это установит трение качения для статических и динамических объектов.
     *
     * @param int $objID идентификатор объекта
     * @param float $friction величина трения качения в виде поплавка
     * @return void
     */
    function SetObject3DPhysicsRollingFriction($objID, $friction)
    {
    }

    /**
     *Задает вектор линейной скорости объекта. Вектор направления автоматически нормализуется.
     *
     * @param int $objID идентификатор объекта
     * @param int $vectorID Идентификатор вектора направления
     * @param float $initialSpeed начальная скорость.
     * @return void
     */
    function SetObject3DPhysicsLinearVelocity($objID, $vectorID, $initialSpeed)
    {
    }

    /**
     *Задает вектор линейной скорости объекта. Вектор направления автоматически нормализуется.
     *
     * @param int $objID идентификатор объекта
     * @param float $dirX X компонент вектора направления
     * @param float $dirY компонент Y вектора направления
     * @param float $dirZ Z-составляющая вектора направления
     * @param float $initialSpeed начальная скорость.
     * @return void
     */
    function SetObject3DPhysicsLinearVelocity($objID, $dirX, $dirY, $dirZ, $initialSpeed)
    {
    }

    /**
     *Задает массу объекта
     *
     * @param int $objID идентификатор объекта
     * @param float $mass масса объекта
     * @return void
     */
    function SetObject3DPhysicsMass($objID, $mass)
    {
    }

    /**
     *Устанавливает группу столкновений объектов и маску. По умолчанию все физические объекты находятся в одной группе и не маскируются. Если вы используете группы столкновений и маски, вы должны использовать их для всех физических объектов в мире.
     *
     * @param int $objID идентификатор объекта
     * @param int $group группа столкновений, к которой принадлежит и этот физический объект.
     * @param int $mask группы столкновений, которые вы хотите замаскировать от столкновения.
     * @return void
     */
    function SetObject3DPhysicsGroupAndMask($objID, $group, $mask)
    {
    }

    /**
     *Это установит трение для динамических и статических объектов
     *
     * @param int $objID идентификатор объекта
     * @param float $friction значение трения в виде поплавка
     * @return void
     */
    function SetObject3DPhysicsFriction($objID, $friction)
    {
    }

    /**
     *Устанавливает линейное и угловое демпфирование для объекта
     *
     * @param int $objID идентификатор объекта
     * @param float $linearDamp Величина линейного демпфирования, приложенного к объекту.
     * @param float $angularDamp Величина углового демпфирования, приложенного к объекту.
     * @return void
     */
    function SetObject3DPhysicsDamping($objID, $linearDamp, $angularDamp)
    {
    }

    /**
     *Это позволит установить тип анизотропного трения.
     *
     * @param int $objID идентификатор объекта
     * @param int $type DISABLED = 0, FRICTION = 1, ROLLING_FRICTION = 2
     * @return void
     */
    function SetObject3DPhysicsAnisotropicFriction($objID, $type)
    {
    }

    /**
     *Устанавливает реституционное трение для объекта. Вы можете установить Реституцию для динамических и статических объектов.
     *
     * @param int $objID идентификатор объекта
     * @param float $friction Величина трения, приложенного к объекту.
     * @return void
     */
    function SetObject3DPhysicsRestitution($objID, $friction)
    {
    }

    /**
     *Устанавливает время деактивации физического объекта. Это количество времени, которое физический объект ждет, когда он придет в состояние покоя, прежде чем он станет деактивированным.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function SetObject3DPhysicsDeactivationTime($objID, $time)
    {
    }

    /**
     *Все динамические объекты автоматически переводятся в состояние покоя. Это остановит автоматическое погружение динамического объекта в спящий режим.
     *
     * @param int $objID идентификатор объекта
     * @param int $canSleep 1 = истина , 0 = ложь
     * @return void
     */
    function SetObject3DPhysicsCanSleep($objID, $canSleep)
    {
    }

    /**
     *Задает локальную целочисленную переменную для этого клиента по имени. Затем другие клиенты могут прочитать эту переменную, используя то же имя при запросе ее значения. Параметр mode указывает, как должна вести себя эта переменная, со значением 1, означающим, что эта переменная будет сброшена до 0 при чтении. Например, если вы хотите отправить уведомление о щелчке, вы можете установить значение 1, чтобы обозначить щелчок со значением режима 1. Когда каждый клиент читает переменную, каждый увидит значение 1, но если он попытается прочитать ее снова, то получит значение 0. Каждый клиент сбрасывает только свою собственную копию переменной. Значение режима 0 означает, что это нормальная переменная, которая не изменится при чтении. Если переменная с таким именем не существует, она создается. Как только переменная создается в обычном или сброшенном режиме, она не может быть изменена, и параметр mode игнорируется.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param string $name Имя этой переменной.
     * @param int $i Значение для установки этой переменной.
     * @param int $mode Тип этой переменной: 0=нормальный, 1=сброс
     * @return void
     */
    function SetNetworkLocalInteger($iNetID, $name, $i, $mode)
    {
    }

    /**
     *Задает локальную целочисленную переменную для этого клиента по имени. Затем другие клиенты могут прочитать эту переменную, используя то же имя при запросе ее значения. Параметр mode указывает, как должна вести себя эта переменная, со значением 1, означающим, что эта переменная будет сброшена до 0 при чтении. Например, если вы хотите отправить уведомление о щелчке, вы можете установить значение 1, чтобы обозначить щелчок со значением режима 1. Когда каждый клиент читает переменную, каждый увидит значение 1, но если он попытается прочитать ее снова, то получит значение 0. Каждый клиент сбрасывает только свою собственную копию переменной. Значение режима 0 означает, что это нормальная переменная, которая не изменится при чтении. Если переменная с таким именем не существует, она создается. Как только переменная создается в обычном или сброшенном режиме, она не может быть изменена, и параметр mode игнорируется.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param string $name Имя этой переменной.
     * @param int $i Значение для установки этой переменной.
     * @return void
     */
    function SetNetworkLocalInteger($iNetID, $name, $i)
    {
    }

    /**
     *Задает угловую скорость объекта. Вектор угла автоматически нормализуется.
     *
     * @param int $objID идентификатор объекта
     * @param float $angX X компонент вектора угла
     * @param float $angY компонент Y вектора угла
     * @param float $angZ Z-составляющая вектора угла
     * @param float $initialSpeed начальная скорость.
     * @return void
     */
    function SetObject3DPhysicsAngularVelocity($objID, $angX, $angY, $angZ, $initialSpeed)
    {
    }

    /**
     *Задает угловую скорость объекта. Вектор угла автоматически нормализуется.
     *
     * @param int $objID идентификатор объекта
     * @param int $vectorID Идентификатор вектора направления.
     * @param float $initialSpeed начальная скорость.
     * @return void
     */
    function SetObject3DPhysicsAngularVelocity($objID, $vectorID, $initialSpeed)
    {
    }

    /**
     *Задает локальную переменную float для этого клиента по имени. Затем другие клиенты могут прочитать эту переменную, используя то же имя при запросе ее значения. Переменная с плавающей точкой может не иметь того же имени, что и целочисленная переменная. Если переменная с таким именем не существует, она создается.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param string $name Имя этой переменной.
     * @param float $f Значение для установки этой переменной.
     * @return void
     */
    function SetNetworkLocalFloat($iNetID, $name, $f)
    {
    }

    /**
     *Задает локальную переменную float для этого клиента по имени. Затем другие клиенты могут прочитать эту переменную, используя то же имя при запросе ее значения. Переменная с плавающей точкой может не иметь того же имени, что и целочисленная переменная. Если переменная с таким именем не существует, она создается.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param string $name Имя этой переменной.
     * @param float $f Значение для установки этой переменной.
     * @param int $mode Тип этой переменной: 0=нормальный, 1=сброс
     * @return void
     */
    function SetNetworkLocalFloat($iNetID, $name, $f, $mode)
    {
    }

    /**
     *Останавливает больше клиентов от подключения к этой сети, применимо только в том случае, если вы размещаете эту сеть. Также прекращается вещание сети в локальную сеть, поэтому она больше не будет отображаться для тех приложений, которые слушают трансляции.
     *
     * @param int $iNetID Идентификатор сети для изменения.
     * @return void
     */
    function SetNetworkNoMoreClients($iNetID)
    {
    }

    /**
     *Присваивает локальное значение одному из 5 слотов данных в клиенте, которые можно использовать для отслеживания элементов, принадлежащих этому клиенту. Например, если вы создаете спрайт для представления клиента в вашей игре, вы можете назначить идентификатор спрайта одному из этих слотов данных, чтобы при просмотре списка клиентов вы могли определить, какой спрайт вы использовали для каждого клиента. Это также позволяет очистить спрайт, если обнаружится, что клиент отключился. Это значение является полностью локальным и не передается по сети.
     *
     * @param int $iNetID Идентификатор сети для хранения значения.
     * @param int $client Идентификатор клиента в сети для хранения значения.
     * @param int $index Индекс (от 0 до 4) устанавливаемого слота данных.
     * @param int $value Целочисленное значение для установки.
     * @return void
     */
    function SetNetworkClientUserData($iNetID, $client, $index, $value)
    {
    }

    /**
     *Устанавливает, как часто сеть отправляет обновления и проверяет наличие обновлений переменных от других клиентов в миллисекундах. Чем ниже это значение, тем чаще этот клиент будет отправлять и получать обновления, что означает, что общие переменные с большей вероятностью будут обновляться, но это увеличит сетевой трафик. В случае соединений через Интернет это особенно важно, так как большое количество переменных, которые часто обновляются, означает, что может не хватить пропускной способности. Значение по умолчанию составляет 15 миллисекунд, что переводится примерно в 67 обновлений каждую секунду, чтобы точно соответствовать частоте кадров игры 60 кадров в секунду. Если вы обновляете большое количество переменных через интернет-соединение, рекомендуется увеличить это значение до 50 миллисекунд, что приведет к 20 обновлениям в секунду или более.
     *
     * @param int $iNetID Идентификатор сети, от которой требуется отключиться.
     * @param int $latency Задержка использования в миллисекундах
     * @return void
     */
    function SetNetworkLatency($iNetID, $latency)
    {
    }

    /**
     *Устанавливает основную громкость для всех музыкальных файлов OGG. Это умножается на объем файла, так что если системный том установлен на 100, а объем файла установлен на 0, то файл все равно будет иметь объем 0.
     *
     * @param int $vol Основной объем для использования, от 0 до 100
     * @return void
     */
    function SetMusicSystemVolumeOGG($vol)
    {
    }

    /**
     *Перезапуск прослушивания новых клиентских подключений, применимый только в том случае, если вы размещаете сеть. Также перезапускается вещание сети в локальную сеть, так что она будет отображаться для тех приложений, которые слушают трансляции. Это нужно сделать только в том случае, если вы ранее вызывали SetNetworkNoMoreClients и теперь хотите снова разрешить соединения.
     *
     * @param int $iNetID Идентификатор сети для изменения.
     * @return void
     */
    function SetNetworkAllowClients($iNetID)
    {
    }

    /**
     *Устанавливает объем для каждого файла. По умолчанию файлы воспроизводятся на томе 100. Уровень громкости должен быть между 0 и 100.
     *
     * @param int $musicID Идентификатор музыкального файла для изменения.
     * @param int $vol Том, который будет использоваться для этого файла.
     * @return void
     */
    function SetMusicVolumeOGG($musicID, $vol)
    {
    }

    /**
     *Устанавливает основную громкость музыкального проигрывателя в диапазоне от 0 до 100.
     *
     * @param int $iVol Новое значение объема для использования.
     * @return void
     */
    function SetMusicSystemVolume($iVol)
    {
    }

    /**
     *Устанавливает время начала и окончания музыкального цикла. Когда PlayMusicOGG используется с параметром loop, он по умолчанию останавливается в конце файла и возвращается к началу файла. Эта команда изменит его на цикл, начинающийся и заканчивающийся в определенное время в музыкальном файле. Использование времени начала -1 приведет к возврату в начало файла, использование и время окончания -1 остановится в конце файла, они соответствуют поведению по умолчанию. Если время начала больше текущего времени воспроизведения, то музыкальный файл будет продолжать воспроизводиться до тех пор, пока не достигнет конечного времени, а затем вернется к выбранному времени начала.
     *
     * @param int $musicID Идентификатор музыкального файла для изменения
     * @param float $startTime Время в секундах для возврата в начало цикла
     * @param float $endTime Время в секундах, чтобы закончить цикл и вернуться к началу
     * @return void
     */
    function SetMusicLoopTimesOGG($musicID, $startTime, $endTime)
    {
    }

    /**
     *Изменяет количество циклов воспроизведения музыкального файла, может быть установлено во время его воспроизведения. Используйте значение 0 для воспроизведения до конца файла или текущего времени окончания цикла, а затем остановитесь. Значение цикла, равное 1, будет циклическим навсегда, значение, большее 1, будет циклическим для этого числа раз. Эта команда сбрасывает команду GetMusicLoopCountOGG и снова начинает отсчет с 0.
     *
     * @param int $musicID Идентификатор музыкального файла для изменения
     * @param int $loop Количество циклов, 0 для остановки цикла.
     * @return void
     */
    function SetMusicLoopCountOGG($musicID, $loop)
    {
    }

    /**
     *Устанавливает громкость на основе каждого файла, этот уровень громкости объединяется с громкостью музыкальной системы для создания окончательной громкости. По умолчанию файлы воспроизводятся на томе 100. Уровень громкости должен быть между 0 и 100.
     *
     * @param int $ID Музыкальный номер для установки.
     * @param int $vol Том, который будет использоваться для этого файла.
     * @return void
     */
    function SetMusicFileVolume($ID, $vol)
    {
    }

    /**
     *Обеспечивает быстрый способ изменения УФ-значений вершины внутри мемблока сетки. Он использует атрибутивные данные из начала мемблока для определения смещения вершин и изменения значений UV. Вершины начинаются с индекса 0.
     *
     * @param int $memID Идентификатор изменяемого мемблока
     * @param int $vertexIndex Индекс вершины для изменения
     * @param float $u Новое значение U для этой вершины
     * @param float $v Новое значение V для этой вершины
     * @return void
     */
    function SetMeshMemblockVertexUV($memID, $vertexIndex, $u, $v)
    {
    }

    /**
     *Обеспечивает быстрый способ изменения положения вершины внутри мемблока сетки. Он использует атрибутивные данные из начала мемблока для определения смещения вершины и изменения значений позиции. Вершины начинаются с индекса 0.
     *
     * @param int $memID Идентификатор изменяемого мемблока
     * @param int $vertexIndex Индекс вершины для изменения
     * @param float $x Новая позиция X для этой вершины
     * @param float $y Новая позиция Y для этой вершины
     * @param float $z Новая позиция Z для этой вершины
     * @return void
     */
    function SetMeshMemblockVertexPosition($memID, $vertexIndex, $x, $y, $z)
    {
    }

    /**
     *Обеспечивает быстрый способ изменения нормали вершины внутри мемблока сетки. Он использует атрибутивные данные из начала мемблока для определения смещения вершин и изменения нормальных значений. Вершины начинаются с индекса 0.
     *
     * @param int $memID Идентификатор изменяемого мемблока
     * @param int $vertexIndex Индекс вершины для изменения
     * @param float $x X компонент новой нормали для этой вершины
     * @param float $y Компонент Y новой нормали для этой вершины
     * @param float $z Z компонент новой нормали для этой вершины
     * @return void
     */
    function SetMeshMemblockVertexNormal($memID, $vertexIndex, $x, $y, $z)
    {
    }

    /**
     *Записывает строку в memblock в виде необработанных байтов. Первый найденный нулевой терминатор завершит строку, и один нулевой терминатор будет записан в данные memblock. Чтобы снова прочитать строку из memblock, вам нужно будет знать ее длину, поэтому рекомендуется также записать значение длины строки перед строковыми данными, чтобы помочь прочитать строку обратно позже. Смещение плюс длина строки, плюс 1 для нулевого терминатора, должно быть меньше размера memblock.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param string $value Строка для записи.
     * @return void
     */
    function SetMemblockString($memID, $offset, $value)
    {
    }

    /**
     *Записывает короткое (2 байта) значение с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 2, поскольку запись коротких значений, не выровненных по 2-байтовым границам, влечет за собой снижение производительности оборудования. Короткие значения хранятся в формате little endian, поэтому запись короткого числа 23 со смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, а байт со смещением 1 как 0. Данное значение будет усечено до диапазона -32768 и 32767.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param int $value Значение для записи.
     * @return void
     */
    function SetMemblockShort($memID, $offset, $value)
    {
    }

    /**
     *Записывает значение int (4 байта) с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку запись целочисленных значений, не выровненных по 4-байтовым границам, влечет за собой снижение производительности оборудования. Значения Int хранятся в формате little endian, поэтому запись int 23 со смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, байт со смещением 1 как 0, байт со смещением 2 как 0 и байт со смещением 3 как 0.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param int $value Значение для записи.
     * @return void
     */
    function SetMemblockInt($memID, $offset, $value)
    {
    }

    /**
     *Запишите значение float (4 байта) с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку запись значений с плавающей запятой, не выровненных по 4-байтовым границам, влечет за собой снижение производительности оборудования. Значения Float хранятся в формате IEEE 754, поэтому запись float и последующее чтение его обратно в байтах вернут различные компоненты формата float.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param float $value Значение для записи.
     * @return void
     */
    function SetMemblockFloat($memID, $offset, $value)
    {
    }

    /**
     *Обеспечивает быстрый способ изменения значений цвета вершины внутри мемблока сетки. Он использует атрибутивные данные из начала memblock для определения смещения вершин и изменения значений цвета. Вершины начинаются с индекса 0. Значения цвета должны быть в диапазоне от 0 до 255.
     *
     * @param int $memID Идентификатор изменяемого мемблока
     * @param int $vertexIndex Индекс вершины для изменения
     * @param int $red Новое красное значение для этой вершины
     * @param int $green Новое зеленое значение для этой вершины
     * @param int $blue Новое синее значение для этой вершины
     * @param int $alpha Новое альфа
     * @return void
     */
    function SetMeshMemblockVertexColor($memID, $vertexIndex, $red, $green, $blue, $alpha)
    {
    }

    /**
     *Записывает однобайтовое значение с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Данное значение будет усечено до диапазона -128 и 127.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param int $value Значение для записи.
     * @return void
     */
    function SetMemblockByteSigned($memID, $offset, $value)
    {
    }

    /**
     *Записывает однобайтовое значение с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Данное значение будет усечено до диапазона 0 и 255.
     *
     * @param int $memID Идентификатор изменяемого мемблока.
     * @param int $offset Смещение от начала мемблока для записи, между 0 и размером.
     * @param int $value Значение для записи.
     * @return void
     */
    function SetMemblockByte($memID, $offset, $value)
    {
    }

    /**
     *Создает локальное уведомление, которое появится в какой-то момент в будущем. Уведомления ссылаются на идентификатор и могут быть перезаписаны путем создания нового уведомления с тем же идентификатором, что и уведомление, которое вы хотите перезаписать. Если уведомление срабатывает во время работы приложения, то оно не появляется и бесшумно исчезает из списка запланированных уведомлений. Если приложение не открыто, то пользователю будет показано уведомление, и нажатие на него откроет ваше приложение. Если вы установите параметр deeplink, то этот URL-адрес будет отправлен в приложение при нажатии уведомления. URL-адрес можно получить с помощью команды GetURLSchemeText. Параметр datetime должен быть указан в unix time, который измеряется в секундах с 1 января 1970 года, вы можете использовать команду GetUnixTime для возврата текущей даты и времени, а затем изменить ее по мере необходимости. Если дата и время находятся в прошлом, то уведомление будет проигнорировано, оно не будет перезаписывать ни одно существующее уведомление. Идентификатор должен находиться в диапазоне от 1 до 100 включительно.
     *
     * @param int $iID Идентификатор, который будет использоваться для ссылки на это уведомление в будущем
     * @param int $datetime Дата и время отображения этого уведомления в unix time
     * @param string $szMessage Сообщение для отображения в уведомлении
     * @return void
     */
    function SetLocalNotification($iID, $datetime, $szMessage)
    {
    }

    /**
     *Создает локальное уведомление, которое появится в какой-то момент в будущем. Уведомления ссылаются на идентификатор и могут быть перезаписаны путем создания нового уведомления с тем же идентификатором, что и уведомление, которое вы хотите перезаписать. Если уведомление срабатывает во время работы приложения, то оно не появляется и бесшумно исчезает из списка запланированных уведомлений. Если приложение не открыто, то пользователю будет показано уведомление, и нажатие на него откроет ваше приложение. Если вы установите параметр deeplink, то этот URL-адрес будет отправлен в приложение при нажатии уведомления. URL-адрес можно получить с помощью команды GetURLSchemeText. Параметр datetime должен быть указан в unix time, который измеряется в секундах с 1 января 1970 года, вы можете использовать команду GetUnixTime для возврата текущей даты и времени, а затем изменить ее по мере необходимости. Если дата и время находятся в прошлом, то уведомление будет проигнорировано, оно не будет перезаписывать ни одно существующее уведомление. Идентификатор должен находиться в диапазоне от 1 до 100 включительно.
     *
     * @param int $iID Идентификатор, который будет использоваться для ссылки на это уведомление в будущем
     * @param int $datetime Дата и время отображения этого уведомления в unix time
     * @param string $szMessage Сообщение для отображения в уведомлении
     * @param string $szDeepLink URL-адрес для отправки в приложение, если уведомление прослушивается
     * @return void
     */
    function SetLocalNotification($iID, $datetime, $szMessage, $szDeepLink)
    {
    }

    /**
     *Джойстик AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания ввода в стиле джойстика в диапазоне от -1 до 1. Эта команда позиционирует виртуальный джойстик на экране только в том случае, если необходимо эмулировать этот ввод. Например, если имеется реальный джойстик или клавиатура, то эта команда не имеет заметного эффекта. Рекомендуется всегда вызывать эту команду в любом случае, если вы собираетесь использовать GetJoystickX или GetJoystickY, просто если вам нужен виртуальный джойстик. Любой виртуальный джойстик будет центрирован в заданном положении X и Y.
     *
     * @param float $x Координата X новой позиции в координатах экрана.
     * @param float $y Координата Y новой позиции в координатах экрана.
     * @param float $size Диаметр джойстика в экранных координатах.
     * @return void
     */
    function SetJoystickScreenPosition($x, $y, $size)
    {
    }

    /**
     *Устанавливает мертвую зону для универсальных джойстиков так, чтобы любое значение X или Y ниже заданного порога возвращало 0. Это значение должно быть между 0 и 1, по умолчанию оно равно 0,15.
     *
     * @param float $threshold Значение, ниже которого будет возвращено 0.
     * @return void
     */
    function SetJoystickDeadZone($threshold)
    {
    }

    /**
     *Задает целевую точку в мировых координатах, к которой мышиный сустав будет пытаться переместить прикрепленное тело. Работает только на мышиных суставах.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @param float $x Координата x новой цели.
     * @param float $y Координата y новой цели.
     * @return void
     */
    function SetJointMouseTarget($iJointIndex, $x, $y)
    {
    }

    /**
     *Устанавливает максимальное усилие, которое может быть использовано суставом мыши для перемещения объекта. По умолчанию это значение равно 0
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @param float $maxForce Максимальное усилие, чтобы позволить.
     * @return void
     */
    function SetJointMouseMaxForce($iJointIndex, $maxForce)
    {
    }

    /**
     *Включает двигатель для соединения так, чтобы оно двигалось непрерывно, пока не будет предотвращено столкновение. Работает на линейных/колесных соединениях, призматических соединениях и вращающихся соединениях. Двигатели работают, прикладывая усилие для достижения заданной скорости, и если они встречают сопротивление, то увеличивают усилие до тех пор, пока двигатель не будет двигаться с желаемой скоростью или не будет достигнута максимальная заданная сила, после чего двигатель остановится, продолжая прикладывать максимальную силу. В случае линейных соединений двигатель работает в одном направлении и либо толкает прикрепленные спрайты вместе, либо раздвигает.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @param float $speed Желаемая скорость двигателя.
     * @param float $maxForce Максимальная сила, которую он может использовать для достижения скорости.
     * @return void
     */
    function SetJointMotorOn($iJointIndex, $speed, $maxForce)
    {
    }

    /**
     *Выключает двигатель, ранее приложенный к шарниру, который его поддерживает. Работает на линейных соединениях, призматических соединениях и револьверных соединениях.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @return void
     */
    function SetJointMotorOff($iJointIndex)
    {
    }

    /**
     *Отключает ограничения для суставов, которые их поддерживают. Работает на призматических и револьверных соединениях.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @return void
     */
    function SetJointLimitOff($iJointIndex)
    {
    }

    /**
     *Демпфирование можно использовать, чтобы сделать сустав мягким, как пружина. Частота задается в герцах и обычно должна быть меньше половины частоты шага физики. Например, если fps равен 60, то частота должна быть меньше 30. Коэффициент демпфирования должен быть между 0 и 1, но может быть и больше. Это можно использовать только на дистанционных соединениях, сварных соединениях, соединениях линии/колеса и соединениях мыши. По умолчанию расстояние и сварные соединения имеют коэффициент демпфирования и частоту 0, что делает соединение жестким. По умолчанию суставы мыши имеют частоту 5 и коэффициент демпфирования 0,7. По умолчанию линейные/колесные соединения имеют частоту 2 и коэффициент демпфирования 0,7.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @param float $dampingRatio Коэффициент демпфирования для использования, как правило, находится в диапазоне от 0 до 1
     * @param float $frequency Частота колебаний, должна быть меньше половины частоты кадров
     * @return void
     */
    function SetJointDamping($iJointIndex, $dampingRatio, $frequency)
    {
    }

    /**
     *Работает на призматических и револьверных соединениях. Устанавливает предел, которого этот сустав может достичь до остановки, для вращающихся суставов это основано на углах, для других-на длине. По умолчанию сустав не имеет ограничений.
     *
     * @param int $iJointIndex Идентификатор соединения для изменения.
     * @param float $lowerLimit Наименьшая степень, до которой может дотянуться сустав.
     * @param float $upperLimit Наибольшей степени, которую может достичь сустав.
     * @return void
     */
    function SetJointLimitOn($iJointIndex, $lowerLimit, $upperLimit)
    {
    }

    /**
     *Устанавливает размер устройства, для которого вы разработали все свои произведения искусства, это позволяет AGK уменьшить размер изображений, чтобы сэкономить память на устройствах с более низким разрешением. Обратите внимание, что такие команды, как SetSpriteAnimation, которые могут предполагать размеры изображений, должны учитывать уменьшенные изображения. Например, загрузка изображения 512x512 и использование SetSpriteAnimation(spr,128,128,16) должны вместо этого использовать SetSpriteAnimation(spr,GetImageWidth(img)/4,GetImageHeight(img)/4,16) в случае, если изображение больше не имеет размера 512. Эта команда устарела, и вы должны использовать LoadImageResized для настройки размеров изображений в зависимости от разрешения устройства, вы можете проверить разрешение устройства с помощью GetDeviceWidth и GetDeviceHeight.
     *
     * @param int $width Предполагаемая ширина
     * @param int $height Предполагаемая высота
     * @return void
     */
    function SetIntendedDeviceSize($width, $height)
    {
    }

    /**
     *Устанавливает данные вашей учетной записи Inneractive для использования CreateAdvert. Не все платформы поддерживают всех поставщиков рекламы, поэтому установка как можно большего количества реквизитов учетной записи позволит AGK выбрать подходящее объявление для этой платформы. В настоящее время Inneractive поддерживается iOS, Android, Windows и Mac.
     *
     * @param string $szCode Код вашей учетной записи предоставлен компанией Inneractive.
     * @return void
     */
    function SetInneractiveDetails($szCode)
    {
    }

    /**
     *Удаляет все экранные элементы управления, которые могли быть размещены на экране операционной системой, например кнопки "Домой" и "Назад", позволяя вашему приложению использовать весь экран. Ваше приложение может быть изменено после вызова этой команды, поэтому, если вы использовали GetDeviceWidth или GetDeviceHeight, вам следует подождать несколько кадров, а затем вызвать их снова, чтобы получить новые значения. Значения могут измениться не сразу после вызова этой команды, так как для изменения навигационной панели требуется некоторое время. Иногда ОС отключает иммерсивный режим без предупреждения, например, при нажатии кнопок регулировки громкости. Когда это произойдет, ваше приложение вернется к своему размеру без погружения в режим, чтобы предотвратить скрытие любой части приложения навигационной панелью, что может сделать некоторые части приложения недоступными для сенсорных событий. Вы можете обнаружить это изменение, регулярно проверяя GetDeviceWidth и GetDeviceHeight, и снова использовать SetImmersiveMode, чтобы запросить возврат в режим погружения. В настоящее время это относится только к устройствам Android под управлением версии 4.4 (API 19) или выше. На других платформах эта команда ничего не делает.
     *
     * @param int $mode 1, чтобы включить иммерсивный режим, 0, чтобы выключить его
     * @return void
     */
    function SetImmersiveMode($mode)
    {
    }

    /**
     *Устанавливает режим УФ-обертывания изображения, когда U-координата выходит за пределы диапазона 0-1. По умолчанию используется режим 0, который фиксирует значение пикселя до последнего допустимого пикселя, режим 1 повторяет текстуру, начиная с противоположной стороны. Чтобы успешно использовать значения UV за пределами 0-1 на всех платформах, рассматриваемое изображение должно иметь степень 2 по ширине и высоте и не быть частью текстуры атласа. Это относится как к зажиму, так и к повторению.
     *
     * @param int $iImageIndex Идентификатор изображения для изменения.
     * @param int $mode Режим обертывания для использования, 0=зажим, 1=повторение
     * @return void
     */
    function SetImageWrapU($iImageIndex, $mode)
    {
    }

    /**
     *Устанавливает режим УФ-обертывания изображения, когда координата V выходит за пределы диапазона 0-1. По умолчанию используется режим 0, который фиксирует значение пикселя до последнего допустимого пикселя, режим 1 повторяет текстуру, начиная с противоположной стороны. Чтобы успешно использовать УФ-значения за пределами 0-1 на всех платформах, рассматриваемое изображение должно иметь степень 2 по ширине и высоте и не быть частью текстуры атласа. Это относится как к зажиму, так и к повторению.
     *
     * @param int $iImageIndex Идентификатор изображения для изменения.
     * @param int $mode Режим обертывания для использования, 0=зажим, 1=повторение
     * @return void
     */
    function SetImageWrapV($iImageIndex, $mode)
    {
    }

    /**
     *Делает определенный цвет полностью прозрачным в выбранном изображении. Это медленная команда, и ее не следует вызывать каждый кадр.
     *
     * @param int $iImage Идентификатор изображения для изменения.
     * @param int $r Красный компонент цвета устанавливается как прозрачный
     * @param int $g Красный компонент цвета устанавливается как прозрачный
     * @param int $b Красный компонент цвета устанавливается как прозрачный
     * @return void
     */
    function SetImageTransparentColor($iImage, $r, $g, $b)
    {
    }

    /**
     *Задает данные подизображения для изображения атласа, которое представляет собой расположение каждого подизображения внутри изображения атласа. Обычно это загружается автоматически из subimages.txt файл при загрузке изображения, но если это невозможно, то эта команда может быть использована для установки этих данных. Файл должен быть действительным subimages.txt файл в том же формате что и указанный в LoadSubImage В отличие от обычной команды load image файл не нуждается в имени subimages.txt, он может иметь любое имя и путь
     *
     * @param int $iImageIndex Идентификатор изображения для изменения
     * @param string $sSubImageFile Путь к файлу вложенных изображений
     * @return void
     */
    function SetImageSubImages($iImageIndex, $sSubImageFile)
    {
    }

    /**
     *Устанавливает фильтр для текстур, когда текстура меньше пространства экрана, в котором она отображается. Вы можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть блочным, или 1, чтобы использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно совпадает с пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница, ближайший имеет тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей.
     *
     * @param int $iImageIndex Идентификатор изображения для изменения.
     * @param int $mode Используемый режим фильтра: 0=ближайший, 1=линейный
     * @return void
     */
    function SetImageMinFilter($iImageIndex, $mode)
    {
    }

    /**
     *Устанавливает фильтр для текстур, когда текстура больше, чем пространство экрана, в котором она отображается. Вы можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть блочным, или 1, чтобы использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно совпадает с пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница, ближайший имеет тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей.
     *
     * @param int $iImageIndex Идентификатор изображения для изменения.
     * @param int $mode Используемый режим фильтра: 0=ближайший, 1=линейный
     * @return void
     */
    function SetImageMagFilter($iImageIndex, $mode)
    {
    }

    /**
     *Копирует цветовой канал с одного изображения на другое. Вы можете указать исходный и конечный каналы, используя значения 1,2,3,4 для представления красного, зеленого, синего и альфа-каналов соответственно. Это медленная команда, и ее не следует вызывать каждый кадр. Значения смещения x,y позволяют смещать исходное изображение на целевом изображении, поэтому небольшое исходное изображение можно использовать для маскировки любой части большого изображения. Любая часть большого изображения за пределами размера маленького изображения останется неизменной. отрицательные значения смещения поддерживаются для смещения исходного изображения от верхнего левого края целевого изображения. Если вы добавляете несколько прозрачных пикселей к изображению, которое в настоящее время не имеет ни одного, и используете изображение на спрайте, то обязательно используйте SetSpriteTransparency, чтобы сделать спрайт прозрачным.
     *
     * @param int $iDstImage Идентификатор изображения для изменения.
     * @param int $iSrcImage Идентификатор изображения, которое будет использоваться в качестве источника.
     * @param int $dst Идентификатор цветового канала, используемого в качестве пункта назначения, 1-4 для RGBA,
     * @param int $src Идентификатор цветового канала, используемого в качестве источника, 1-4 для RGBA,
     * @param int $x Смещение x для исходного изображения на целевом изображении,
     * @param int $y Смещение y для исходного изображения на целевом изображении.
     * @return void
     */
    function SetImageMask($iDstImage, $iSrcImage, $dst, $src, $x, $y)
    {
    }

    /**
     *Устанавливает, должно ли устройство проверять SSL-сертификат при создании защищенного соединения. Если сервер, к которому вы подключаетесь, использует самозаверяющий сертификат, вам нужно будет установить его равным 0, иначе соединение не удастся. Во всех остальных случаях вы должны оставить это значение равным 1, чтобы обеспечить безопасное соединение с сервером. Отключение проверки отключит защиту от атак man in the middle на SSL-соединения.
     *
     * @param int $iHTTP Идентификатор устанавливаемого соединения.
     * @param int $mode 1 для проверки, 0 для не проверки.
     * @return void
     */
    function SetHTTPVerifyCertificate($iHTTP, $mode)
    {
    }

    /**
     *Устанавливает время в миллисекундах, в течение которого AGK будет ждать установления соединения, прежде чем отказаться от него.
     *
     * @param int $iHTTP Идентификатор устанавливаемого соединения.
     * @param int $milliseconds Время ожидания в миллисекундах.
     * @return void
     */
    function SetHTTPTimeout($iHTTP, $milliseconds)
    {
    }

    /**
     *Задает домен хоста, к которому вы хотите подключиться, например для доступа www.thegamecreators.com/index.php вы бы использовали значение хоста www.thegamecreators.com, не включайте http:, который обычно идет перед ним. Обратите внимание, что попытка использовать определенный порт с www.thegamecreators.com:8080 на некоторых платформах это может быть проигнорировано, и в этих случаях будет использоваться порт 80. При экспорте в HTML5 обратите внимание, что веб-браузеры ограничивают количество серверов, к которым вы можете подключиться. По умолчанию вы ограничены файлами, размещенными на том же сервере, что и ваше приложение. Однако если сервер отправляет заголовок Access-Control-Allow-Origin в своем ответе, который разрешает сервер вашего приложения, то браузер позволит вам подключиться к нему.
     *
     * @param int $iHTTP Идентификатор устанавливаемого соединения.
     * @param string $szHost Домен для подключения.
     * @param int $iSecure Установите значение 1, чтобы использовать защищенное соединение HTTPS, и 0, чтобы использовать стандартное соединение HTTP.
     * @return int
     */
    function SetHTTPHost($iHTTP, $szHost, $iSecure)
    {
    }

    /**
     *Задает домен хоста, к которому вы хотите подключиться, например для доступа www.thegamecreators.com/index.php вы бы использовали значение хоста www.thegamecreators.com, не включайте http:, который обычно идет перед ним. Обратите внимание, что попытка использовать определенный порт с www.thegamecreators.com:8080 на некоторых платформах это может быть проигнорировано, и в этих случаях будет использоваться порт 80. При экспорте в HTML5 обратите внимание, что веб-браузеры ограничивают количество серверов, к которым вы можете подключиться. По умолчанию вы ограничены файлами, размещенными на том же сервере, что и ваше приложение. Однако если сервер отправляет заголовок Access-Control-Allow-Origin в своем ответе, который разрешает сервер вашего приложения, то браузер позволит вам подключиться к нему.
     *
     * @param int $iHTTP Идентификатор устанавливаемого соединения.
     * @param string $szHost Домен для подключения.
     * @param int $iSecure Установите значение 1, чтобы использовать защищенное соединение HTTPS, и 0, чтобы использовать стандартное соединение HTTP.
     * @param string $szUser Имя пользователя для отправки на сервер.
     * @param string $szPass Пароль для отправки на сервер.
     * @return int
     */
    function SetHTTPHost($iHTTP, $szHost, $iSecure, $szUser, $szPass)
    {
    }

    /**
     *Задает положение всех 3D-объектов относительно 2D-объектов. Например, использование глобальной 3D-глубины 100 будет означать, что все спрайты на глубине меньше или равной 100 будут появляться над любыми 3D-объектами, в то время как спрайты на глубине больше 100 будут появляться под любыми 3D-объектами.
     *
     * @param int $depth Глубина спрайта для рендеринга 3D.
     * @return void
     */
    function SetGlobal3DDepth($depth)
    {
    }

    /**
     *Устанавливает, генерируются ли и используются ли загруженные изображения с mip-картами. Должен быть вызван до того, как будут загружены какие-либо изображения. Может быть изменено до загрузки другого изображения, чтобы некоторые использовали mip-карты, а другие-нет.
     *
     * @param int $generate Установите значение 1 для создания mip-карт (по умолчанию 0)
     * @return void
     */
    function SetGenerateMipmaps($generate)
    {
    }

    /**
     *При обычном использовании вашему приложению AGK доступны только две папки: папка чтения и папка записи. Папка чтения - это расположение исполняемого файла, включающее папку мультимедиа. Папка записи (которая также имеет разрешение на чтение) находится в безопасном месте платформы и отличается в зависимости от устройства. Например, в Windows по умолчанию используется следующее место записи: C:\Users\username\AppData\AGKApps\appName (По умолчанию это скрытая папка в Windows, и вам, возможно, придется показать скрытые файлы, чтобы увидеть ее). Это ваши корневые папки. Любые файлы, созданные/записанные с помощью OpenToWrite, будут сохранены в папке записи. Для простоты AGK объединяет эти две папки чтения и записи в один набор команд. Это означает, что при попытке открыть или загрузить файл AGK сначала будет искать в папке записи, а затем в папке чтения. При использовании SetFolder его поведение соответствует тому, что вы ожидаете от команды CD в консоли Windows или Linux; Он работает из текущего каталога. Например, если текущая папка чтения C:\games\myApp\ затем SetFolder("images") поместит вас в C:\games\myApp\images. Вызов команды во второй раз с помощью SetFolder("backgrounds") приведет вас в C:\games\myApp\images\backgrounds\. Есть два способа вернуться на базовый путь. Первый-вызвать SetFolder (""), используя пустую строку. Другой способ-предварить свой путь прямой косой чертой, SetFolder("/stuff"). Это также относится и к загрузке ваших файлов с помощью других команд. Предположим, что вы все еще находитесь в папках images\backgrounds и хотите загрузить файл bk.png, расположенный в основании папки read. Вы можете просто сказать LoadImage("/bk.png"), который будет загружаться C:\games\myApp\bk.png. Установка пути к несуществующей папке и использование OpenToWrite создаст эту папку в пути записи. SetFolder не проверяет, существует ли папка, он просто устанавливает внутренний путь, который будет использоваться в следующей команде file. По умолчанию AGK первым делом вызывает SetFolder("media"). Эта команда возвращает 1 при успешном выполнении или 0, если вы используете недопустимый путь, такой как SetFolder("C:\"). Примечание: При настройке путей важно помнить, что всегда следует использовать косую черту вперед, а не обратную. AGK преобразует их в соответствующий файловый разделитель для данной платформы. Если вы хотите получить доступ к файлам вне папок чтения и записи, вы можете использовать обычные файловые команды, такие как OpenToRead с путем к файлу "raw:", см. Эту команду для получения более подробной информации. Для доступа к папкам вне папок чтения и записи можно использовать команды OpenRawFolder.
     *
     * @param string $str Путь к папке для установки
     * @return int
     */
    function SetFolder($str)
    {
    }

    /**
     *Устанавливает диапазон действия 3D-тумана. На минимальном расстоянии не будет возникать тумана, после чего туман начнет действовать. Максимальное расстояние не является пределом и является лишь приблизительным руководством для того, как далеко вы хотите видеть в своей сцене. Туман увеличивается экспоненциально, чтобы имитировать реальность, то есть сначала он быстро увеличивается, затем затихает и постепенно достигает полной интенсивности на максимальном расстоянии.
     *
     * @param float $minDist Минимальное расстояние для тумана, никакой туман не повлияет на пиксели в пределах этого расстояния от камеры.
     * @param float $maxDist Максимальное расстояние для тумана, туман достигнет полной интенсивности вокруг этого расстояния.
     * @return void
     */
    function SetFogRange($minDist, $maxDist)
    {
    }

    /**
     *Устанавливает цвет солнца 3D тумана. Это используется вместо обычного цвета тумана, когда камера обращена к солнцу, как определено командой SetSunDirection. Это может быть использовано для имитации эффектов рассеяния света, чтобы воздух казался туманным. Цвет туманного солнца должен быть близок к цвету солнца для лучшего эффекта, но это не обязательно. Обратите внимание, что вызов этой команды изменяет расчет тумана на более сложную версию, что приведет к снижению производительности на мобильных устройствах. Чтобы вернуться к более быстрому методу расчета тумана, сделайте цвет солнца тумана равным нормальному цвету тумана.
     *
     * @param int $red Красная составляющая цвета.
     * @param int $green Зеленая составляющая цвета.
     * @param int $blue Синяя составляющая цвета.
     * @return void
     */
    function SetFogSunColor($red, $green, $blue)
    {
    }

    /**
     *Устанавливает цвет 3D тумана. Объекты будут постепенно исчезать до этого цвета по мере удаления от камеры. Цветовые значения должны находиться в диапазоне от 0 до 255, но этим они не ограничиваются и система будет принимать значения вне диапазона, в том числе и отрицательные.
     *
     * @param int $red Красная составляющая цвета.
     * @param int $green Зеленая составляющая цвета.
     * @param int $blue Синяя составляющая цвета.
     * @return void
     */
    function SetFogColor($red, $green, $blue)
    {
    }

    /**
     *Устанавливает 3D туман включенным или выключенным, это может быть использовано для создания атмосферной дымки или выцветания объектов до цвета фона, чтобы имитировать уменьшенную видимость. Туман будет автоматически применен ко всем 3D-объектам, если они используют шейдер по умолчанию. Если вы применили свой собственный шейдер с помощью SetObjectShader, то объявите функцию mediump vec3 ApplyFog( mediump vec3 color, highp vec3 pointPos ); в пиксельном шейдере, который AGK заполнит для вас во время выполнения. pointPos-это положение пикселя в мировых координатах, которое вам нужно будет передать из вершинного шейдера.
     *
     * @param int $mode 1, чтобы включить туман, 0, чтобы выключить его.
     * @return void
     */
    function SetFogMode($mode)
    {
    }

    /**
     *Задает текущую позицию чтения в файле
     *
     * @param int $iFileID Идентификатор файла для проверки.
     * @param int $pos Новая позиция для продолжения чтения
     * @return void
     */
    function SetFilePos($iFileID, $pos)
    {
    }

    /**
     *Задает номер версии для использования в других командах расширения файла. В настоящее время применимо только к Android. Номер версии файла расширения определяется номером версии APK, который был загружен вместе с ним. Например, APK может быть обновлен до нового номера версии, но файл расширения все равно может быть исходным номером версии.
     *
     * @param int $version Номер версии, используемый при проверке и загрузке файла расширения.
     * @return void
     */
    function SetExpansionFileVersion($version)
    {
    }

    /**
     *Задает открытый ключ для использования в других командах расширения файла. В настоящее время применимо только к Android. Открытый ключ можно найти в консоли разработчика Google Play и он отличается для каждого приложения. Нажмите на приложение, а затем нажмите на раздел Служб и API, это длинная строка, которая начинается MIIB.
     *
     * @param string $key Открытый ключ, используемый при проверке и загрузке файла расширения.
     * @return void
     */
    function SetExpansionFileKey($key)
    {
    }

    /**
     *Устанавливает режим ошибки для команд AGK from ignore, report или stop from AGK, например, идентификатор спрайта не существует в команде, которая принимает идентификатор спрайта. Игнорирование заставит AGK попытаться продолжить, игнорируя всю команду, если это необходимо. Отчет заставит AGK сообщить об ошибке в соответствующую консоль отладки и продолжить работу. Stop заставит AGK сообщить об ошибке, как и раньше, а затем остановится, вызвав исключение, которое должно быть поймано, иначе приложение завершится. В случае уровня 1 исключение перехватывается интерпретатором и при отладке отображается в IDE.
     *
     * @param int $mode 0=игнорировать, 1=сообщить, 2=остановить
     * @return void
     */
    function SetErrorMode($mode)
    {
    }

    /**
     *Если SetEditBoxMultiLine имеет значение 0, эта команда устанавливает, будет ли одна строка текста прокручиваться вправо или переноситься на новую строку, когда она перетекает по ширине поля редактирования. Использование по-прежнему не будет разрешено вводить новые символы строки самостоятельно.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $mode 0 для прокрутки вправо (по умолчанию), 1 для переноса на новую строку.
     * @return void
     */
    function SetEditBoxWrapMode($index, $mode)
    {
    }

    /**
     *Переключает видимое состояние этого поля редактирования, когда видимое установлено в 1, поле редактирования можно щелкнуть, получить фокус и изменить, когда установлено в 0, поле редактирования не отображается, не может быть изменено или получить фокус.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $visible Новое состояние поля редактирования, 1 для видимого, 0 для невидимого.
     * @return void
     */
    function SetEditBoxVisible($index, $visible)
    {
    }

    /**
     *Задает, будет ли поле редактирования использовать альтернативный метод ввода текста, если поле редактирования будет скрыто виртуальной клавиатурой. Это относится только к мобильным платформам, таким как iOS и Android, и альтернативный метод ввода обычно представляет собой меньшее поле редактирования, расположенное чуть выше клавиатуры. Поле редактирования по-прежнему будет обновляться в режиме реального времени, как если бы оно вводилось непосредственно, но поскольку оно закрыто клавиатурой, пользователь его не увидит. По умолчанию он включен. Если вы хотите, вы можете отключить его и переместить поле редактирования в поле зрения, когда GetEditBoxHasFocus возвращает 1, обязательно переместите его обратно, когда GetEditBoxHasFocus возвращает 0.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $mode 1 для использования альтернативного ввода (по умолчанию), 0 для использования обычного ввода.
     * @return void
     */
    function SetEditBoxUseAlternateInput($index, $mode)
    {
    }

    /**
     *Задает высоту в мировых координатах текста в этом поле редактирования. По умолчанию он установлен на высоту поля редактирования минус 2.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $size Новый размер шрифта для использования.
     * @return void
     */
    function SetEditBoxTextSize($index, $size)
    {
    }

    /**
     *Задает цвет вводимого текста.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $red Красная составляющая цвета (от 0 до 255).
     * @param int $green Зеленая составляющая цвета (от 0 до 255).
     * @param int $blue Синяя составляющая цвета (от 0 до 255).
     * @return void
     */
    function SetEditBoxTextColor($index, $red, $green, $blue)
    {
    }

    /**
     *Задает текст, который в данный момент отображается в поле редактирования.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param string $str Новый текст для отображения.
     * @return void
     */
    function SetEditBoxText($index, $str)
    {
    }

    /**
     *Задает размер поля редактирования в мировых координатах. При этом устанавливается размер фактического поля ввода текста, его граница будет выходить за пределы этих значений.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $width Ширина нового размера.
     * @param float $height Высота нового размера.
     * @return void
     */
    function SetEditBoxSize($index, $width, $height)
    {
    }

    /**
     *При рисовании поле редактирования привязывается к указанным мировым координатам.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $x Координата x верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $y Координата y верхнего левого угла прямоугольника для использования в качестве границы клипа.
     * @param float $x2 Координата x в правом нижнем углу окна для использования в качестве границы клипа.
     * @param float $y2 Координата y в правом нижнем углу окна для использования в качестве границы клипа.
     * @return void
     */
    function SetEditBoxScissor($index, $x, $y, $x2, $y2)
    {
    }

    /**
     *Устанавливает положение в мировых координатах поля редактирования, используя его верхний левый угол. Это устанавливает положение фактического поля ввода текста, его граница будет расширяться влево и выше этой точки.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $x Значение X позиции.
     * @param float $y Значение Y позиции.
     * @return void
     */
    function SetEditBoxPosition($index, $x, $y)
    {
    }

    /**
     *Задает, будут ли в поле редактирования отображаться звезды вместо ввода текста. Использование GetEditBoxText по-прежнему будет возвращать фактические символы, введенные пользователем.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $mode 1 для отображения звезд, 0 для отображения нормального ввода.
     * @return void
     */
    function SetEditBoxPasswordMode($index, $mode)
    {
    }

    /**
     *Задает, будет ли поле редактирования переносить текст в новую строку, когда он достигнет края поля редактирования. По умолчанию многострочный текст равен 0, поэтому текст представляет собой одну непрерывную строку в поле.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $multiline 1 для включения многострочного режима, 0 для отключения.
     * @return void
     */
    function SetEditBoxMultiLine($index, $multiline)
    {
    }

    /**
     *Задает максимальное количество строк, которые могут быть введены в это многострочное поле редактирования. Используйте 0 для неограниченного количества.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $max Максимальное количество строк.
     * @return void
     */
    function SetEditBoxMaxLines($index, $max)
    {
    }

    /**
     *Задает максимальное количество символов, которое может быть введено в это поле редактирования. Используйте 0 для неограниченного количества.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $max Максимальное количество символов.
     * @return void
     */
    function SetEditBoxMaxChars($index, $max)
    {
    }

    /**
     *Задает тип клавиатуры, которая будет отображаться на мобильных устройствах при редактировании этого поля редактирования. Там, где это возможно, будет отображаться клавиатура такого типа, например клавиатура только с цифрами.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $inputType 0 для обычного текста, 1 только для чисел.
     * @return void
     */
    function SetEditBoxInputType($index, $inputType)
    {
    }

    /**
     *Устанавливает изображение шрифта, которое будет использоваться для этого поля редактирования, должно быть ранее загружено с помощью LoadImage(). Используйте 0, чтобы вернуть поле редактирования к шрифту по умолчанию.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $image Идентификатор используемого изображения-0 для шрифта по умолчанию.
     * @return void
     */
    function SetEditBoxFontImage($index, $image)
    {
    }

    /**
     *Переключает состояние фокуса этого поля редактирования, когда фокус установлен на 1, курсор начинает мигать, и любое нажатие клавиши добавит текст в поле редактирования. При установке значения 0 курсор исчезает, и текст не добавляется.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $focus Новое состояние поля редактирования, 1 для активного, 0 для неактивного.
     * @return void
     */
    function SetEditBoxFocus($index, $focus)
    {
    }

    /**
     *Устанавливает шрифт, используемый для этого поля редактирования, который должен быть ранее загружен с помощью LoadFont. Используйте 0, чтобы вернуть поле редактирования к шрифту по умолчанию.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $fontID Идентификатор используемого шрифта-0 для шрифта по умолчанию.
     * @return void
     */
    function SetEditBoxFont($index, $fontID)
    {
    }

    /**
     *Устанавливает расширенное изображение шрифта, используемое для этого поля редактирования, должно быть ранее загружено с помощью LoadImage(). Используйте 0, чтобы удалить расширенное изображение шрифта. Если вы не установите это изображение, поле редактирования не будет принимать расширенные символы, такие как £ é á и т. Д.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $image Идентификатор изображения для использования, 0 для использования без изображения.
     * @return void
     */
    function SetEditBoxExtendedFontImage($index, $image)
    {
    }

    /**
     *Устанавливает глубину поля редактирования таким образом, чтобы оно могло появляться позади или перед другими спрайтами и текстовыми объектами.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $depth Глубина в диапазоне от 0 (спереди) до 10000 (сзади).
     * @return void
     */
    function SetEditBoxDepth($index, $depth)
    {
    }

    /**
     *Устанавливает ширину в мировых координатах курсора ввода текста, по умолчанию это значение равно 1,5 Обратите внимание, что функции, изменяющие размер текста или размер поля редактирования, могут перезаписать это значение.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $width Новая ширина курсора.
     * @return void
     */
    function SetEditBoxCursorWidth($index, $width)
    {
    }

    /**
     *Задает время в секундах между видимым и невидимым курсором в поле ввода текста.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $time Время в секундах.
     * @return void
     */
    function SetEditBoxCursorBlinkTime($index, $time)
    {
    }

    /**
     *Задает цвет мигающего курсора в этом поле редактирования.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $red Красная составляющая цвета (от 0 до 255).
     * @param int $green Зеленая составляющая цвета (от 0 до 255).
     * @param int $blue Синяя составляющая цвета (от 0 до 255).
     * @return void
     */
    function SetEditBoxCursorColor($index, $red, $green, $blue)
    {
    }

    /**
     *Устанавливает курсор в заданную позицию в тексте, т. е. позиция 0 находится слева от первого символа, позиция 1-слева от второго символа и т. Д. Если значение позиции находится вне диапазона, оно будет зажато до ближайшего символа. Текущая позиция курсора гарантированно находится в поле зрения пользователя, поэтому ее можно использовать для выравнивания текста влево или вправо, установив курсор в крайнем левом или правом углу текста.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $pos Новое положение курсора
     * @return void
     */
    function SetEditBoxCursorPosition($index, $pos)
    {
    }

    /**
     *Задает размер границы в мировых координатах, которая будет окружать поле ввода текста. Например, значение 2 добавит границу в 2 пикселя вокруг поля ввода.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param float $size Размер границы.
     * @return void
     */
    function SetEditBoxBorderSize($index, $size)
    {
    }

    /**
     *Устанавливает изображение для использования в качестве границы, это может быть использовано вместе с цветом границы. Используйте 0, чтобы удалить изображение границы.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $image Идентификатор используемого изображения.
     * @return void
     */
    function SetEditBoxBorderImage($index, $image)
    {
    }

    /**
     *Задает цвет любой присутствующей границы. Вы также можете использовать изображение с помощью SetEditBoxBorderImage().
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $red Красная составляющая цвета (от 0 до 255).
     * @param int $green Зеленая составляющая цвета (от 0 до 255).
     * @param int $blue Синяя составляющая цвета (от 0 до 255).
     * @param int $alpha Альфа-компонент цвета (от 0 до 255). 255 полностью непрозрачен.
     * @return void
     */
    function SetEditBoxBorderColor($index, $red, $green, $blue, $alpha)
    {
    }

    /**
     *Задает цвет основного поля ввода текста.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $red Красная составляющая цвета (от 0 до 255).
     * @param int $green Зеленая составляющая цвета (от 0 до 255).
     * @param int $blue Синяя составляющая цвета (от 0 до 255).
     * @param int $alpha Альфа-компонент цвета (от 0 до 255). 255 полностью непрозрачен.
     * @return void
     */
    function SetEditBoxBackgroundColor($index, $red, $green, $blue, $alpha)
    {
    }

    /**
     *Устанавливает изображение для использования в качестве фона, это может быть использовано вместе с цветом фона. Используйте 0, чтобы удалить фоновое изображение.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $image Идентификатор используемого изображения.
     * @return void
     */
    function SetEditBoxBackgroundImage($index, $image)
    {
    }

    /**
     *Эта команда используется в сочетании с системой позиционирования по умолчанию на основе процентов в AGK. При использовании этого подхода вам нужно будет указать аспект отображения, чтобы AGK знал, как правильно отображать объекты на экране. Если бы ваше произведение изначально было рассчитано на разрешение 1024 x 768, это привело бы к соотношению сторон 4:3, что также равносильно утверждению 1024 / 768 = 1.33, поэтому вы бы вызвали SetDisplayAspect и передали бы значение 1.33 в качестве вашего соотношения сторон. На платформах, где разрешение было другим, AGK позаботится о том, чтобы ваше приложение все еще поддерживало это соотношение сторон и выглядело правильно. Альтернативный подход заключается в вызове SetVirtualResolution для управления системой координат и размещения спрайтов с использованием экранных координат вместо использования процентов, и в этом случае вы не должны вызывать эту команду. Если спрайты уже существуют, когда это называется, они будут искажены. Если заданное соотношение сторон не подходит точно на текущем устройстве, черные границы будут нарисованы вокруг области рендеринга, чтобы центрировать ее на экране. Используйте соотношение сторон 0, чтобы использовать текущую систему координат в качестве соотношения сторон. Используйте соотношение сторон -1 для использования соотношения сторон устройства (заполняет весь экран без черных границ, но вызовет растяжение и будет выглядеть по-разному на каждом устройстве) Альтернативным методом заполнения экрана, который позволяет избежать этой проблемы, является использование SetScissor со значениями 0,0,0,0.
     *
     * @param float $aspect соотношение сторон, которое будет использоваться с этого момента, в виде ширины/высоты.
     * @return void
     */
    function SetDisplayAspect($aspect)
    {
    }

    /**
     *Использование идентификатора изображения, большего нуля, приведет к потоковой передаче камеры устройства на выбранное изображение. Изображение в данный момент не должно существовать, оно будет создано этой командой. Используйте ImageID 0, чтобы остановить потоковую передачу, это также приведет к удалению изображения. Параметр cameraID используется, когда устройство имеет несколько камер, например фронтальную и заднюю. Обычно 0 относится к камере, обращенной назад. Используйте GetNumDeviceCameras, чтобы узнать, сколько камер имеет это устройство, и GetDeviceCameraType, чтобы проверить, обращено ли оно спереди или сзади. Этот параметр игнорируется, если ImageID равен 0. У вас может быть активна только одна камера устройства одновременно, поэтому для переключения с задней камеры на фронтальную вы должны сначала вызвать эту команду с ImageID, установленным в 0, чтобы остановить захват, а затем запустить его снова с новым cameraID. Возвращает 1, если она была успешной, 0, если возникла проблема или текущая платформа не поддерживает эту команду. В настоящее время это поддерживается на iOS, Android 4.0.3 и выше, а также Windows.
     *
     * @param int $cameraID Идентификатор камеры устройства, которую вы хотите использовать, может быть задней или фронтальной камерой
     * @param int $imageID ImageID, который вы хотите использовать для этого изображения, не должен существовать
     * @return int
     */
    function SetDeviceCameraToImage($cameraID, $imageID)
    {
    }

    /**
     *Устанавливает текстурное обертывание по умолчанию для изображений, где координаты UV выходят за пределы диапазона от 0 до 1 в направлении V.
     *
     * @param int $mode Режим обертывания для использования 0=зажим, 1=повторение
     * @return void
     */
    function SetDefaultWrapV($mode)
    {
    }

    /**
     *Устанавливает текстурное обертывание по умолчанию для изображений, где координаты UV выходят за пределы диапазона от 0 до 1 в направлении U.
     *
     * @param int $mode Режим обертывания для использования 0=зажим, 1=повторение
     * @return void
     */
    function SetDefaultWrapU($mode)
    {
    }

    /**
     *Переключает активное состояние этого поля редактирования, когда активное установлено в 1, поле редактирования можно щелкнуть, получить фокус и изменить, когда установлено в 0, поле редактирования нельзя ни изменить, ни получить фокус.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $active Новое состояние поля редактирования, 1 для активного, 0 для неактивного.
     * @return void
     */
    function SetEditBoxActive($index, $active)
    {
    }

    /**
     *Устанавливает фильтр минификации по умолчанию для текстур, когда текстура меньше пространства экрана, в котором она отображается. Вы можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть блочным, или 1, чтобы использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно совпадает с пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница, ближайший имеет тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей. Вы можете установить это значение для каждого изображения с помощью SetImageMinFilter.
     *
     * @param int $filter Режим фильтра для использования 0=ближайший, 1=линейный
     * @return void
     */
    function SetDefaultMinFilter($filter)
    {
    }

    /**
     *Устанавливает фильтр увеличения по умолчанию для текстур, когда текстура больше, чем пространство экрана, в котором она отображается. Вы можете использовать режим 0, чтобы использовать ближайший пиксель, который будет выглядеть блочным, или 1, чтобы использовать линейный фильтр, который будет выглядеть размытым. Когда изображение точно совпадает с пространством экрана, то оба фильтра будут выглядеть одинаково, когда есть небольшая разница, ближайший имеет тенденцию быть более резким, но может мерцать, когда он меняет выбор пикселей. Вы можете установить это значение для каждого изображения с помощью SetImageMagFilter.
     *
     * @param int $filter Режим фильтра для использования 0=ближайший, 1=линейный
     * @return void
     */
    function SetDefaultMagFilter($filter)
    {
    }

    /**
     *Устанавливает время в секундах между появлением и исчезновением курсора в полноэкранном окне редактирования
     *
     * @param float $seconds Время в секундах.
     * @return void
     */
    function SetCursorBlinkTime($seconds)
    {
    }

    /**
     *Эта команда устарела и была заменена на SetFolder.
     *
     * @param string $szPath Каталог, который будет использоваться в качестве нового текущего каталога.
     * @return int
     */
    function SetCurrentDir($szPath)
    {
    }

    /**
     *Устанавливает переменную облачных данных в заданное значение. Если несколько устройств записывают значение одновременно, то облачный провайдер выбирает одно из них и отправляет его всем устройствам. Имя переменной должно быть меньше 64 байт, один символ UTF8 может быть несколько байт, но обычно 1 символ равен 1 байту. Рекомендуется, чтобы имена переменных включали имя приложения, например "myapp.myvariablename", поскольку при трансляции ваших приложений все они будут совместно использовать одно хранилище данных в приложении AGK PLayer. Изменяемые данные хранятся локально, поэтому GetCloudDataVariable немедленно вернет новое значение, однако синхронизация с облаком выполняется в фоновом режиме и может занять несколько минут. Если устройство не имеет подключения к Интернету, то данные будут синхронизированы при следующей доступной возможности. В iOS вы ограничены 1024 переменными с общим объемом памяти 1 МБ. На Android любые данные, которые вы храните, засчитываются в лимит хранения Google Диска пользователя, пользователь может очистить данные вашего приложения, чтобы освободить место, но он не может прочитать данные, которые вы храните.  Вы не должны хранить конфиденциальную информацию, такую как пароли, в виде обычного текста с помощью этих команд.
     *
     * @param string $varName Имя переменной, которую нужно изменить, должно быть меньше 64 байт
     * @param string $varValue Значение для установки переменной
     * @return void
     */
    function SetCloudDataVariable($varName, $varValue)
    {
    }

    /**
     *Устанавливает буфер обмена устройства на указанный текст, при этом перезаписывается все, что ранее было в буфере обмена устройства. Буфер обмена такой же, как и тот, который используется функцией копирования/вставки устройства.
     *
     * @param string $szText Текст для копирования
     * @return void
     */
    function SetClipboardText($szText)
    {
    }

    /**
     *Устанавливает четкий цвет, используемый при очистке заднего буфера.
     *
     * @param int $red Красный компонент ясного цвета
     * @param int $green Зеленая составляющая прозрачного цвета
     * @param int $blue Синий компонент прозрачного цвета
     * @return void
     */
    function SetClearColor($red, $green, $blue)
    {
    }

    /**
     *Устанавливает данные вашей учетной записи Chartboost для использования в интерстициальной (полноэкранной) рекламе и видеорекламе вознаграждений. После вызова этой команды будет предпринята попытка кэшировать интерстициал, чтобы вы могли сразу же отобразить его позже. Вы можете проверить ход выполнения этой задачи с помощью GetFullscreenAdvertLoadedChartboost. Обратите внимание, что эта команда не будет автоматически кэшировать видеорекламу с вознаграждением, вы должны сделать это вручную с помощью CacheRewardAdChartboost. Реклама Chartboost в настоящее время поддерживается Android и iOS.
     *
     * @param string $szKey1 Идентификатор приложения
     * @param string $szKey2 Подпись приложения
     * @return void
     */
    function SetChartboostDetails($szKey1, $szKey2)
    {
    }

    /**
     *Устанавливает вращение указанной камеры с помощью кватерниона. В качестве альтернативы вы можете использовать SetCameraRotation для использования углов Эйлера. По умолчанию камеры создаются с кватернионом 1,0,0,0 в порядке w,x,y,z. Кватернион-это 4-мерное представление трехмерного вращения со свойством w^2+x^2+y^2+z^2 = 1, которое позволяет легко интерполировать между двумя вращениями путем линейной интерполяции двух кватернионов и их нормализации. Каждое 3D-вращение представлено ровно 2 кватернионами, w,x,y,z и -w,-x,-y,-z, поэтому любая версия может быть возвращена командами GetCameraQuat. Кватернионы и углы Эйлера могут использоваться одновременно. Например, установка вращения кватерниона создаст представление Эйлера, которое можно получить с помощью GetCameraAngleX и т. Д.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $w W-компонент кватерниона.
     * @param float $x X-компонент кватерниона.
     * @param float $y Y-компонент кватерниона.
     * @param float $z Z-компонент кватерниона.
     * @return void
     */
    function SetCameraRotationQuat($cameraID, $w, $x, $y, $z)
    {
    }

    /**
     *Задает поворот указанной камеры с помощью углов Эйлера в градусах. В качестве альтернативы вы можете использовать SetCameraRotationQuat для использования кватерниона. По умолчанию камеры создаются с углами 0,0,0 в порядке YXZ. Углы Эйлера-это составные углы, где камера начинается с 0,0,0 и затем поворачивается на заданный угол Y, затем на заданный угол X, а затем катится на заданный угол Z. Каждое 3D-вращение может быть представлено 2 комбинациями углов Эйлера, Y,X,Z и Y-180,X-180,Z-180, поэтому любая версия может быть возвращена командами GetCameraAngle. Кватернионы и углы Эйлера могут использоваться одновременно. Например, установка угла поворота Эйлера создаст представление кватерниона, которое можно получить с помощью GetCameraQuatX и т. Д.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $angx X-компонент вращения Эйлера.
     * @param float $angy Y-компонент вращения Эйлера.
     * @param float $angz Z-компонент вращения Эйлера.
     * @return void
     */
    function SetCameraRotation($cameraID, $angx, $angy, $angz)
    {
    }

    /**
     *Устанавливает ближнюю и дальнюю плоскости камеры. Из-за ограничений рендеринга не все перед камерой может быть рендерено, поэтому они должны быть ограничены видимым диапазоном. Все, что находится за пределами этого диапазона, отсекается системой рендеринга и остается невидимым. Ближняя плоскость-это самое близкое, что объект может быть к камере и все еще визуализироваться, она должна быть больше 0. Обратите внимание, что использование очень малых значений для ближней плоскости повлияет на точность буфера глубины при рендеринге объектов вдали, что может вызвать мерцание на удаленных объектах. Это происходит потому, что буфер глубины не является линейным, вместо этого он смещен в сторону ближней плоскости, и чем ближе к 0 становится ближняя плоскость, тем меньше буфера глубины доступно для дальних объектов. Дальняя плоскость-это максимальное расстояние, на котором объект может находиться от камеры и все еще визуализироваться, его максимальное значение равно бесконечности, но опять же, чем дальше вы пытаетесь визуализировать объект от ближней плоскости, тем менее точной становится буферизация глубины. Если объект пересекает ближнюю или дальнюю плоскость так, что часть его находится с одной стороны, а часть-с другой, то объект будет разрезан плоскостью, и будет видна только часть в пределах диапазона обзора. Диапазон по умолчанию-near=1, far=1000.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $fNear Самое близкое, что объект будет визуализирован.
     * @param float $fFar Самое дальнее, что объект будет визуализирован.
     * @return void
     */
    function SetCameraRange($cameraID, $fNear, $fFar)
    {
    }

    /**
     *Устанавливает положение указанной камеры. По умолчанию камеры расположены на уровне 0,0,0, основная камера-ID 1.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $x X-компонент позиции.
     * @param float $y Y-компонент позиции.
     * @param float $z Z-компонент позиции.
     * @return void
     */
    function SetCameraPosition($cameraID, $x, $y, $z)
    {
    }

    /**
     *Устанавливает камеру на использование смещенной от центра проекционной матрицы. Вы должны установить значения матрицы проекции с помощью SetCameraBounds и SetCameraRange.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param int $mode 1 для использования матрицы проекции вне центра, 0 для использования нормальной матрицы, значение по умолчанию равно 0.
     * @return void
     */
    function SetCameraOffCenter($cameraID, $mode)
    {
    }

    /**
     *Если FOV камеры установлен в 0, то это будет определять ширину ортогонального вида, значение по умолчанию равно 40. Значение высоты будет вычислено из него на основе соотношения сторон камеры. При использовании ортогональной проекции все остается одного и того же размера независимо от того, насколько близко или далеко оно находится к камере, поэтому при использовании значения ширины по умолчанию куб размером 80 единиц всегда будет заполнять вид камеры, когда камера смотрит на него, так как 40 измеряется от центра экрана до края. Эта команда перезапишет все значения, заданные с помощью SetCameraBounds.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $width Ширина вида в мировых координатах.
     * @return void
     */
    function SetCameraOrthoWidth($cameraID, $width)
    {
    }

    /**
     *Поворачивает камеру, чтобы посмотреть на определенную точку в пространстве с дополнительным значением крена. "смотреть" определяется как выравнивание локальной оси Z камеры, чтобы указать ее положительную сторону в данной точке. Это может быть достигнуто с помощью только углов Y и X в эйлеровой нотации, поэтому вы можете указать дополнительный угол Z в градусах, чтобы повернуть камеру влево или вправо, всегда глядя на одно и то же место.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $x X-компонент позиции, на которую нужно смотреть.
     * @param float $y Y-компонент позиции, на которую нужно смотреть.
     * @param float $z Z-компонент позиции, на которую нужно смотреть.
     * @param float $roll Угол Z для поворота камеры при взгляде на заданное положение отрицательный-по часовой стрелке.
     * @return void
     */
    function SetCameraLookAt($cameraID, $x, $y, $z, $roll)
    {
    }

    /**
     *Устанавливает горизонтальное поле зрения камеры (FOV). Это определяет угол между левой и правой сторонами обзора камеры, по умолчанию равный 70, и обеспечивает реалистичную 3D-проекцию. Использование меньших значений будет выглядеть так, как будто камера увеличивает масштаб сцены, фактически не двигаясь. Это иногда используется для драматического эффекта в фильмах, где FOV масштабируется в одну сторону, в то время как камера движется в другую. Использование значения FOV 0-это особый случай, который будет генерировать ортогональную матрицу вместо проекционной матрицы, это заставит все оставаться одного и того же размера независимо от того, насколько близко или далеко оно находится к камере. Ортогональная матрица будет иметь ширину 40 мировых единиц с высотой, определяемой соотношением сторон камеры.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $fov Поле зрения в градусах.
     * @return void
     */
    function SetCameraFOV($cameraID, $fov)
    {
    }

    /**
     *Задает параметры для матрицы проекции вне центра. Ближние и дальние значения задаются отдельно с помощью SetCameraRange. Чтобы использовать матрицу проекции вне центра, вы должны активировать ее с помощью SetCameraOffCenter.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $left Левая составляющая проекционной матрицы.
     * @param float $right Правая составляющая проекционной матрицы.
     * @param float $top Верхний компонент проекционной матрицы.
     * @param float $bottom Нижняя составляющая проекционной матрицы.
     * @return void
     */
    function SetCameraBounds($cameraID, $left, $right, $top, $bottom)
    {
    }

    /**
     *Устанавливает соотношение сторон камеры при рендеринге 3D. По умолчанию используется GetDeviceWidth()/GetDeviceHeight() и обеспечивает реалистичную 3D-проекцию. Если размер backbuffer устройства изменяется, например, если устройство меняет ориентацию, или размер окна изменяется, или вызывается SetScreenResolution, то это значение будет сброшено до значения по умолчанию.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $aspect Новое соотношение сторон для использования.
     * @return void
     */
    function SetCameraAspect($cameraID, $aspect)
    {
    }

    /**
     *Эта функция позиционирует виртуальную кнопку в заданном положении только в том случае, если это необходимо для данного устройства, например, если присутствует реальный джойстик или клавиатура, то эта команда не будет иметь заметного эффекта. Рекомендуется вызвать эту команду в любом случае, просто на случай, если потребуется виртуальная кнопка. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут использоваться для команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5 соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая появится на экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа гарантированно имеет способ активации кнопок AGK. Если виртуальная кнопка создана,она будет центрирована на заданной позиции X, Y.
     *
     * @param int $index Идентификатор кнопки, которую нужно расположить, должен находиться в диапазоне от 1 до 5 включительно.
     * @param float $x Координата X положения кнопки в координатах экрана.
     * @param float $y Координата Y положения кнопки в координатах экрана.
     * @param float $size Диаметр положения кнопки в координатах экрана.
     * @return void
     */
    function SetButtonScreenPosition($index, $x, $y, $size)
    {
    }

    /**
     *Устанавливает цвет или любые границы, используемые, когда дисплей не точно соответствует соотношению сторон. Если этот цвет отличается от цвета clear, то выполняется дополнительная операция clear, которая может повлиять на производительность, если скорость заполнения является проблемой.
     *
     * @param int $red Красная составляющая цвета границы
     * @param int $green Зеленая составляющая цвета границы
     * @param int $blue Синий компонент цвета границы
     * @return void
     */
    function SetBorderColor($red, $green, $blue)
    {
    }

    /**
     *Задает, должно ли устройство использовать сглаживание при рендеринге в задний буфер. В настоящее время это относится только к Windows, Mac и Linux, и доступна только 4-кратная множественная выборка. Это не относится ни к каким объектам, нарисованным на изображении с помощью SetRenderToImage, только задний буфер сглажен.
     *
     * @param int $mode 0=выкл., 1=4xMSAA
     * @return void
     */
    function SetAntialiasMode($mode)
    {
    }

    /**
     *Задает новый цвет для глобального окружающего света. Значения должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать свет. Цвет окружающей среды по умолчанию-76,76,76.
     *
     * @param int $red Красная составляющая нового цвета.
     * @param int $green Зеленая составляющая нового цвета.
     * @param int $blue Синий компонент нового цвета.
     * @return void
     */
    function SetAmbientColor($red, $green, $blue)
    {
    }

    /**
     *Определяет, будут ли объявления Amazon тестовыми или платными. Это должно быть вызвано перед SetAmazonAdDetails, чтобы убедиться, что все объявления являются тестовыми. По умолчанию будет показываться платная реклама.
     *
     * @param int $mode 0=показывать платную рекламу, 1=показывать тестовую рекламу
     * @return void
     */
    function SetAmazonAdTesting($mode)
    {
    }

    /**
     *Устанавливает данные учетной записи Amazon Ads для использования в интерстициальной (полноэкранной) рекламе. После вызова этой команды будет предпринята попытка кэшировать интерстициал, чтобы вы могли сразу же отобразить его позже. Вы можете проверить ход этого процесса с помощью GetFullscreenAdvertLoadedAmazon. В настоящее время Amazon ads поддерживается iOS и Android.
     *
     * @param string $szKey Идентификатор рекламного блока, предоставленный Amazon.
     * @return void
     */
    function SetAmazonAdDetails($szKey)
    {
    }

    /**
     *Установите видимость любого объявления.
     *
     * @param int $iVisible 1 покажет рекламу, а 0 скроет ее.
     * @return void
     */
    function SetAdvertVisible($iVisible)
    {
    }

    /**
     *Размещает рекламу, созданную с помощью CreateAdvert, где-то на экране и пытается масштабировать ее до определенной ширины. Поскольку реклама будет иметь свое собственное соотношение сторон, высота будет рассчитываться исходя из ширины. Это не гарантирует работу со всеми поставщиками рекламы, в настоящее время только Inneractive может масштабировать и перемещать рекламу в абсолютное положение.
     *
     * @param float $x Положение x в верхнем левом углу объявления
     * @param float $y Положение y в верхнем левом углу объявления
     * @param float $width Желаемая ширина объявления, она будет масштабирована до этой ширины
     * @return void
     */
    function SetAdvertPosition($x, $y, $width)
    {
    }

    /**
     *Размещает рекламу, созданную с помощью CreateAdvert, где-то на экране и пытается масштабировать ее до определенной ширины. Поскольку реклама будет иметь свое собственное соотношение сторон, высота будет рассчитываться исходя из ширины. Это обеспечивает грубое позиционирование, позволяя вам выбирать между левым, центрированным или правым выравниванием для горизонтального и вертикального положений. Это не гарантирует работу со всеми поставщиками рекламы, в настоящее время только Inneractive может масштабировать рекламу до определенной ширины.
     *
     * @param int $horz Горизонтальное положение объявления, 0=слева, 1=в центре, 2=справа
     * @param int $vert Вертикальное положение объявления, 0=верх, 1=центр, 2=низ
     * @param float $width Желаемая ширина объявления, она будет масштабирована до этой ширины
     * @return void
     */
    function SetAdvertLocation($horz, $vert, $width)
    {
    }

    /**
     *Устанавливает данные вашей учетной записи AdMob для использования в видеообъявлениях с вознаграждением. После вызова этой команды будет предпринята попытка кэшировать видео награды, чтобы вы могли сразу же отобразить его позже. Вы можете проверить ход выполнения этой задачи с помощью GetRewardAdLoadedAdMob. Видео AdMob reward в настоящее время поддерживаются iOS и Android.
     *
     * @param string $szID Идентификатор рекламного блока, предоставленный AdMob (не идентификатор приложения).
     * @return void
     */
    function SetAdMobRewardAdDetails($szID)
    {
    }

    /**
     *Размещает рекламу, созданную с помощью CreateAdvert, где-то на экране и пытается масштабировать ее до определенной ширины. Поскольку реклама будет иметь свое собственное соотношение сторон, высота будет рассчитываться исходя из ширины. Это обеспечивает грубое позиционирование, позволяя вам выбирать между левым, центрированным или правым выравниванием для горизонтального и вертикального положений. Это не гарантирует работу со всеми поставщиками рекламы, в настоящее время только Inneractive может масштабировать рекламу до определенной ширины.
     *
     * @param int $horz Горизонтальное положение объявления: 0=слева, 1=в центре, 2=справа
     * @param int $vert Вертикальное положение объявления, 0=верх, 1=центр, 2=низ
     * @param float $offsetx когда horz равен 0 или 2 это значение смещает объявление от указанного края
     * @param float $offsety когда vert равен 0 или 2 это значение смещает объявление от указанного края
     * @param float $width Желаемая ширина объявления, она будет масштабирована до этой ширины
     * @return void
     */
    function SetAdvertLocationEx($horz, $vert, $offsetx, $offsety, $width)
    {
    }

    /**
     *Определяет, будут ли объявления AdMob тестовыми или платными. Это должно быть вызвано перед SetAdMobDetails, чтобы убедиться, что все объявления являются тестовыми. По умолчанию будет показываться платная реклама. Обратите внимание, что если вы показываете платные объявления во время тестирования, вы не должны нажимать на них, иначе ваша учетная запись AdMob может быть приостановлена.
     *
     * @param int $mode 0 = показывать платные объявления, 1 = показывать тестовые объявления
     * @return void
     */
    function SetAdMobTesting($mode)
    {
    }

    /**
     *Устанавливает данные учетной записи AdMob для использования в баннерной рекламе и интерстициальной (полноэкранной) рекламе. Обратите внимание, что это поддерживает только одно или другое, вы можете установить либо ИДЕНТИФИКАТОР рекламного блока баннера, либо идентификатор интерстициального рекламного блока, но не оба одновременно. После вызова этой команды будет предпринята попытка кэшировать интерстициал, чтобы вы могли сразу же отобразить его позже. Вы можете проверить ход выполнения этой задачи с помощью GetFullscreenAdvertLoadedAdMob. Реклама AdMob в настоящее время поддерживается iOS и Android.
     *
     * @param string $szID Идентификатор рекламного блока, предоставленный AdMob.
     * @return void
     */
    function SetAdMobDetails($szID)
    {
    }

    /**
     *Устанавливает рейтинг контента для рекламы AdMob, если ваше приложение ориентировано на детей. Это должно быть вызвано перед SetAdMobDetails
     *
     * @param int $rating 0 = нормальная реклама, 1 = безопасная для детей реклама
     * @return void
     */
    function SetAdMobChildRating($rating)
    {
    }

    /**
     *Установите целевую скорость для твист-соединения. Должен быть вызван в цикле. Сначала включите соединение с Set3DPhysicsTwistJointMotorIsEnabled()
     *
     * @param int $jointID Id соединения
     * @param int $rotationVec3ID Идентификатор вектора, который имеет цель вращения для двигателя твист-сустава.
     * @return void
     */
    function Set3DPhysicsTwistJointMotorRotationTarget($jointID, $rotationVec3ID)
    {
    }

    /**
     *Устанавливает статику тряпичной куклы, изменяя массу всех костей тряпичной куклы на ноль.
     *
     * @param int $objID идентификатор объекта
     * @param int $isStatic 1 = истина, 0 = ложь
     * @return void
     */
    function Set3DphysicsRagdollStatic($objID, $isStatic)
    {
    }

    /**
     *Включает двигатель с твист-соединением.
     *
     * @param int $jointID идентификатор СОЕДИНЕНИЯ
     * @param int $isEnabled 1 = истина , 0 = ложь
     * @return void
     */
    function Set3DPhysicsTwistJointMotorIsEnabled($jointID, $isEnabled)
    {
    }

    /**
     *Устанавливает максимальное значение импульса двигателя для Твист-соединения. Сначала включите соединение с Set3DPhysicsTwistJointMotorIsEnabled()
     *
     * @param int $jointID Id соединения
     * @param float $maxImpulse Максимальный импульс, который должен быть приложен к двигателю сустава.
     * @return void
     */
    function Set3DPhysicsTwistJointMaxMotorImpulse($jointID, $maxImpulse)
    {
    }

    /**
     *Задает вращение статической плоскости
     *
     * @param int $planeID статический идентификатор плоскости
     * @param float $angX Угол вращения мира X.
     * @param float $angY Угол поворота мира Y.
     * @param float $angZ Угол поворота мира Z.
     * @return void
     */
    function Set3DPhysicsStaticPlaneRotation($planeID, $angX, $angY, $angZ)
    {
    }

    /**
     *Устанавливает целевую линейную скорость двигателя для физического ползункового соединения.
     *
     * @param int $jointID Id соединения
     * @param float $linearMotorVelocity Линейная скорость, которая должна быть приложена к совместному двигателю.
     * @return void
     */
    function Set3DPhysicsSliderJointTargetLinearMotorVelocity($jointID, $linearMotorVelocity)
    {
    }

    /**
     *Установите линейный двигатель с приводом от ползунковых соединений в положение включено.
     *
     * @param int $jointID Id соединения
     * @param int $isEnabled 1 = истина, 0 = ложь
     * @return void
     */
    function Set3DPhysicsSliderJointPoweredLinearMotorIsEnabled($jointID, $isEnabled)
    {
    }

    /**
     *Устанавливает двигатель шарниров на максимальное линейное усилие.
     *
     * @param int $jointID Id соединения
     * @param float $maxLinearForce Максимальная линейная сила, приложенная к шарнирному двигателю.
     * @return void
     */
    function Set3DPhysicsSliderJointMaxLinearMotorForce($jointID, $maxLinearForce)
    {
    }

    /**
     *Устанавливает пороги сна для создаваемой тряпичной куклы. Значения по умолчанию должны быть хороши для большинства ситуаций. Звоните только в том случае, если вы хотите изменить эти значения. Должен быть вызван до Finalize3DPhysicsRagDoll()
     *
     * @param float $linear Значение по умолчанию-1.8
     * @param float $angular Значение по умолчанию-2.8
     * @return void
     */
    function Set3DPhysicsRagdollSleepingThresholds($linear, $angular)
    {
    }

    /**
     *Устанавливает время деактивации создаваемой тряпичной куклы. Значения по умолчанию должны быть хороши для большинства ситуаций. Звоните только в том случае, если вы хотите изменить эти значения. Должен быть вызван перед Finalize3DPhysicsRagDoll()
     *
     * @param float $time Значение по умолчанию-0.8
     * @return void
     */
    function Set3DPhysicsRagdollDeactivationTime($time)
    {
    }

    /**
     *Задает положение статической плоскости
     *
     * @param int $planeID статический идентификатор плоскости
     * @param float $posX Положение мира X.
     * @param float $posY Положение в мире Y.
     * @param float $posZ Положение мира Z.
     * @return void
     */
    function Set3DPhysicsStaticPlanePosition($planeID, $posX, $posY, $posZ)
    {
    }

    /**
     *Поддерживает физическую тряпичную куклу в активном состоянии. Не допускает автоматической деактивации, когда рэгдолл приходит в состояние покоя.
     *
     * @param int $objID идентификатор объекта
     * @param int $isDisabled 1 = истина, 0 = ложь
     * @return void
     */
    function Set3DPhysicsRagdollDeactivation($objID, $isDisabled)
    {
    }

    /**
     *Устанавливает демпфирование для создаваемой тряпичной куклы. Значения по умолчанию должны быть хороши для большинства ситуаций. Звоните только в том случае, если вы хотите изменить эти значения. Должен быть вызван перед Finalize3DPhysicsRagDoll()
     *
     * @param float $linear Значение по умолчанию-0,08
     * @param float $angular Значение по умолчанию-0.95
     * @return void
     */
    function Set3DPhysicsRagdollDamping($linear, $angular)
    {
    }

    /**
     *Показывает объекты кости тряпичной куклы и скрывает объект.
     *
     * @param int $objID идентификатор объекта
     * @param int $isVisible 1 = истина, 0 = ложь
     * @return void
     */
    function Set3DPhysicsRagdollBonesVisible($objID, $isVisible)
    {
    }

    /**
     *Устанавливает линейные пределы для ползункового соединения. Чтобы разблокировать соединение, установите нижний предел больше верхнего.
     *
     * @param int $jointID Id соединения
     * @param float $lowerLimit Нижний предел
     * @param float $upperLimit Верхний предел
     * @return void
     */
    function Set3DPhysicsJointSliderLinearLimits($jointID, $lowerLimit, $upperLimit)
    {
    }

    /**
     *Устанавливает угловые пределы для ползункового соединения. Чтобы разблокировать соединение, установите нижний предел больше верхнего.
     *
     * @param int $jointID Id соединения
     * @param float $lowerLimit Нижний предел в градусах
     * @param float $upperLimit Верхний предел в градусах
     * @return void
     */
    function Set3DPhysicsJointSliderAngularLimits($jointID, $lowerLimit, $upperLimit)
    {
    }

    /**
     *Устанавливает угловые пределы для шарнирного соединения в градусах. Чтобы разблокировать соединение, установите нижний предел больше верхнего.
     *
     * @param int $jointID Id соединения
     * @param float $minAng Минимальный угол в градусах.
     * @param float $maxAng Максимальный угол в градусах.
     * @return void
     */
    function Set3DPhysicsJointHingeLimits($jointID, $minAng, $maxAng)
    {
    }

    /**
     *Устанавливает порог разрушения соединения.
     *
     * @param int $jointID Id соединения
     * @param int $isEnabled 0 отключит соединение
     * @return void
     */
    function Set3DPhysicsJointEnabled($jointID, $isEnabled)
    {
    }

    /**
     *Устанавливает угловые пределы для соединения закрутки конуса в градусах. Чтобы разблокировать определенное значение установите его на 360
     *
     * @param int $jointID Id соединения
     * @param float $swingSpan1 угол в градусах
     * @param float $swingSpan2 угол в градусах
     * @param float $twistSpan угол в градусах
     * @return void
     */
    function Set3DPhysicsJointConeTwistLimits($jointID, $swingSpan1, $swingSpan2, $twistSpan)
    {
    }

    /**
     *Установите целевую скорость для шарнирного соединения. Должен быть вызван в цикле. Сначала включите соединение с Set3DPhysicsHingeJointMotorIsEnabled()
     *
     * @param int $jointID Id соединения
     * @param float $targetVelocity Целевая скорость, которую нужно использовать.
     * @return void
     */
    function Set3DPhysicsHingeJointMotorVelocity($jointID, $targetVelocity)
    {
    }

    /**
     *Включает мотор шарнирного соединения.
     *
     * @param int $jointID Id соединения
     * @param int $isEnabled 1 = истина , 0 = ложь
     * @return void
     */
    function Set3DPhysicsHingeJointMotorIsEnabled($jointID, $isEnabled)
    {
    }

    /**
     *Устанавливает порог разрушения соединения.
     *
     * @param int $jointID Id соединения
     * @param float $breakThreshold пороговое значение разрыва
     * @return void
     */
    function Set3DPhysicsJointBreakingThreshold($jointID, $breakThreshold)
    {
    }

    /**
     *Устанавливает максимальное значение импульса двигателя для шарнирного соединения. Сначала включите соединение с Set3DPhysicsHingeJointMotorIsEnabled()
     *
     * @param int $jointID Id соединения
     * @param float $maxImpulse Максимальное значение импульса, которое должно быть приложено к совместному двигателю.
     * @return void
     */
    function Set3DPhysicsHingeJointMaxMotorImpulse($jointID, $maxImpulse)
    {
    }

    /**
     *Устанавливает высоту, на которую контроллер может подниматься и опускаться.
     *
     * @param int $objID идентификатор объекта
     * @param float $stepHeight Высота шага в мировых ценностях.
     * @return void
     */
    function Set3DPhysicsCharacterControllerStepHeight($objID, $stepHeight)
    {
    }

    /**
     *Устанавливает гравитацию мира физики, гравитация измеряется в метрах в секунду. По умолчанию гравитация установлена на ( 0.0, -10.0, 0.0 ). Вам нужно только вызвать эту команду, если вам нужно изменить настройки по умолчанию.
     *
     * @param float $x Величина силы тяжести по оси Х в метрах в секунду.
     * @param float $y Величина силы тяжести по оси Y в метрах в секунду.
     * @param float $z Величина силы тяжести по оси Z в метрах в секунду.
     * @return void
     */
    function Set3DPhysicsGravity($x, $y, $z)
    {
    }

    /**
     *Устанавливает гравитацию мира физики, гравитация измеряется в метрах в секунду. По умолчанию гравитация установлена на ( 0.0, -10.0, 0.0 ). Вам нужно только вызвать эту команду, если вам нужно изменить настройки по умолчанию.
     *
     * @param int $vectorID Идентификатор вектора для использования
     * @return void
     */
    function Set3DPhysicsGravity($vectorID)
    {
    }

    /**
     *Перемещает Контроллер в новые переданные координаты. Не размещайте контроллер внутри другого физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @param float $posX Новая координата X
     * @param float $posY Новая координата Y
     * @param float $posZ Новая координата Z
     * @return void
     */
    function Set3DPhysicsCharacterControllerPosition($objID, $posX, $posY, $posZ)
    {
    }

    /**
     *установите максимальный наклон в угловых градусах, на которые может подняться контроллер.
     *
     * @param int $objID идентификатор объекта
     * @param float $maxSlopeDegress Значение по умолчанию-45,0 градуса.
     * @return void
     */
    function Set3DPhysicsCharacterControllerMaxSlope($objID, $maxSlopeDegress)
    {
    }

    /**
     *Установите скорость, с которой контроллер перемещается вверх при вызове прыжка.
     *
     * @param int $objID идентификатор объекта
     * @param float $jumpSpeed Значение по умолчанию-10.0
     * @return void
     */
    function Set3DPhysicsCharacterControllerJumpSpeed($objID, $jumpSpeed)
    {
    }

    /**
     *Устанавливает гравитацию для контроллера символов. Эта гравитация не то же самое, что физическая мировая гравитация. и влияет только на индивидуальный характер контроллера.
     *
     * @param int $objID идентификатор объекта
     * @param float $gravity Значение по умолчанию равно (9,8 * 3)
     * @return void
     */
    function Set3DPhysicsCharacterControllerGravity($objID, $gravity)
    {
    }

    /**
     *Устанавливает скорость, с которой контроллер будет падать.
     *
     * @param int $objID идентификатор объекта
     * @param float $fallSpeed Значение по умолчанию-55,0, что является конечной скоростью скай-дайвера в метрах в секунду.
     * @return void
     */
    function Set3DPhysicsCharacterControllerFallSpeed($objID, $fallSpeed)
    {
    }

    /**
     *Устанавливает, рисуются ли испускаемые частицы. Установите значение 1, чтобы показать частицы, и 0, чтобы скрыть их. Частицы все равно будут обновляться, пока они скрыты, вы можете остановить обновление частиц с помощью Set3DParticlesActive
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $visible 1=показать, 0=скрыть
     * @return void
     */
    function Set3DParticlesVisible($ID, $visible)
    {
    }

    /**
     *Устанавливает минимальный и максимальный множитель, который будет влиять на испускаемые частицы. Это может быть использовано для обеспечения некоторого изменения скорости при испускании частиц.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $v1 Минимальный множитель скорости.
     * @param float $v2 Множитель максимальной скорости.
     * @return void
     */
    function Set3DParticlesVelocityRange($ID, $v1, $v2)
    {
    }

    /**
     *Установите прозрачность частиц на определенную настройку с выбором без прозрачности, альфа-прозрачности и аддитивного смешивания. По умолчанию частицы создаются с альфа-прозрачностью.
     *
     * @param int $ID Идентификатор излучателя частиц для изменения.
     * @param int $mode Режим прозрачности для этих частиц: 0=выкл., 1=альфа-прозрачность, 2=аддитивное смешивание
     * @return void
     */
    function Set3DParticlesTransparency($ID, $mode)
    {
    }

    /**
     *Задает область вокруг излучателя, в которой могут появиться новые частицы. Эти значения относятся к положению эмиттера, например, зона 0,0,0,0 будет означать, что все частицы начинаются в точке положения эмиттера. Зона -10 в x и +10 x, где y и z равны 0 (-10,0,0,10,0,0), создаст линию, центрированную на положении излучателя, вдоль которой будут случайным образом появляться частицы. Зона коробки, где x, y и z не равны нулю, означала бы, что частицы могут начинаться в любой точке внутри коробки.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x1 Координата x верхнего левого угла стартовой зоны.
     * @param float $y1 Координата y верхнего левого угла стартовой зоны.
     * @param float $z1 z-координата верхнего левого угла стартовой зоны.
     * @param float $x2 Координата x в правом нижнем углу стартовой зоны.
     * @param float $y2 Координата y в правом нижнем углу стартовой зоны.
     * @param float $z2 Координата z в правом нижнем углу стартовой зоны.
     * @return void
     */
    function Set3DParticlesStartZone($ID, $x1, $y1, $z1, $x2, $y2, $z2)
    {
    }

    /**
     *Задает размер всех частиц в мировых координатах. Установка большого количества частиц на большой размер будет плохо работать на мобильных устройствах с низкой скоростью заполнения (количество пикселей, которые он может нарисовать в секунду).
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $size Размер частиц
     * @return void
     */
    function Set3DParticlesSize($ID, $size)
    {
    }

    /**
     *Устанавливает положение 3D-излучателя частиц. Это положение, из которого будут появляться новые частицы, и не влияет на частицы, которые уже видны.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x Новая координата x для излучателя в мировых координатах.
     * @param float $y Новая координата y для излучателя в мировых координатах.
     * @param float $z Новая координата z для излучателя в мировых координатах.
     * @return void
     */
    function Set3DParticlesPosition($ID, $x, $y, $z)
    {
    }

    /**
     *Устанавливает максимальное количество частиц, которые будут испускаться. Если это значение равно -1, то число бесконечно. Излучатель будет вести подсчет общего количества частиц, которые он испускает, и остановится, когда будет достигнут предел. Чтобы проверить, достиг ли излучатель своего предела, используйте Get3DParticlesMaxReached. Чтобы сбросить счетчик и заставить его снова начать излучать, используйте Reset3DParticleCount.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $max Максимальное количество испускаемых частиц
     * @return void
     */
    function Set3DParticlesMax($ID, $max)
    {
    }

    /**
     *Устанавливает время жизни частиц в секундах после их испускания. После того, как частицы будут живы в течение заданного количества секунд, они исчезнут. Это одно из двух значений, влияющих на количество генерируемых частиц, другое-Set3DParticlesFrequency. Максимальное количество частиц, которое может быть на экране в любой момент времени, - это freq*life, причем freq-это количество частиц, испускаемых в секунду. Это значение не зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время в секундах, в течение которого частица видна.
     * @return void
     */
    function Set3DParticlesLife($ID, $time)
    {
    }

    /**
     *Устанавливает изображение, которое будет использоваться для каждой частицы.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $imageID Идентификатор изображения, используемого для испускаемых частиц.
     * @return void
     */
    function Set3DParticlesImage($ID, $imageID)
    {
    }

    /**
     *Задает частоту генерации новых частиц. Значение freq указывает, сколько частиц должно быть произведено в секунду, это не зависит от частоты кадров. Это одно из двух значений, влияющих на количество генерируемых частиц, другое-SetParticlesLife. Максимальное количество частиц, которое может быть на экране в любой момент времени, - это freq*life, причем жизнь-это количество секунд, в течение которых частица живет, прежде чем исчезнуть.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $freq Скорость образования новых частиц в частицах в секунду.
     * @return void
     */
    function Set3DParticlesFrequency($ID, $freq)
    {
    }

    /**
     *Задает диапазон направления в градусах, который частица может выбрать при первом запуске. Это берет базовое направление, заданное с помощью Set3DParticlesDirection, и регулирует его на случайную величину между 0 и углом 1/2 градуса в одном направлении и углом 2/2 градуса в перпендикулярном направлении. Например, угол 1, равный 0, и угол 2, равный 0, означают, что все новые частицы следуют точно в указанном ранее направлении. Угол 1, равный 360, и угол 2, равный 0, означали бы, что частицы могут двигаться в любом направлении по плоскому кругу, в то время как угол 1, равный 360, и угол 2, равный 180, означали бы, что частицы будут двигаться в любом направлении по сфере. Углы образуют пирамиду, выровненную с направлением излучателя частиц, указанным ранее. Угол 1 должен быть между 0 и 360, угол 2 должен быть между 0 и 180.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $angle1 Диапазон изменения, который частица может выбрать из направления излучателя.
     * @param float $angle2 Перпендикулярный диапазон изменения, который частица может выбрать из направления излучателя.
     * @return void
     */
    function Set3DParticlesDirectionRange($ID, $angle1, $angle2)
    {
    }

    /**
     *Задает начальное направление новых частиц, когда они выходят из излучателя. Это можно использовать вместе с командой Set3DParticlesDirectionRange, чтобы установить диапазон отклонения от этого начального направления, которое могут выбрать новые частицы. Это также устанавливает начальную скорость частиц, принимая длину вектора за единицы в секунду. Например, если начальное направление vx=10, vy=-15, vz=0, частицы начнут двигаться в направлении X со скоростью 10 единиц в секунду и в направлении Y со скоростью 15 единиц в секунду и будут продолжать эту скорость движения в течение всей своей жизни, если на них не будут влиять силы, добавленные с помощью Add3DParticlesForce.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $vx Направление x, в котором частицы будут двигаться изначально.
     * @param float $vy Направление y, в котором частицы будут двигаться изначально.
     * @param float $vz Направление z, в котором частицы будут двигаться изначально.
     * @param float $roll Угол поворота излучателя в заданном направлении
     * @return void
     */
    function Set3DParticlesDirection($ID, $vx, $vy, $vz, $roll)
    {
    }

    /**
     *Устанавливает режим интерполяции для изменения цвета. Цвета могут быть установлены в определенные моменты жизни частицы с помощью Add3DParticlesColorKeyFrame, и частица либо смешается между этими цветами (плавная интерполяция), либо быстро изменится, когда достигнет следующего изменения цвета (без интерполяции).
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $mode 1=плавная интерполяция, 0=отсутствие интерполяции
     * @return void
     */
    function Set3DParticlesColorInterpolation($ID, $mode)
    {
    }

    /**
     *Устанавливает, обновляются ли испускаемые частицы каждый кадр. Установите значение 1, чтобы обновить частицы как обычно, и 0, чтобы приостановить их. Частицы будут продолжать быть видимыми, когда остановятся. Чтобы скрыть частицы, используйте Set3DParticlesVisible.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $active 1=нормально, 0=пауза
     * @return void
     */
    function Set3DParticlesActive($ID, $active)
    {
    }

    /**
     *Отправит строку на удаленное соединение. Обратите внимание, что данные отправляются не сразу, для их отправки необходимо вызвать FlushSocket. Если вы отправляете строку в приложение, не являющееся AGK, то строка строится из значения длины 4 байта, за которым следует X байт строковых данных, где X-значение длины. Строка не завершается нулем. Возвращает 1, если строка была успешно записана в буфер, 0, если сокет отключен.
     *
     * @param int $socketID Идентификатор сокета для записи
     * @param string $value Значение для отправки
     * @return int
     */
    function SendSocketString($socketID, $value)
    {
    }

    /**
     *Отправляет сетевое сообщение, созданное с помощью CreateNetworkMessage, на указанный удаленный IP-адрес и порт. Вы должны указать прослушиватель UDP для использования в качестве исходного IP-адреса и порта. Эта функция удалит указанный идентификатор сообщения.
     *
     * @param int $listenerID Идентификатор прослушивателя для использования в качестве исходного IP-адреса и порта
     * @param int $messageID Идентификатор отправляемого сетевого сообщения
     * @param string $toIP IP-адрес для отправки сообщения
     * @param int $toPort Порт для отправки сообщения
     * @return void
     */
    function SendUDPNetworkMessage($listenerID, $messageID, $toIP, $toPort)
    {
    }

    /**
     *Отправит 4-байтовое целое число на удаленное соединение. Обратите внимание, что данные отправляются не сразу, для их отправки необходимо вызвать FlushSocket. Возвращает 1, если целое число было успешно записано в буфер, 0, если сокет отключен.
     *
     * @param int $socketID Идентификатор сокета для записи
     * @param int $value Значение для отправки
     * @return int
     */
    function SendSocketInteger($socketID, $value)
    {
    }

    /**
     *Отправит 4-байтовый поплавок на удаленное соединение. Обратите внимание, что данные отправляются не сразу, для их отправки необходимо вызвать FlushSocket. Возвращает 1, если float был успешно записан в буфер, 0, если сокет отключен.
     *
     * @param int $socketID Идентификатор сокета для записи
     * @param float $value Значение для отправки
     * @return int
     */
    function SendSocketFloat($socketID, $value)
    {
    }

    /**
     *Отправка данных на смарт-часы в фоновом режиме, если приложение watch в данный момент не открыто, сообщение будет поставлено в очередь и получено приложением watch при следующем открытии. Сообщение должно быть в виде строки JSON, например "{"label":"my message"}". Вы также можете использовать тип с функцией .toJSON() для создания строки JSON. Приложение watch получит его как NSDictionary с метками в качестве ключей.  В настоящее время работает только на iOS.
     *
     * @param string $szJson Строка JSON, содержащая сообщение для отправки в приложение watch.
     * @return void
     */
    function SendSmartWatchData($szJson)
    {
    }

    /**
     *Отправит один байт в диапазоне от -128 до 127 на удаленное соединение. Обратите внимание, что данные отправляются не сразу, для их отправки необходимо вызвать FlushSocket. Возвращает 1, если байт был успешно записан в буфер, 0, если сокет отключен.
     *
     * @param int $socketID Идентификатор сокета для записи
     * @param int $value Значение для отправки
     * @return int
     */
    function SendSocketByte($socketID, $value)
    {
    }

    /**
     *Отправляет созданное сетевое сообщение данному клиенту в данной сети. Используйте идентификатор клиента 0 для отправки всем подключенным клиентам (кроме отправителя), в противном случае, если идентификатор клиента не существует, будет сгенерирована ошибка. Эта функция удалит указанный идентификатор сообщения.
     *
     * @param int $iNetID Идентификатор сети, по которой будет отправлено сообщение.
     * @param int $toClient Идентификатор клиента, которому нужно отправить сообщение, 0 для отправки всем.
     * @param int $iMsgID Идентификатор отправляемого сообщения.
     * @return void
     */
    function SendNetworkMessage($iNetID, $toClient, $iMsgID)
    {
    }

    /**
     *Отправьте запрос на сервер, указанный в SetHTTPHost, например, если запрашивается http: www.thegamecreators.com/index.php szServerFile должен быть "index.php". Эта команда немедленно возвращается и ждет ответа сервера в фоновом режиме. Вы можете проверить статус ответа с помощью GetHTTPResponseReady и, когда он будет готов, получить ответ с помощью GetHTTPResponse.
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после доменной части URL-адреса.
     * @return int
     */
    function SendHTTPRequestASync($iHTTP, $szServerFile)
    {
    }

    /**
     *Отправьте запрос на сервер, указанный в SetHTTPHost, например, если запрашивается http: www.thegamecreators.com/index.php szServerFile должен быть "index.php". Эта команда немедленно возвращается и ждет ответа сервера в фоновом режиме. Вы можете проверить статус ответа с помощью GetHTTPResponseReady и, когда он будет готов, получить ответ с помощью GetHTTPResponse.
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после доменной части URL-адреса.
     * @param string $szPostData Необработанные данные post для отправки на сервер обратите внимание, что & и =
     * @return int
     */
    function SendHTTPRequestASync($iHTTP, $szServerFile, $szPostData)
    {
    }

    /**
     *Отправьте запрос на сервер, указанный в SetHTTPHost (), например, если запрашивается http: www.thegamecreators.com/index.php szServerFile должен быть "index.php". Эта команда ожидает ответа сервера и возвращает ответ сервера. Если вы используете уровень 2, вы должны удалить этот ответ, когда закончите с ним. Не работает при экспорте в HTML5
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после доменной части URL-адреса.
     * @return string
     */
    function SendHTTPRequest($iHTTP, $szServerFile)
    {
    }

    /**
     *Отправьте запрос на сервер, указанный в SetHTTPHost (), например, если запрашивается http: www.thegamecreators.com/index.php szServerFile должен быть "index.php". Эта команда ожидает ответа сервера и возвращает ответ сервера. Если вы используете уровень 2, вы должны удалить этот ответ, когда закончите с ним. Не работает при экспорте в HTML5
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после доменной части URL-адреса.
     * @param string $szPostData Необработанные данные post для отправки на сервер обратите внимание, что & и =
     * @return string
     */
    function SendHTTPRequest($iHTTP, $szServerFile, $szPostData)
    {
    }

    /**
     *Отправьте файл на сервер, указанный в SetHTTPHost, например, если запрашивается http: www.thegamecreators.com/index.php szServerFile должен быть "index.php". Также позволяет отправлять POST-данные на сервер, которые могут включать переменные или файловые данные, например "myvar=5&var2=test". Эта команда немедленно возвращается и ждет ответа сервера в фоновом режиме. Вы можете проверить статус ответа с помощью GetHTTPResponseReady и, когда он будет готов, получить ответ с помощью GetHTTPResponse. Вы можете проверить ход загрузки с помощью GetHTTPFileProgress. Не работает при экспорте в HTML5
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после доменной части URL-адреса.
     * @param string $szPostData Необработанные данные post для отправки на сервер обратите внимание, что & и =
     * @param string $szLocalFile Имя файла, который вы хотите отправить на сервер.
     * @return int
     */
    function SendHTTPFile($iHTTP, $szServerFile, $szPostData, $szLocalFile)
    {
    }

    /**
     *Стремится к заданному значению времени, если файл воспроизводится в данный момент, то он немедленно продолжит воспроизведение оттуда. Если файл в данный момент не воспроизводится, то он вступит в силу после следующего вызова PlayMusicOGG. Параметр mode позволяет выбрать, следует ли искать на основе абсолютного или относительного значения времени. Абсолют будет стремиться к этой позиции в файле, в то время как относительный будет искать относительно текущей позиции.
     *
     * @param int $musicID Идентификатор музыкального файла для поиска
     * @param float $seconds Время в секундах, чтобы стремиться к
     * @param int $mode 0 для абсолютного поиска, 1 для относительного поиска
     * @return void
     */
    function SeekMusicOGG($musicID, $seconds, $mode)
    {
    }

    /**
     *Ищет воспроизводимую в данный момент музыку в заданном количестве секунд, либо относительно текущей позиции, либо в абсолютном положении. Например, если музыкальная дорожка имеет длину 60 секунд и в настоящее время находится в положении 10 секунд (она воспроизводила 10 секунд музыки), поиск абсолютного значения 3 секунды вернет ее обратно к 3 секундам после начала музыкальной дорожки. Используя относительное значение 3, вы добавите 3 секунды к текущей позиции, взяв ее до 13.
     *
     * @param float $seconds Количество секунд для поиска.
     * @param int $mode 0 для использования абсолютного положения, 1 для использования относительного положения
     * @return void
     */
    function SeekMusic($seconds, $mode)
    {
    }

    /**
     *Преобразует координату Y экрана в мировую координату Y на основе текущего смещения и масштабирования вида. Когда SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен на 20 пикселей вниз, ввод при 0,0 на экране будет выглядеть 0,20 в мире.
     *
     * @param float $y Экран Y-координата для преобразования.
     * @return float
     */
    function ScreenToWorldY($y)
    {
    }

    /**
     *Преобразует координату X экрана в мировую координату X на основе текущего смещения и масштабирования вида. Когда SetViewOffset равен 0,0, а SetViewZoom равен 1,0, координаты мира и экрана совпадают. Например, когда вид смещен на 20 пикселей вправо, ввод при 0,0 на экране появится 20,0 в мире.
     *
     * @param float $x Экран X координата для преобразования.
     * @return float
     */
    function ScreenToWorldX($x)
    {
    }

    /**
     *Возвращает среднее значение кадров в секунду на основе времени рендеринга последних нескольких кадров. Чтобы получить точное время, затраченное на последний кадр, вы можете вызвать GetFrameTime.
     *
     * @return float
     */
    function ScreenFPS()
    {
    }

    /**
     *Сохраняет звуковой файл в папку записи приложения.
     *
     * @param int $iID Идентификатор звука для сохранения.
     * @param string $sFilename Имя файла, которое будет использоваться для звукового файла, рекомендуется заканчивать на .wav.
     * @return void
     */
    function SaveSound($iID, $sFilename)
    {
    }

    /**
     *Сохраняет форму столкновения объектов в файл .bcs (Bullet Collision Shape). Возвращает true, если это удалось.
     *
     * @param int $objID идентификатор объекта
     * @param string $fileName имя файла в виде строки.
     * @return int
     */
    function SaveObjectShape($objID, $fileName)
    {
    }

    /**
     *Сохраняет переменную, чтобы к ней можно было получить доступ из других приложений. Это работает только на платформах iOS, Android 10 и ниже, а также HTML5. Приложения могут совместно использовать переменную только в том случае, если они отвечают определенным требованиям, основанным на платформе. В iOS приложения должны быть созданы одной и той же учетной записью разработчика Apple и иметь одну и ту же группу приложений, добавленную к их идентификаторам приложений на портале разработчиков Apple. После этого вам нужно будет заново создать профиль подготовки. В iOS вы должны сообщить AGK, что такое группа приложений, используя SetSharedVariableAppGroup. На Android 10 и ниже приложения должны иметь разрешение WRITE_EXTERNAL_STORAGE и иметь одно и то же имя пакета до последней точки. Например, com.mycompany.mygroup.myapp1 и com.mycompany.mygroup.myapp2 смогут совместно использовать переменные. На Android общие переменные записываются в доступное пользователю место, поэтому имейте в виду, что пользователи могут читать и/или редактировать сохраненные вами переменные. На Android 11 или выше эта команда не будет работать, так как приложения ограничены в записи в общие места. В HTML приложения должны размещаться в одном домене, значения хранятся в виде файлов cookie. Переменные идентифицируются по имени, поэтому использование SaveSharedVariable("username", "Alice") установит переменную с именем "username" в значение "Alice". Затем это может быть прочитано другими приложениями с помощью LoadSharedVariable( "username",""), Если два приложения сохраняют разные значения в одном и том же имени переменной, то значение будет перезаписано и будет доступно только самое последнее значение. Значения переменных будут сохраняться даже в том случае, если приложение будет удалено и повторно установлено. Вы не должны использовать эту команду для хранения любой конфиденциальной информации, такой как пароли, в виде обычного текста. В iOS длина имени переменной плюс длина идентификатора вашего приложения до последней точки (например, com.mycompany.mygroup) должна быть меньше 58.
     *
     * @param string $varName Имя, используемое для идентификации этой переменной
     * @param string $varValue Значение, которое нужно сохранить в этой переменной
     * @return void
     */
    function SaveSharedVariable($varName, $varValue)
    {
    }

    /**
     *Еще не функционирует.
     *
     * @param int $objID Идентификатор объекта для сохранения.
     * @param string $szFilename Имя файла, которое будет использоваться для нового файла.
     * @return void
     */
    function SaveObject($objID, $szFilename)
    {
    }

    /**
     *Сохраняет изображение с заданным идентификатором в указанное имя файла. Файл будет помещен в папку записи приложения в том месте, которое в данный момент указано SetFolder. Кроме того, вы можете указать путь, начинающийся с прямой косой черты, чтобы выбрать местоположение из корня папки записи, игнорируя любую папку SetFolder. Рекомендуется использовать расширение ".png" в конце имени файла для сохранения в формате PNG. Некоторые платформы могут поддерживать дополнительные расширения, такие как ".jpg", но это не гарантирует работу на всех платформах.
     *
     * @param int $iImageIndex Идентификатор изображения для изменения.
     * @param string $filename Имя файла сохраненного изображения
     * @return void
     */
    function SaveImage($iImageIndex, $filename)
    {
    }

    /**
     *Округляет поплавок до ближайшего целого числа (положительного или отрицательного).
     *
     * @param float $a Значение округлить.
     * @return int
     */
    function Round($a)
    {
    }

    /**
     *Вращает указанный объект вокруг своей локальной оси Z, то есть если бы объект был самолетом, эта команда заставила бы его сделать бочкообразный крен независимо от того, в каком направлении он был обращен.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота по локальной оси Z в градусах, положительные крены против часовой стрелки, отрицательные крены по часовой стрелке.
     * @return void
     */
    function RotateObjectLocalZ($objID, $amount)
    {
    }

    /**
     *Запускает внешний исполняемый файл, который не зависит от этого приложения. Он вернет идентификатор, который вы можете использовать, чтобы проверить, работает ли приложение по-прежнему или, в крайнем случае, завершить его работу. Если это не удастся, он вернет 0. В настоящее время работает только на Windows, Mac, Linux и Raspberry Pi.
     *
     * @param string $szFilename Имя файла нового приложения, доступ к которому осуществляется так же, как и к любому другому файлу в AGK
     * @param string $szParameters Необязательные параметры командной строки для передачи в приложение или пустая строка
     * @return int
     */
    function RunApp($szFilename, $szParameters)
    {
    }

    /**
     *Вращает указанный объект вокруг его локальной оси Y, то есть если бы объект был самолетом, эта команда заставила бы его поворачиваться влево и вправо независимо от того, в каком направлении он находится.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота по локальной оси Y в градусах, положительный поворот вправо, отрицательный поворот влево.
     * @return void
     */
    function RotateObjectLocalY($objID, $amount)
    {
    }

    /**
     *Вращает указанный объект вокруг глобальной оси Z. Представьте себе, что камера смотрит вниз по оси Z на объект со случайным вращением. Эта команда будет вращать объект влево и вправо относительно камеры независимо от того, в какую сторону он обращен.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота по глобальной оси Z в градусах, положительные крены против часовой стрелки, отрицательные крены по часовой стрелке.
     * @return void
     */
    function RotateObjectGlobalZ($objID, $amount)
    {
    }

    /**
     *Вращает указанный объект вокруг его локальной оси X, то есть, если бы объект был самолетом, эта команда заставила бы его наклоняться вверх и вниз независимо от того, в каком направлении он обращен.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота по локальной оси X в градусах, положительный смотрит вниз, отрицательный смотрит вверх.
     * @return void
     */
    function RotateObjectLocalX($objID, $amount)
    {
    }

    /**
     *Вращает указанный объект вокруг глобальной оси Y. Представьте себе, что камера смотрит вниз по оси Z на объект со случайным вращением. Эта команда повернет объект влево и вправо относительно камеры независимо от того, в какую сторону он обращен.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота по глобальной оси Y в градусах, положительный поворот вправо, отрицательный поворот влево.
     * @return void
     */
    function RotateObjectGlobalY($objID, $amount)
    {
    }

    /**
     *Вращает указанный объект вокруг глобальной оси X. Представьте себе, что камера смотрит вниз по оси Z на объект со случайным вращением. Эта команда будет наклонять объект вверх и вниз относительно камеры независимо от того, в какую сторону он обращен.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Угол поворота на глобальной оси X в градусах, положительный шаг вниз, отрицательный шаг вверх.
     * @return void
     */
    function RotateObjectGlobalX($objID, $amount)
    {
    }

    /**
     *Катит указанную кость вокруг своей локальной оси Z, то есть если бы кость была самолетом, эта команда заставила бы ее сделать бочкообразный крен независимо от того, в каком направлении она обращена.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param float $amount Угол поворота по локальной оси Z в градусах, положительные крены против часовой стрелки, отрицательные крены по часовой стрелке.
     * @return void
     */
    function RotateObjectBoneLocalZ($objID, $boneIndex, $amount)
    {
    }

    /**
     *Вращает указанную кость вокруг ее локальной оси X, то есть, если бы кость была самолетом, эта команда заставила бы ее наклоняться вверх и вниз независимо от того, в каком направлении она обращена.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param float $amount Угол поворота по локальной оси X в градусах, положительный смотрит вниз, отрицательный смотрит вверх.
     * @return void
     */
    function RotateObjectBoneLocalX($objID, $boneIndex, $amount)
    {
    }

    /**
     *Вращает указанную кость вокруг ее локальной оси Y, то есть, если бы кость была самолетом, эта команда заставила бы ее поворачиваться влево и вправо независимо от того, в каком направлении она обращена.
     *
     * @param int $objID Идентификатор объекта, содержащего кость.
     * @param int $boneIndex Индекс кости нужно модифицировать.
     * @param float $amount Угол поворота по локальной оси Y в градусах, положительный поворот вправо, отрицательный поворот влево.
     * @return void
     */
    function RotateObjectBoneLocalY($objID, $boneIndex, $amount)
    {
    }

    /**
     *Вращает указанную камеру вокруг своей локальной оси Z, то есть если бы камера была самолетом, эта команда заставила бы ее катиться влево и вправо независимо от того, в каком направлении она была обращена.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота по локальной оси Z в градусах, отрицательный-по часовой стрелке.
     * @return void
     */
    function RotateCameraLocalZ($cameraID, $amount)
    {
    }

    /**
     *Вращает указанную камеру вокруг своей локальной оси Y, то есть если бы камера была самолетом, эта команда заставила бы ее поворачиваться влево и вправо независимо от того, в каком направлении она обращена.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота по локальной оси Y в градусах, положительный поворот вправо, отрицательный поворот влево.
     * @return void
     */
    function RotateCameraLocalY($cameraID, $amount)
    {
    }

    /**
     *Вращает указанную камеру вокруг своей локальной оси X, то есть если бы камера была самолетом, эта команда заставила бы ее наклоняться вверх и вниз независимо от того, в каком направлении она обращена.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота по локальной оси X в градусах, положительный смотрит вниз, отрицательный смотрит вверх.
     * @return void
     */
    function RotateCameraLocalX($cameraID, $amount)
    {
    }

    /**
     *Вращает указанную камеру вокруг глобальной оси Z. Представьте себе, что вы смотрите на камеру, как если бы это был объект, расположенный на 0,0,0 и смотрящий в случайном направлении. Эта команда будет вращать его вокруг фиксированной оси Z, которая используется для определения положения всего в мире.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота на глобальной оси Z в градусах, отрицательный-по часовой стрелке.
     * @return void
     */
    function RotateCameraGlobalZ($cameraID, $amount)
    {
    }

    /**
     *Вращает указанную камеру вокруг глобальной оси Y. Представьте себе, что вы смотрите на камеру, как если бы это был объект, расположенный на 0,0,0 и смотрящий в случайном направлении. Эта команда повернет его вокруг неподвижной оси Y, той, которая используется для определения положения всего в мире.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота по глобальной оси Y в градусах, положительный поворот вправо, отрицательный поворот влево.
     * @return void
     */
    function RotateCameraGlobalY($cameraID, $amount)
    {
    }

    /**
     *Вращает указанную камеру вокруг глобальной оси X. Представьте себе, что вы смотрите на камеру, как если бы это был объект, расположенный на 0,0,0 и смотрящий в случайном направлении. Эта команда будет вращать его вокруг фиксированной оси X, которая используется для определения положения всего в мире.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Угол поворота на глобальной оси X в градусах, положительный шаг вниз, отрицательный шаг вверх.
     * @return void
     */
    function RotateCameraGlobalX($cameraID, $amount)
    {
    }

    /**
     *Вращает контроллер.
     *
     * @param int $objID идентификатор объекта
     * @param float $angle количество в градусах
     * @return void
     */
    function Rotate3DPhysicsCharacterController($objID, $angle)
    {
    }

    /**
     *Обрезает заданную строку, сохраняя наибольшее количество символов справа до заданного значения счетчика.
     *
     * @param string $strin Строка, которую нужно обрезать
     * @param int $count Количество символов, которые нужно сохранить
     * @return string
     */
    function Right($strin, $count)
    {
    }

    /**
     *Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenText. Если анимация уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @param int $textID ИДЕНТИФИКАТОР текста для возобновления
     * @return void
     */
    function ResumeTweenText($tweenID, $textID)
    {
    }

    /**
     *Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenSprite. Если анимация уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @param int $spriteID Идентификатор спрайта для возобновления
     * @return void
     */
    function ResumeTweenSprite($tweenID, $spriteID)
    {
    }

    /**
     *Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenCustom. Если анимация уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @return void
     */
    function ResumeTweenCustom($tweenID)
    {
    }

    /**
     *Возобновляет заданный интервал с того момента, когда он был приостановлен с помощью PauseTweenChar. Если анимация уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @param int $textID ИДЕНТИФИКАТОР текста для возобновления
     * @param int $charID Индекс персонажа для возобновления
     * @return void
     */
    function ResumeTweenChar($tweenID, $textID, $charID)
    {
    }

    /**
     *Возобновляет заданную анимацию с того момента, когда она была приостановлена с помощью PauseTweenObject. Если анимация уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @param int $objectID ИДЕНТИФИКАТОР объекта для возобновления
     * @return void
     */
    function ResumeTweenObject($tweenID, $objectID)
    {
    }

    /**
     *Возобновляет данный твин с того момента, когда он был приостановлен с помощью PauseTweenCamera. Если анимация уже возобновлена или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор твина для возобновления
     * @param int $cameraID Идентификатор камеры для возобновления работы
     * @return void
     */
    function ResumeTweenCamera($tweenID, $cameraID)
    {
    }

    /**
     *Возобновляет воспроизведение музыкального файла, если он был приостановлен.
     *
     * @param int $musicID Идентификатор музыкального файла для приостановки
     * @return void
     */
    function ResumeMusicOGG($musicID)
    {
    }

    /**
     *Продолжает анимацию спрайта, используя значения, используемые для его настройки. Продолжается с текущего кадра, а не начинается снова с первого кадра.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для возобновления анимации.
     * @return void
     */
    function ResumeSprite($iSpriteIndex)
    {
    }

    /**
     *Возобновляет прерванную музыку с того места, где она остановилась.
     *

     * @return void
     */
    function ResumeMusic()
    {
    }

    /**
     *Восстанавливает приложение из свернутого состояния в нормальное окно.
     *
     * @return void
     */
    function RestoreApp()
    {
    }

    /**
     *Изменяет размер изображения на новую ширину и высоту. Если изображение является изображением атласа, то его subimages.txt значения также будут изменены таким образом, чтобы LoadSubImage все еще работал. Обратите внимание, что если вы ранее использовали LoadSubImage на этом изображении, то изменение его размера приведет к неправильному отображению этих субизображений. Эта команда не будет работать с самими субизображениями.
     *
     * @param int $imageID Идентификатор изображения для изменения размера
     * @param int $width Новая ширина изображения
     * @param int $height Новая высота изображения
     * @return void
     */
    function ResizeImage($imageID, $width, $height)
    {
    }

    /**
     *Эта команда восстанавливает нормальную функциональность UV-координат после вызова SetSpriteUV.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @return void
     */
    function ResetSpriteUV($iSpriteIndex)
    {
    }

    /**
     *Сбрасывает время, возвращенное таймером, на 0. Это позволяет восстановить полную точность после того, как ваше приложение работает в течение некоторого времени. Это также сбрасывает значения, возвращаемые getSeconds и GetMilliseconds, на 0.
     *
     * @return void
     */
    function ResetTimer()
    {
    }

    /**
     *Устанавливает значение вознаграждения AdMob равным 0. Вы можете использовать это после обнаружения события вознаграждения и действовать так, чтобы не вознаграждать пользователя более одного раза.
     *
     * @return void
     */
    function ResetRewardAdMob()
    {
    }

    /**
     *Устанавливает значение вознаграждения Chartboost равным 0. Вы можете использовать это после обнаружения события вознаграждения и действовать так, чтобы не вознаграждать пользователя более одного раза.
     *
     * @return void
     */
    function ResetRewardChartboost()
    {
    }

    /**
     *Сбрасывает количество испускаемых частиц, когда излучатель был установлен с максимальным количеством частиц с помощью SetParticlesMax. Вы можете проверить, когда излучатель достиг своего максимального количества, используя GetParticlesMaxReached. Если максимум установлен на -1, то эта команда не имеет никакого эффекта.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function ResetParticleCount($ID)
    {
    }

    /**
     *Останавливает любую воспроизводимую анимацию и сбрасывает кости объекта в их положение привязки.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @return void
     */
    function ResetObjectAnimation($objID)
    {
    }

    /**
     *Это удаляет физический мир и все формы, твердые тела, суставы, совместные двигатели, тряпичные куклы и контроллеры персонажей. Затем воссоздается пустой физический мир с масштабом и гравитацией по умолчанию. Затем вам нужно будет воссоздать все формы, твердые тела, суставы, совместные двигатели, тряпичные куклы и контроллеры персонажей, которые вам нужны.
     *
     * @return void
     */
    function Reset3DPhysicsWorld()
    {
    }

    /**
     *Сбрасывает количество испускаемых частиц, когда излучатель был установлен с максимальным количеством частиц с помощью Set3DParticlesMax. Вы можете проверить, когда излучатель достиг своего максимального количества, используя Get3DParticlesMaxReached. Если максимум установлен на -1, то эта команда не имеет никакого эффекта.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function Reset3DParticleCount($ID)
    {
    }

    /**
     *Только для Android все остальные платформы ничего не сделают. Генерирует системный диалог с запросом у пользователя указанного разрешения устройства, используемого определенными командами Android. Разрешения следующие: "writeExternal" - используется командами SaveSharedVariable и любыми путями "raw:", которые обращаются к SD-карте. "Местоположение" - используется командами GPS "Камера" - используется командой SetDeviceCameraToImage и для канала AR - камеры "RecordAudio" - используется командой StartScreenRecording Вы можете проверить результат запроса, вызвав checkPermission. После первого запроса Android предоставит пользователю возможность прекратить отображение диалогового окна запроса. В этом случае эта команда больше не будет генерировать диалоговое окно запроса и вместо этого ничего не будет делать. Пользователю придется зайти в настройки приложения устройства, чтобы отменить это решение. Любое разрешение, не указанное здесь, не требует от вас запроса разрешения пользователя, оно будет автоматически предоставлено при установке, если ваше приложение этого требует. Все разрешения, которые использует ваше приложение, даже те, которые требуют запроса, должны быть указаны в диалоговом окне экспорта APK, установив соответствующие флажки.
     *
     * @param string $szPermission Разрешение на запрос
     * @return void
     */
    function RequestPermission($szPermission)
    {
    }

    /**
     *Отображает всплывающее диалоговое окно с запросом согласия пользователя на показ персонализированной рекламы. Ответ пользователя будет автоматически использован для изменения настроек AdMob таким образом, чтобы реклама отображалась в соответствии с предпочтениями пользователя. Статус согласия также будет сохранен на сервере AdMob, чтобы будущий вызов LoadConsentStatusAdMob мог получить это значение. Вы можете вызвать эту команду в любое время в вашем приложении, чтобы пользователь мог изменить свои предпочтения, пользователь должен иметь возможность сделать это где-то внутри вашего приложения.  Это согласие не распространяется на Chartboost или Amazon, оно запрашивает только согласие на показ персонализированной рекламы от AdMob. Вам понадобится свой собственный метод запроса согласия для Chartboost и Amazon.
     *
     * @return void
     */
    function RequestConsentAdMob()
    {
    }

    /**
     *iOS 10.3 имеет специальную функцию, которая позволит пользователю просматривать ваше приложение изнутри самого приложения, эта команда подскажет iOS начать этот процесс. Обратите внимание, что iOS не гарантирует отображение чего-либо при вызове этой команды, и она не должна вызываться в ответ на нажатие кнопки или другое взаимодействие пользователя. Вы должны вызвать его, когда в приложении наступает затишье, например в конце уровня. Если вы хотите запустить процесс проверки в ответ на действие пользователя, например нажатие кнопки, то вам следует использовать команду OpenBrowser для открытия AppStore.
     *
     * @return void
     */
    function RequestAppReview()
    {
    }

    /**
     *Вызовите эту команду, чтобы запросить новое объявление. Обычно реклама предоставляется автоматически. Вы можете сделать это только при переключении на новые экраны в вашем приложении
     *
     * @return void
     */
    function RequestAdvertRefresh()
    {
    }

    /**
     *Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает Render2DBack, RenderShadowMap, Render3D, Render2DFront, чтобы нарисовать все в мире. Эта команда вычисляет только карту теней.
     *

     * @return void
     */
    function RenderShadowMap()
    {
    }

    /**
     *Возвращает строку со всеми экземплярами "find", замененными на "replace". Вы можете использовать параметр qty для ограничения количества сделанных замен или использовать -1 для ограничения без ограничений. Исходная строка не изменяется, и возвращается новая строка с заменами в ней. Обратите внимание, что если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена, когда вы закончите с ней.
     *
     * @param string $str Строка для изменения
     * @param string $find Строка, которую нужно найти
     * @param string $replace Строка, чтобы заменить его на
     * @param int $qty Максимальное количество замен, которые нужно сделать, используйте минус 1 без ограничений
     * @return string
     */
    function ReplaceString($str, $find, $replace, $qty)
    {
    }

    /**
     *Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает Render2DBack, ClearDepthBuffer, Render3D, ClearDepthBuffer, Render2DFront, чтобы нарисовать все в мире. Эта команда рисует только 2D-спрайты и текст, которые находятся перед 3D.
     *

     * @return void
     */
    function Render2DFront()
    {
    }

    /**
     *Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает Render2DBack, RenderShadowMap, Render3D, Render2DFront, чтобы нарисовать все в мире. Эта команда рисует только 3D-объекты.
     *

     * @return void
     */
    function Render3D()
    {
    }

    /**
     *Звонил автоматически. Это расширенная команда для управления конвейером рендеринга. Обычно Render вызывает Render2DBack, ClearDepthBuffer, Render3D, ClearDepthBuffer, Render2DFront, чтобы нарисовать все в мире. Эта команда рисует только 2D-спрайты и текст, которые находятся за 3D.
     *

     * @return void
     */
    function Render2DBack()
    {
    }

    /**
     *Рисует все 2D и 3D, созданные с использованием идентификационного номера, в текущий буфер кадров. Он не переключает backbuffer на экран. Он не рисует спрайты или объекты, созданные вами с помощью указателей, вам придется либо рисовать их по отдельности, либо назначать их менеджеру спрайтов для пакетного рисования. В этом случае Рендеринг все равно должен быть вызван, так как он также рисует печатный текст. Вызываемый автоматически Sync, вы можете использовать Sync или Update(), Render(), Swap() для ручной синхронизации. Если вы хотите иметь больше контроля, вы можете разбить это дальше и заменить Рендеринг на Render2DBack, ClearDepthBuffer, Render3D, ClearDepthBuffer, Render2DFront
     *
     * @return void
     */
    function Render()
    {
    }

    /**
     *Удаляет заголовок, который вы ранее добавили, если вы не использовали AddHTTPHeader для добавления заголовка с заданным именем, то эта команда ничего не делает. Если имя заголовка является стандартным заголовком, который обычно включается, то эта команда не удаляет его, а вместо этого использует AddHTTPHeader с пустой строкой, чтобы перезаписать его. Если имя заголовка является стандартным заголовком, который вы перезаписали, то эта команда возвращает его к нормальному значению. Обратите внимание, что эта команда не работает в версии HTML5.
     *
     * @param int $iHTTP Идентификатор соединения для изменения.
     * @param string $headerName Имя заголовка для удаления
     * @return void
     */
    function RemoveHTTPHeader($iHTTP, $headerName)
    {
    }

    /**
     *Еще не функционирует.
     *
     * @param string $szFilename Файл для сохранения звука.
     * @return void
     */
    function RecordSound($szFilename)
    {
    }

    /**
     *Получает сообщение в очереди из приложения watch. Это будет в виде строки JSON. Если вы вызываете эту команду из уровня 2, вы должны удалить возвращенную строку, когда закончите с ней, вызвав agk::DeleteString.  В настоящее время работает только на iOS.
     *
     * @return string
     */
    function ReceiveSmartWatchData()
    {
    }

    /**
     *Считывает строку из данного файла, который должен быть открыт для чтения. Обратите внимание, что это может читать только строки в двоичной форме, такие как те, которые написаны с помощью WriteString2, если вы пытаетесь прочитать строки, разделенные новыми строками, то вместо этого используйте ReadLine. Если вы используете эту команду на уровне 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней. Это использует другой метод от ReadString, который немного быстрее, но эта команда может читать только строки, написанные с помощью WriteString2
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return string
     */
    function ReadString2($iFileID)
    {
    }

    /**
     *Считывает строку с нулевым завершением из данного файла, который должен быть открыт для чтения. Обратите внимание, что это может читать только строки в двоичной форме, такие как те, которые написаны с помощью WriteString, если вы пытаетесь прочитать строки, разделенные новыми строками, то вместо этого используйте ReadLine. Если вы используете эту команду на уровне 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней.
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return string
     */
    function ReadString($iFileID)
    {
    }

    /**
     *Считывает новую строку, завершенную строкой из данного файла, который должен быть открыт для чтения. Если вы используете эту команду на уровне 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней.
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return string
     */
    function ReadLine($iFileID)
    {
    }

    /**
     *Считывает 4-байтовое целое число из данного файла, который должен быть открыт для чтения.
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return int
     */
    function ReadInteger($iFileID)
    {
    }

    /**
     *Считывает 1-байтовое целое число без знака (0-255) из данного файла, который должен быть открыт для чтения.
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return int
     */
    function ReadByte($iFileID)
    {
    }

    /**
     *Считывает 4-байтовый поплавок из данного файла, который должен быть открыт для чтения.
     *
     * @param int $iFileID Идентификатор файла для чтения.
     * @return float
     */
    function ReadFloat($iFileID)
    {
    }

    /**
     *Бросьте луч и проверьте объект.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $rayID Идентификатор луча
     * @param int $fromVec3ID Идентификатор вектора начальной точки. Создайте вектор с помощью команды CreateVector3 ().
     * @param int $toVec3ID Идентификатор вектора назначения
     * @param int $allOrClosest 1 = все контакты, 0 = ближайший контакт
     * @return int
     */
    function RayCast3DPhysicsObject($objID, $rayID, $fromVec3ID, $toVec3ID, $allOrClosest)
    {
    }

    /**
     *Бросьте луч
     *
     * @param int $rayID Идентификатор луча
     * @param int $fromVec3ID Идентификатор вектора начальной точки. Создайте вектор с помощью команды CreateVector3 ().
     * @param int $toVec3ID Идентификатор вектора назначения
     * @param int $allOrClosest 1 = все контакты, 0 = ближайший контакт
     * @return void
     */
    function RayCast3DPhysics($rayID, $fromVec3ID, $toVec3ID, $allOrClosest)
    {
    }

    /**
     *Верните 1, если луч существует. Возвращает 0, если это не так.
     *
     * @param int $rayID Идентификатор луча
     * @return int
     */
    function Ray3DPhysicsExist($rayID)
    {
    }

    /**
     *Отображает диалоговое окно с запросом пользователя оценить приложение в App Store. В настоящее время эта команда поддерживается только на iOS.
     *
     * @param string $szID Это идентификатор вашего приложения. Вы можете получить его в iTunes Connect.
     * @param string $szTitle Строка, используемая в качестве заголовка диалогового окна, обычно это "Rate AppName"
     * @return void
     */
    function RateApp($szID, $szTitle)
    {
    }

    /**
     *Отображает диалоговое окно с запросом пользователя оценить приложение в App Store. В настоящее время эта команда поддерживается только на iOS.
     *
     * @param string $szID Это идентификатор вашего приложения. Вы можете получить его в iTunes Connect.
     * @param string $szTitle Строка, используемая в качестве заголовка диалогового окна, обычно это "Rate AppName"
     * @param string $szMessage Строка, используемая в качестве сообщения диалогового окна
     * @return void
     */
    function RateApp($szID, $szTitle, $szMessage)
    {
    }

    /**
     *Отображает диалоговое окно с запросом пользователя оценить приложение в App Store. В настоящее время эта команда поддерживается только на iOS.
     *
     * @param string $szID Это идентификатор вашего приложения. Вы можете получить его в iTunes Connect.
     * @return void
     */
    function RateApp($szID)
    {
    }

    /**
     *Генерирует случайное число на основе текущего начального значения. Генератор случайных чисел встроен в AGK, поэтому определенное начальное значение будет производить одну и ту же последовательность чисел на каждой платформе. Производит случайное число между -2,147,483,648 и 2,147,483,647. Этот генератор работает медленнее, чем Случайный, но производит более качественную случайность в большем диапазоне значений.
     *

     * @return int
     */
    function Random2()
    {
    }

    /**
     *Генерирует случайное число на основе текущего начального значения. Генератор случайных чисел встроен в AGK, поэтому определенное начальное значение будет производить одну и ту же последовательность чисел на каждой платформе. Производит случайное число между -2,147,483,648 и 2,147,483,647. Этот генератор работает медленнее, чем Случайный, но производит более качественную случайность в большем диапазоне значений.
     *
     * @param int $from Самое низкое значение для возврата
     * @param int $to Самое высокое значение для возврата
     * @return int
     */
    function Random2($from, $to)
    {
    }

    /**
     *Будет случайным образом отрицать данное значение и возвращать его. Имеет 50-50 шансов на отрицание ценности. Начальное значение может быть отрицательным, и в этом случае оно случайно станет положительным.
     *
     * @param int $value Значение, которое нужно изменить.
     * @return int
     */
    function RandomSign($value)
    {
    }

    /**
     *Генерирует случайное число на основе текущего начального значения. Генератор случайных чисел встроен в AGK, поэтому определенное начальное значение будет производить одну и ту же последовательность чисел на каждой платформе. Производит случайное число от 0 до 65535
     *

     * @return int
     */
    function Random()
    {
    }

    /**
     *Генерирует случайное число на основе текущего начального значения. Генератор случайных чисел встроен в AGK, поэтому определенное начальное значение будет производить одну и ту же последовательность чисел на каждой платформе. Производит случайное число от 0 до 65535
     *
     * @param int $from Самое низкое значение для возврата
     * @param int $to Самое высокое значение для возврата
     * @return int
     */
    function Random($from, $to)
    {
    }

    /**
     *Возвращает 1, если настройка прошла успешно, 0, если она не удалась или устройство не поддерживает push-уведомления.
     *
     * @return int
     */
    function PushNotificationSetup()
    {
    }

    /**
     *Печать изображения на подключенном принтере. Эта команда не гарантированно работает на всех платформах. Параметр size определяет размер изображения на странице, значение 100 позволяет использовать как можно большую часть страницы, 50-половину этой суммы, 25-четверть и так далее.
     *
     * @param int $image идентификатор изображения для печати
     * @param float $size объем пространства, используемого на странице, находится в диапазоне от 0 до 100.
     * @return void
     */
    function PrintImage($image, $size)
    {
    }

    /**
     *Выводит заданное значение или строку на экран, но не добавляет новый символ строки в конец. Следующая команда Print или PrintC будет следовать непосредственно из этой.
     *
     * @param string $szString Строка для печати.
     * @return void
     */
    function PrintC($szString)
    {
    }

    /**
     *Выводит заданное значение или строку на экран, но не добавляет новый символ строки в конец. Следующая команда Print или PrintC будет следовать непосредственно из этой.
     *
     * @param int $i Целое число для печати.
     * @return void
     */
    function PrintC($i)
    {
    }

    /**
     *Выводит заданное значение или строку на экран, но не добавляет новый символ строки в конец. Следующая команда Print или PrintC будет следовать непосредственно из этой.
     *
     * @param float $f Поплавок для печати.
     * @return void
     */
    function PrintC($f)
    {
    }

    /**
     *Выводит заданное значение или строку на экран и добавляет новый символ строки, чтобы следующая команда печати была на одну строку ниже.
     *
     * @param int $i Целое число для печати.
     * @return void
     */
    function Print($i)
    {
    }

    /**
     *Выводит заданное значение или строку на экран и добавляет новый символ строки, чтобы следующая команда печати была на одну строку ниже.
     *
     * @param float $f Поплавок для печати.
     * @return void
     */
    function Print($f)
    {
    }

    /**
     *Выводит заданное значение или строку на экран и добавляет новый символ строки, чтобы следующая команда печати была на одну строку ниже.
     *
     * @param string $szString Строка для печати.
     * @return void
     */
    function Print($szString)
    {
    }

    /**
     *Возвращает a, возведенное в степень b.
     *
     * @param float $a База.
     * @param float $b Сила.
     * @return float
     */
    function Pow($a, $b)
    {
    }

    /**
     *Воспроизводит указанное видео Youtube в отдельном окне над вашим приложением. Для Android вы должны включить Youtube Data API v3 в Google Cloud Console для вашего приложения и создать для него ключ API в разделе учетные данные. Вы можете создать ключ специально для использования с API Youtube или использовать неограниченный ключ, который может использоваться несколькими API. Видеоид-это строка, которая следует за ?v= часть URL-адреса Youtube, например "eLIgxYHCgWA". Вы также можете указать время начала воспроизведения видео с середины, а не с самого начала. Время указывается в секундах и принимает десятичные значения для представления долей секунды.  В Windows, Mac и Linux эта команда откроет браузер по умолчанию для воспроизведения видео Youtube. Поле ключа разработчика требуется только для Android.
     *
     * @param string $developerKey Учетные данные ключа API, созданные в облачной консоли Google для API данных Youtube v3.
     * @param string $videoID Идентификатор видео, например eLIgxYHCgWA
     * @param float $startTime Время поиска в секундах, с которого начинается воспроизведение видео
     * @return void
     */
    function PlayYoutubeVideo($developerKey, $videoID, $startTime)
    {
    }

    /**
     *Воспроизведение видео или возобновление его после паузы. Воспроизведение видео на изображение, а не на экран, изображение не должно уже существовать. Изображение будет удалено при вызове DeleteVideo, вы не должны удалять его вручную. Вы можете использовать либо эту команду, либо playVideo, но не оба. Если вы приостановите видео, вы должны возобновить его с помощью той же команды, что и при запуске, с теми же параметрами. В настоящее время это поддерживается только на iOS 7.0 или выше, Android 4.0.3 или выше и Windows.
     *
     * @param int $imageID Идентификатор, используемый для ссылки на новое изображение, не должен уже существовать
     * @return void
     */
    function PlayVideoToImage($imageID)
    {
    }

    /**
     *Воспроизводит видео на экране или возобновляет его после паузы. Вы можете использовать либо эту команду, либо PlayVideoToImage, но не оба. Если вы ставите видео на паузу, вы должны возобновить его с помощью той же команды, что и при запуске.
     *
     * @return void
     */
    function PlayVideo()
    {
    }

    /**
     *Применяет данный идентификатор анимации к заданному текстовому идентификатору с необязательной задержкой и начинает его воспроизведение. Анимация может воспроизводиться на нескольких текстовых объектах одновременно, просто вызовите эту команду еще раз с другим текстовым идентификатором. Текст не будет изменен до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на текстовом объекте, текст будет соответствующим образом корректировать свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param int $textID Идентификатор изменяемого текстового объекта
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenText($tweenID, $textID, $delay)
    {
    }

    /**
     *Применяет заданный идентификатор анимации к заданному идентификатору спрайта с необязательной задержкой и начинает его воспроизведение. Анимация может воспроизводиться на нескольких спрайтах одновременно, просто вызовите эту команду снова с другим идентификатором спрайта. Спрайт не будет изменен до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на спрайте, то спрайт соответствующим образом скорректирует свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param int $spriteID Идентификатор изменяемого спрайта
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenSprite($tweenID, $spriteID, $delay)
    {
    }

    /**
     *Применяет заданный идентификатор анимации к заданному идентификатору объекта с необязательной задержкой и начинает его воспроизведение. Анимация может воспроизводиться на нескольких объектах одновременно, просто вызовите эту команду снова с другим идентификатором объекта. Объект не будет изменен до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на объекте, то объект соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param int $objectID ИДЕНТИФИКАТОР объекта для изменения
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenObject($tweenID, $objectID, $delay)
    {
    }

    /**
     *Применяет заданный идентификатор анимации к заданному символу в текстовом объекте с необязательной задержкой и начинает его воспроизведение. Анимация может воспроизводиться на нескольких символах в нескольких текстовых объектах одновременно, просто вызовите эту команду снова с другим идентификатором текста или символа. Символ не будет изменен до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на символе, то символ соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param int $textID Идентификатор изменяемого текстового объекта
     * @param int $charID Индекс символа, индексы начинаются с 0, если он выходит за пределы диапазона, то будет проигнорирован
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenChar($tweenID, $textID, $charID, $delay)
    {
    }

    /**
     *Воспроизводит заданный пользовательский идентификатор анимации с дополнительной задержкой и начинает его воспроизведение. В отличие от других подростков, это не применяется к какому-либо конкретному элементу или объекту и не может иметь несколько копий, работающих одновременно, вам придется создать отдельный пользовательский твин для каждой копии, которую вы хотите запустить одновременно. Значения анимации не будут изменены до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение tween изменяется во время воспроизведения tween, то tween соответствующим образом скорректирует свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenCustom($tweenID, $delay)
    {
    }

    /**
     *Применяет заданный идентификатор анимации к заданному идентификатору камеры с дополнительной задержкой и начинает его воспроизведение. Анимация может воспроизводиться на нескольких камерах одновременно, просто вызовите эту команду еще раз с другим идентификатором камеры. Камера не будет изменена до тех пор, пока не пройдет время задержки, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на камере, камера соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $tweenID Идентификатор твина для использования
     * @param int $cameraID Идентификатор камеры для изменения
     * @param float $delay Количество секунд до начала воспроизведения анимации
     * @return void
     */
    function PlayTweenCamera($tweenID, $cameraID, $delay)
    {
    }

    /**
     *Начинает воспроизведение данной цепочки с самого начала или возобновляет ее, если она была приостановлена.
     *
     * @param int $chainID Идентификатор цепочки для изменения
     * @return void
     */
    function PlayTweenChain($chainID)
    {
    }

    /**
     *Начинается анимация спрайта на основе заданных значений. Скорость анимации основана на кадрах анимации в секунду и не зависит от частоты кадров рисования.
     *
     * @param int $iSpriteIndex Идентификатор анимируемого спрайта.
     * @return void
     */
    function PlaySprite($iSpriteIndex)
    {
    }

    /**
     *Начинается анимация спрайта на основе заданных значений. Скорость анимации основана на кадрах анимации в секунду и не зависит от частоты кадров рисования.
     *
     * @param int $iSpriteIndex Идентификатор анимируемого спрайта.
     * @param float $fFps Кадров в секунду. Количество кадров, которые спрайт должен пытаться циклически проходить каждую секунду (необязательно, по умолчанию 10).
     * @return void
     */
    function PlaySprite($iSpriteIndex, $fFps)
    {
    }

    /**
     *Начинается анимация спрайта на основе заданных значений. Скорость анимации основана на кадрах анимации в секунду и не зависит от частоты кадров рисования.
     *
     * @param int $iSpriteIndex Идентификатор анимируемого спрайта.
     * @param float $fFps Кадров в секунду. Количество кадров, которые спрайт должен пытаться циклически проходить каждую секунду (необязательно, по умолчанию 10).
     * @param int $iLoop Режим зацикливания спрайта, 0 равно не зацикливаться, 1 равно зацикливаться навсегда (необязательно, по умолчанию 1).
     * @return void
     */
    function PlaySprite($iSpriteIndex, $fFps, $iLoop)
    {
    }

    /**
     *Начинается анимация спрайта на основе заданных значений. Скорость анимации основана на кадрах анимации в секунду и не зависит от частоты кадров рисования.
     *
     * @param int $iSpriteIndex Идентификатор анимируемого спрайта.
     * @param float $fFps Кадров в секунду. Количество кадров, которые спрайт должен пытаться циклически проходить каждую секунду (необязательно, по умолчанию 10).
     * @param int $iLoop Режим зацикливания спрайта, 0 равно не зацикливаться, 1 равно зацикливаться навсегда (необязательно, по умолчанию 1).
     * @param int $iFromFrame Кадр, с которого нужно начать, начинается с 1 (необязательно, по умолчанию минус 1).
     * @param int $iToFrame Фрейм, на который нужно закончить, фреймы заканчиваются на GetSpriteFrameCount (необязательно, по умолчанию минус 1).
     * @return void
     */
    function PlaySprite($iSpriteIndex, $fFps, $iLoop, $iFromFrame, $iToFrame)
    {
    }

    /**
     *Воспроизведение звука, ранее загруженного в указанный звуковой номер. Эта команда может быть вызвана несколько раз для одного и того же идентификатора звука, и она запустит несколько копий этого звука, воспроизводимых в качестве экземпляров. Команда вернет идентификатор экземпляра, который можно использовать для взаимодействия с этим экземпляром во время его воспроизведения. Когда экземпляр перестает воспроизводиться, он автоматически удаляется и больше не может быть использован. По умолчанию звук не зацикливается.
     *
     * @param int $iID Звуковой номер для воспроизведения.
     * @param int $iVol Громкость, на которой должен воспроизводиться звук (необязательно, по умолчанию 100).
     * @return int
     */
    function PlaySound($iID, $iVol)
    {
    }

    /**
     *Воспроизведение звука, ранее загруженного в указанный звуковой номер. Эта команда может быть вызвана несколько раз для одного и того же идентификатора звука, и она запустит несколько копий этого звука, воспроизводимых в качестве экземпляров. Команда вернет идентификатор экземпляра, который можно использовать для взаимодействия с этим экземпляром во время его воспроизведения. Когда экземпляр перестает воспроизводиться, он автоматически удаляется и больше не может быть использован. По умолчанию звук не зацикливается.
     *
     * @param int $iID Звуковой номер для воспроизведения.
     * @param int $iVol Громкость, на которой должен воспроизводиться звук (необязательно, по умолчанию 100).
     * @param int $iLoop Количество раз, чтобы зациклить экземпляр, или 1 навсегда.
     * @return int
     */
    function PlaySound($iID, $iVol, $iLoop)
    {
    }

    /**
     *Воспроизведение звука, ранее загруженного в указанный звуковой номер. Эта команда может быть вызвана несколько раз для одного и того же идентификатора звука, и она запустит несколько копий этого звука, воспроизводимых в качестве экземпляров. Команда вернет идентификатор экземпляра, который можно использовать для взаимодействия с этим экземпляром во время его воспроизведения. Когда экземпляр перестает воспроизводиться, он автоматически удаляется и больше не может быть использован. По умолчанию звук не зацикливается.
     *
     * @param int $iID Звуковой номер для воспроизведения.
     * @param int $iVol Громкость, на которой должен воспроизводиться звук (необязательно, по умолчанию 100).
     * @param int $iLoop Количество раз, чтобы зациклить экземпляр, или 1 навсегда.
     * @param int $iPriority Зарезервировано для будущего использования, должно быть 0 (необязательно, по умолчанию 0).
     * @return int
     */
    function PlaySound($iID, $iVol, $iLoop, $iPriority)
    {
    }

    /**
     *Воспроизведение звука, ранее загруженного в указанный звуковой номер. Эта команда может быть вызвана несколько раз для одного и того же идентификатора звука, и она запустит несколько копий этого звука, воспроизводимых в качестве экземпляров. Команда вернет идентификатор экземпляра, который можно использовать для взаимодействия с этим экземпляром во время его воспроизведения. Когда экземпляр перестает воспроизводиться, он автоматически удаляется и больше не может быть использован. По умолчанию звук не зацикливается.
     *
     * @param int $iID Звуковой номер для воспроизведения.
     * @return int
     */
    function PlaySound($iID)
    {
    }

    /**
     *Воспроизводит данную анимацию по имени, если она существует с необязательным временем начала (По умолчанию 0), необязательным циклом и необязательным временем анимации (по умолчанию 0). Время анимации будет плавно интерполировать скелет из его текущего состояния в первый кадр указанной анимации, прежде чем он начнет анимацию, так что резкого перехода не будет. Значение цикла 1 будет петлять вечно, значение цикла больше 1 будет петлять столько раз, а затем остановится, а значение цикла 0 будет воспроизводить анимацию один раз, а затем остановится
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param string $anim Название анимации для воспроизведения
     * @param float $starttime Необязательное смещение в анимацию для пропуска некоторых кадров
     * @param int $loop 1, чтобы зациклить анимацию до тех пор, пока она не остановится, 0, чтобы воспроизвести ее один раз, больше 1, чтобы зациклить столько раз
     * @param float $tweentime Количество секунд для перехода из текущего состояния перед анимацией
     * @return void
     */
    function PlaySkeleton2DAnimation($iSkeleton, $anim, $starttime, $loop, $tweentime)
    {
    }

    /**
     *Воспроизводит заданную анимацию на своем родительском объекте. Только объекты, загруженные с помощью LoadObjectWithChildren, будут иметь назначенные им анимации. Имена анимаций определяются программой моделирования при создании анимаций вы можете узнать, что это за имена, используя GetObjectAnimationName. Анимация может быть запущена и закончена в любой момент анимации с использованием параметров start и end, они задаются в секундах, и если цикл включен, то объект вернется к заданному времени начала в начале каждого цикла. Если вы хотите, чтобы петля была бесшовной, то положение костей в начале и в конце должно быть точно таким же, так как при петле между ними не будет интерполяции. Параметр tweentime можно использовать для интерполяции между текущими позициями костей и временем начала анимации, чтобы не было резкого скачка в позициях костей. Это твининг происходит только один раз, он не происходит каждый цикл и не вносит свой вклад во время анимации. По сути, анимация приостанавливается до тех пор, пока твининг не закончит. Обратите внимание, что как только эта команда будет вызвана, кости будут управляться анимацией и не могут быть перемещены с помощью SetObjectBonePosition или аналогичных команд. Вы можете восстановить ручное управление отдельными костями, используя SetObjectBoneCanAnimate на нем. Вы можете восстановить контроль над всей костной структурой с помощью ResetObjectAnimation.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param string $animName Название воспроизводимой анимации, определяемое программой моделирования
     * @param float $starttime Точка в анимации, в которой объект должен начать воспроизведение, в секундах
     * @param float $endtime Точка в анимации, в которой объект должен прекратить воспроизведение, минус 1, чтобы продолжить до конца
     * @param int $loop 1, чтобы зациклить анимацию навсегда, 0, чтобы воспроизвести один раз, любое другое положительное целое число, чтобы зациклить столько раз
     * @param float $tweentime Время в секундах для перехода от текущего состояния объектов к первому кадру анимации
     * @return void
     */
    function PlayObjectAnimation($objID, $animName, $starttime, $endtime, $loop, $tweentime)
    {
    }

    /**
     *Воспроизведение музыкального файла. Несколько музыкальных файлов OGG могут воспроизводиться одновременно.
     *
     * @param int $musicID Идентификатор музыкального файла для воспроизведения
     * @param int $iLoop Количество раз, чтобы зациклиться, или 1, чтобы зациклиться навсегда
     * @return void
     */
    function PlayMusicOGG($musicID, $iLoop)
    {
    }

    /**
     *Воспроизведение музыкального файла. Несколько музыкальных файлов OGG могут воспроизводиться одновременно.
     *
     * @param int $musicID Идентификатор музыкального файла для воспроизведения
     * @return void
     */
    function PlayMusicOGG($musicID)
    {
    }

    /**
     *Воспроизводит только данный музыкальный файл и при желании зацикливает его. Это изменение по сравнению с предыдущими версиями, где AGK продолжал бы воспроизводить следующий музыкальный трек после этого. Теперь вы должны использовать дополнительные параметры PlayMusic для воспроизведения треков один за другим. В любой момент времени может воспроизводиться только один музыкальный файл.
     *
     * @param int $iID Начнем с музыкального файла.
     * @param int $bLoop 1
     * @return void
     */
    function PlayMusic($iID, $bLoop)
    {
    }

    /**
     *Воспроизводит только данный музыкальный файл и при желании зацикливает его. Это изменение по сравнению с предыдущими версиями, где AGK продолжал бы воспроизводить следующий музыкальный трек после этого. Теперь вы должны использовать дополнительные параметры PlayMusic для воспроизведения треков один за другим. В любой момент времени может воспроизводиться только один музыкальный файл.
     *
     * @param int $iID Начнем с музыкального файла.
     * @return void
     */
    function PlayMusic($iID)
    {
    }

    /**
     *Воспроизводит только данный музыкальный файл и при желании зацикливает его. Это изменение по сравнению с предыдущими версиями, где AGK продолжал бы воспроизводить следующий музыкальный трек после этого. Теперь вы должны использовать дополнительные параметры PlayMusic для воспроизведения треков один за другим. В любой момент времени может воспроизводиться только один музыкальный файл.
     *
     * @return void
     */
    function PlayMusic()
    {
    }

    /**
     *Воспроизводит только данный музыкальный файл и при желании зацикливает его. Это изменение по сравнению с предыдущими версиями, где AGK продолжал бы воспроизводить следующий музыкальный трек после этого. Теперь вы должны использовать дополнительные параметры PlayMusic для воспроизведения треков один за другим. В любой момент времени может воспроизводиться только один музыкальный файл.
     *
     * @param int $iID Начнем с музыкального файла.
     * @param int $bLoop 1
     * @param int $iStartID Идентификатор, к которому нужно вернуться при циклическом переходе от конца к началу списка файлов.
     * @param int $iEndID Идентификатор, после которого он должен вернуться к началу цикла.
     * @return void
     */
    function PlayMusic($iID, $bLoop, $iStartID, $iEndID)
    {
    }

    /**
     *Бросает луч через все физические объекты, включая спрайты, у которых включена физика, и сохраняет ближайший предмет, попавший в цель. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Эта функция фильтрует проверяемые спрайты, поэтому проверяются только спрайты определенной группы, а значение группы 0 означает, что будут проверены все группы. Возвращает 1, если произошло столкновение, и 0, если нет.
     *
     * @param int $group Идентификатор группы, проверяемый на пересечение с лучом, может быть отрицательным.
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function PhysicsRayCastGroup($group, $x, $y, $x2, $y2)
    {
    }

    /**
     *Бросает луч через все физические объекты, включая спрайты, у которых включена физика, и сохраняет ближайший предмет, попавший в цель. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Эта функция фильтрует проверяемые спрайты, поэтому проверяются только спрайты определенных категорий. Параметр category - это побитовое поле, которое использует младшие 16 битов для представления каждой из возможных 16 категорий, используемых при настройке спрайта. Значение по умолчанию all 1s означает, что все категории будут включены, тогда как значение all 0s означает, что никакие категории не будут включены. Вы можете установить отдельные биты, чтобы установить, какие из них должны быть проверены. Возвращает 1, если произошло столкновение, и 0, если нет.
     *
     * @param int $category Категории для проверки на пересечение с лучом, побитовое поле с использованием самых нижних 16 бит.
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function PhysicsRayCastCategory($category, $x, $y, $x2, $y2)
    {
    }

    /**
     *Бросает луч через все физические объекты, включая спрайты, у которых включена физика, и сохраняет ближайший предмет, попавший в цель. Результаты приведения лучей могут быть получены с помощью других функций приведения лучей, таких как GetRayCastNormalX. Если луч начинается внутри фигуры, то эта фигура не будет учитываться в результатах. Возвращает 1, если произошло столкновение, и 0, если нет.
     *
     * @param float $x Координата X начальной точки в мировых координатах.
     * @param float $y Координата Y начальной точки в мировых координатах.
     * @param float $x2 Координата X конечной точки в мировых координатах.
     * @param float $y2 Координата Y конечной точки в мировых координатах.
     * @return int
     */
    function PhysicsRayCast($x, $y, $x2, $y2)
    {
    }

    /**
     *Приостанавливает видео и сохраняет его на экране.
     *
     * @return void
     */
    function PauseVideo()
    {
    }

    /**
     *Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван ResumeTweenText. Если анимация уже остановилась или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @param int $textID ИДЕНТИФИКАТОР текста для паузы
     * @return void
     */
    function PauseTweenText($tweenID, $textID)
    {
    }

    /**
     *Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван ResumeTweenSprite. Если анимация уже остановилась или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @param int $spriteID Идентификатор спрайта для паузы
     * @return void
     */
    function PauseTweenSprite($tweenID, $spriteID)
    {
    }

    /**
     *Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван ResumeTweenObject. Если анимация уже остановилась или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @param int $objectID Идентификатор объекта для приостановки
     * @return void
     */
    function PauseTweenObject($tweenID, $objectID)
    {
    }

    /**
     *Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван ResumeTweenCustom. Если анимация уже остановилась или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @return void
     */
    function PauseTweenCustom($tweenID)
    {
    }

    /**
     *Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызван ResumeTweenChar. Если твин уже остановился или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @param int $textID ИДЕНТИФИКАТОР текста для паузы
     * @param int $charID Индекс символа для паузы
     * @return void
     */
    function PauseTweenChar($tweenID, $textID, $charID)
    {
    }

    /**
     *Приостанавливает данную цепочку, которая начала играть, она может быть возобновлена с помощью PlayTweenChain
     *
     * @param int $chainID Идентификатор цепочки для изменения
     * @return void
     */
    function PauseTweenChain($chainID)
    {
    }

    /**
     *Приостанавливает данный твин в его текущей точке. Он не будет обновляться снова до тех пор, пока не будет вызвана ResumeTweenCamera. Если твин уже остановился или не существует, то это ничего не делает.
     *
     * @param int $tweenID Идентификатор анимации для паузы
     * @param int $cameraID Идентификатор камеры для паузы
     * @return void
     */
    function PauseTweenCamera($tweenID, $cameraID)
    {
    }

    /**
     *Ставит музыкальный файл на паузу. GetMusicPlayingOGG будет продолжать возвращать 1.
     *
     * @param int $musicID Идентификатор музыкального файла для приостановки
     * @return void
     */
    function PauseMusicOGG($musicID)
    {
    }

    /**
     *Приостанавливает воспроизведение музыки в данный момент, какой бы идентификатор это ни был.
     *

     * @return void
     */
    function PauseMusic()
    {
    }

    /**
     *Заставляет Chartboost использовать данное значение согласия при показе рекламы, по умолчанию AGK показывает неперсонализированные объявления из Chartboost. Эта команда может быть использована, если у вас есть собственный метод получения согласия пользователя на показ персонализированной рекламы. Обратите внимание, что GDPR требует от вас по закону получить согласие пользователей ЕС, прежде чем показывать им персонализированную рекламу.
     *
     * @param int $consent Значение согласия на использование, 1=неперсонализированное, 2=персонализированное
     * @return void
     */
    function OverrideConsentChartboost($consent)
    {
    }

    /**
     *Если AdMob использует заданное значение согласия при показе рекламы, оно не сохраняется на сервере AdMob и переопределяет обычный процесс получения согласия. Это используется, если у вас есть собственный метод получения согласия пользователя на показ персонализированной рекламы. Обратите внимание, что GDPR требует от вас по закону получить согласие пользователей ЕС, прежде чем показывать им персонализированную рекламу.
     *
     * @param int $consent Значение согласия на использование, 1=неперсонализированное, 2=персонализированное
     * @return void
     */
    function OverrideConsentAdMob($consent)
    {
    }

    /**
     *Открывает файл, хранящийся в локальной файловой системе, для записи в указанный идентификатор. Все платформы ограничены одной папкой для записи, поэтому пути к файлам должны быть относительными, а не абсолютными. Эта папка записи не является той же папкой, что и само приложение, поэтому изображения, звуки и само приложение не могут быть перезаписаны. Файлы, записанные в эту папку, можно читать с помощью OpenToRead. Если файл не существует, он будет создан, если файл существует, он будет перезаписан, если append равен 0. или добавлен, если append равен 1. Если каталог указан в имени файла и не существует, он будет создан. Чтобы записать файл вне обычной папки записи, вы можете использовать "raw:", за которым следует абсолютный путь для текущей платформы, например "raw:C:\MyFolder\MyFile.txt" на окнах или "raw:/sdcard/Documents/MyFile.txt-на Андроиде. Если какие-либо папки в выбранном вами пути не существуют, они будут созданы. На Raspberry Pi вы можете использовать эту команду, чтобы открыть pin-код GPIO для записи, используя имя файла "gpio:", за которым следует номер pin-кода GPIO, например OpenToWrite(1, "gpio:4"), это чувствительно к регистру. Затем вы можете использовать writeByte для записи 0 или 1 в pin-код и CloseFile для закрытия pin-кода.
     *
     * @param int $ID Идентификатор, который будет использоваться для ссылки на этот файл позже.
     * @param string $szFile Имя файла, которое нужно открыть для записи.
     * @return void
     */
    function OpenToWrite($ID, $szFile)
    {
    }

    /**
     *Открывает файл, хранящийся в локальной файловой системе, для записи в указанный идентификатор. Все платформы ограничены одной папкой для записи, поэтому пути к файлам должны быть относительными, а не абсолютными. Эта папка записи не является той же папкой, что и само приложение, поэтому изображения, звуки и само приложение не могут быть перезаписаны. Файлы, записанные в эту папку, можно читать с помощью OpenToRead. Если файл не существует, он будет создан, если файл существует, он будет перезаписан, если append равен 0. или добавлен, если append равен 1. Если каталог указан в имени файла и не существует, он будет создан. Чтобы записать файл вне обычной папки записи, вы можете использовать "raw:", за которым следует абсолютный путь для текущей платформы, например "raw:C:\MyFolder\MyFile.txt" на окнах или "raw:/sdcard/Documents/MyFile.txt-на Андроиде. Если какие-либо папки в выбранном вами пути не существуют, они будут созданы. На Raspberry Pi вы можете использовать эту команду, чтобы открыть pin-код GPIO для записи, используя имя файла "gpio:", за которым следует номер pin-кода GPIO, например OpenToWrite(1, "gpio:4"), это чувствительно к регистру. Затем вы можете использовать writeByte для записи 0 или 1 в pin-код и CloseFile для закрытия pin-кода.
     *
     * @param string $szFile Имя файла, которое нужно открыть для записи.
     * @param int $append Установите значение 1 для добавления в файл, 0 для перезаписи всех данных (необязательно, по умолчанию 0).
     * @return int
     */
    function OpenToWrite($szFile, $append)
    {
    }

    /**
     *Открывает файл, хранящийся в локальной файловой системе, для записи в указанный идентификатор. Все платформы ограничены одной папкой для записи, поэтому пути к файлам должны быть относительными, а не абсолютными. Эта папка записи не является той же папкой, что и само приложение, поэтому изображения, звуки и само приложение не могут быть перезаписаны. Файлы, записанные в эту папку, можно читать с помощью OpenToRead. Если файл не существует, он будет создан, если файл существует, он будет перезаписан, если append равен 0. или добавлен, если append равен 1. Если каталог указан в имени файла и не существует, он будет создан. Чтобы записать файл вне обычной папки записи, вы можете использовать "raw:", за которым следует абсолютный путь для текущей платформы, например "raw:C:\MyFolder\MyFile.txt" на окнах или "raw:/sdcard/Documents/MyFile.txt-на Андроиде. Если какие-либо папки в выбранном вами пути не существуют, они будут созданы. На Raspberry Pi вы можете использовать эту команду, чтобы открыть pin-код GPIO для записи, используя имя файла "gpio:", за которым следует номер pin-кода GPIO, например OpenToWrite(1, "gpio:4"), это чувствительно к регистру. Затем вы можете использовать writeByte для записи 0 или 1 в pin-код и CloseFile для закрытия pin-кода.
     *
     * @param string $szFile Имя файла, которое нужно открыть для записи.
     * @return int
     */
    function OpenToWrite($szFile)
    {
    }

    /**
     *Открывает файл, хранящийся в локальной файловой системе, для записи в указанный идентификатор. Все платформы ограничены одной папкой для записи, поэтому пути к файлам должны быть относительными, а не абсолютными. Эта папка записи не является той же папкой, что и само приложение, поэтому изображения, звуки и само приложение не могут быть перезаписаны. Файлы, записанные в эту папку, можно читать с помощью OpenToRead. Если файл не существует, он будет создан, если файл существует, он будет перезаписан, если append равен 0. или добавлен, если append равен 1. Если каталог указан в имени файла и не существует, он будет создан. Чтобы записать файл вне обычной папки записи, вы можете использовать "raw:", за которым следует абсолютный путь для текущей платформы, например "raw:C:\MyFolder\MyFile.txt" на окнах или "raw:/sdcard/Documents/MyFile.txt-на Андроиде. Если какие-либо папки в выбранном вами пути не существуют, они будут созданы. На Raspberry Pi вы можете использовать эту команду, чтобы открыть pin-код GPIO для записи, используя имя файла "gpio:", за которым следует номер pin-кода GPIO, например OpenToWrite(1, "gpio:4"), это чувствительно к регистру. Затем вы можете использовать writeByte для записи 0 или 1 в pin-код и CloseFile для закрытия pin-кода.
     *
     * @param int $ID Идентификатор, который будет использоваться для ссылки на этот файл позже.
     * @param string $szFile Имя файла, которое нужно открыть для записи.
     * @param int $append Установите значение 1 для добавления в файл, 0 для перезаписи всех данных (необязательно, по умолчанию 0).
     * @return void
     */
    function OpenToWrite($ID, $szFile, $append)
    {
    }

    /**
     *Открывает файл, хранящийся в локальной файловой системе, для чтения в указанный идентификатор. Все платформы ограничены одной папкой для чтения и записи, поэтому пути к файлам должны быть относительными, а не абсолютными. Эта команда сначала проверит специальную папку записи, а если она не сможет найти файл, то проверит папку мультимедиа, так что вы можете загрузить изображения, звуки и другие связанные медиафайлы с помощью этой команды. Чтобы прочитать файл вне обычных папок чтения или записи, вы можете использовать "raw:", за которым следует абсолютный путь для текущей платформы, например "raw:C:\MyFolder\MyFile.txt" на окнах или "raw:/sdcard/Documents/MyFile.txt-на Андроиде. На Raspberry Pi вы можете использовать эту команду, чтобы открыть pin-код GPIO для чтения, используя имя файла "gpio:", за которым следует номер pin-кода GPIO, например OpenToRead(1, "gpio:4"), это чувствительно к регистру. Затем вы можете использовать ReadByte для чтения из pin-кода и CloseFile для закрытия pin-кода.
     *
     * @param int $ID Идентификатор, который будет использоваться для ссылки на этот файл позже.
     * @param string $szFile Имя файла, которое нужно открыть для чтения.
     * @return void
     */
    function OpenToRead($ID, $szFile)
    {
    }

    /**
     *Открывает файл, хранящийся в локальной файловой системе, для чтения в указанный идентификатор. Все платформы ограничены одной папкой для чтения и записи, поэтому пути к файлам должны быть относительными, а не абсолютными. Эта команда сначала проверит специальную папку записи, а если она не сможет найти файл, то проверит папку мультимедиа, так что вы можете загрузить изображения, звуки и другие связанные медиафайлы с помощью этой команды. Чтобы прочитать файл вне обычных папок чтения или записи, вы можете использовать "raw:", за которым следует абсолютный путь для текущей платформы, например "raw:C:\MyFolder\MyFile.txt" на окнах или "raw:/sdcard/Documents/MyFile.txt-на Андроиде. На Raspberry Pi вы можете использовать эту команду, чтобы открыть pin-код GPIO для чтения, используя имя файла "gpio:", за которым следует номер pin-кода GPIO, например OpenToRead(1, "gpio:4"), это чувствительно к регистру. Затем вы можете использовать ReadByte для чтения из pin-кода и CloseFile для закрытия pin-кода.
     *
     * @param string $szFile Имя файла, которое нужно открыть для чтения.
     * @return int
     */
    function OpenToRead($szFile)
    {
    }

    /**
     *Открывает папку в любом месте файловой системы и считывает список содержащихся в ней файлов и папок. Это делается немедленно, поэтому любые изменения, которые происходят в папке после этой команды, не будут замечены, вам нужно будет вызвать эту команду снова, чтобы получить обновленное содержимое. Путь к файлу должен быть абсолютным для текущего устройства, то есть он должен начинаться с буквы диска и двоеточия в Windows и прямой косой черты на всех других платформах. Путь должен существовать и быть доступен для текущего приложения, иначе эта команда выдаст ошибку. Путь может начинаться с текста "raw:" или нет, принимаются обе формы. Эта команда вернет идентификатор, который вы можете использовать для доступа к найденному списку файлов, он будет оставаться доступным до тех пор, пока вы не закроете его с помощью CloseRawFolder. Несколько папок могут быть открыты одновременно, каждому из них будет присвоен свой идентификатор.
     *
     * @param string $szPath Путь к папке, которую нужно открыть
     * @return int
     */
    function OpenRawFolder($szPath)
    {
    }

    /**
     *Открывает браузер по умолчанию текущей платформы и указывает его на заданную страницу.
     *
     * @param string $url URL
     * @return void
     */
    function OpenBrowser($url)
    {
    }

    /**
     *Немедленно перемещает все существующие частицы на заданное смещение. Например,смещение x=3, y=5 сдвинет все частицы вправо на 3 единицы и вниз на 5 единиц. Это не влияет на излучатель частиц, но может быть использовано в сочетании с SetParticlesPosition для перемещения как излучателя, так и уже существующих частиц.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x Расстояние для перемещения частиц в направлении X.
     * @param float $y Расстояние для перемещения частиц в направлении Y.
     * @return void
     */
    function OffsetParticles($ID, $x, $y)
    {
    }

    /**
     *Эта команда делает то же самое, что и ObjectSphereCast, но в течение нескольких итераций, чтобы создать точку скольжения для использования в скользящих столкновениях. Он создает скользящую точку, которая снова проверяется, чтобы убедиться, что эта новая точка не сталкивается ни с какими объектами. Это порождает еще одну точку, которую необходимо проверить и так далее. ObjectSphereSlide использует максимум три итерации для завершения точки, которая будет держать сферу вне всех проверенных объектов. Команда GetObjectRayCastNumHits может быть использована для получения количества итераций, используемых этой командой. Подробная информация о точке столкновения, нормали и точке скольжения для каждой итерации также доступна с использованием индексов столкновения от 1 до 3, т. е. GetObjectRayCastX(1) (2) или (3). Конечная точка столкновения, нормаль и точка скольжения находятся в индексе 0, то есть GetObjectRayCastSlideX(0).
     *
     * @param int $objID Идентификатор проверяемого объекта-0 для всех объектов.
     * @param float $oldx Компонент X начальной позиции.
     * @param float $oldy Компонент Y начальной позиции.
     * @param float $oldz Z-компонент начальной позиции.
     * @param float $newx X-компонент конечного положения.
     * @param float $newy Компонент Y конечного положения.
     * @param float $newz Z-компонент конечного положения.
     * @param float $radius Радиус сферы для отливки.
     * @return int
     */
    function ObjectSphereSlide($objID, $oldx, $oldy, $oldz, $newx, $newy, $newz, $radius)
    {
    }

    /**
     *Немедленно перемещает все существующие частицы на заданное смещение. Например, смещение x=3,y=5,z=0 сдвинет все частицы вправо на 3 единицы и вниз на 5 единиц. Это не влияет на излучатель частиц, но может быть использовано в сочетании с Set3DParticlesPosition для перемещения как излучателя, так и уже существующих частиц.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $x Расстояние для перемещения частиц в направлении X.
     * @param float $y Расстояние для перемещения частиц в направлении Y.
     * @param float $z Расстояние для перемещения частиц в направлении Z.
     * @return void
     */
    function Offset3DParticles($ID, $x, $y, $z)
    {
    }

    /**
     *Бросает луч через 1 или все объекты, чтобы проверить пересечение с объектом. Лучи определяются с начальным положением и конечным положением и не сталкиваются с задними поверхностями, вернут номер объекта, попавшего первым, или 0 для отсутствия столкновения. Команды лучевого литья полезны для расчета столкновений пуль с уровнями и объектами или для представления линии визирования противника, чтобы определить, могут ли они видеть игрока.
     *
     * @param int $objID Идентификатор проверяемого объекта-0 для всех объектов.
     * @param float $oldx Компонент X начальной позиции.
     * @param float $oldy Компонент Y начальной позиции.
     * @param float $oldz Z-компонент начальной позиции.
     * @param float $newx X-компонент конечного положения.
     * @param float $newy Компонент Y конечного положения.
     * @param float $newz Z-компонент конечного положения.
     * @return int
     */
    function ObjectRayCast($objID, $oldx, $oldy, $oldz, $newx, $newy, $newz)
    {
    }

    /**
     *Проверит, не сталкивается ли луч, начинающийся в oldx, oldy, oldz и заканчивающийся в newx, newy, newz и радиусом ширины, с указанным объектом (ObjId=0 для всех). Не сталкивается с задними гранями, вернет номер объекта, попавшего первым, или 0 для отсутствия столкновения. Команды Sphere casting добавляют измерение ширины к нормальному лучевому кастингу, которое можно использовать для проверки того, ударил ли игрок что-нибудь во время движения, и для позиционирования их в точке столкновения, чтобы обеспечить "липкое" столкновение, где игрок останавливается, если он что-нибудь ударит. Альтернативой является скользящее столкновение. см. раздел ObjectSphereSlide
     *
     * @param int $objID Идентификатор проверяемого объекта-0 для всех объектов.
     * @param float $oldx Компонент X начальной позиции.
     * @param float $oldy Компонент Y начальной позиции.
     * @param float $oldz Z-компонент начальной позиции.
     * @param float $newx X-компонент конечного положения.
     * @param float $newy Компонент Y конечного положения.
     * @param float $newz Z-компонент конечного положения.
     * @param float $radius Радиус сферы для отливки.
     * @return int
     */
    function ObjectSphereCast($objID, $oldx, $oldy, $oldz, $newx, $newy, $newz, $radius)
    {
    }

    /**
     *Перемещает указанный объект вдоль его локальной оси Z, то есть если бы объект был символом, эта команда заставила бы его двигаться вперед независимо от того, в каком направлении он находится.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении Z, может быть отрицательным.
     * @return void
     */
    function MoveObjectLocalZ($objID, $amount)
    {
    }

    /**
     *Перемещает указанный объект вдоль его локальной оси Y, то есть если бы объект был символом, эта команда заставила бы его прыгать независимо от того, в каком направлении он находится.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении Y, может быть отрицательным.
     * @return void
     */
    function MoveObjectLocalY($objID, $amount)
    {
    }

    /**
     *Перемещает указанный объект вдоль его локальной оси X, то есть, если бы объект был символом, эта команда заставила бы их стреляться независимо от того, в каком направлении они были обращены.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении X, может быть отрицательным.
     * @return void
     */
    function MoveObjectLocalX($objID, $amount)
    {
    }

    /**
     *Перемещает указанную камеру вдоль ее локальной оси Z, то есть если бы камера была символом, эта команда заставила бы их двигаться вперед независимо от того, в каком направлении они были обращены.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении Z, может быть отрицательным.
     * @return void
     */
    function MoveCameraLocalZ($cameraID, $amount)
    {
    }

    /**
     *Перемещает указанную камеру вдоль ее локальной оси Y, то есть если бы камера была символом, эта команда заставила бы их прыгать независимо от того, в каком направлении они были обращены.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении Y, может быть отрицательным.
     * @return void
     */
    function MoveCameraLocalY($cameraID, $amount)
    {
    }

    /**
     *Перемещает указанную камеру вдоль ее локальной оси X, то есть если бы камера была символом, эта команда заставила бы их стреляться независимо от того, в каком направлении они были обращены.
     *
     * @param int $cameraID Идентификатор камеры для изменения, основная камера-ID 1.
     * @param float $amount Расстояние, на которое нужно двигаться в локальном направлении X, может быть отрицательным.
     * @return void
     */
    function MoveCameraLocalX($cameraID, $amount)
    {
    }

    /**
     *Перемещает контроллер.
     *
     * @param int $objID идентификатор объекта
     * @param float $x Сумма, которая будет двигаться в направлении x, будет нормализована с направлением z
     * @param float $z Сумма, которая будет двигаться в направлении z, будет нормализована с направлением x
     * @param float $velocity скорость перемещения
     * @return void
     */
    function Move3DPhysicsCharacterController($objID, $x, $z, $velocity)
    {
    }

    /**
     *Перемещает контроллер.
     *
     * @param int $objID идентификатор объекта
     * @param int $direction 0 = стоп, 1 = вперед, 2 = назад, 3 = стрейф влево, 4 = стрейф вправо
     * @param float $velocity скорость перемещения
     * @return void
     */
    function Move3DPhysicsCharacterController($objID, $direction, $velocity)
    {
    }

    /**
     *Возвращает остаток от целочисленного деления a/b.
     *
     * @param int $a Числитель.
     * @param int $b Знаменатель.
     * @return int
     */
    function Mod($a, $b)
    {
    }

    /**
     *Отправляет приложение в фоновый режим. На настольных платформах, таких как Windows, приложение будет продолжать работать, когда оно свернуто. На Android приложение будет приостановлено. На iOS он ничего не сделает, так как пользователь должен свернуть приложение, нажав кнопку home. На настольных платформах окно можно восстановить с помощью RestoreApp.
     *
     * @return void
     */
    function MinimizeApp()
    {
    }

    /**
     *Извлекает подстроку из заданной строки, расположенной в указанной позиции.
     *
     * @param string $strin Строка, из которой нужно извлечь
     * @param int $position Позиция, которая начинается в строке, первый символ-это позиция 1.
     * @param int $length Количество символов, извлекаемых из строки, используйте минус 1, чтобы продолжить до конца строки
     * @return string
     */
    function Mid($strin, $position, $length)
    {
    }

    /**
     *Отображает окно сообщения, содержащее заданный текст. Ваше приложение не гарантированно приостановится во время отображения сообщения.
     *
     * @param string $msg Сообщение для отображения
     * @return void
     */
    function Message($msg)
    {
    }

    /**
     *Максимизирует окно таким образом, чтобы оно было максимально возможным размером в текущем видимом пространстве без перехода на полный экран. Ничего не делает на мобильных устройствах.
     *
     * @return void
     */
    function MaximizeWindow()
    {
    }

    /**
     *Создает папку по текущему пути. По умолчанию это определяется командой SetFolder. Вы также можете использовать имя файла, начинающееся с "raw:", чтобы создать папку в любом месте файловой системы, например MakeFolder("raw:C:\Temp\MyFolder")
     *
     * @param string $szName Имя папки create.
     * @return int
     */
    function MakeFolder($szName)
    {
    }

    /**
     *Создает составное значение цвета из цветовых компонентов, которое затем можно использовать с командами 2D-рисования.
     *
     * @param int $red Красная составляющая цвета.
     * @param int $green Зеленая составляющая цвета.
     * @param int $blue Синяя составляющая цвета.
     * @return int
     */
    function MakeColor($red, $green, $blue)
    {
    }

    /**
     *Преобразует строку в символы нижнего регистра.
     *
     * @param string $strin Строка для преобразования
     * @return string
     */
    function Lower($strin)
    {
    }

    /**
     *Отображает указанный текст в соответствующем окне журнала устройства или вывода.
     *
     * @param string $szMessage текстовое сообщение для отправки в область журнала/вывода
     * @return void
     */
    function Log($szMessage)
    {
    }

    /**
     *Возвращает натуральный логарифм заданного значения.
     *
     * @param float $a Входное значение
     * @return float
     */
    function Log($a)
    {
    }

    /**
     *Загружает субизображение из текстуры атласа для использования в качестве автономного изображения в указанный идентификатор изображения. В subimages.txt файл должен начинаться с того же имени, что и файл изображения, например, атласное изображение myImage.png будет иметь файл подизображений с именем "myImage subimages.txt". Файл подизображений содержит ряд строк, каждая из которых описывает изображение, существующее в изображении атласа. Каждая строка должна иметь имя формата:X:Y:Width:Height с разделителем :, используемым между полями. Поле Name - это имя, которое вы хотите использовать для ссылки на субизображение при загрузке, оно должно соответствовать параметру sImageFilename этой команды LoadSubImage. Поля X:Y-это координаты пикселей X и Y, представляющие верхний левый угол подизображения, а поля Width:Height-это размер в пикселях подизображения. Эти значения затем используются для извлечения вашего именованного изображения из атласа и загрузки его в свой собственный идентификатор изображения, который будет использоваться как обычное изображение. Изображение атласа должно оставаться загруженным в течение всего времени использования загруженного субизображения. Обратите внимание, что при загрузке подизображения AGK немного изменит UV-координаты, чтобы изображение не крало пиксели из соседних изображений во время фильтрации, по умолчанию он сдвигает UV внутрь на 0,5 пикселя. Вы можете переопределить это, установив SetSpriteUVBorder равным 0 для спрайтов, где вам нужны идеальные пиксельные результаты, но вам придется следить за тем, чтобы пиксель кровоточил по краям, и, возможно, вам придется дать вашим субизображениям границу в 1 пиксель соответствующего цвета, которую он может безопасно украсть при фильтрации.
     *
     * @param int $iParentIndex Идентификатор изображения, содержащего текстуру атласа, загруженную ранее.
     * @param string $sImageFilename Имя файла вложенного образа, хранящегося в subimages.txt. Не используйте путь перед именем файла.
     * @return int
     */
    function LoadSubImage($iParentIndex, $sImageFilename)
    {
    }

    /**
     *Загружает субизображение из текстуры атласа для использования в качестве автономного изображения в указанный идентификатор изображения. В subimages.txt файл должен начинаться с того же имени, что и файл изображения, например, атласное изображение myImage.png будет иметь файл подизображений с именем "myImage subimages.txt". Файл подизображений содержит ряд строк, каждая из которых описывает изображение, существующее в изображении атласа. Каждая строка должна иметь имя формата:X:Y:Width:Height с разделителем :, используемым между полями. Поле Name - это имя, которое вы хотите использовать для ссылки на субизображение при загрузке, оно должно соответствовать параметру sImageFilename этой команды LoadSubImage. Поля X:Y-это координаты пикселей X и Y, представляющие верхний левый угол подизображения, а поля Width:Height-это размер в пикселях подизображения. Эти значения затем используются для извлечения вашего именованного изображения из атласа и загрузки его в свой собственный идентификатор изображения, который будет использоваться как обычное изображение. Изображение атласа должно оставаться загруженным в течение всего времени использования загруженного субизображения. Обратите внимание, что при загрузке подизображения AGK немного изменит UV-координаты, чтобы изображение не крало пиксели из соседних изображений во время фильтрации, по умолчанию он сдвигает UV внутрь на 0,5 пикселя. Вы можете переопределить это, установив SetSpriteUVBorder равным 0 для спрайтов, где вам нужны идеальные пиксельные результаты, но вам придется следить за тем, чтобы пиксель кровоточил по краям, и, возможно, вам придется дать вашим субизображениям границу в 1 пиксель соответствующего цвета, которую он может безопасно украсть при фильтрации.
     *
     * @param int $iImageIndex Идентификатор изображения, который будет использоваться для ссылки на это изображение позже.
     * @param int $iParentIndex Идентификатор изображения, содержащего текстуру атласа, загруженную ранее.
     * @param string $sImageFilename Имя файла вложенного образа, хранящегося в subimages.txt. Не используйте путь перед именем файла.
     * @return void
     */
    function LoadSubImage($iImageIndex, $iParentIndex, $sImageFilename)
    {
    }

    /**
     *Эта команда загружает видеофайл, готовый к воспроизведению. Одновременно может быть загружен только один видеофайл, поэтому загрузка видео удаляет все существующие видеофайлы. На iOS, Android и Mac рекомендуется использовать файлы .mp4 с кодеком H264 (MPEG-4 AVC) для видео. Для аудио он должен быть закодирован в формате MP3 или AAC. В Windows это зависит от установленных кодеков, и хотя в некоторых случаях он будет воспроизводить файлы mp4, рекомендуется использовать wmv в Windows для максимальной поддержки. Возвращает 1 в случае успеха, 0, если произошла ошибка, -1, если эта платформа не поддерживает видео.
     *
     * @param string $szFilename Видеофайл для загрузки.
     * @return int
     */
    function LoadVideo($szFilename)
    {
    }

    /**
     *Создает спрайт в пустом идентификаторе спрайта с явным изображением для использования при рендеринге, возвращает используемый идентификатор спрайта. По умолчанию спрайты создаются с глубиной 10, имеют размер, используя данное изображение в качестве направляющей, и позиционируются на 0,0, используя их верхний левый угол. Если назначенное изображение имеет альфа-пиксели, то спрайт создается с режимом прозрачности 1, в противном случае он использует режим прозрачности 0 (непрозрачный) Эта команда берет имя файла изображения и загружает его специально для этого спрайта, это изображение будет удалено, когда спрайт будет удален. Если много спрайтов собираются использовать одно и то же изображение, вы должны загрузить его отдельно и передать его идентификатор команде CreateSprite для экономии памяти.
     *
     * @param string $imagefile Имя файла изображения, которое будет использоваться при рисовании этого спрайта
     * @return int
     */
    function LoadSprite($imagefile)
    {
    }

    /**
     *Создает спрайт в пустом идентификаторе спрайта с явным изображением для использования при рендеринге, возвращает используемый идентификатор спрайта. По умолчанию спрайты создаются с глубиной 10, имеют размер, используя данное изображение в качестве направляющей, и позиционируются на 0,0, используя их верхний левый угол. Если назначенное изображение имеет альфа-пиксели, то спрайт создается с режимом прозрачности 1, в противном случае он использует режим прозрачности 0 (непрозрачный) Эта команда берет имя файла изображения и загружает его специально для этого спрайта, это изображение будет удалено, когда спрайт будет удален. Если много спрайтов собираются использовать одно и то же изображение, вы должны загрузить его отдельно и передать его идентификатор команде CreateSprite для экономии памяти.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который будет использоваться для ссылки на этот спрайт позже (отдельно от идентификаторов изображений, поэтому может быть как спрайт 1, так и изображение 1)
     * @param string $imagefile Имя файла изображения, которое будет использоваться при рисовании этого спрайта
     * @return void
     */
    function LoadSprite($iSpriteIndex, $imagefile)
    {
    }

    /**
     *Загружает шейдер, используемый для изменения спрайтов, поскольку он содержит только пиксельный шейдер, вершинный шейдер автоматически генерируется, чтобы убедиться, что он появляется в нужном месте. Этот тип шейдера должен применяться только к спрайтам, но ничего плохого не произойдет, если вы решите применить его к объектам, он просто даст необычные результаты рендеринга для этого объекта. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера. Возвращает идентификатор, который можно использовать для ссылки на этот шейдер в других командах. Идентификаторы являются общими для всех типов шейдеров, поэтому загрузка спрайтового шейдера в ID 1 не будет работать, если 3D-шейдер существует с ID 1.
     *
     * @param string $szPixelFile Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return int
     */
    function LoadSpriteShader($szPixelFile)
    {
    }

    /**
     *Загружает шейдер, используемый для изменения спрайтов, поскольку он содержит только пиксельный шейдер, вершинный шейдер автоматически генерируется, чтобы убедиться, что он появляется в нужном месте. Этот тип шейдера должен применяться только к спрайтам, но ничего плохого не произойдет, если вы решите применить его к объектам, он просто даст необычные результаты рендеринга для этого объекта. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера. Возвращает идентификатор, который можно использовать для ссылки на этот шейдер в других командах. Идентификаторы являются общими для всех типов шейдеров, поэтому загрузка спрайтового шейдера в ID 1 не будет работать, если 3D-шейдер существует с ID 1.
     *
     * @param int $shaderID Идентификатор, используемый для ссылки на этот шейдер в других командах.
     * @param string $szPixelFile Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return void
     */
    function LoadSpriteShader($shaderID, $szPixelFile)
    {
    }

    /**
     *Загружает анимацию спрайтера, экспортированную в формате JSON. Пожалуйста, обратитесь к разделу руководства для получения подробной информации о том, что поддерживается. Возвращает идентификатор, используемый для ссылки на этот скелет. Параметр atlas image еще не поддерживается и должен быть равен 0, изображения будут загружаться по путям, указанным в файле Spriter JSON. Вы можете использовать значение масштаба, чтобы изменить размер спрайтов и костей в соответствии с выбранным вами разрешением. Значение 1 не изменит размеров, значение 2 сделает все в два раза больше, значение 0,5 уменьшит размер вдвое, и так далее.
     *
     * @param string $filename Имя файла, который нужно загрузить, должно быть таким .экспорт json из позвоночника
     * @param float $scale Сумма для масштабирования размеров объекта
     * @param int $atlasImage зарезервировано, должно быть 0
     * @return int
     */
    function LoadSkeleton2DFromSpriterFile($filename, $scale, $atlasImage)
    {
    }

    /**
     *Загружает анимацию спрайтера, экспортированную в формате JSON. Пожалуйста, обратитесь к разделу руководства для получения подробной информации о том, что поддерживается. Возвращает идентификатор, используемый для ссылки на этот скелет. Параметр atlas image еще не поддерживается и должен быть равен 0, изображения будут загружаться по путям, указанным в файле Spriter JSON. Вы можете использовать значение масштаба, чтобы изменить размер спрайтов и костей в соответствии с выбранным вами разрешением. Значение 1 не изменит размеров, значение 2 сделает все в два раза больше, значение 0,5 уменьшит размер вдвое, и так далее.
     *
     * @param int $iSkeleton ID для использования для этого скелета
     * @param string $filename Имя файла, который нужно загрузить, должно быть таким .экспорт json из позвоночника
     * @param float $scale Сумма для масштабирования размеров объекта
     * @param int $atlasImage зарезервировано, должно быть 0
     * @return void
     */
    function LoadSkeleton2DFromSpriterFile($iSkeleton, $filename, $scale, $atlasImage)
    {
    }

    /**
     *Загружает звуковой файл из папки мультимедиа приложения и возвращает номер звука. Пути к файлам должны быть относительными, а не абсолютными, вы не можете загружать звуковые файлы из другого места на диске. Обратите внимание, что сжатые WAV-файлы не поддерживаются. Вы должны использовать несжатые WAV-файлы, чтобы обеспечить совместимость на всех платформах.
     *
     * @param string $sFilename Имя файла загружаемого звукового файла должно быть WAV-файлом.
     * @return int
     */
    function LoadSound($sFilename)
    {
    }

    /**
     *Загружает звуковой файл из папки мультимедиа приложения и возвращает номер звука. Пути к файлам должны быть относительными, а не абсолютными, вы не можете загружать звуковые файлы из другого места на диске. Обратите внимание, что сжатые WAV-файлы не поддерживаются. Вы должны использовать несжатые WAV-файлы, чтобы обеспечить совместимость на всех платформах.
     *
     * @param int $iID Звуковой номер для хранения звука.
     * @param string $sFilename Имя файла загружаемого звукового файла должно быть WAV-файлом.
     * @return void
     */
    function LoadSound($iID, $sFilename)
    {
    }

    /**
     *Загружает звуковой файл из папки мультимедиа приложения. Пути к файлам должны быть относительными, а не абсолютными, вы не можете загружать звуковые файлы из других мест на диске. Эта команда берет сжатый OGG-файл и распаковывает его во время загрузки, позволяя вам сохранить размер файла, но использование памяти будет таким же, как если бы вы использовали WAV-файл. Если вы хотите использовать OGG, а также экономить память, то используйте новые команды LoadMusicOGG.
     *
     * @param int $iID Звуковой номер для хранения звука.
     * @param string $sFilename Имя файла загружаемого звукового файла должно быть OGG-файлом.
     * @return void
     */
    function LoadSoundOGG($iID, $sFilename)
    {
    }

    /**
     *Загружает звуковой файл из папки мультимедиа приложения. Пути к файлам должны быть относительными, а не абсолютными, вы не можете загружать звуковые файлы из других мест на диске. Эта команда берет сжатый OGG-файл и распаковывает его во время загрузки, позволяя вам сохранить размер файла, но использование памяти будет таким же, как если бы вы использовали WAV-файл. Если вы хотите использовать OGG, а также экономить память, то используйте новые команды LoadMusicOGG.
     *
     * @param string $sFilename Имя файла загружаемого звукового файла должно быть OGG-файлом.
     * @return int
     */
    function LoadSoundOGG($sFilename)
    {
    }

    /**
     *Загружает анимацию позвоночника, экспортированную в формате JSON. Пожалуйста, обратитесь к разделу руководства для получения подробной информации о том, что поддерживается. Возвращает идентификатор, используемый для ссылки на этот скелет. Сначала вы должны загрузить изображение атласа, экспортированное Spine, в изображение AGK с помощью команды normal LoadImage и передать его в эту функцию. Вы также можете загрузить анимацию или просто спрайты и кости и переместить или изменить их вручную. Вы можете использовать значение масштаба, чтобы изменить размер спрайтов и костей в соответствии с выбранным вами разрешением. Значение 1 не изменит размеров, значение 2 сделает все в два раза больше, значение 0,5 уменьшит размер вдвое, и так далее.
     *
     * @param string $filename Имя файла, который нужно загрузить, должно быть таким .экспорт json из позвоночника
     * @param float $scale Сумма для масштабирования размеров объекта
     * @param int $atlasImage Идентификатор изображения атласа, содержащего все изображения
     * @param int $loadAnim 1 для загрузки анимации, 0 для загрузки только спрайтов и костей
     * @return int
     */
    function LoadSkeleton2DFromSpineFile($filename, $scale, $atlasImage, $loadAnim)
    {
    }

    /**
     *Загружает анимацию позвоночника, экспортированную в формате JSON. Пожалуйста, обратитесь к разделу руководства для получения подробной информации о том, что поддерживается. Возвращает идентификатор, используемый для ссылки на этот скелет. Сначала вы должны загрузить изображение атласа, экспортированное Spine, в изображение AGK с помощью команды normal LoadImage и передать его в эту функцию. Вы также можете загрузить анимацию или просто спрайты и кости и переместить или изменить их вручную. Вы можете использовать значение масштаба, чтобы изменить размер спрайтов и костей в соответствии с выбранным вами разрешением. Значение 1 не изменит размеров, значение 2 сделает все в два раза больше, значение 0,5 уменьшит размер вдвое, и так далее.
     *
     * @param int $iSkeleton ID для использования для этого скелета
     * @param string $filename Имя файла, который нужно загрузить, должно быть таким .экспорт json из позвоночника
     * @param float $scale Сумма для масштабирования размеров объекта
     * @param int $atlasImage Идентификатор изображения атласа, содержащего все изображения
     * @param int $loadAnim 1 для загрузки анимации, 0 для загрузки только спрайтов и костей
     * @return void
     */
    function LoadSkeleton2DFromSpineFile($iSkeleton, $filename, $scale, $atlasImage, $loadAnim)
    {
    }

    /**
     *Загружает переменную, сохраненную этим приложением или другим приложением. Это работает только на платформах iOS, Android 10 и ниже, а также HTML5. Приложения могут совместно использовать переменную только в том случае, если они отвечают определенным требованиям, основанным на платформе. В iOS приложения должны иметь один и тот же начальный идентификатор пакета (также называемый префиксом идентификатора приложения) и иметь один и тот же явный идентификатор приложения до последней точки. Например, com.mycompany.mygroup.myapp1 и com.mycompany.mygroup.myapp2 смогут совместно использовать переменные. На Android 10 и ниже приложения должны иметь разрешение WRITE_EXTERNAL_STORAGE и иметь одно и то же имя пакета до последней точки. Например, com.mycompany.mygroup.myapp1 и com.mycompany.mygroup.myapp2 смогут совместно использовать переменные. На Android общие переменные записываются в доступное пользователю место, поэтому имейте в виду, что пользователи могут читать и/или редактировать сохраненные вами переменные. На Android 11 или выше эта команда не будет работать, так как приложения ограничены в записи в общие места. В HTML приложения должны размещаться в одном домене, значения хранятся в виде файлов cookie. Переменные идентифицируются по имени, поэтому использование SaveSharedVariable("username", "Alice") установит переменную с именем "username" в значение "Alice". Затем это может быть прочитано другими приложениями с помощью LoadSharedVariable( "username", "" ). Если переменная с заданным именем не существует, то вместо нее возвращается указанное значение по умолчанию
     *
     * @param string $varName Имя переменной для извлечения
     * @param string $defaultValue Значение, возвращаемое, если переменная не существует
     * @return string
     */
    function LoadSharedVariable($varName, $defaultValue)
    {
    }

    /**
     *Загружает шейдер, используемый для рисования объектов. Вершинный шейдер преобразует полигоны в экранное пространство, а пиксельный шейдер определяет окончательный цвет каждого пикселя, который покрывает объект. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера.
     *
     * @param int $shaderID Идентификатор, используемый для ссылки на этот шейдер в других командах.
     * @param string $szVertexSource Имя файла вершинного шейдера, обычно заканчивающееся .vs
     * @param string $szPixelSource Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return void
     */
    function LoadShaderFromString($shaderID, $szVertexSource, $szPixelSource)
    {
    }

    /**
     *Загружает шейдер, используемый для рисования объектов. Вершинный шейдер преобразует полигоны в экранное пространство, а пиксельный шейдер определяет окончательный цвет каждого пикселя, который покрывает объект. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера.
     *
     * @param string $szVertexSource Имя файла вершинного шейдера, обычно заканчивающееся .vs
     * @param string $szPixelSource Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return int
     */
    function LoadShaderFromString($szVertexSource, $szPixelSource)
    {
    }

    /**
     *Загружает шейдер, используемый для рисования объектов. Вершинный шейдер преобразует полигоны в экранное пространство, а пиксельный шейдер определяет окончательный цвет каждого пикселя, который покрывает объект. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера.
     *
     * @param int $shaderID Идентификатор, используемый для ссылки на этот шейдер в других командах.
     * @param string $szVertexFile Имя файла вершинного шейдера, обычно заканчивающееся .vs
     * @param string $szPixelFile Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return void
     */
    function LoadShader($shaderID, $szVertexFile, $szPixelFile)
    {
    }

    /**
     *Загружает шейдер, используемый для рисования объектов. Вершинный шейдер преобразует полигоны в экранное пространство, а пиксельный шейдер определяет окончательный цвет каждого пикселя, который покрывает объект. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера.
     *
     * @param string $szVertexFile Имя файла вершинного шейдера, обычно заканчивающееся .vs
     * @param string $szPixelFile Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return int
     */
    function LoadShader($szVertexFile, $szPixelFile)
    {
    }

    /**
     *Загружает объект из файла, в настоящее время поддерживаются форматы .X .FBX .dae (collada) .3ds .md3 .smd .md5 .lwo .ac .b3d .dae .3d .lws .ms3d .blend .obj и .ago. Если файл модели содержит иерархию костей или анимационные данные, то они также будут загружены и связаны с объектом. Обратите внимание, что объекты с более чем 50 костями могут не отображаться на некоторых старых устройствах. AGK имеет предел в 200 костей. Если файл модели содержит график сцены, содержащий несколько объектов, то они также будут загружены и сохранены в отдельных объектах, которые могут быть обнаружены с помощью GetObjectNumChildren. Если вы просто хотите загрузить один объект без каких-либо костей, анимации или детей, то вместо этого используйте LoadObject. Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.
     *
     * @param string $szFilename Имя загружаемого объектного файла.
     * @return int
     */
    function LoadObjectWithChildren($szFilename)
    {
    }

    /**
     *Загружает объект из файла, в настоящее время поддерживаются форматы .X .FBX .dae (collada) .3ds .md3 .smd .md5 .lwo .ac .b3d .dae .3d .lws .ms3d .blend .obj и .ago. Если файл модели содержит иерархию костей или анимационные данные, то они также будут загружены и связаны с объектом. Обратите внимание, что объекты с более чем 50 костями могут не отображаться на некоторых старых устройствах. AGK имеет предел в 200 костей. Если файл модели содержит график сцены, содержащий несколько объектов, то они также будут загружены и сохранены в отдельных объектах, которые могут быть обнаружены с помощью GetObjectNumChildren. Если вы просто хотите загрузить один объект без каких-либо костей, анимации или детей, то вместо этого используйте LoadObject. Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param string $szFilename Имя загружаемого объектного файла.
     * @return void
     */
    function LoadObjectWithChildren($objID, $szFilename)
    {
    }

    /**
     *загружает форму столкновения из файла .bcs (Bullet Collision Shape) и устанавливает ее на объект. Возвращает true, если это удалось.
     *
     * @param int $objID идентификатор объекта
     * @param string $fileName имя файла
     * @return int
     */
    function LoadObjectShape($objID, $fileName)
    {
    }

    /**
     *Загружает объект из файла, в настоящее время поддерживаются форматы .X .3ds .md3 .smd .md5 .lwo. ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj и .ago. Эта команда не будет загружать никаких анимационных или костных данных и объединит вершины в один объект с как можно меньшим количеством сеток. Для загрузки анимации и костных данных используйте вместо этого LoadObjectWithChildren.
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param string $szFilename Имя загружаемого объектного файла.
     * @return void
     */
    function LoadObject($objID, $szFilename)
    {
    }

    /**
     *Загружает объект из файла, в настоящее время поддерживаются форматы .X .3ds .md3 .smd .md5 .lwo. ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj и .ago. Эта команда не будет загружать никаких анимационных или костных данных и объединит вершины в один объект с как можно меньшим количеством сеток. Для загрузки анимации и костных данных используйте вместо этого LoadObjectWithChildren.
     *
     * @param string $szFilename Имя загружаемого объектного файла.
     * @param float $height Масштабируйте загруженный объект до этой высоты.
     * @return int
     */
    function LoadObject($szFilename, $height)
    {
    }

    /**
     *Загружает объект из файла, в настоящее время поддерживаются форматы .X .3ds .md3 .smd .md5 .lwo. ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj и .ago. Эта команда не будет загружать никаких анимационных или костных данных и объединит вершины в один объект с как можно меньшим количеством сеток. Для загрузки анимации и костных данных используйте вместо этого LoadObjectWithChildren.
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param string $szFilename Имя загружаемого объектного файла.
     * @param float $height Масштабируйте загруженный объект до этой высоты.
     * @return void
     */
    function LoadObject($objID, $szFilename, $height)
    {
    }

    /**
     *Загружает объект из файла, в настоящее время поддерживаются форматы .X .3ds .md3 .smd .md5 .lwo. ac .b3d .dae .3d .lws .ms3d .blend .m3 .obj и .ago. Эта команда не будет загружать никаких анимационных или костных данных и объединит вершины в один объект с как можно меньшим количеством сеток. Для загрузки анимации и костных данных используйте вместо этого LoadObjectWithChildren.
     *
     * @param string $szFilename Имя загружаемого объектного файла.
     * @return int
     */
    function LoadObject($szFilename)
    {
    }

    /**
     *Загружает музыкальный файл из папки мультимедиа приложения в указанный идентификатор. Пути к файлам должны быть относительными, а не абсолютными, вы не можете загружать музыкальные файлы из других мест на диске. Он возвращает идентификатор музыкального файла для последующей ссылки на него. Рекомендуемый формат для кросс-платформенной совместимости-MP3. Обратите внимание, что платформа Meego в настоящее время не поддерживает MP3, вместо этого она попытается загрузить файл OGG Vorbis. Например, если вы попытаетесь загрузить "music.mp3", на Meego это будет интерпретировано как "music.ogg". Идентификатор должен находиться в диапазоне от 1 до 50.
     *
     * @param int $iID Музыкальный номер для хранения музыки.
     * @param string $sFile Имя файла загружаемого музыкального файла.
     * @return void
     */
    function LoadMusic($iID, $sFile)
    {
    }

    /**
     *Загружает музыкальный файл из папки мультимедиа приложения в указанный идентификатор. Пути к файлам должны быть относительными, а не абсолютными, вы не можете загружать музыкальные файлы из других мест на диске. Он возвращает идентификатор музыкального файла для последующей ссылки на него. Рекомендуемый формат для кросс-платформенной совместимости-MP3. Обратите внимание, что платформа Meego в настоящее время не поддерживает MP3, вместо этого она попытается загрузить файл OGG Vorbis. Например, если вы попытаетесь загрузить "music.mp3", на Meego это будет интерпретировано как "music.ogg". Идентификатор должен находиться в диапазоне от 1 до 50.
     *
     * @param string $sFile Имя файла загружаемого музыкального файла.
     * @return int
     */
    function LoadMusic($sFile)
    {
    }

    /**
     *Загружает музыкальный файл, сжатый с помощью OGG Vorbis. Это поддерживается на всех платформах, как и новый предпочтительный способ воспроизведения музыки, заменяющий команду LoadMusic. Одновременно можно воспроизводить несколько музыкальных файлов OGG. Идентификаторы музыкальных файлов OGG отделены от обычных идентификаторов музыкальных файлов и не ограничены определенным диапазоном чисел.
     *
     * @param int $musicID Идентификатор, используемый для ссылки на этот музыкальный файл.
     * @param string $sFile Имя файла загружаемого музыкального файла.
     * @return void
     */
    function LoadMusicOGG($musicID, $sFile)
    {
    }

    /**
     *Загружает музыкальный файл, сжатый с помощью OGG Vorbis. Это поддерживается на всех платформах, как и новый предпочтительный способ воспроизведения музыки, заменяющий команду LoadMusic. Одновременно можно воспроизводить несколько музыкальных файлов OGG. Идентификаторы музыкальных файлов OGG отделены от обычных идентификаторов музыкальных файлов и не ограничены определенным диапазоном чисел.
     *
     * @param string $sFile Имя файла загружаемого музыкального файла.
     * @return int
     */
    function LoadMusicOGG($sFile)
    {
    }

    /**
     *Загружает изображение, изменяя его размер в процессе. Это позволяет вам иметь одно высококачественное изображение, а затем изменять его размер в зависимости от разрешения устройства во время выполнения, вместо того чтобы иметь несколько уровней качества. Уменьшение размера изображения предпочтительнее увеличения размера изображения, так как увеличение размера изображения не улучшает качество, но оба варианта поддерживаются. Значение 1.0 не изменяет размер изображения, значение меньше 1 сделает изображение меньше, значение больше 1 сделает изображение больше. Значения масштабирования должны быть больше 0, но могут быть любой дробью, то есть допустима шкала 0,6742. Масштаб 0,5 уменьшит размер изображения вдвое, 2,0-вдвое, и так далее. Изображение может быть изменено по-разному в направлениях X и Y, хотя это приведет к растяжению. Если вы загружаете текстуру атласа с помощью этой команды, то subimages.txt файл также будет иметь свои значения, измененные таким образом, чтобы LoadSubImage по-прежнему работал правильно. Параметр кэша больше не используется, так как масштабирование изображения теперь выполняется графическим процессором, поэтому почти не влияет на производительность
     *
     * @param string $szFilename Имя загружаемого файла
     * @param float $scaleX Сумма для масштабирования в направлении X, 1.0-это исходный размер
     * @param float $scaleY Сумма для масштабирования в направлении Y, 1.0-это исходный размер
     * @param int $cache Больше не используется, должно быть 0
     * @return int
     */
    function LoadImageResized($szFilename, $scaleX, $scaleY, $cache)
    {
    }

    /**
     *Загружает изображение, изменяя его размер в процессе. Это позволяет вам иметь одно высококачественное изображение, а затем изменять его размер в зависимости от разрешения устройства во время выполнения, вместо того чтобы иметь несколько уровней качества. Уменьшение размера изображения предпочтительнее увеличения размера изображения, так как увеличение размера изображения не улучшает качество, но оба варианта поддерживаются. Значение 1.0 не изменяет размер изображения, значение меньше 1 сделает изображение меньше, значение больше 1 сделает изображение больше. Значения масштабирования должны быть больше 0, но могут быть любой дробью, то есть допустима шкала 0,6742. Масштаб 0,5 уменьшит размер изображения вдвое, 2,0-вдвое, и так далее. Изображение может быть изменено по-разному в направлениях X и Y, хотя это приведет к растяжению. Если вы загружаете текстуру атласа с помощью этой команды, то subimages.txt файл также будет иметь свои значения, измененные таким образом, чтобы LoadSubImage по-прежнему работал правильно. Параметр кэша больше не используется, так как масштабирование изображения теперь выполняется графическим процессором, поэтому почти не влияет на производительность
     *
     * @param int $iImageID Идентификатор, который будет использоваться для ссылки на это изображение в будущем
     * @param string $szFilename Имя загружаемого файла
     * @param float $scaleX Сумма для масштабирования в направлении X, 1.0-это исходный размер
     * @param float $scaleY Сумма для масштабирования в направлении Y, 1.0-это исходный размер
     * @param int $cache Больше не используется, должно быть 0
     * @return void
     */
    function LoadImageResized($iImageID, $szFilename, $scaleX, $scaleY, $cache)
    {
    }

    /**
     *Загружает изображение из файла в указанный идентификатор изображения, также может быть использован для загрузки текстуры атласа, которая будет использоваться субизображениями. При загрузке текстуры атласа a subimages.txt файл должен существовать с подробным описанием всех содержащихся в нем изображений. Ширина и высота изображения должны быть от 1 до 2048 пикселей, некоторые устройства могут поддерживать большие размеры, но это не гарантируется. Изображения не должны быть размером в 2 степени (2,4,8,16,32 и т. Д.). Если у вас есть много небольших изображений, вы можете объединить их в текстуру атласа, чтобы повысить производительность.
     *
     * @param int $ID Идентификатор, который будет использоваться для ссылки на это изображение позже.
     * @param string $sImageFilename Имя файла загружаемого изображения.
     * @param int $bBlackToAlpha Установите значение 1, чтобы переопределить альфа-канал изображения, чтобы он был прозрачным там, где есть черные пиксели, и непрозрачным в противном случае (по умолчанию 0)
     * @return void
     */
    function LoadImage($ID, $sImageFilename, $bBlackToAlpha)
    {
    }

    /**
     *Загружает изображение из файла в указанный идентификатор изображения, также может быть использован для загрузки текстуры атласа, которая будет использоваться субизображениями. При загрузке текстуры атласа a subimages.txt файл должен существовать с подробным описанием всех содержащихся в нем изображений. Ширина и высота изображения должны быть от 1 до 2048 пикселей, некоторые устройства могут поддерживать большие размеры, но это не гарантируется. Изображения не должны быть размером в 2 степени (2,4,8,16,32 и т. Д.). Если у вас есть много небольших изображений, вы можете объединить их в текстуру атласа, чтобы повысить производительность.
     *
     * @param string $sImageFilename Имя файла загружаемого изображения.
     * @param int $bBlackToAlpha Установите значение 1, чтобы переопределить альфа-канал изображения, чтобы он был прозрачным там, где есть черные пиксели, и непрозрачным в противном случае (по умолчанию 0)
     * @return int
     */
    function LoadImage($sImageFilename, $bBlackToAlpha)
    {
    }

    /**
     *Загружает изображение из файла в указанный идентификатор изображения, также может быть использован для загрузки текстуры атласа, которая будет использоваться субизображениями. При загрузке текстуры атласа a subimages.txt файл должен существовать с подробным описанием всех содержащихся в нем изображений. Ширина и высота изображения должны быть от 1 до 2048 пикселей, некоторые устройства могут поддерживать большие размеры, но это не гарантируется. Изображения не должны быть размером в 2 степени (2,4,8,16,32 и т. Д.). Если у вас есть много небольших изображений, вы можете объединить их в текстуру атласа, чтобы повысить производительность.
     *
     * @param string $sImageFilename Имя файла загружаемого изображения.
     * @return int
     */
    function LoadImage($sImageFilename)
    {
    }

    /**
     *Загружает изображение из файла в указанный идентификатор изображения, также может быть использован для загрузки текстуры атласа, которая будет использоваться субизображениями. При загрузке текстуры атласа a subimages.txt файл должен существовать с подробным описанием всех содержащихся в нем изображений. Ширина и высота изображения должны быть от 1 до 2048 пикселей, некоторые устройства могут поддерживать большие размеры, но это не гарантируется. Изображения не должны быть размером в 2 степени (2,4,8,16,32 и т. Д.). Если у вас есть много небольших изображений, вы можете объединить их в текстуру атласа, чтобы повысить производительность.
     *
     * @param int $ID Идентификатор, который будет использоваться для ссылки на это изображение позже.
     * @param string $sImageFilename Имя файла загружаемого изображения.
     * @return void
     */
    function LoadImage($ID, $sImageFilename)
    {
    }

    /**
     *Загружает файл шрифта в AGK, как правило, в формате TrueType, но все, что поддерживается FreeType, должно работать. Параметр szFontFile может быть либо файлом шрифта, расположенным в вашей папке мультимедиа, либо именем системного шрифта, эта команда сначала проверит вашу папку мультимедиа, прежде чем проверять наличие системных шрифтов. Если вы загружаете системный шрифт, то расширение файла является необязательным, например "Arial.ttf" и "Arial" будут загружать системный шрифт "Arial", если он существует. При загрузке системного шрифта имя файла не должно иметь никаких путей к папкам в имени файла, то есть никаких прямых или обратных косых черт. Чтобы повысить производительность, вы должны загрузить шрифт только один раз. Например, если вы хотите использовать шрифт "Arial" в нескольких местах, то вам следует загрузить его в идентификатор, а затем использовать этот идентификатор для всех целей, а не загружать несколько копий файла шрифта Arial в отдельные идентификаторы.
     *
     * @param int $iFontID Идентификатор, который будет использоваться для ссылки на этот шрифт в будущем
     * @param string $szFontFile Имя файла загружаемого шрифта
     * @return void
     */
    function LoadFont($iFontID, $szFontFile)
    {
    }

    /**
     *Загружает файл шрифта в AGK, как правило, в формате TrueType, но все, что поддерживается FreeType, должно работать. Параметр szFontFile может быть либо файлом шрифта, расположенным в вашей папке мультимедиа, либо именем системного шрифта, эта команда сначала проверит вашу папку мультимедиа, прежде чем проверять наличие системных шрифтов. Если вы загружаете системный шрифт, то расширение файла является необязательным, например "Arial.ttf" и "Arial" будут загружать системный шрифт "Arial", если он существует. При загрузке системного шрифта имя файла не должно иметь никаких путей к папкам в имени файла, то есть никаких прямых или обратных косых черт. Чтобы повысить производительность, вы должны загрузить шрифт только один раз. Например, если вы хотите использовать шрифт "Arial" в нескольких местах, то вам следует загрузить его в идентификатор, а затем использовать этот идентификатор для всех целей, а не загружать несколько копий файла шрифта Arial в отдельные идентификаторы.
     *
     * @param string $szFontFile Имя файла загружаемого шрифта
     * @return int
     */
    function LoadFont($szFontFile)
    {
    }

    /**
     *Загружает текущий статус согласия пользователя с сервера AdMob, это необходимо сделать перед вызовом RequestConsentAdMob. Вы должны дождаться, пока GetConsentStatusAdMob вернет неотрицательное значение, прежде чем использовать другие команды согласия AdMob.
     *
     * @param string $szPubID Идентификатор издателя для вашей учетной записи AdMob
     * @param string $privacyPolicy URL
     * @return void
     */
    function LoadConsentStatusAdMob($szPubID, $privacyPolicy)
    {
    }

    /**
     *Загружает шейдер, используемый для изменения целей рендеринга, поскольку он содержит только пиксельный шейдер, вершинный шейдер автоматически генерируется, чтобы убедиться, что он применим к полному экрану. Этот тип шейдера должен применяться только к объектам, созданным с помощью CreateObjectQuad, но ничего плохого не произойдет, если вы решите применить его к другим объектам, он просто даст необычные результаты рендеринга для этого объекта. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера. Возвращает идентификатор, который можно использовать для ссылки на этот шейдер в других командах. Идентификаторы являются общими для всех типов шейдеров, поэтому загрузка полноэкранного шейдера в ID 1 не будет работать, если существует обычный шейдер с ID 1.
     *
     * @param string $szPixelFile Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return int
     */
    function LoadFullScreenShader($szPixelFile)
    {
    }

    /**
     *Загружает шейдер, используемый для изменения целей рендеринга, поскольку он содержит только пиксельный шейдер, вершинный шейдер автоматически генерируется, чтобы убедиться, что он применим к полному экрану. Этот тип шейдера должен применяться только к объектам, созданным с помощью CreateObjectQuad, но ничего плохого не произойдет, если вы решите применить его к другим объектам, он просто даст необычные результаты рендеринга для этого объекта. В настоящее время шейдеры по умолчанию используют GLSL версии 1.10, строка "#version 110" будет автоматически добавлена в качестве первой строки шейдера, если вы не укажете свою собственную строку "#version". Обратите внимание, что это может означать, что ваш шейдер работает не на всех устройствах и платформах. Глобальное значение "точность" будет добавлено и не должно быть включено в исходный код шейдера. Возвращает идентификатор, который можно использовать для ссылки на этот шейдер в других командах. Идентификаторы являются общими для всех типов шейдеров, поэтому загрузка полноэкранного шейдера в ID 1 не будет работать, если существует обычный шейдер с ID 1.
     *
     * @param int $shaderID Идентификатор, используемый для ссылки на этот шейдер в других командах.
     * @param string $szPixelFile Имя файла пиксельного шейдера, обычно заканчивающееся на .ps
     * @return void
     */
    function LoadFullScreenShader($shaderID, $szPixelFile)
    {
    }

    /**
     *Возвращает количество символов в данной строке. Обратите внимание, что для строк, закодированных в UTF-8, это может быть не равно количеству байтов в строке, так как каждый символ может использовать до 4 байт. Для определения длины в байтах используйте команду ByteLen.
     *
     * @param string $strin Строка для измерения длины
     * @return int
     */
    function Len($strin)
    {
    }

    /**
     *Обрезает заданную строку, сохраняя наибольшее количество символов слева до заданного значения счетчика.
     *
     * @param string $strin Строка, которую нужно обрезать
     * @param int $count Количество символов, которые нужно сохранить
     * @return string
     */
    function Left($strin, $count)
    {
    }

    /**
     *Пинает клиента из сети. Это происходит не сразу, и клиент может оставаться в течение нескольких кадров, прежде чем его окончательно пнут. Клиент отключится обычным способом, вы должны проверить GetNetworkClientDisconnected, чтобы обнаружить, когда клиент был выгнан, а затем вызвать DeleteNetworkClient, чтобы окончательно избавиться от него.
     *
     * @param int $iNetID Идентификатор сети.
     * @param int $client идентификатор клиента, которого нужно пнуть.
     * @return void
     */
    function KickNetworkClient($iNetID, $client)
    {
    }

    /**
     *Соединяет два пути вместе и упрощает их, например, соединение пути с ../ удалит последнюю папку из пути. При необходимости между ними будет добавлена прямая косая черта, если первый путь заканчивается прямой косой чертой, а второй путь начинается с прямой косой черты, то один из них будет удален, чтобы сделать правильный путь. Любые обратные косые черты будут преобразованы в прямые косые черты. Первый путь может быть относительным или абсолютным, второй путь должен быть относительным. Это не будет проверено.
     *
     * @param string $szPath Первая часть пути
     * @param string $szPath2 Вторая часть пути
     * @return string
     */
    function JoinPaths($szPath, $szPath2)
    {
    }

    /**
     *Перемещает контроллер вверх на высоту прыжка.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Jump3DPhysicsCharacterController($objID)
    {
    }

    /**
     *Присоединяется к сети AGK, размещенной другим приложением. Сеть определяется по имени или по IP-адресу и номеру порта. Для именованных сетей приложение будет искать любые сети AGK, транслируемые с этим именем, и подключаться к ним, если они будут найдены. В качестве альтернативы, используя IP-адрес и номер порта, вы попытаетесь установить прямое соединение с хостом. В случае подключения к Интернету IP-адрес и порт-это единственный способ подключения, так как широковещательные передачи не покидают локальную сеть. IP-адреса могут быть IPv4 или IPv6 в зависимости от того, какие IP-адреса использует хост (он может иметь один или несколько из них). Вы можете обнаружить все сети, доступные для подключения, настроив прослушиватель широковещательных передач и прослушивая их самостоятельно, а затем отобразить список обнаруженных сетей пользователю, чтобы он мог решить, к какой из них подключиться. Эта функция не подключается сразу, она возвращает идентификатор сети и продолжает пытаться подключиться в фоновом режиме. Вы можете определить, когда установлено соединение, проверив, что GetNetworkNumClients больше 1, что указывает на то, что по крайней мере локальный клиент и серверный клиент были обнаружены. Если IsNetworkActive возвращает 0 в любой момент, то соединение с сервером не удалось и сеть должна быть закрыта, вы можете попытаться восстановить соединение, открыв новую сеть. После подключения приложение становится клиентом сети вместе с хостом и любыми другими клиентами, которые подключились к нему. Все клиенты обрабатываются одинаково и имеют список локальных переменных, которые они могут читать и записывать, все клиенты также могут читать любые переменные на других клиентах только для чтения. Вы должны идентифицировать своего клиента с именем клиента, которое будет видно другим клиентам, имя клиента не обязательно должно быть уникальным. Возвращает идентификатор сети, используемый при взаимодействии с этой сетью. Не работает при экспорте в HTML5
     *
     * @param string $szIP IP-адрес хоста для подключения может быть IPv4 или IPv6
     * @param int $port Порт для подключения.
     * @param string $szMyName Имя, которое нужно использовать для идентификации этого клиента.
     * @return int
     */
    function JoinNetwork($szIP, $port, $szMyName)
    {
    }

    /**
     *Присоединяется к сети AGK, размещенной другим приложением. Сеть определяется по имени или по IP-адресу и номеру порта. Для именованных сетей приложение будет искать любые сети AGK, транслируемые с этим именем, и подключаться к ним, если они будут найдены. В качестве альтернативы, используя IP-адрес и номер порта, вы попытаетесь установить прямое соединение с хостом. В случае подключения к Интернету IP-адрес и порт-это единственный способ подключения, так как широковещательные передачи не покидают локальную сеть. IP-адреса могут быть IPv4 или IPv6 в зависимости от того, какие IP-адреса использует хост (он может иметь один или несколько из них). Вы можете обнаружить все сети, доступные для подключения, настроив прослушиватель широковещательных передач и прослушивая их самостоятельно, а затем отобразить список обнаруженных сетей пользователю, чтобы он мог решить, к какой из них подключиться. Эта функция не подключается сразу, она возвращает идентификатор сети и продолжает пытаться подключиться в фоновом режиме. Вы можете определить, когда установлено соединение, проверив, что GetNetworkNumClients больше 1, что указывает на то, что по крайней мере локальный клиент и серверный клиент были обнаружены. Если IsNetworkActive возвращает 0 в любой момент, то соединение с сервером не удалось и сеть должна быть закрыта, вы можете попытаться восстановить соединение, открыв новую сеть. После подключения приложение становится клиентом сети вместе с хостом и любыми другими клиентами, которые подключились к нему. Все клиенты обрабатываются одинаково и имеют список локальных переменных, которые они могут читать и записывать, все клиенты также могут читать любые переменные на других клиентах только для чтения. Вы должны идентифицировать своего клиента с именем клиента, которое будет видно другим клиентам, имя клиента не обязательно должно быть уникальным. Возвращает идентификатор сети, используемый при взаимодействии с этой сетью. Не работает при экспорте в HTML5
     *
     * @param string $szNetworkName Имя сети для подключения.
     * @param string $szMyName Имя, которое нужно использовать для идентификации этого клиента.
     * @return int
     */
    function JoinNetwork($szNetworkName, $szMyName)
    {
    }

    /**
     *Эта команда возвращает 1, если текущее устройство поддерживает использование изображений глубины с помощью SetRenderToImage. Если это возвращает 0, то единственными допустимыми идентификаторами изображения глубины для SetRenderToImage являются 0 для отсутствия глубины или -1 для нормального буфера глубины.
     *
     * @return int
     */
    function IsSupportedDepthTexture()
    {
    }

    /**
     *Возвращает 1, если Speak был вызван, а текст еще не закончен. Если несколько элементов текста были поставлены в очередь, то эта команда будет продолжать возвращать 1 до тех пор, пока все они не будут произнесены или не будет вызван StopSpeaking.  В настоящее время работает только на iOS и Android.
     *
     * @return int
     */
    function IsSpeaking()
    {
    }

    /**
     *Возвращает 1, если запись экрана в данный момент активна, и 0, если она остановилась. На Android он мог остановиться, потому что приложение было отправлено в фоновый режим или было активировано другое действие, например покупка в приложении.
     *
     * @return int
     */
    function IsScreenRecording()
    {
    }

    /**
     *Еще не функционирует.
     *
     * @return int
     */
    function IsSoundRecording()
    {
    }

    /**
     *Проверяет, что сеть активна, в случае присоединения к сети это вернет 0, если соединение не удалось или по какой-то причине соединение с сервером разорвалось. Для хостера эта функция вернет 0, если ему не удалось прослушать указанный порт для клиентов, в противном случае она навсегда вернет 1, так как не перестанет управлять никакими подключенными клиентами, даже если все отключатся.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function IsNetworkActive($iNetID)
    {
    }

    /**
     *Возвращает 1, если AGK в данный момент отображает экран выбора изображения и ждет, пока пользователь выберет изображение. Когда это возвращает 0, пользователь либо отменил, либо выбрал изображение, проверьте GetChosenImage, чтобы увидеть, каков был результат.
     *
     * @return int
     */
    function IsChoosingImage()
    {
    }

    /**
     *Эта функция устарела, вместо нее используйте SetDeviceCameraToImage. Возвращает 1, если AGK в данный момент отображает ленту камеры и ждет, когда пользователь захватит изображение. Когда это возвращает 0, пользователь либо отменил, либо захватил изображение, проверьте GetCapturedImage, чтобы увидеть, каков был результат.
     *
     * @return int
     */
    function IsCapturingImage()
    {
    }

    /**
     *Возвращает 1, если данный путь является абсолютным, 0, если он относителен. Это зависит от платформы, поэтому путь, начинающийся с "C:/", считается абсолютным в Windows, но не в Linux, в то время как путь, начинающийся с прямой косой черты, считается абсолютным в Linux, но не в Windows. Путь может начинаться с префикса "raw:" или нет, принимаются оба варианта.
     *
     * @param string $szPath Путь для проверки
     * @return int
     */
    function IsAbsolutePath($szPath)
    {
    }

    /**
     *Возвращает 1, если Тряпичная кукла статична.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function Is3dPhysicsRagdollStatic($objID)
    {
    }

    /**
     *Копирует объект в новый идентификатор, новый объект делится данными вершин с исходным объектом. Исходный объект должен существовать для того, чтобы экземпляр объекта рисовался правильно. Создание экземпляра объекта, который уже является экземпляром, ничего не даст. Создание экземпляра объекта, а затем удаление оригинала, вероятно, приведет к сбою. Установка шейдера на объект экземпляра разрешена до тех пор, пока атрибуты вершин, используемые шейдером, точно совпадают по имени и порядку с теми, которые используются на шейдере исходного объекта. Поддерживается установка различных изображений на экземпляре и исходном объекте.
     *
     * @param int $objID Идентификатор объекта для копирования.
     * @return int
     */
    function InstanceObject($objID)
    {
    }

    /**
     *Копирует объект в новый идентификатор, новый объект делится данными вершин с исходным объектом. Исходный объект должен существовать для того, чтобы экземпляр объекта рисовался правильно. Создание экземпляра объекта, который уже является экземпляром, ничего не даст. Создание экземпляра объекта, а затем удаление оригинала, вероятно, приведет к сбою. Установка шейдера на объект экземпляра разрешена до тех пор, пока атрибуты вершин, используемые шейдером, точно совпадают по имени и порядку с теми, которые используются на шейдере исходного объекта. Поддерживается установка различных изображений на экземпляре и исходном объекте.
     *
     * @param int $newobjID Идентификатор нового объекта.
     * @param int $objID Идентификатор объекта для копирования.
     * @return void
     */
    function InstanceObject($newobjID, $objID)
    {
    }

    /**
     *После установки названия покупки в приложении и добавления идентификаторов продуктов вызовите InAppPurchaseSetup, чтобы завершить процесс. После этого момента вы можете попытаться приобрести разблокируемый контент. В настоящее время эта команда поддерживается только на iOS и Android.
     *
     * @return void
     */
    function InAppPurchaseSetup()
    {
    }

    /**
     *Устанавливает все необходимые внутренние данные при настройке IAP для этой платформы. В настоящее время это относится только к Google Play и Ouya, где вам нужно предоставить свой открытый ключ в base64. Это должно быть вызвано перед InAppPurchaseSetup. Чтобы найти открытый ключ для приложений Google Play, откройте сведения о приложении в консоли Google PlayDeveloper и нажмите кнопку Службы и API. Открытый ключ будет находиться в поле под названием "Ваш лицензионный ключ для этого приложения".
     *
     * @param string $szData1 Открытый ключ
     * @param string $szData2 Разработчик UUID (только Ouya)
     * @return void
     */
    function InAppPurchaseSetKeys($szData1, $szData2)
    {
    }

    /**
     *Задает имя приложения таким образом, чтобы оно отображалось в любых диалоговых окнах, отображаемых при использовании команд покупки в приложении. В настоящее время эта команда поддерживается только на iOS и Android.
     *
     * @param string $szTitle Название вашей заявки
     * @return void
     */
    function InAppPurchaseSetTitle($szTitle)
    {
    }

    /**
     *Восстанавливает все управляемые покупки, сделанные на этой платформе. Например, если пользователь приобрел товар, а затем переустановил приложение, то приложение вернет 0 для GetInAppPurchaseAvailable, если оно не было приобретено снова. Несмотря на то, что это не будет взимать плату с пользователя снова за управляемые товары, Apple требует, чтобы у вас была кнопка, вызывающая эту функцию, вместо того чтобы заставлять пользователя снова проходить процесс покупки. После вызова этой команды вы можете вызвать GetInAppPurchaseAvailable. В настоящее время эта команда поддерживается только на iOS. Эта команда не нужна на Android и Amazon, так как она автоматически восстанавливается в InAppPurchaseSetup
     *
     * @return void
     */
    function InAppPurchaseRestore()
    {
    }

    /**
     *Используйте эту команду для добавления любых идентификаторов продуктов в список, например com.yourcompany.yourproduct.iap. Первый идентификатор продукта, который вы добавляете, становится 0, второй-1 и т. Д. Вы также должны указать тип этого продукта: расходуемый (1) или непотребляемый(0). Расходные материалы-это как монеты, которые можно покупать снова и снова, они называются неуправляемыми предметами в Google Play. Непотребляемые продукты-это одноразовые покупки, такие как разблокировка полной версии приложения, они называются управляемыми элементами Google Play. В настоящее время эта команда поддерживается только на iOS, Google Play и Amazon. Это должно быть вызвано до InAppPurchaseSetup, после чего никакие другие продукты не могут быть добавлены.
     *
     * @param string $szID Идентификатор продукта, указанный в iTunes Connect или консоли разработчика Google Play
     * @param int $type Тип этого продукта-расходуемый (1) или непотребляемый(0)
     * @return void
     */
    function InAppPurchaseAddProductID($szID, $type)
    {
    }

    /**
     *Вызовите это, когда вы хотите начать процесс активации / разблокировки дополнительного контента. В настоящее время эта команда поддерживается только на iOS и Android.
     *
     * @param int $iID этот идентификатор соответствует идентификаторам продуктов, которые были добавлены, например, ваш первый продукт
     * @return void
     */
    function InAppPurchaseActivate($iID)
    {
    }

    /**
     *Создает сеть AGK с этим приложением в качестве контроллера, это приложение добавляется в качестве первого клиента в сеть. Сети AGK идентифицируются по имени и автоматически транслируются всем, кто слушает в локальной сети, а это означает, что другие приложения AGK в локальной сети могут принимать все широковещательные сети, отображать их имена своим пользователям и позволять им выбирать одну из них для присоединения. Приложения AGK вне локальной сети нуждаются в IP-адресе и порту хостера, чтобы присоединиться к сети, этот порт будет нуждаться в переадресации на хост через любой промежуточный брандмауэр. Значение порта должно быть между 1025 и 65535 и завершится ошибкой, если другое приложение уже прослушивает этот порт. Вы также должны указать имя клиента, которое будет использоваться для идентификации вашего клиента, все имена клиентов должны быть уникальными. Это имя будет видно всем остальным клиентам. Клиенты будут добавлены в сеть автоматически и могут быть подсчитаны с помощью GetNetworkNumClients. Вы можете вызвать IsNetworkActive сразу после этой команды, чтобы проверить, что сеть была успешно настроена, после установки сеть не станет неактивной для хостера. После подключения приложение становится клиентом сети, и все другие клиенты, подключающиеся к нему, присоединяются к сети. Все клиенты обрабатываются одинаково и имеют список локальных переменных, которые они могут читать и записывать, все клиенты также могут читать любые переменные на других клиентах только для чтения. Некоторые порты используются AGK для внутренней сети и не должны использоваться вашим приложением. Порты 5689-5692 используются для управления приложениями, транслируемыми из IDE. Порты 45631 и 45632 используются для именованных сетевых соединений. В сетях IPv4 сетевая трансляция идет на все устройства в локальной подсети, в сетях IPv6 трансляция идет на адрес AGK multicast "FF02::41:474B". Если устройство имеет как IPv4, так и IPv6 IP-адреса, то хост-сеть будет принимать соединения как из сетей IPv4, так и из сетей IPv6. Если вы укажете 0 для порта, то он отключит IPv4-соединения, если вы установите portv6 в 0, то он отключит IPv6-соединения. По крайней мере один должен быть больше 0, иначе будет сгенерирована ошибка. Если вы вообще не укажете portv6, то он будет установлен в 0. Должно быть безопасно использовать один и тот же порт как для IPv4, так и для IPv6, но это не было широко протестировано. Возвращает идентификатор, который можно использовать для взаимодействия с этой сетью. Не работает при экспорте в HTML5
     *
     * @param string $szNetworkName Имя, используемое для идентификации этой сети.
     * @param string $szMyName Имя, которое нужно использовать для идентификации этого клиента.
     * @param int $port Порт, который другие клиенты должны использовать для подключения к этой сети при использовании IPv4, 0 для отключения IPv4-соединений.
     * @param int $portv6 Порт, который другие клиенты должны использовать для подключения к этой сети при использовании IPv6, 0 для отключения соединений IPv6.
     * @return int
     */
    function HostNetwork($szNetworkName, $szMyName, $port, $portv6)
    {
    }

    /**
     *Создает сеть AGK с этим приложением в качестве контроллера, это приложение добавляется в качестве первого клиента в сеть. Сети AGK идентифицируются по имени и автоматически транслируются всем, кто слушает в локальной сети, а это означает, что другие приложения AGK в локальной сети могут принимать все широковещательные сети, отображать их имена своим пользователям и позволять им выбирать одну из них для присоединения. Приложения AGK вне локальной сети нуждаются в IP-адресе и порту хостера, чтобы присоединиться к сети, этот порт будет нуждаться в переадресации на хост через любой промежуточный брандмауэр. Значение порта должно быть между 1025 и 65535 и завершится ошибкой, если другое приложение уже прослушивает этот порт. Вы также должны указать имя клиента, которое будет использоваться для идентификации вашего клиента, все имена клиентов должны быть уникальными. Это имя будет видно всем остальным клиентам. Клиенты будут добавлены в сеть автоматически и могут быть подсчитаны с помощью GetNetworkNumClients. Вы можете вызвать IsNetworkActive сразу после этой команды, чтобы проверить, что сеть была успешно настроена, после установки сеть не станет неактивной для хостера. После подключения приложение становится клиентом сети, и все другие клиенты, подключающиеся к нему, присоединяются к сети. Все клиенты обрабатываются одинаково и имеют список локальных переменных, которые они могут читать и записывать, все клиенты также могут читать любые переменные на других клиентах только для чтения. Некоторые порты используются AGK для внутренней сети и не должны использоваться вашим приложением. Порты 5689-5692 используются для управления приложениями, транслируемыми из IDE. Порты 45631 и 45632 используются для именованных сетевых соединений. В сетях IPv4 сетевая трансляция идет на все устройства в локальной подсети, в сетях IPv6 трансляция идет на адрес AGK multicast "FF02::41:474B". Если устройство имеет как IPv4, так и IPv6 IP-адреса, то хост-сеть будет принимать соединения как из сетей IPv4, так и из сетей IPv6. Если вы укажете 0 для порта, то он отключит IPv4-соединения, если вы установите portv6 в 0, то он отключит IPv6-соединения. По крайней мере один должен быть больше 0, иначе будет сгенерирована ошибка. Если вы вообще не укажете portv6, то он будет установлен в 0. Должно быть безопасно использовать один и тот же порт как для IPv4, так и для IPv6, но это не было широко протестировано. Возвращает идентификатор, который можно использовать для взаимодействия с этой сетью. Не работает при экспорте в HTML5
     *
     * @param string $szNetworkName Имя, используемое для идентификации этой сети.
     * @param string $szMyName Имя, которое нужно использовать для идентификации этого клиента.
     * @param int $port Порт, который другие клиенты должны использовать для подключения к этой сети при использовании IPv4, 0 для отключения IPv4-соединений.
     * @return int
     */
    function HostNetwork($szNetworkName, $szMyName, $port)
    {
    }

    /**
     *Преобразует шестнадцатеричную строку в строку Base64. Шестнадцатеричная строка-это строка, содержащая только символы 0-9 и A-F. Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.
     *
     * @param string $input Строка для преобразования
     * @return string
     */
    function HexToBase64($input)
    {
    }

    /**
     *Кодирует строку таким образом, чтобы она могла быть отправлена на сервер по протоколу HTTP без вмешательства в HTTP-запрос. Например, если вы хотите отправить переменную POST, содержащую символы & или=, они будут выглядеть как дополнительные переменные внутри строки, которую вы хотите отправить. Использование HTTPEncode в этой строке превратит эти символы в ПОСТ-безопасные значения, которые затем автоматически преобразуются обратно в исходные символы, как только они достигнут чего-то вроде PHP-скрипта. При этом используется стандартная кодировка URL-адреса для не буквенно-цифровых символов, оставляя только буквенно-цифровые символы.
     *
     * @param string $str Строка для кодирования
     * @return string
     */
    function HTTPEncode($str)
    {
    }

    /**
     *Преобразует целочисленное значение в строку, содержащую его шестнадцатеричное представление. Например, Hex(31) вернет строку, содержащую "1F". Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.
     *
     * @param int $i Целочисленное значение для преобразования в шестнадцатеричную строку
     * @return string
     */
    function Hex($i)
    {
    }

    /**
     *Декодирует строку, закодированную URL-адресом. Он может декодировать все буквенно-цифровые символы и большинство не буквенно-цифровых символов.
     *
     * @param string $str Строка для декодирования
     * @return string
     */
    function HTTPDecode($str)
    {
    }

    /**
     *Возвращает значение от 0 до 100 для представления хода извлечения zip-файла, запущенного с помощью ExtractZipASync.
     *
     * @return float
     */
    function GetZipExtractProgress()
    {
    }

    /**
     *Возвращает год заданного значения времени unix. Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным. Если не использовать 64 - битные значения, то значение времени unix ограничено периодом с 1901 по 2038 год.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetYearFromUnix($unixtime)
    {
    }

    /**
     *Возвращает 0, если выполняется извлечение zip-файла, начатое с помощью ExtractZipASync, или 1, если оно завершено. Он не дает указания на то, была ли добыча успешной, только на то, что она закончилась.
     *
     * @return int
     */
    function GetZipExtractComplete()
    {
    }

    /**
     *Возвращает каталог, в который будут записаны новые файлы на текущей платформе, на которой работает приложение.
     *
     * @return string
     */
    function GetWritePath()
    {
    }

    /**
     *Преобразует точку на спрайте в мировые координаты. Например,если спрайт 10x10 был повернут на 45 градусов вокруг своей центральной точки (в точке 5x5), то, чтобы найти положение в мире верхнего левого угла спрайта, вы бы вызвали эту команду со значениями -5, -5, так как значения относятся к центральной точке спрайта (определяемой SetSpriteOffset). Команда не ограничена размером спрайта, поэтому в приведенном выше примере допустимы значения 20 или -15.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $x X-компонент точки на спрайте.
     * @param float $y Компонент Y точки на спрайте.
     * @return float
     */
    function GetWorldYFromSprite($iSpriteIndex, $x, $y)
    {
    }

    /**
     *Преобразует точку на спрайте в мировые координаты. Например,если спрайт 10x10 был повернут на 45 градусов вокруг своей центральной точки (в точке 5x5), то, чтобы найти положение в мире верхнего левого угла спрайта, вы бы вызвали эту команду со значениями -5, -5, так как значения относятся к центральной точке спрайта (определяемой SetSpriteOffset). Команда не ограничена размером спрайта, поэтому в приведенном выше примере допустимы значения 20 или -15.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $x X-компонент точки на спрайте.
     * @param float $y Компонент Y точки на спрайте.
     * @return float
     */
    function GetWorldXFromSprite($iSpriteIndex, $x, $y)
    {
    }

    /**
     *Возвращает букву диска указанного диска, от 0 до CountWindowsDrives минус один. Значения вне этого диапазона будут возвращать пустую строку. Возвращаемая строка будет включать букву диска и двоеточие, больше ничего. Это относится только к Windows, другие платформы вернут пустую строку. Если вы вызываете эту команду из уровня 2, то вы должны удалить возвращенную строку с помощью agk::DeleteString (), когда закончите с ней.
     *
     * @param int $index Индекс диска для возврата
     * @return string
     */
    function GetWindowsDrive($index)
    {
    }

    /**
     *Возвращает высоту окна текущего устройства. Это значение может отличаться от GetDeviceHeight, если размер окна не соответствует размеру пикселя backbuffer, который используется для рисования окна. Например, на Mac с дисплеем Retina размер окна будет равен половине размера пикселя.
     *
     * @return int
     */
    function GetWindowHeight()
    {
    }

    /**
     *Возвращает ширину окна текущего устройства. Это значение может отличаться от GetDeviceWidth, если размер окна не соответствует размеру пикселя backbuffer, который используется для рисования окна. Например, на Mac с дисплеем Retina размер окна будет равен половине размера пикселя.
     *
     * @return int
     */
    function GetWindowWidth()
    {
    }

    /**
     *Возвращает координату для крайней правой части экрана. В системе координат, основанной на процентах по умолчанию, это 100. Если вы настроили виртуальное разрешение с помощью SetVirtualResolution, то будет возвращена указанная здесь ширина.
     *
     * @return int
     */
    function GetVirtualWidth()
    {
    }

    /**
     *Возвращает значение X виртуального джойстика по заданному индексу. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. Когда пользователь не взаимодействует с виртуальным джойстиком, он возвращает 0.
     *
     * @param int $index Идентификатор виртуального джойстика для проверки.
     * @return float
     */
    function GetVirtualJoystickX($index)
    {
    }

    /**
     *Возвращает значение Y виртуального джойстика по заданному индексу. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. Когда пользователь не взаимодействует с виртуальным джойстиком, он возвращает 0.
     *
     * @param int $index Идентификатор виртуального джойстика для проверки.
     * @return float
     */
    function GetVirtualJoystickY($index)
    {
    }

    /**
     *Возвращает 1, если виртуальный джойстик существует по заданному индексу. Должно быть в диапазоне от 1 до 4.
     *
     * @param int $index Идентификатор виртуального джойстика для проверки.
     * @return int
     */
    function GetVirtualJoystickExists($index)
    {
    }

    /**
     *Возвращает координату для нижней части экрана. В системе координат, основанной на процентах по умолчанию, это 100. Если вы настроили виртуальное разрешение с помощью SetVirtualResolution, то будет возвращена указанная здесь высота.
     *
     * @return int
     */
    function GetVirtualHeight()
    {
    }

    /**
     *Возвращает 1, если виртуальная кнопка в данный момент находится внизу, и 0, если она поднята. Используйте GetVirtualButtonPressed или GetVirtualButtonReleased, чтобы проверить, нажата или отпущена ли кнопка.
     *
     * @param int $index Идентификатор виртуальной кнопки для проверки.
     * @return int
     */
    function GetVirtualButtonState($index)
    {
    }

    /**
     *Возвращает 1 если виртуальная кнопка была нажата в этом кадре, то после первоначального нажатия эта функция вернется к 0. Используйте GetVirtualButtonState, чтобы проверить, находится ли виртуальная кнопка вверх или вниз.
     *
     * @param int $index Идентификатор виртуальной кнопки для проверки.
     * @return int
     */
    function GetVirtualButtonPressed($index)
    {
    }

    /**
     *Возвращает 1 если виртуальная кнопка была выпущена в этом кадре, то после первоначального выпуска эта функция вернется к 0. Используйте GetVirtualButtonState, чтобы проверить, находится ли виртуальная кнопка вверх или вниз.
     *
     * @param int $index Идентификатор виртуальной кнопки для проверки.
     * @return int
     */
    function GetVirtualButtonReleased($index)
    {
    }

    /**
     *Возвращает 1, если виртуальная кнопка существует в данном индексе. 0 в противном случае.
     *
     * @param int $index Идентификатор виртуальной кнопки для проверки.
     * @return int
     */
    function GetVirtualButtonExists($index)
    {
    }

    /**
     *Возвращает текущий уровень масштабирования прокрутки, установленный с помощью SetViewZoom.
     *
     * @return float
     */
    function GetViewZoom()
    {
    }

    /**
     *Возвращает текущее смещение вида в направлении Y, заданное с помощью SetViewOffset.
     *
     * @return float
     */
    function GetViewOffsetY()
    {
    }

    /**
     *Возвращает текущее смещение вида в направлении X, заданное с помощью SetViewOffset.
     *
     * @return float
     */
    function GetViewOffsetX()
    {
    }

    /**
     *Возвращает ширину в пикселях текущего загруженного видео, если это возвращает 0, то вызовите его в цикле с помощью функции Sync (), чтобы дождаться завершения загрузки метаданных видео. Если он возвращает меньше 0, то эта платформа не поддерживает эту команду или произошла ошибка. пример: width = GetVideoWidth() if ( width = 0 ) repeat Sync() width = GetVideoWidth() until width != 0 endif
     *
     * @return float
     */
    function GetVideoWidth()
    {
    }

    /**
     *Возвращает 1, если видео воспроизводится в данный момент, 0, если оно закончено или остановлено с помощью stopVideo() или PauseVideo().
     *
     * @return int
     */
    function GetVideoPlaying()
    {
    }

    /**
     *Возвращает количество секунд, сыгранных до сих пор.
     *
     * @return float
     */
    function GetVideoPosition()
    {
    }

    /**
     *Возвращает высоту в пикселях текущего загруженного видео, если это возвращает 0, то вызовите его в цикле с помощью функции Sync (), чтобы дождаться завершения загрузки метаданных видео. Если он возвращает меньше 0, то эта платформа не поддерживает эту команду или произошла ошибка. пример: height = GetVideoHeight() if ( height = 0 ) repeat Sync() height = GetVideoHeight() until height != 0 endif
     *
     * @return float
     */
    function GetVideoHeight()
    {
    }

    /**
     *Возвращает количество секунд, в течение которых видео длится от начала до конца. Если это возвращает 0, то вызовите его в цикле с помощью функции Sync (), чтобы дождаться завершения загрузки метаданных видео. Если он возвращает меньше 0, то эта платформа не поддерживает эту команду или произошла ошибка. пример: duration = GetVideoDuration() if ( duration = 0 ) repeat Sync() duration = GetVideoDuration() until duration != 0 endif
     *
     * @return float
     */
    function GetVideoDuration()
    {
    }

    /**
     *Возвращает количество вершин, обработанных последним кадром графического процессора.
     *
     * @return int
     */
    function GetVerticesProcessed()
    {
    }

    /**
     *Получает z из вектора.
     *
     * @param int $vectorID идентификатор вектора
     * @return float
     */
    function GetVector3Z($vectorID)
    {
    }

    /**
     *Получает y из вектора.
     *
     * @param int $vectorID идентификатор вектора
     * @return float
     */
    function GetVector3Y($vectorID)
    {
    }

    /**
     *Получает x из вектора.
     *
     * @param int $vectorID идентификатор вектора
     * @return float
     */
    function GetVector3X($vectorID)
    {
    }

    /**
     *Умножает компоненты данного вектора на данный множитель
     *
     * @param int $resultVec ИДЕНТИФИКАТОР вектора для умножения.
     * @param float $multiplier плавающее значение для умножения.
     * @return void
     */
    function GetVector3Multiply($resultVec, $multiplier)
    {
    }

    /**
     *Возвращает длину вектора
     *
     * @param int $vectorID Идентификатор вектора
     * @return float
     */
    function GetVector3Length($vectorID)
    {
    }

    /**
     *Возвращает расстояние между 2 векторами.
     *
     * @param int $vectorU Идентификатор первого вектора
     * @param int $vectorV Идентификатор второго вектора
     * @return float
     */
    function GetVector3Distance($vectorU, $vectorV)
    {
    }

    /**
     *Заполняет результирующий вектор перекрестным произведением 2 переданных векторов.
     *
     * @param int $resultVec ИДЕНТИФИКАТОР вектора для результатов
     * @param int $vectorU Идентификатор первого вектора
     * @param int $vectorV Идентификатор второго вектора
     * @return void
     */
    function GetVector3Cross($resultVec, $vectorU, $vectorV)
    {
    }

    /**
     *Возвращает точечное произведение 2 векторов
     *
     * @param int $vectorU Идентификатор первого вектора
     * @param int $vectorV Идентификатор второго вектора
     * @return float
     */
    function GetVector3Dot($vectorU, $vectorV)
    {
    }

    /**
     *Заполняет вектор resultVec суммой вектора resultVec и вектора addVec.
     *
     * @param int $resultVec ИДЕНТИФИКАТОР вектора для добавления и удержания результатов.
     * @param int $addVec ИДЕНТИФИКАТОР вектора для добавления.
     * @return void
     */
    function GetVector3Add($resultVec, $addVec)
    {
    }

    /**
     *Возвращает количество секунд и долей секунд, потраченных на обновление всего в мире, кроме физики. Это включает в себя анимацию спрайтов, эмуляцию ввода и обработку звуков.
     *
     * @return float
     */
    function GetUpdateTime()
    {
    }

    /**
     *Возвращает текущую дату и время в формате unix time, которое измеряется в секундах с 1 января 1970 года. Он может быть отрицательным для дат до 1970 года.
     *
     * @return int
     */
    function GetUnixTime()
    {
    }

    /**
     *Преобразует заданную дату и время в свой эквивалент времени unix, unix time-это количество секунд с 1 января 1970 года. Если не использовать 64 - битные значения, то значение времени unix ограничено периодом с 1901 по 2038 год.
     *
     * @param int $year Годовая часть даты.
     * @param int $month Месячная часть даты, в диапазоне от 1 до 12.
     * @param int $days Дневная часть даты, в диапазоне от 1 до 31.
     * @param int $hours Часовая часть даты, в диапазоне от 0 до 23.
     * @param int $minutes Минутная часть даты, в диапазоне от 0 до 59.
     * @param int $seconds Секундная часть даты в диапазоне от 0 до 59.
     * @return int
     */
    function GetUnixFromDate($year, $month, $days, $hours, $minutes, $seconds)
    {
    }

    /**
     *Возвращает количество изображений, загруженных в данный момент в приложение, но не назначенных спрайту или текстовому объекту. Это полезно для отладки, чтобы проверить, что вы удалили все неиспользуемые изображения при переключении из меню на уровень или с одного уровня на другой.
     *
     * @return int
     */
    function GetUnassignedImages()
    {
    }

    /**
     *Возвращает имя файла указанного неназначенного изображения.
     *
     * @param int $index Индекс неназначенного изображения, между 1 и значением, возвращаемым GetUnassignedImages
     * @return string
     */
    function GetUnassignedImageFileName($index)
    {
    }

    /**
     *На Android и iOS это возвращает полный URL-адрес, который был использован для открытия этого приложения, если использовалась схема URL-адресов. Например, если вы установили схему URL-адресов "myapp" для этого приложения и пользователь нажимает на ссылку типа "myapp: sometext", то ОС откроет ваше приложение, а GetURLSchemeText будет возвращать "myapp: sometext" до тех пор, пока приложение не будет открыто в следующий раз. Если URL - адрес не был использован для открытия приложения или платформа не поддерживает схемы URL-адресов, то будет возвращена пустая строка. При выборе схемы URL-адресов вы должны убедиться, что она уникальна для вашего приложения, так как iOS не позволит двум приложениям иметь одну и ту же схему.
     *
     * @return string
     */
    function GetURLSchemeText()
    {
    }

    /**
     *Проверяет прослушиватель UDP на наличие любых широковещательных передач. Возвращает 0, если ничего не было получено. Возвращает идентификатор сообщения если что-то было получено, вы можете получить доступ к содержимому этого сообщения с помощью команд сетевого сообщения. Сообщение должно быть удалено, когда вы закончите чтение.
     *
     * @param int $listenerID Идентификатор прослушивателя для проверки сообщений
     * @return int
     */
    function GetUDPNetworkMessage($listenerID)
    {
    }

    /**
     *Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном текстовом объекте, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @param int $textID ИДЕНТИФИКАТОР текста для проверки
     * @return int
     */
    function GetTweenTextPlaying($tweenID, $textID)
    {
    }

    /**
     *Возвращает 1, если существует анимация с заданным идентификатором и это текстовая анимация, в противном случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenTextExists($tweenID)
    {
    }

    /**
     *Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном спрайте, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @param int $spriteID Идентификатор спрайта для проверки
     * @return int
     */
    function GetTweenSpritePlaying($tweenID, $spriteID)
    {
    }

    /**
     *Возвращает 1, если существует анимация с заданным идентификатором и это спрайт-анимация, в противном случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenSpriteExists($tweenID)
    {
    }

    /**
     *Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном объекте, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @param int $objectID ИДЕНТИФИКАТОР проверяемого объекта
     * @return int
     */
    function GetTweenObjectPlaying($tweenID, $objectID)
    {
    }

    /**
     *Возвращает 1, если анимация любого типа существует в данном идентификаторе, и 0 в противном случае.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenExists($tweenID)
    {
    }

    /**
     *Возвращает текущее значение четвертого целого числа пользовательского твина.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomInteger4($tweenID)
    {
    }

    /**
     *Возвращает 1, если данный пользовательский идентификатор анимации воспроизводится в данный момент, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomPlaying($tweenID)
    {
    }

    /**
     *Возвращает текущее значение третьего целого числа пользовательского твина.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomInteger3($tweenID)
    {
    }

    /**
     *Возвращает текущее значение второго целого числа пользовательского твина.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomInteger2($tweenID)
    {
    }

    /**
     *Возвращает текущее значение первого целого числа пользовательского твина.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomInteger1($tweenID)
    {
    }

    /**
     *Возвращает текущее значение четвертого поплавка пользовательской анимации.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return float
     */
    function GetTweenCustomFloat4($tweenID)
    {
    }

    /**
     *Возвращает текущее значение третьего поплавка пользовательской анимации.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return float
     */
    function GetTweenCustomFloat3($tweenID)
    {
    }

    /**
     *Возвращает текущее значение второго поплавка пользовательской анимации.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return float
     */
    function GetTweenCustomFloat2($tweenID)
    {
    }

    /**
     *Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данном символе и текстовом объекте, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @param int $textID ИДЕНТИФИКАТОР текста для проверки
     * @param int $charID Индекс проверяемого символа, индексы начинаются с 0, если он находится вне диапазона, то игнорируется
     * @return int
     */
    function GetTweenCharPlaying($tweenID, $textID, $charID)
    {
    }

    /**
     *Возвращает 1, если существует анимация с заданным идентификатором и это пользовательская анимация, в противном случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCustomExists($tweenID)
    {
    }

    /**
     *Возвращает текущее значение первого поплавка пользовательской анимации.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return float
     */
    function GetTweenCustomFloat1($tweenID)
    {
    }

    /**
     *Возвращает 1, если цепочка в данный момент работает со своим списком подростков. Если последняя анимация закончилась или цепочка еще не запущена, она вернет 0.
     *
     * @param int $chainID Идентификатор цепочки для проверки
     * @return int
     */
    function GetTweenChainPlaying($chainID)
    {
    }

    /**
     *Возвращает 1, если анимация существует в данном идентификаторе и это объект tween, в противном случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenObjectExists($tweenID)
    {
    }

    /**
     *Возвращает общую длину цепочки твинов в секундах.
     *
     * @param int $chainID Идентификатор цепочки для проверки
     * @return float
     */
    function GetTweenChainEndTime($chainID)
    {
    }

    /**
     *Возвращает 1, если данный идентификатор анимации в данный момент воспроизводится на данной камере, в противном случае 0. Это все равно вернет 1, если анимация в данный момент приостановлена.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @param int $cameraID Идентификатор камеры для проверки
     * @return int
     */
    function GetTweenCameraPlaying($tweenID, $cameraID)
    {
    }

    /**
     *Возвращает 1, если анимация существует по заданному идентификатору и это анимация камеры, в противном случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCameraExists($tweenID)
    {
    }

    /**
     *Возвращает текущее положение X текстового объекта в мировых координатах, текст позиционируется с помощью его верхнего левого угла.
     *
     * @param int $iTextIndex Идентификатор возвращаемого текстового объекта.
     * @return float
     */
    function GetTextX($iTextIndex)
    {
    }

    /**
     *Возвращает текущее положение Y текстового объекта в мировых координатах, текст позиционируется с помощью его верхнего левого угла.
     *
     * @param int $iTextIndex Идентификатор возвращаемого текстового объекта.
     * @return float
     */
    function GetTextY($iTextIndex)
    {
    }

    /**
     *Возвращает 0, если текущий текст был установлен как невидимый с помощью SetTextVisible, 1, если он установлен как видимый (по умолчанию). Это не проверяет, находится ли текст в данный момент в видимом видовом окне.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return int
     */
    function GetTextVisible($iTextIndex)
    {
    }

    /**
     *Возвращает текущую ширину текстового объекта в мировых единицах измерения. Если текстовый объект отображает текст в нескольких строках, он возвращает ширину самой длинной строки. Это не учитывает индивидуальные смещения символов, если вы использовали SetTextCharX или что-то подобное для перемещения символа. Возвращаемое значение-это ширина, используемая положением рисунка текстовых символов по умолчанию.
     *
     * @param int $iTextIndex Идентификатор возвращаемого текстового объекта.
     * @return float
     */
    function GetTextTotalWidth($iTextIndex)
    {
    }

    /**
     *Возвращает 1, когда механизм преобразования текста в речь готов начать преобразование текста в речь. Вызов других команд преобразования текста в речь, когда он не готов, будет проигнорирован.  В настоящее время работает только на iOS и Android.
     *
     * @return int
     */
    function GetTextToSpeechReady()
    {
    }

    /**
     *Возвращает текущую высоту текстового объекта в мировых единицах измерения. Это не учитывает индивидуальные смещения символов, если вы использовали SetTextCharY или что-то подобное для перемещения символа. Возвращаемое значение-это высота, используемая для расположения текстовых символов на чертеже по умолчанию. Обратите внимание, что если строка текста пуста, то это значение вернет 0.
     *
     * @param int $iTextIndex Идентификатор возвращаемого текстового объекта.
     * @return float
     */
    function GetTextTotalHeight($iTextIndex)
    {
    }

    /**
     *Возвращает текущую строку, отображаемую текстовым объектом. В tier 2 возвращаемая строка должна быть удалена, когда вы закончите с ней.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return string
     */
    function GetTextString($iTextIndex)
    {
    }

    /**
     *Возвращает текущий размер текстового объекта, заданного с помощью setTextSize.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return float
     */
    function GetTextSize($iTextIndex)
    {
    }

    /**
     *Возвращает текущий интервал текстового объекта, заданного с помощью SetTextSpacing.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return float
     */
    function GetTextSpacing($iTextIndex)
    {
    }

    /**
     *Возвращает 1, если существует анимация с заданным идентификатором и она является char tween, в противном случае 0.
     *
     * @param int $tweenID Идентификатор твина для проверки
     * @return int
     */
    function GetTweenCharExists($tweenID)
    {
    }

    /**
     *Возвращает текущий межстрочный интервал текстового объекта, заданного с помощью SetTextLineSpacing.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return float
     */
    function GetTextLineSpacing($iTextIndex)
    {
    }

    /**
     *Возвращает текущую длину строки, отображаемой текстовым объектом.
     *
     * @param int $iTextIndex Идентификатор возвращаемого текстового объекта.
     * @return int
     */
    function GetTextLength($iTextIndex)
    {
    }

    /**
     *Возвращает 1 для кадра, который пользователь завершил ввод текста (успешно или нет). После завершения эта команда вернется к 0. На этом этапе вы можете проверить, отменил ли пользователь ввод, используя GetTextInputCancelled.
     *
     * @return int
     */
    function GetTextInputCompleted()
    {
    }

    /**
     *Возвращает 1, если пользователь отменил ввод текста, и 0, если нет. Это значение команды не определяется до тех пор, пока GetTextInputCompleted не вернет 1.
     *
     * @return int
     */
    function GetTextInputCancelled()
    {
    }

    /**
     *Возвращает 0, если пользователь в данный момент вводит текст, и 1, если нет.
     *
     * @return int
     */
    function GetTextInputState()
    {
    }

    /**
     *Возвращает строку, введенную пользователем. Он будет содержать символы, закодированные с помощью UTF-8, некоторые устройства также могут разрешать возврат символов новой строки. Это значение команды не определяется до тех пор, пока GetTextInputCompleted не вернет 1.
     *
     * @return string
     */
    function GetTextInput()
    {
    }

    /**
     *Возвращает 1, если заданная точка в мировых координатах находится внутри ограничивающего прямоугольника текста. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY. Это не учитывает отдельные позиции символов, например, если вы расположили символ с помощью SetTextCharX или аналогичного. Проверяется только ограничивающая рамка, созданная путем рисования символов в их позициях по умолчанию.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param float $x Координата x точки для проверки в мировых координатах.
     * @param float $y Координата y точки для проверки в мировых координатах.
     * @return int
     */
    function GetTextHitTest($iTextIndex, $x, $y)
    {
    }

    /**
     *Получите красную составляющую цвета текста. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для проверки.
     * @return int
     */
    function GetTextColorRed($iTextIndex)
    {
    }

    /**
     *Возвращает 1, если текст существует, и 0, если его нет.
     *
     * @param int $iTextIndex Идентификатор текста для проверки
     * @return int
     */
    function GetTextExists($iTextIndex)
    {
    }

    /**
     *Получите зеленую составляющую цвета текста. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для проверки.
     * @return int
     */
    function GetTextColorGreen($iTextIndex)
    {
    }

    /**
     *Возвращает текущую глубину текстового объекта, где 0-передняя часть экрана, а 10000 - задняя.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return int
     */
    function GetTextDepth($iTextIndex)
    {
    }

    /**
     *Получите синий компонент цвета текста. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для проверки.
     * @return int
     */
    function GetTextColorBlue($iTextIndex)
    {
    }

    /**
     *Получите альфа-компонент цвета текста. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор текста для проверки.
     * @return int
     */
    function GetTextColorAlpha($iTextIndex)
    {
    }

    /**
     *Возвращает красный компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @return int
     */
    function GetTextCharColorRed($iTextIndex, $iCharIndex)
    {
    }

    /**
     *Возвращает текущую позицию Y указанного символа относительно текстового объекта.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @return float
     */
    function GetTextCharY($iTextIndex, $iCharIndex)
    {
    }

    /**
     *Возвращает текущую позицию X указанного символа относительно текстового объекта.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @return float
     */
    function GetTextCharX($iTextIndex, $iCharIndex)
    {
    }

    /**
     *Возвращает зеленый компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @return int
     */
    function GetTextCharColorGreen($iTextIndex, $iCharIndex)
    {
    }

    /**
     *Возвращает синий компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @return int
     */
    function GetTextCharColorBlue($iTextIndex, $iCharIndex)
    {
    }

    /**
     *Возвращает текущий угол в радианах указанного символа.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @return float
     */
    function GetTextCharAngleRad($iTextIndex, $iCharIndex)
    {
    }

    /**
     *Возвращает альфа-компонент заданного цвета символа. Значение будет находиться в диапазоне 0-255.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @return int
     */
    function GetTextCharColorAlpha($iTextIndex, $iCharIndex)
    {
    }

    /**
     *Возвращает текущее выравнивание набора текстовых объектов с помощью SetTextAlignment.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @return int
     */
    function GetTextAlignment($iTextIndex)
    {
    }

    /**
     *Возвращает 1, если система содержит шрифт с заданным именем, и 0 в противном случае. Если возвращается 1, то передача того же имени файла в LoadFont будет успешной. В iOS это всегда будет возвращать 0, так как системные файлы шрифтов недоступны, однако AGK поставляется со встроенным шрифтом, который вы можете использовать, используя идентификатор шрифта 0 с текстовыми объектами.
     *
     * @param string $szFontFile Название шрифта для проверки
     * @return int
     */
    function GetSystemFontExists($szFontFile)
    {
    }

    /**
     *Возвращает количество изменяющихся значений, которые могут быть использованы в шейдерах на текущем устройстве. Вариации-это переменные, которые передают данные между вершинным и пиксельным шейдерами. Это значение гарантированно будет не менее 32, но большинство устройств поддерживают больше. Один vec4 varying содержит 4 различных значения, поэтому 32 значения varyings означают, что вы можете иметь максимум 8 вариаций vec4. Обратите внимание, что переменная vec3 может занимать 4 пространства значений, если она не может быть упакована с какой-либо другой переменной. Вариации будут автоматически упакованы вместе, если они могут заполнить vec4 без разделения, например, vec3 и поплавок могут быть упакованы вместе, как и два вариации vec2. Однако две вариации vec3 не могут быть упакованы вместе без разделения, поэтому каждая из них будет использовать до 4 значений, а дополнительное пространство будет потрачено впустую.
     *
     * @return int
     */
    function GetSupportedShaderVaryings()
    {
    }

    /**
     *Возвращает определенный токен из строки, разделенной заданным разделителем, например строка, содержащая "first:second:third", имеет три токена, разделенных ":". Аналогично GetStringToken, за исключением того, что эта команда принимает только один символ в качестве разделителя и распознает пустые поля. Например, "first:second::fourth" имеет четыре токена, а третий-пустую строку. В tier 2 возвращаемая строка должна быть удалена, когда вы закончите с ней. Вы можете использовать CountStringTokens2 для подсчета количества токенов в строке.
     *
     * @param string $str Строка для проверки.
     * @param string $delimiter Символ, разделяющий строку.
     * @param int $token индекс возвращаемого токена, начинающийся с 1 для первого токена.
     * @return string
     */
    function GetStringToken2($str, $delimiter, $token)
    {
    }

    /**
     *Возвращает определенный токен из строки, разделенной заданными разделителями, например строка, содержащая "first:second:third", имеет три токена, разделенных ":" и "first:second;third", имеет три токена, разделенных разделителями ":;". Вы можете иметь несколько разделителей между каждым токеном, например "first:;second:third" является допустимым и имеет три токена. В tier 2 возвращаемая строка должна быть удалена, когда вы закончите с ней. Вы можете использовать CountStringTokens для подсчета количества токенов в строке. Эта команда полезна для разделения слов в предложении, которое может быть разделено как пробелом, так и пунктуацией.
     *
     * @param string $str Строка для проверки.
     * @param string $delimiters Набор символов, разделяющих строку.
     * @param int $token индекс возвращаемого токена, начинающийся с 1 для первого токена.
     * @return string
     */
    function GetStringToken($str, $delimiters, $token)
    {
    }

    /**
     *Возвращает общее количество МБ хранения данных по указанному пути, использованных и неиспользуемых. Например, использование пути, указывающего на местоположение на SD-карте на Android, вернет размер sd-карты, в то время как использование пути, указывающего на папку записи AGK, вернет количество МБ во внутреннем хранилище. В некоторых случаях это может быть одно и то же. Эта команда возвращает значение -1, если размер хранилища не может быть определен. В настоящее время реализовано только на iOS и Android, другие платформы вернут -1.
     *
     * @param string $path Путь для проверки
     * @return int
     */
    function GetStorageTotal($path)
    {
    }

    /**
     *Возвращает количество МБ, доступных приложению для хранения данных по указанному пути. Например, использование пути, указывающего на местоположение на SD-карте Android, вернет, сколько МБ может быть сохранено там, в то время как использование пути, указывающего на папку записи AGK, вернет количество МБ, которое приложение может хранить в своем внутреннем хранилище. В некоторых случаях это может быть одно и то же. Эта команда возвращает -1, если доступное пространство не может быть определено. В настоящее время реализовано только на iOS и Android, другие платформы вернут -1.
     *
     * @param string $path Путь для проверки
     * @return int
     */
    function GetStorageRemaining($path)
    {
    }

    /**
     *Преобразует точку пикселя на изображении спрайта в точку на поверхности спрайта, которая представляет, где находится этот пиксель. Например, если изображение размером 200x100 пикселей было назначено спрайту размером 10x10, то вызов этой команды со значением пикселя 50 (центр изображения) вернет 5 (центр спрайта). Для этого спрайту должно быть назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером изображения или спрайта, поэтому в приведенном выше примере допустимо значение пикселя 300 или -10.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param int $y Координата y пикселя для проверки.
     * @return float
     */
    function GetSpriteYFromPixel($iSpriteIndex, $y)
    {
    }

    /**
     *Возвращает текущую координату Y текущей точки смещения спрайта в мире.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteYByOffset($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущую координату Y верхнего левого угла спрайта в виде значения с плавающей запятой.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteY($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущий угол в градусах указанного символа.
     *
     * @param int $iTextIndex Идентификатор проверяемого текстового объекта.
     * @param int $iCharIndex Индекс проверяемого символа, индексы начинаются с 0, если индекс находится вне диапазона, он будет проигнорирован.
     * @return float
     */
    function GetTextCharAngle($iTextIndex, $iCharIndex)
    {
    }

    /**
     *Преобразует точку в мировых координатах в точку на спрайте. Это противоположно GetWorldXFromSprite и будет возвращать значения относительно центральной точки спрайта, определенной с помощью SetSpriteOffset. По умолчанию это центр спрайта. Команда не ограничена размером спрайта, она может возвращать значения, превышающие границы спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $x X-компонент точки для преобразования в координаты спрайта.
     * @param float $y Компонент Y точки для преобразования в координаты спрайта.
     * @return float
     */
    function GetSpriteXFromWorld($iSpriteIndex, $x, $y)
    {
    }

    /**
     *Преобразует точку пикселя на изображении спрайта в точку на поверхности спрайта, которая представляет, где находится этот пиксель. Например, если изображение размером 200x100 пикселей было назначено спрайту размером 10x10, то вызов этой команды со значением пикселя 100 (центр изображения) вернет 5 (центр спрайта). Для этого спрайту должно быть назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером изображения или спрайта, поэтому в приведенном выше примере допустимо значение пикселя 300 или -10.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param int $x Координата x пикселя для проверки.
     * @return float
     */
    function GetSpriteXFromPixel($iSpriteIndex, $x)
    {
    }

    /**
     *Возвращает текущую координату X текущей точки смещения спрайта в мире.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteXByOffset($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущую координату X верхнего левого угла спрайта в виде значения с плавающей запятой.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteX($iSpriteIndex)
    {
    }

    /**
     *Возвращает 0, если спрайт был установлен как невидимый с помощью SetSpriteVisible, в противном случае возвращает 1.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteVisible($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущий режим прозрачности спрайта, 0=отсутствие прозрачности, 1=прозрачность альфа-канала, 2=аддитивное смешивание.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteTransparency($iSpriteIndex)
    {
    }

    /**
     *Преобразует точку в мировых координатах в точку на спрайте. Это противоположно GetWorldYFromSprite и будет возвращать значения относительно центральной точки спрайта, определенной с помощью SetSpriteOffset. По умолчанию это центр спрайта. Команда не ограничена размером спрайта, она может возвращать значения, превышающие границы спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $x X-компонент точки для преобразования в координаты спрайта.
     * @param float $y Компонент Y точки для преобразования в координаты спрайта.
     * @return float
     */
    function GetSpriteYFromWorld($iSpriteIndex, $x, $y)
    {
    }

    /**
     *Возвращает значение Y данной вершины в заданной форме. Это относится только к полигональным и цепным формам. Идентификаторы фигур начинаются с 1 для первой фигуры вплоть до значения, возвращаемого GetSpriteNumShapes. Идентификаторы вершин начинаются с 1 для первой вершины вплоть до значения, возвращаемого GetSpriteShapeNumVertices
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @param int $shapeID Идентификатор формы для проверки
     * @param int $vertex идентификатор проверяемой вершины, вершины начинаются с идентификатора 1.
     * @return float
     */
    function GetSpriteShapeVertexY($iSpriteIndex, $shapeID, $vertex)
    {
    }

    /**
     *Возвращает текущую ширину спрайта в виде значения с плавающей запятой.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteWidth($iSpriteIndex)
    {
    }

    /**
     *Возвращает значение X данной вершины в заданной форме. Это относится только к полигональным и цепным формам. Идентификаторы фигур начинаются с 1 для первой фигуры вплоть до значения, возвращаемого GetSpriteNumShapes. Идентификаторы вершин начинаются с 1 для первой вершины вплоть до значения, возвращаемого GetSpriteShapeNumVertices
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @param int $shapeID Идентификатор формы для проверки
     * @param int $vertex идентификатор проверяемой вершины, вершины начинаются с идентификатора 1.
     * @return float
     */
    function GetSpriteShapeVertexX($iSpriteIndex, $shapeID, $vertex)
    {
    }

    /**
     *Возвращает количество вершин в заданной форме. Это относится только к полигональным и цепным формам. Идентификаторы фигур начинаются с 1 для первой фигуры вплоть до значения, возвращаемого GetSpriteNumShapes.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @param int $shapeID Идентификатор формы для проверки
     * @return int
     */
    function GetSpriteShapeNumVertices($iSpriteIndex, $shapeID)
    {
    }

    /**
     *Возвращает текущее масштабирование спрайта в направлении Y как задано с помощью SetSpriteScale или SetSpriteScaleByOffset
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteScaleY($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущее масштабирование спрайта в направлении X как задано с помощью SetSpriteScale или SetSpriteScaleByOffset
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteScaleX($iSpriteIndex)
    {
    }

    /**
     *Возвращает 1, если спрайт в данный момент воспроизводит анимацию, и 0, если нет.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpritePlaying($iSpriteIndex)
    {
    }

    /**
     *Преобразует точку на изображении спрайта в пиксель на изображении спрайта, который находится под этой точкой. Например, если изображение размером 200x100 пикселей было назначено спрайту размером 10x10, то вызов этой команды со значением пикселя 5 (центр спрайта) вернет 100 (центр изображения). Для этого спрайту должно быть назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером изображения или спрайта, поэтому в приведенном выше примере значение пикселя 20 или -1 будет допустимым.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $x Координата x точки спрайта для проверки.
     * @return int
     */
    function GetSpritePixelFromX($iSpriteIndex, $x)
    {
    }

    /**
     *Преобразует точку на изображении спрайта в пиксель на изображении спрайта, который находится под этой точкой. Например, если изображение размером 200x100 пикселей было назначено спрайту размером 10x10, то вызов этой команды со значением пикселя 5 (центр спрайта) вернет 50 (центр изображения). Для этого спрайту должно быть назначено изображение, иначе он всегда будет возвращать 0. Команда не ограничена размером изображения или спрайта, поэтому в приведенном выше примере допустимо значение пикселя 20 или -1.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @param float $y Координата y точки спрайта для проверки.
     * @return int
     */
    function GetSpritePixelFromY($iSpriteIndex, $y)
    {
    }

    /**
     *Возвращает линейную скорость спрайта в направлении Y. Это количество единиц в секунду, которое спрайт в данный момент перемещает в выбранном вами разрешении.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return float
     */
    function GetSpritePhysicsVelocityY($iSpriteIndex)
    {
    }

    /**
     *Возвращает массу спрайта в килограммах, используемых в данный момент. Он либо генерировался автоматически при создании формы, либо добавлялся, либо устанавливался вручную.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return float
     */
    function GetSpritePhysicsMass($iSpriteIndex)
    {
    }

    /**
     *Возвращает значение X текущего Центра масс для физического тела данного спрайта. Все фигуры, добавленные в данный момент к этому спрайту, вносят свой вклад в это значение. Если вы установили центр масс вручную, то он вернет это значение. Для работы команды необходимо включить физику, иначе она вернет 0.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @return float
     */
    function GetSpritePhysicsCOMX($iSpriteIndex)
    {
    }

    /**
     *Возвращает угловую скорость спрайта в радианах в секунду. Это скорость, с которой в данный момент вращается спрайт.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return float
     */
    function GetSpritePhysicsAngularVelocity($iSpriteIndex)
    {
    }

    /**
     *Возвращает компонент Y текущей точки смещения спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteOffsetY($iSpriteIndex)
    {
    }

    /**
     *Возвращает компонент X текущей точки смещения спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteOffsetX($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущее количество фигур, назначенных этому спрайту. Идентификаторы фигур действительны от 1 до значения, возвращаемого этой командой, включая его.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @return int
     */
    function GetSpriteNumShapes($iSpriteIndex)
    {
    }

    /**
     *Возвращает 1, если спрайт в данный момент находится в видимой области экрана, и 0, если он находится за пределами видимой области. Обратите внимание, что если спрайт находится очень близко к краю, где может быть трудно определить, находятся ли все пиксели в спрайте за пределами видимой области, то эта команда вернет 1 и предположит, что он виден. Другими словами, если эта команда возвращает 0, то спрайт определенно находится вне экрана, если она возвращает 1, то спрайт, скорее всего, находится на экране, но на самом деле может быть вне экрана и очень близко к краю.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteInScreen($iSpriteIndex)
    {
    }

    /**
     *Возвращает 1, если форма столкновения спрайта касается заданного круга в мировых координатах, и 0, если нет. Если спрайт не имеет формы, ему присваивается собственная прямоугольная форма, которая останется после этой команды. Эта команда учитывает поворот и масштаб спрайта при проверке пересечения. Обратите внимание, что из-за изменений соотношения сторон эта команда ведет себя не так, как ожидалось при использовании процентной системы координат. Вместо этого он будет проверять эллипс с правильным радиусом в направлении X, но большим радиусом в направлении Y.
     *
     * @param int $iSprite Идентификатор спрайта для проверки
     * @param float $x1 Координата X центра окружности в мировых координатах.
     * @param float $y1 Координата Y центра окружности в мировых координатах.
     * @param float $radius Радиус окружности в мировых координатах.
     * @return int
     */
    function GetSpriteInCircle($iSprite, $x1, $y1, $radius)
    {
    }

    /**
     *Возвращает линейную скорость спрайта в направлении X. Это количество единиц в секунду, которое спрайт в данный момент перемещает в выбранном вами разрешении.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return float
     */
    function GetSpritePhysicsVelocityX($iSpriteIndex)
    {
    }

    /**
     *Возвращает 1, если форма столкновения спрайта касается заданного поля в мировых координатах, и 0, если нет. Если спрайт не имеет формы, ему присваивается собственная прямоугольная форма, которая останется после этой команды. Эта команда учитывает поворот и масштаб спрайта при проверке пересечения.
     *
     * @param int $iSprite Идентификатор спрайта для проверки
     * @param float $x1 Координата X верхнего левого угла прямоугольника в мировых координатах.
     * @param float $y1 Координата Y верхнего левого угла прямоугольника в мировых координатах.
     * @param float $x2 Координата X в правом нижнем углу прямоугольника в мировых координатах.
     * @param float $y2 Координата Y нижнего правого угла коробки в мировых координатах.
     * @return int
     */
    function GetSpriteInBox($iSprite, $x1, $y1, $x2, $y2)
    {
    }

    /**
     *Возвращает идентификатор изображения, назначенного в данный момент спрайту. Это работает только в том случае, если изображение было загружено с идентификатором (или присвоено ему AGK).
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteImageID($iSpriteIndex)
    {
    }

    /**
     *Возвращает значение Y текущего Центра масс для физического тела данного спрайта. Все фигуры, добавленные в данный момент к этому спрайту, вносят свой вклад в это значение. Если вы установили центр масс вручную, то он вернет это значение. Для работы команды необходимо включить физику, иначе она вернет 0.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @return float
     */
    function GetSpritePhysicsCOMY($iSpriteIndex)
    {
    }

    /**
     *Возвращает 1,если точка x, y в мировых координатах лежит внутри спрайта, 0, если нет. Учитывает вращение и масштабные значения спрайта. Использует форму, назначенную ему из SetSpriteShape, если форма не задана, она использует ширину и высоту спрайта в качестве формы коробки. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY.
     *
     * @param int $iSpriteIndex Спрайт для проверки.
     * @param float $x Положение x в мировых координатах нужно проверить.
     * @param float $y Положение y в мировых координатах для проверки.
     * @return int
     */
    function GetSpriteHitTest($iSpriteIndex, $x, $y)
    {
    }

    /**
     *Возвращает идентификатор первого спрайта,найденного под точкой x, y в мировых координатах, 0, если нет. Спрайты упорядочены по глубине, поэтому спрайт, появляющийся над другим в порядке розыгрыша, будет возвращен вместо спрайта позади него. Фильтрует результаты только для тех спрайтов, которые находятся в указанной группе. По умолчанию спрайты создаются в группе 0, вы можете изменить это с помощью SetSpriteGroup. Учитывается вращение и масштаб значений спрайта. Он не учитывает прозрачность спрайта, только его форму столкновения. Использует форму, назначенную ему из SetSpriteShape, если форма не задана, то она использует ширину и высоту спрайта в качестве формы коробки. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY.
     *
     * @param int $group Идентификатор группы для проверки.
     * @param float $x Положение x в мировых координатах нужно проверить.
     * @param float $y Положение y в мировых координатах для проверки.
     * @return int
     */
    function GetSpriteHitGroup($group, $x, $y)
    {
    }

    /**
     *Возвращает идентификатор первого спрайта,найденного под точкой x, y в мировых координатах, 0, если нет. Спрайты упорядочены по глубине, поэтому спрайт, появляющийся над другим в порядке розыгрыша, будет возвращен вместо спрайта позади него. Эта функция фильтрует результаты, поэтому проверяются только спрайты определенных категорий. Параметр category - это побитовое поле, которое использует младшие 16 битов для представления каждой из возможных 16 категорий, используемых при настройке спрайта. Значение по умолчанию all 1s означает, что все категории будут включены, тогда как значение all 0s означает, что никакие категории не будут включены. Вы можете установить отдельные биты, чтобы установить, какие из них должны быть проверены. Вы можете установить, к каким категориям относится спрайт, с помощью SetSpriteCategoryBits. Учитывает вращение и масштабные значения спрайта. Он не учитывает прозрачность спрайта, только его форму столкновения. Использует форму, назначенную ему из SetSpriteShape, если форма не задана, она использует ширину и высоту спрайта в качестве формы коробки. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY.
     *
     * @param int $categories Категории, которые нужно проверить.
     * @param float $x Положение x в мировых координатах нужно проверить.
     * @param float $y Положение y в мировых координатах для проверки.
     * @return int
     */
    function GetSpriteHitCategory($categories, $x, $y)
    {
    }

    /**
     *Возвращает идентификатор первого спрайта,найденного под точкой x, y в мировых координатах, 0, если нет. Спрайты упорядочены по глубине, поэтому спрайт, появляющийся над другим в порядке розыгрыша, будет возвращен вместо спрайта позади него. Учитывает вращение и масштабные значения спрайта. Он не учитывает прозрачность спрайта, только его форму столкновения. Использует форму, назначенную ему из SetSpriteShape, если форма не задана, она использует ширину и высоту спрайта в качестве формы коробки. Если вы тестируете мышь или сенсорную координату, не забудьте преобразовать ее в мировые координаты с помощью ScreenToWorldX и ScreenToWorldY.
     *
     * @param float $x Положение x в мировых координатах нужно проверить.
     * @param float $y Положение y в мировых координатах для проверки.
     * @return int
     */
    function GetSpriteHit($x, $y)
    {
    }

    /**
     *Возвращает текущую высоту спрайта в виде значения с плавающей запятой.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения
     * @return float
     */
    function GetSpriteHeight($iSpriteIndex)
    {
    }

    /**
     *Возвращает значение набора групп с помощью SetSpriteGroup. Если вы не установили группу, то это будет 0.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteGroup($iSpriteIndex)
    {
    }

    /**
     *Возвращает общее количество кадров, которые спрайту удалось получить из своего изображения. Может быть меньше, чем количество кадров, запрошенных во время настройки.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения.
     * @return int
     */
    function GetSpriteFrameCount($iSpriteIndex)
    {
    }

    /**
     *Циклически просматривает список контактов только для данного спрайта. Возвращает 1 если контакт существует, вы можете получить другой спрайт, вовлеченный в этот контакт, используя GetSpriteContactSpriteID2, вы можете перейти к следующему контакту, снова вызвав эту команду, она вернет 0, когда больше контактов не будет. Работает только на спрайтах, настроенных для физики.
     *

     * @return int
     */
    function GetSpriteNextContact()
    {
    }

    /**
     *Возвращает 1, если спрайт был перевернут вертикально с помощью SetSpriteFlip, в противном случае возвращает 0.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteFlippedV($iSpriteIndex)
    {
    }

    /**
     *Возвращает 1, если спрайт был перевернут горизонтально с помощью SetSpriteFlip, в противном случае возвращает 0.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteFlippedH($iSpriteIndex)
    {
    }

    /**
     *Циклически просматривает список контактов только для данного спрайта. Возвращает 1 если контакт существует, вы можете получить другой спрайт, вовлеченный в этот контакт, используя GetSpriteContactSpriteID2, вы можете перейти к следующему контакту с GetSpriteNextContact. Работает только на спрайтах, настроенных для физики. Возвращает 0, если контактов нет.
     *
     * @param int $iSprite1 Спрайт для проверки физических контактов.
     * @return int
     */
    function GetSpriteFirstContact($iSprite1)
    {
    }

    /**
     *Возвращает координату Y ближайшей точки на sprite 2 к sprite 1 из последнего вызова GetSpriteDistance в мировых координатах.
     *

     * @return float
     */
    function GetSpriteDistancePoint2Y()
    {
    }

    /**
     *Возвращает 1, если спрайт существует, и 0, если нет.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки
     * @return int
     */
    function GetSpriteExists($iSpriteIndex)
    {
    }

    /**
     *Возвращает координату X ближайшей точки на sprite 2 к sprite 1 из последнего вызова GetSpriteDistance в мировых координатах.
     *

     * @return float
     */
    function GetSpriteDistancePoint2X()
    {
    }

    /**
     *Возвращает координату X ближайшей точки на спрайте 1 к спрайту 2 от последнего вызова GetSpriteDistance в мировых координатах.
     *

     * @return float
     */
    function GetSpriteDistancePoint1X()
    {
    }

    /**
     *Возвращает координату Y ближайшей точки на спрайте 1 к спрайту 2 от последнего вызова GetSpriteDistance в мировых координатах.
     *

     * @return float
     */
    function GetSpriteDistancePoint1Y()
    {
    }

    /**
     *Возвращает текущую глубину спрайта в диапазоне 0-10000, где 0-передняя часть экрана, а 10000-задняя.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteDepth($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущий идентификатор кадра спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения.
     * @return int
     */
    function GetSpriteCurrentFrame($iSpriteIndex)
    {
    }

    /**
     *Возвращает координату Y точки контакта в мировых координатах.
     *

     * @return float
     */
    function GetSpriteContactWorldY()
    {
    }

    /**
     *Возвращает координату X точки контакта в мировых координатах.
     *

     * @return float
     */
    function GetSpriteContactWorldX()
    {
    }

    /**
     *Возвращает идентификатор другого спрайта, участвующего в этом контакте.
     *

     * @return int
     */
    function GetSpriteContactSpriteID2()
    {
    }

    /**
     *Возвращает текущий красный компонент спрайта в диапазоне 0-255.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteColorRed($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущий синий компонент спрайта в диапазоне 0-255.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteColorBlue($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущий зеленый компонент спрайта в диапазоне 0-255.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteColorGreen($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущее альфа-значение спрайта в диапазоне 0-255.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteColorAlpha($iSpriteIndex)
    {
    }

    /**
     *Проверяет два спрайта на столкновение, если они перекрываются, то возвращает 1. В противном случае возвращает 0. Никакая другая информация не может быть возвращена об этом типе столкновения. Эта команда предназначена в первую очередь для спрайтов, которые не используют физику. Хотя он может быть использован на физических спрайтах, физическая система уже вычислит перекрытие всех физических спрайтов в течение последнего кадра и сохранит результаты в списке контактов. Эта функция фактически выполняет вычисления, необходимые для определения того, перекрываются ли спрайты. Эта функция не ограничена настройками группы или категории. Эта функция работает только с базовой формой спрайта. Любые дополнительные фигуры, добавленные к физическим спрайтам, не будут использоваться в этой функции, вместо этого используйте GetPhysicsCollision. Кроме того, цепные формы всегда не будут возвращать никаких столкновений с помощью этой команды, цепные формы используются только в физических расчетах. Если вы не назначили форму ни одному из спрайтов с помощью SetSpriteShape, они будут использовать форму коробки по умолчанию, основанную на ширине и высоте спрайта.
     *
     * @param int $iSprite1 Спрайт для проверки на пересечение со спрайтом 2
     * @param int $iSprite2 Спрайт для проверки на пересечение со спрайтом 1
     * @return int
     */
    function GetSpriteCollision($iSprite1, $iSprite2)
    {
    }

    /**
     *Возвращает текущий угол спрайта в радианах, 0 радианов-это направление x=0 y=-1 и движение по часовой стрелке.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения.
     * @return float
     */
    function GetSpriteAngleRad($iSpriteIndex)
    {
    }

    /**
     *Возвращает текущий угол спрайта в градусах, 0 градусов-это направление x=0 y=-1 и движение по часовой стрелке.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для извлечения.
     * @return float
     */
    function GetSpriteAngle($iSpriteIndex)
    {
    }

    /**
     *Возвращает 0, если спрайт был установлен как неактивный с помощью SetSpriteActive, в противном случае возвращает 1.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для проверки.
     * @return int
     */
    function GetSpriteActive($iSpriteIndex)
    {
    }

    /**
     *Возвращает имя заданного голоса. На iOS это имя читается человеком, но не дает никаких подробностей о акценте или языке этого голоса. На Android имя дает информацию о языке и акценте, но не так легко читается.  В настоящее время работает только на iOS и Android.
     *
     * @param int $index Индекс голоса, который нужно проверить, начинается с 0 для первого голоса
     * @return string
     */
    function GetSpeechVoiceName($index)
    {
    }

    /**
     *Вычисляет минимальное расстояние, разделяющее два спрайта. Если спрайты перекрываются, это будет меньше 0. В противном случае это будет расстояние между ближайшими точками на каждом спрайте, эти точки можно найти с помощью GetSpriteDistancePoint1X и т. Д. Этот расчет занимает больше времени, чем просто проверка перекрытия спрайтов, если вам не нужно расстояние, разделяющее спрайты, используйте GetSpriteCollision. Эта функция не ограничена настройками группы или категории. Если вы не назначили форму ни одному из спрайтов с помощью SetSpriteShape, они будут использовать форму коробки по умолчанию, основанную на ширине и высоте спрайта.
     *
     * @param int $iSprite1 Спрайт для проверки расстояния с помощью спрайта 2
     * @param int $iSprite2 Спрайт для проверки расстояния с помощью спрайта 1
     * @return float
     */
    function GetSpriteDistance($iSprite1, $iSprite2)
    {
    }

    /**
     *Возвращает идентификатор данного голоса. Идентификатор можно использовать с SetSpeechLanguageByID для выбора конкретного голоса.
     *
     * @param int $index Индекс голоса, который нужно проверить, начинается с 0 для первого голоса
     * @return string
     */
    function GetSpeechVoiceID($index)
    {
    }

    /**
     *Возвращает количество голосов, которые можно выбрать с помощью команды SetSpeechLanguage. Вы можете использовать команды GetSpeechVoiceName и GetSpeechVoiceLanguage, чтобы получить подробную информацию о различных голосах.  В настоящее время работает только на iOS и Android.
     *
     * @return int
     */
    function GetSpeechNumVoices()
    {
    }

    /**
     *Возвращает языковую строку данного голоса. Это можно использовать непосредственно с командой SetSpeechLanguage, чтобы использовать этот голос для любой будущей речи.  В настоящее время работает только на iOS и Android.
     *
     * @param int $index Индекс голоса, который нужно проверить, начинается с 0 для первого голоса
     * @return string
     */
    function GetSpeechVoiceLanguage($index)
    {
    }

    /**
     *Возвращает количество экземпляров этого звукового идентификатора, которые в данный момент воспроизводятся или зацикливаются. Это точно так же, как GetSoundInstances.
     *
     * @param int $iID Звуковой номер для проверки.
     * @return int
     */
    function GetSoundsPlaying($iID)
    {
    }

    /**
     *Получает минимальную скорость и какие звуковые файлы могут быть воспроизведены на этом устройстве. Скорость 1,0 - это нормальная скорость, скорость 2,0-это двойная скорость, 0,5-половина скорости и так далее. Если вы попытаетесь изменить скорость воспроизведения звука за пределами этих значений, она будет привязана к этим значениям. Если и min, и max возвращают 1.0, то изменение скорости воспроизведения звука на этом устройстве не поддерживается.
     *
     * @return float
     */
    function GetSoundMinRate()
    {
    }

    /**
     *Получает максимальную скорость и какие звуковые файлы могут быть воспроизведены на этом устройстве. Скорость 1,0 - это нормальная скорость, скорость 2,0-это двойная скорость, 0,5-половина скорости и так далее. Если вы попытаетесь изменить скорость воспроизведения звука за пределами этих значений, она будет привязана к этим значениям. Если и min, и max возвращают 1.0, то изменение скорости воспроизведения звука на этом устройстве не поддерживается.
     *
     * @return float
     */
    function GetSoundMaxRate()
    {
    }

    /**
     *Возвращает количество экземпляров этого звукового идентификатора, которые в данный момент воспроизводятся или зацикливаются. Это точно так же, как GetSoundsPlaying.
     *
     * @param int $iID Звуковой номер для проверки.
     * @return int
     */
    function GetSoundInstances($iID)
    {
    }

    /**
     *Возвращает текущую скорость воспроизведения указанного экземпляра, где 1.0-нормальная скорость, 2.0 - двойная скорость и т. Д. Не все устройства гарантированно поддерживают изменение скорости воспроизведения.
     *
     * @param int $iID Идентификатор проверяемого экземпляра
     * @return float
     */
    function GetSoundInstanceRate($iID)
    {
    }

    /**
     *Возвращает текущий объем указанного экземпляра в диапазоне от 0 до 100.
     *
     * @param int $iID Идентификатор проверяемого экземпляра
     * @return int
     */
    function GetSoundInstanceVolume($iID)
    {
    }

    /**
     *Возвращает 1, если данный экземпляр все еще воспроизводится или зацикливается, и 0, если он остановился. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука. Как только эта команда вернет 0, экземпляр будет удален и на него больше нельзя будет ссылаться, любая попытка изменить его будет проигнорирована. Вам нужно будет создать новый экземпляр, снова используя PlaySound.
     *
     * @param int $iID Идентификатор проверяемого экземпляра
     * @return int
     */
    function GetSoundInstancePlaying($iID)
    {
    }

    /**
     *Если звук воспроизводился с включенным циклированием, эта команда возвращает количество завершенных до сих пор циклов. Если экземпляр использует фиксированное количество циклов, то он никогда на самом деле не достигнет этого значения количества циклов, так как будет немедленно удален по достижении конца своего последнего цикла. Идентификатор экземпляра - это значение, возвращаемое из PlaySound при инициировании воспроизведения звука.
     *
     * @param int $iID Идентификатор проверяемого экземпляра
     * @return int
     */
    function GetSoundInstanceLoopCount($iID)
    {
    }

    /**
     *Будет считывать строку из соединения сокета и возвращать ее. Если вы отправляете строку из источника, отличного от AGK, то строка должна начинаться со значения длины 4 байта, за которым следует X байт строковых данных, где X-значение длины. Строка не должна заканчиваться null. Если существует менее 4 байт данных, ожидающих чтения, то эта команда немедленно вернется и вернет пустую строку. Вы можете проверить, сколько данных нужно прочитать, используя GetSocketBytesAvailable. Если есть 4 или более байтов, ожидающих чтения, то эта команда будет ждать, пока вся строка не будет получена, прежде чем вернуться.
     *
     * @param int $socketID Идентификатор сокета для чтения
     * @return string
     */
    function GetSocketString($socketID)
    {
    }

    /**
     *Возвращает IP-адрес компьютера или устройства на другом конце соединения. Это может быть адрес IPv4 или IPv6.
     *
     * @param int $socketID Идентификатор сокета для проверки
     * @return string
     */
    function GetSocketRemoteIP($socketID)
    {
    }

    /**
     *Возвращает значение 1, если указанный звуковой номер существует, в противном случае возвращается 0.
     *
     * @param int $iID Звуковой номер для проверки.
     * @return int
     */
    function GetSoundExists($iID)
    {
    }

    /**
     *Возвращает идентификатор сокета, подключенного к вашему устройству. Прослушиватель будет принимать соединения в фоновом режиме и добавлять их в очередь, эта команда удаляет один из сокетов из очереди и передает вам управление им. Если вы не хотите принимать соединение, вы должны удалить его с помощью DeleteSocket. Вы должны вызвать GetSocketListenerConnection в цикле до тех пор, пока он не вернет 0, чтобы убедиться, что вы справились со всеми подключенными сокетами. Вы можете узнать IP-адрес устройства, которое подключилось к вам, вызвав GetSocketRemoteIP на возвращенном сокете.
     *
     * @param int $listenerID Идентификатор прослушивателя для проверки
     * @return int
     */
    function GetSocketListenerConnection($listenerID)
    {
    }

    /**
     *Будет считывать 4-байтовый поплавок из соединения сокета и возвращать его. Если существует менее 4 байт данных, ожидающих чтения, то эта команда немедленно вернется и вернет 0. Вы можете проверить, сколько данных нужно прочитать, используя GetSocketBytesAvailable.
     *
     * @param int $socketID Идентификатор сокета для чтения
     * @return float
     */
    function GetSocketFloat($socketID)
    {
    }

    /**
     *Возвращает 1, если указанный сокет подключен, и 0, если он все еще находится в процессе подключения. Если сокет будет отключен или не сможет подключиться, то это вернет -1.
     *
     * @param int $socketID Идентификатор сокета для проверки
     * @return int
     */
    function GetSocketConnected($socketID)
    {
    }

    /**
     *Возвращает 1, если указанный сокет существует, и 0 в противном случае.
     *
     * @param int $socketID Идентификатор сокета для проверки
     * @return int
     */
    function GetSocketExists($socketID)
    {
    }

    /**
     *Возвращает количество байтов, доступных для чтения. Если это возвращает 0, то команды чтения, такие как GetSocketInteger, не будут возвращать никаких данных.
     *
     * @param int $socketID Идентификатор сокета для проверки
     * @return int
     */
    function GetSocketBytesAvailable($socketID)
    {
    }

    /**
     *Получает Y-положение корня скелета, не изменяется во время анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return float
     */
    function GetSkeleton2DY($iSkeleton)
    {
    }

    /**
     *Получает положение X корня скелета, не изменяется во время анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return float
     */
    function GetSkeleton2DX($iSkeleton)
    {
    }

    /**
     *возвращает 1, если скелет переходит в анимационный кадр.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return int
     */
    function GetSkeleton2DIsTweening($iSkeleton)
    {
    }

    /**
     *возвращает 1, если скелет анимируется или переходит в первый кадр воспроизводимой анимации
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return int
     */
    function GetSkeleton2DIsAnimating($iSkeleton)
    {
    }

    /**
     *Будет считывать 4-байтовое целое число из соединения сокета и возвращать его. Если существует менее 4 байт данных, ожидающих чтения, то эта команда немедленно вернется и вернет 0. Вы можете проверить, сколько данных нужно прочитать, используя GetSocketBytesAvailable.
     *
     * @param int $socketID Идентификатор сокета для чтения
     * @return int
     */
    function GetSocketInteger($socketID)
    {
    }

    /**
     *Возвращает 1, если скелет существует с указанным идентификатором, в противном случае 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return int
     */
    function GetSkeleton2DExists($iSkeleton)
    {
    }

    /**
     *Получает текущую глубину скелета. Это находится в диапазоне 0-10000. 0 находится сверху, 10000 - сзади
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return int
     */
    function GetSkeleton2DDepth($iSkeleton)
    {
    }

    /**
     *Получить текущее время текущей воспроизводимой анимации в секундах
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return float
     */
    function GetSkeleton2DCurrentTime($iSkeleton)
    {
    }

    /**
     *Будет считывать один байт из сокета соединения и возвращать его. Если нет данных, ожидающих чтения, то эта команда немедленно вернется и вернет 0. Вы можете проверить, сколько данных нужно прочитать, используя GetSocketBytesAvailable.
     *
     * @param int $socketID Идентификатор сокета для чтения
     * @return int
     */
    function GetSocketByte($socketID)
    {
    }

    /**
     *Возвращает исходное положение Y указанной кости, также известное как установочная поза. Это значение не изменится, пока кость анимируется, вместо этого анимация строится поверх установочной позы, чтобы создать положение кости, видимое на экране. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneY($iSkeleton, $bone)
    {
    }

    /**
     *Возвращает текущее состояние подключения смарт-часов: 0=начальное состояние, ActivateSmartWatch не вызывался. 1=подключение, через мгновение перейдет в более детальное состояние. 2=соединение успешно, вы можете отправлять и получать данные. -1=команды watch не поддерживаются на этом устройстве. -2=соединение не удалось или часы не найдены. -3=часы найдены, но в данный момент они не сопряжены с устройством, -4=часы найдены, но наше приложение для часов в данный момент не установлено.  В настоящее время работает только на iOS.
     *
     * @return int
     */
    function GetSmartWatchState()
    {
    }

    /**
     *Возвращает исходное положение X указанной кости, также известное как установочная поза. Это значение не изменится, пока кость анимируется, вместо этого анимация строится поверх установочной позы, чтобы создать положение кости, видимое на экране. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneX($iSkeleton, $bone)
    {
    }

    /**
     *Возвращает идентификатор родителя указанной кости. Если кость не существует или у нее нет родителя, она вернет -1. Индексы начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return int
     */
    function GetSkeleton2DBoneParent($iSkeleton, $bone)
    {
    }

    /**
     *Возвращает текущее положение Y указанной кости в ее текущем анимированном положении. Это значение будет меняться во время анимации кости. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneCurrY($iSkeleton, $bone)
    {
    }

    /**
     *Возвращает текущий угол указанной кости в ее текущем анимированном положении. Это значение будет меняться во время анимации кости. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneCurrAngle($iSkeleton, $bone)
    {
    }

    /**
     *Возвращает идентификатор указанной кости для этого скелета. Если кости с заданным именем не существует, она вернет -1. Индекс 0-это допустимая кость.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param string $name Имя кости, которую нужно найти
     * @return int
     */
    function GetSkeleton2DBone($iSkeleton, $name)
    {
    }

    /**
     *получить общее время именованной анимации
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param string $anim Имя анимации для проверки
     * @return float
     */
    function GetSkeleton2DAnimationTime($iSkeleton, $anim)
    {
    }

    /**
     *Получает угол наклона корня скелета, не меняется во время анимации.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @return float
     */
    function GetSkeleton2DAngle($iSkeleton)
    {
    }

    /**
     *Возвращает количество полигонов, нарисованных последним кадром графического процессора при построении теневых карт.
     *
     * @return int
     */
    function GetShadowPolygonsDrawn()
    {
    }

    /**
     *Возвращает 1, если теневое отображение поддерживается на этом устройстве, и 0 в противном случае.
     *
     * @return int
     */
    function GetShadowMappingSupported()
    {
    }

    /**
     *Возвращает текущий режим отображения теней, который был установлен с помощью SetShadowMappingMode
     *
     * @return int
     */
    function GetShadowMappingMode()
    {
    }

    /**
     *Возвращает 1, если шейдер в данный момент загружен с заданным идентификатором, в противном случае он возвращает 0.
     *
     * @param int $shaderID Идентификатор шейдера для проверки
     * @return int
     */
    function GetShaderExists($shaderID)
    {
    }

    /**
     *Возвращает секунды заданного значения времени unix (от 0 до 59). Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetSecondsFromUnix($unixtime)
    {
    }

    /**
     *Получите количество целых секунд с момента запуска приложения. С точностью до 1 секунды.  Вызов этой команды внутренне вызовет системный вызов, чтобы получить количество прошедшего времени, поэтому он может меняться каждый раз, когда вы его вызываете.
     *
     * @return int
     */
    function GetSeconds()
    {
    }

    /**
     *Возвращает текущее положение X указанной кости в ее текущем анимированном положении. Это значение будет меняться во время анимации кости. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneCurrX($iSkeleton, $bone)
    {
    }

    /**
     *Возвращает исходный угол указанной кости, также известный как установочная поза. Это значение не изменится, пока кость анимируется, вместо этого анимация строится поверх установочной позы, чтобы создать вращение кости, видимое на экране. Если кость не существует, она вернет 0. Идентификаторы костей начинаются с 0.
     *
     * @param int $iSkeleton Идентификатор скелета для проверки
     * @param int $bone Идентификатор кости для проверки
     * @return float
     */
    function GetSkeleton2DBoneAngle($iSkeleton, $bone)
    {
    }

    /**
     *Преобразует 3D-точку в экранные координаты.
     *
     * @param float $x X-компонент 3D-точки.
     * @param float $y Компонент Y трехмерной точки.
     * @param float $z Z-компонент 3D-точки.
     * @return float
     */
    function GetScreenYFrom3D($x, $y, $z)
    {
    }

    /**
     *Возвращает верхний край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть черные границы в верхней и нижней части дисплея, то это значение будет отрицательным. Это означает, что 0-это конец видимой области и начало черной границы, а верхняя граница - это конец черной границы и край экрана. Если сверху нет черной границы, то верхняя граница всегда будет равна 0.
     *
     * @return float
     */
    function GetScreenBoundsTop()
    {
    }

    /**
     *Преобразует 3D-точку в экранные координаты.
     *
     * @param float $x X-компонент 3D-точки.
     * @param float $y Компонент Y трехмерной точки.
     * @param float $z Z-компонент 3D-точки.
     * @return float
     */
    function GetScreenXFrom3D($x, $y, $z)
    {
    }

    /**
     *Возвращает правый край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть черные границы слева и справа от дисплея, то это значение будет больше, чем GetVirtualWidth. Это означает, что виртуальная ширина-это конец видимой области и начало черной границы, а правая граница - это конец черной границы и край экрана. Если справа нет черной границы, то правая граница всегда будет равна GetVirtualWidth.
     *
     * @return float
     */
    function GetScreenBoundsRight()
    {
    }

    /**
     *Возвращает левый край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть черные границы слева и справа от дисплея, то это значение будет отрицательным. Это означает, что 0-это конец видимой области и начало черной границы, а левая граница - это конец черной границы и край экрана. Если слева нет черной границы, то левая граница всегда будет равна 0.
     *
     * @return float
     */
    function GetScreenBoundsLeft()
    {
    }

    /**
     *Возвращает нижний край видимого экрана. Это включает в себя любую область черной границы, поэтому, если есть черные границы в верхней и нижней части дисплея, то это значение будет больше, чем GetVirtualHeight. Это означает, что виртуальная высота является концом видимой области и началом черной границы, а нижняя граница-концом черной границы и краем экрана. Если внизу нет черной границы, то нижняя граница всегда будет равна GetVirtualHeight.
     *
     * @return float
     */
    function GetScreenBoundsBottom()
    {
    }

    /**
     *Возвращает значение загруженного в данный момент объявления о вознаграждении, это вернет 0, если значение вознаграждения неизвестно. Если в данный момент не загружено ни одно объявление о вознаграждении, то это значение не определено, оно может быть равно 0 или это может быть значение предыдущего объявления. Вы должны спросить пользователя, хочет ли он просмотреть объявление о вознаграждении, прежде чем показывать его, а также вознаграждение, которое он получит за это. Вы можете использовать эту функцию значения для определения подходящего вознаграждения. Это значение останется неизменным при вызове ResetRewardAdMob
     *
     * @return int
     */
    function GetRewardAdValueAdMob()
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет датчик вектора вращения, который в настоящее время поддерживается AGK, и 0, если нет.
     *
     * @return int
     */
    function GetRotationVectorSensorExists()
    {
    }

    /**
     *Возвращает 1, если ранее показанное объявление о вознаграждении привело к вознаграждению, которое должно быть дано пользователю, например, некоторые внутриигровые монеты. При вызове ShowRewardAdAdMob это значение устанавливается равным 0 и устанавливается равным 1 только в том случае, если пользователь завершил бонусное видео, в противном случае оно останется равным 0. После того как вы дали пользователю вознаграждение, вы можете установить его обратно в 0 с помощью ResetRewardAdMob.
     *
     * @return int
     */
    function GetRewardAdRewardedChartboost()
    {
    }

    /**
     *Возвращает 1, если есть предварительно загруженное и готовое к показу объявление Chartboost reward, в противном случае 0. Если это так, вы можете отобразить его с помощью ShowRewardAdChartboost. Объявления предварительно загружаются после вызова CacheRewardAdChartboost и после того, как каждое объявление о вознаграждении отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают 0, вы можете попробовать снова позвонить в CacheRewardAdChartboost, чтобы перезапустить процесс загрузки и посмотреть, стали ли доступны новые объявления.
     *
     * @return int
     */
    function GetRewardAdLoadedChartboost()
    {
    }

    /**
     *Возвращает 1, если объявление AdMob reward предварительно загружено и готово к показу, в противном случае 0. Если это так, вы можете отобразить его с помощью ShowRewardAdAdMob. Объявления предварительно загружаются, как только вы устанавливаете свои данные о вознаграждении AdMob, и после того, как каждое объявление о вознаграждении отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают 0, то вы можете попробовать вызвать ShowRewardAdAdMob в любом случае, он ничего не покажет, так как ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны какие-либо новые объявления.
     *
     * @return int
     */
    function GetRewardAdLoadedAdMob()
    {
    }

    /**
     *Возвращает 1, если ваше приложение было передано в фоновый режим и только что было повторно активировано. Когда это произойдет, вы должны активировать экран паузы. На мобильных платформах приложения не будут работать, пока они находятся в фоновом режиме, так что первый шанс, что ваше приложение получит это уведомление, - это когда оно вернется из фонового режима и продолжит работу. Поскольку пользователь, возможно, еще не готов продолжить воспроизведение, вы должны проверить это значение и показать экран паузы до тех пор, пока он не будет готов.
     *
     * @return int
     */
    function GetResumed()
    {
    }

    /**
     *Возвращает каталог, содержащий исполняемый файл приложения на текущей платформе, на которой оно запущено. Обратите внимание, что на Android этот путь недоступен при обычном использовании и вернет пустую строку.
     *
     * @return string
     */
    function GetReadPath()
    {
    }

    /**
     *Возвращает координату X точки пересечения последней проверки приведения луча. Результат - в мировых координатах.
     *
     * @return float
     */
    function GetRayCastX()
    {
    }

    /**
     *Возвращает компонент Y нормали самой последней проверки приведения луча. Это не будет единичный вектор, так как он был преобразован в мировые координаты.
     *
     * @return float
     */
    function GetRayCastNormalY()
    {
    }

    /**
     *Возвращает X-компоненту нормали самой последней проверки приведения луча. Это не будет единичный вектор, так как он был преобразован в мировые координаты.
     *
     * @return float
     */
    function GetRayCastNormalX()
    {
    }

    /**
     *Возвращает 1, если ранее показанное объявление о вознаграждении привело к вознаграждению, которое должно быть дано пользователю, например, некоторые внутриигровые монеты. При вызове ShowRewardAdAdMob это значение устанавливается равным 0 и устанавливается равным 1 только в том случае, если пользователь завершил бонусное видео, в противном случае оно останется равным 0. После того как вы дали пользователю вознаграждение, вы можете установить его обратно в 0 с помощью ResetRewardAdMob.
     *
     * @return int
     */
    function GetRewardAdRewardedAdMob()
    {
    }

    /**
     *Возвращает имя текущего средства визуализации, например "OpenGL" или "OpenGLES"
     *
     * @return string
     */
    function GetRendererName()
    {
    }

    /**
     *Извлекает значение, ранее сохраненное в этом событии с помощью SetRawTouchValue.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return int
     */
    function GetRawTouchValue($iIndex)
    {
    }

    /**
     *Возвращает долю луча, пройденного до достижения столкновения. 0 означает начало луча, а 1.0-его конец.
     *
     * @return float
     */
    function GetRayCastFraction()
    {
    }

    /**
     *Возвращает координату Y точки пересечения последней проверки приведения луча. Результат - в мировых координатах.
     *
     * @return float
     */
    function GetRayCastY()
    {
    }

    /**
     *Возвращает тип данного события касания. Все, в чем вы можете быть уверены при неизвестных событиях, - это то, что палец в данный момент находится на экране и находится там менее 1 секунды. Через 1 секунду он автоматически становится событием удержания. Если пользователь поднимает палец с экрана до этого, то это становится коротким событием, а если он перемещает палец дальше, чем расстояние, указанное SetRawTouchMoveSensitivity, то это становится событием перетаскивания. Если текущее событие неизвестно, то оно возвращает 0. События могут измениться с событий удержания на события перетаскивания, но короткие события и события перетаскивания не изменяют тип. Неизвестные события гарантированно изменят тип, как только появится дополнительная информация. Возможные возвращаемые значения-0 для обозначения неизвестного, 1 для короткого касания, 2 для удержания и 3 для перетаскивания.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return int
     */
    function GetRawTouchType($iIndex)
    {
    }

    /**
     *Возвращает положение Y в координатах экрана, в котором началось событие касания. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldY.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchStartY($iIndex)
    {
    }

    /**
     *Возвращает общее время, которое заняло это событие, от нажатия до выпуска в секундах.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchTime($iIndex)
    {
    }

    /**
     *Возвращает идентификатор спрайта, попавшего в самую последнюю проверку ray cast. Если луч попал в не спрайтовую фигуру, то будет возвращено 0.
     *

     * @return int
     */
    function GetRayCastSpriteID()
    {
    }

    /**
     *Возвращает позицию X в координатах экрана, где началось событие касания. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldX.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchStartX($iIndex)
    {
    }

    /**
     *Возвращает позицию Y в координатах экрана, где событие касания было записано в последний раз до его текущего местоположения. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldY.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchLastY($iIndex)
    {
    }

    /**
     *Возвращает позицию X в координатах экрана, где событие касания было записано в последний раз до его текущего местоположения. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldX.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchLastX($iIndex)
    {
    }

    /**
     *Возвращает позицию X в координатах экрана, где в данный момент находится событие касания. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldX.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchCurrentX($iIndex)
    {
    }

    /**
     *Возвращает положение Y в координатах экрана, где в данный момент находится событие касания. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldY.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return float
     */
    function GetRawTouchCurrentY($iIndex)
    {
    }

    /**
     *Возвращает количество событий касания, происходящих в данный момент. По умолчанию AGK не считает событие до тех пор, пока не узнает, какой это тип события, например короткое, длинное, перетаскивание и т. Д. Чтобы также подсчитать неизвестные события, установите значение bIncludeUnknown равным 1. Используйте 0, чтобы игнорировать неизвестные события.
     *
     * @param int $bIncludeUnknown Установите значение 1, чтобы подсчитать неизвестные события, которые могут стать любым типом сенсорного события в будущем.
     * @return int
     */
    function GetRawTouchCount($bIncludeUnknown)
    {
    }

    /**
     *Возвращает Z-компонент текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите сориентировать объект, используйте GetRawRotationVectorZ
     *
     * @return float
     */
    function GetRawRotationVectorZ2()
    {
    }

    /**
     *Возвращает компонент Y текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите сориентировать объект, используйте GetRawRotationVectorY
     *
     * @return float
     */
    function GetRawRotationVectorY2()
    {
    }

    /**
     *Возвращает Z-компонент текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorZ2
     *
     * @return float
     */
    function GetRawRotationVectorZ()
    {
    }

    /**
     *Возвращает компонент Y текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorY2
     *
     * @return float
     */
    function GetRawRotationVectorY()
    {
    }

    /**
     *Возвращает компонент X текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите сориентировать объект, используйте GetRawRotationVectorX
     *
     * @return float
     */
    function GetRawRotationVectorX2()
    {
    }

    /**
     *Возвращает компонент X текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorX2
     *
     * @return float
     */
    function GetRawRotationVectorX()
    {
    }

    /**
     *Возвращает W-компонент текущей ориентации устройства в виде кватерниона. Это может быть применено к камерам с SetCameraRotationQuat, чтобы использовать устройство как гарнитуру виртуальной реальности. Эта команда выполняет внутренние вычисления на основе значений SetOrientationAllowed для получения правильной ориентации камеры для текущей ориентации устройства. Эта команда предназначена для использования с камерами, если вы хотите сориентировать объект, используйте GetRawRotationVectorW
     *
     * @return float
     */
    function GetRawRotationVectorW2()
    {
    }

    /**
     *Возвращает W-компонент текущей ориентации устройства в виде кватерниона. Это можно применить к объектам с помощью SetObjectRotationQuat, чтобы имитировать ориентацию устройства с объектом. Эта команда предназначена для использования с объектами, если вы хотите сориентировать камеру, используйте GetRawRotationVectorW2
     *
     * @return float
     */
    function GetRawRotationVectorW()
    {
    }

    /**
     *Если датчик приближения существует, возвращает расстояние устройства от любого объекта, находящегося в данный момент перед ним, непроверенное, поскольку ни одно устройство не поддерживало его во время тестирования.
     *
     * @return float
     */
    function GetRawProximityDistance()
    {
    }

    /**
     *Возвращает 1 если прикосновение было отпущено, это всегда будет 1 для коротких событий, события удержания и перетаскивания будут продолжать сообщать 0 до тех пор, пока они не будут отпущены, и в этот момент вы, возможно, захотите предпринять какие-то действия. Каждое событие будет сообщаться только как 1 раз, прежде чем быть удаленным из списка событий. Если событие касания игнорируется (не запрашивается) в течение одного кадра после его освобождения, оно будет удалено из списка событий.
     *
     * @param int $iIndex Индекс события для проверки, полученный от GetRawNextTouchEvent или GetRawFirstTouchEvent.
     * @return int
     */
    function GetRawTouchReleased($iIndex)
    {
    }

    /**
     *Возвращает индекс к следующему событию касания, доступному для чтения, если больше нет доступных событий, он возвращает 0.
     *

     * @return int
     */
    function GetRawNextTouchEvent()
    {
    }

    /**
     *Возвращает компонент Y текущего положения мыши в координатах экрана. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return float
     */
    function GetRawMouseY()
    {
    }

    /**
     *Возвращает компонент X текущего положения мыши в координатах экрана. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return float
     */
    function GetRawMouseX()
    {
    }

    /**
     *Возвращает разницу между текущим положением колесика мыши и предыдущим положением колесика мыши, может быть положительной или отрицательной, обновляется один раз в кадр. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return float
     */
    function GetRawMouseWheelDelta()
    {
    }

    /**
     *Возвращает текущее положение колесика мыши, может быть положительным или отрицательным, начинается с 0. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return float
     */
    function GetRawMouseWheel()
    {
    }

    /**
     *Возвращает 1, если правая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseRightState()
    {
    }

    /**
     *Возвращает 1, если правая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseRightReleased()
    {
    }

    /**
     *Возвращает 1, если была нажата правая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseRightPressed()
    {
    }

    /**
     *Возвращает 1, если средняя кнопка мыши в данный момент опущена, и 0, если нет. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseMiddleState()
    {
    }

    /**
     *Возвращает 1, если средняя кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseMiddleReleased()
    {
    }

    /**
     *Возвращает 1, если была нажата средняя кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseMiddlePressed()
    {
    }

    /**
     *Возвращает 1, если левая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseLeftState()
    {
    }

    /**
     *Возвращает 1, если четвертая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFourthReleased()
    {
    }

    /**
     *Возвращает 1, если была нажата четвертая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFourthPressed()
    {
    }

    /**
     *Возвращает 1, если пятая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFifthState()
    {
    }

    /**
     *Возвращает 1, если пятая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFifthReleased()
    {
    }

    /**
     *Возвращает 1, если была нажата пятая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFifthPressed()
    {
    }

    /**
     *Если магнитный датчик существует, возвращает Z-компоненту любого окружающего магнитного поля. На iOS может потребоваться несколько секунд, чтобы начать отображать данные, отличные от 0, во время этого процесса устройство использует данные движения для калибровки магнитного датчика
     *
     * @return float
     */
    function GetRawMagneticZ()
    {
    }

    /**
     *Возвращает 1, если левая кнопка мыши была отпущена, а затем возвращает 0, когда кнопка поднята. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseLeftReleased()
    {
    }

    /**
     *Возвращает 1, если четвертая кнопка мыши в данный момент нажата, и 0, если нет. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseFourthState()
    {
    }

    /**
     *Если магнитный датчик существует, возвращает Y-компоненту любого окружающего магнитного поля. На iOS может потребоваться несколько секунд, чтобы начать отображать данные, отличные от 0, во время этого процесса устройство использует данные движения для калибровки магнитного датчика
     *
     * @return float
     */
    function GetRawMagneticY()
    {
    }

    /**
     *Возвращает 1, если была нажата левая кнопка мыши, а затем возвращает 0, пока кнопка удерживается нажатой. Если мыши не существует, она всегда будет возвращать 0.
     *
     * @return int
     */
    function GetRawMouseLeftPressed()
    {
    }

    /**
     *Если магнитный датчик существует, возвращает X-компоненту любого окружающего магнитного поля. На iOS может потребоваться несколько секунд, чтобы начать отображать данные, отличные от 0, во время этого процесса устройство использует данные движения для калибровки магнитного датчика
     *
     * @return float
     */
    function GetRawMagneticX()
    {
    }

    /**
     *Если датчик окружающего света существует, получите измерение окружающего света в люмел в виде поплавка.
     *
     * @return float
     */
    function GetRawLightLevel()
    {
    }

    /**
     *Возвращает код последней нажатой клавиши. Это относится только к платформам с полноразмерной клавиатурой, таким как ПК, Mac и Linux. Вы можете проверить, существует ли клавиатура, используя GetKeyboardExists. Эта функция продолжает возвращать последнюю нажатую клавишу даже после того, как она была отпущена. Проверьте страницу коды сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому коду ключа
     *

     * @return int
     */
    function GetRawLastKey()
    {
    }

    /**
     *Возвращает 1, если данный код ключа в данный момент не работает. 0, если он поднят. Это относится только к платформам с полноразмерной клавиатурой, таким как ПК и Mac, в противном случае все клавиши вернут 0. Вы можете проверить, существует ли клавиатура, проверив, что GetKeyboardExists возвращает 1. Коды клавиш находятся в диапазоне от 0 до 255, все, что выходит за пределы диапазона, возвращает 0. Проверьте страницу коды сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому коду ключа
     *
     * @param int $key Код ключа от ключа для проверки.
     * @return int
     */
    function GetRawKeyState($key)
    {
    }

    /**
     *Возвращает 1, если данный код ключа был выпущен в этом кадре, а затем возвращает 0, пока ключ находится вверх. Это относится только к платформам с полноразмерной клавиатурой, таким как ПК и Mac, в противном случае все клавиши вернут 0. Вы можете проверить, существует ли клавиатура, проверив, что GetKeyboardExists возвращает 1. Коды клавиш находятся в диапазоне от 0 до 255, все, что выходит за пределы диапазона, возвращает 0. Проверьте страницу коды сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому коду ключа
     *
     * @param int $key Код ключа от ключа для проверки.
     * @return int
     */
    function GetRawKeyReleased($key)
    {
    }

    /**
     *Возвращает 1, если данный код клавиши был нажат в этом кадре, а затем возвращает 0, пока клавиша удерживается нажатой. Это относится только к платформам с полноразмерной клавиатурой, таким как ПК и Mac, в противном случае все клавиши вернут 0. Вы можете проверить, существует ли клавиатура, проверив, что GetKeyboardExists возвращает 1. Коды клавиш находятся в диапазоне от 0 до 255, все, что выходит за пределы диапазона, возвращает 0. Проверьте страницу коды сканирования в разделе руководства файлов справки, чтобы узнать, какой ключ соответствует какому коду ключа
     *
     * @param int $key Код ключа от ключа для проверки.
     * @return int
     */
    function GetRawKeyPressed($key)
    {
    }

    /**
     *Возвращает текущее значение Z (если применимо) для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickZ($index)
    {
    }

    /**
     *Возвращает текущее значение ползунка джойстика, которое может варьироваться в зависимости от типа джойстика. В настоящее время индекс ползунка должен быть либо 0, либо 1. Ползунки обычно используются для дополнительных осей.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @param int $slider Индекс ползунка для проверки.
     * @return int
     */
    function GetRawJoystickSlider($index, $slider)
    {
    }

    /**
     *Возвращает текущее значение Y для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickY($index)
    {
    }

    /**
     *Возвращает текущее значение X для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickX($index)
    {
    }

    /**
     *Возвращает текущее вращательное значение Z (если применимо) для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. На самом деле некоторые джойстики используют это значение для второго аналогового джойстика.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickRZ($index)
    {
    }

    /**
     *Возвращает имя джойстика, обнаруженное операционной системой, в настоящее время работает только на Windows и Linux. В Tier 2 строка кодируется в UTF-8 и должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return string
     */
    function GetRawJoystickName($index)
    {
    }

    /**
     *Возвращает текущее вращательное значение X (если применимо) для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. На самом деле некоторые джойстики используют это значение для второго аналогового джойстика.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickRX($index)
    {
    }

    /**
     *Возвращает текущее значение POV джойстика, это может варьироваться в зависимости от типа джойстика. В настоящее время индекс POV должен быть либо 0, 1, 2, либо 3
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @param int $pov Индекс POV для проверки.
     * @return int
     */
    function GetRawJoystickPOV($index, $pov)
    {
    }

    /**
     *Возвращает 1, если джойстик существует в данном индексе. Физические джойстики обнаруживаются при запуске и постепенно помещаются в идентификаторы 1-8. Вы должны вызвать CompleteRawJoystickDetection в какой-то момент перед этой командой, чтобы убедиться, что все присутствующие джойстики были обнаружены. После первоначального процесса обнаружения подключение дополнительных джойстиков не будет обнаружено (за исключением Android, который обнаружит новые джойстики). Отсоединение джойстика не приведет к удалению его индекса, и эта команда все равно вернет 1. Вы можете использовать GetRawJoystickConnected для обнаружения отсоединения ранее обнаруженного джойстика. Если отсоединенный джойстик будет снова подключен, AGK попытается снова подключиться к нему. Альтернативная версия этой команды существует GetJoystickExists, и в этом случае она вернет 1, если есть какие-либо необработанные джойстики.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return int
     */
    function GetRawJoystickExists($index)
    {
    }

    /**
     *Возвращает 1, если указанный джойстик подключен, и 0, если нет. Это относится только к джойстикам, которые были подключены при запуске приложения, подключение нового джойстика после запуска приложения не будет обнаружено. Используйте GetRawJoystickExists, чтобы узнать, какие джойстики были обнаружены при запуске. Эта команда в настоящее время не работает на Mac.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return int
     */
    function GetRawJoystickConnected($index)
    {
    }

    /**
     *Возвращает 1, если данная кнопка в данный момент опущена, в противном случае возвращает 0. Чтобы обнаружить экземпляр, в котором кнопка нажата или отпущена, используйте GetRawJoystickButtonPressed или GetRawJoystickButtonReleased. AGK поддерживает до 64 кнопок джойстика в диапазоне 1-64.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @param int $button Идентификатор кнопки для проверки.
     * @return int
     */
    function GetRawJoystickButtonState($index, $button)
    {
    }

    /**
     *Возвращает 1, если данная кнопка была отпущена в этом кадре, в противном случае возвращает 0. Как только кнопка была отпущена, эта функция возвращается к 0, чтобы проверить состояние кнопки, используйте GetRawJoystickButtonState. AGK поддерживает до 64 кнопок джойстика в диапазоне 1-64.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @param int $button Идентификатор кнопки для проверки.
     * @return int
     */
    function GetRawJoystickButtonReleased($index, $button)
    {
    }

    /**
     *Если гироскоп существует, возвращает Z-составляющую текущей скорости вращения устройства. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании гироскопа.
     *
     * @return float
     */
    function GetRawGyroVelocityZ()
    {
    }

    /**
     *Если гироскоп существует, возвращает Y-компоненту текущей скорости вращения устройства. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании гироскопа.
     *
     * @return float
     */
    function GetRawGyroVelocityY()
    {
    }

    /**
     *Если гироскоп существует, возвращает X-компоненту текущей скорости вращения устройства. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании гироскопа.
     *
     * @return float
     */
    function GetRawGyroVelocityX()
    {
    }

    /**
     *Возвращает текущее вращательное значение Y (если применимо) для физического джойстика с заданным индексом. Это будет находиться в диапазоне от -1.0 до 1.0 с центрированием 0. На самом деле некоторые джойстики используют это значение для второго аналогового джойстика.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @return float
     */
    function GetRawJoystickRY($index)
    {
    }

    /**
     *Возвращает самую последнюю доступную долготу.
     *
     * @return float
     */
    function GetRawGPSLongitude()
    {
    }

    /**
     *Возвращает самую актуальную высоту, доступную в метрах над уровнем моря.
     *
     * @return float
     */
    function GetRawGPSAltitude()
    {
    }

    /**
     *Возвращает количество файлов, найденных при вызове OpenRawFolder.
     *
     * @param int $ID Идентификатор папки для проверки
     * @return int
     */
    function GetRawFolderNumFiles($ID)
    {
    }

    /**
     *Возвращает количество папок, найденных при вызове OpenRawFolder.
     *
     * @param int $ID Идентификатор папки для проверки
     * @return int
     */
    function GetRawFolderNumFolders($ID)
    {
    }

    /**
     *Возвращая конкретное имя папки из списка файлов, индекс должен быть в диапазоне от 0 до GetRawFolderNumFolders минус один.
     *
     * @param int $ID Идентификатор папки для проверки
     * @param int $index Индекс возвращаемой папки, индексы начинаются с 0
     * @return string
     */
    function GetRawFolderFolderName($ID, $index)
    {
    }

    /**
     *Возвращая конкретное имя файла из списка файлов, индекс должен быть в диапазоне от 0 до GetRawFolderNumFiles минус один.
     *
     * @param int $ID Идентификатор папки для проверки
     * @param int $index Индекс возвращаемого файла, индексы начинаются с 0
     * @return string
     */
    function GetRawFolderFileName($ID, $index)
    {
    }

    /**
     *Возвращает 1, если данная кнопка была нажата в этом кадре, в противном случае возвращает 0. После нажатия кнопки эта функция возвращается к 0, чтобы проверить состояние кнопки, используйте GetRawJoystickButtonState. AGK поддерживает до 64 кнопок джойстика в диапазоне 1-64.
     *
     * @param int $index Идентификатор джойстика для проверки.
     * @param int $button Идентификатор кнопки для проверки.
     * @return int
     */
    function GetRawJoystickButtonPressed($index, $button)
    {
    }

    /**
     *Возвращает индекс к первому событию касания, доступному для чтения. По умолчанию AGK не считает событие до тех пор, пока не узнает, какой это тип события, например короткое, длинное, перетаскивание и т. Д. Для получения неизвестных событий также установите значение bIncludeUnknown равным 1. Используйте 0, чтобы игнорировать неизвестные события. Все, в чем вы можете быть уверены при неизвестных событиях, - это то, что палец в данный момент находится на экране и находится там менее 1 секунды. Через 1 секунду он автоматически становится событием удержания. Если пользователь поднимает палец с экрана, это становится коротким событием, а если он двигает пальцем, это становится событием перетаскивания. Если никакие события не доступны, он возвращает 0.
     *
     * @param int $bIncludeUnknown Установите значение true для получения неизвестных событий, которые могут стать событиями любого типа в будущем.
     * @return int
     */
    function GetRawFirstTouchEvent($bIncludeUnknown)
    {
    }

    /**
     *Если акселерометр существует, возвращает текущее значение акселерометра для направления Z в диапазоне от -1 до 1. Положительное значение Z означает, что экран направлен вверх. Если акселерометр не существует, то он всегда будет возвращать 0, так как нет эмулируемой команды для направления Z. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана акселерометром. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании акселерометра.
     *
     * @return float
     */
    function GetRawAccelZ()
    {
    }

    /**
     *Если акселерометр существует, возвращает текущее значение акселерометра для направления X в диапазоне от -1 до 1. Это соответствует экранной системе координат положительного существа справа. Если акселерометра не существует, то он всегда будет возвращать 0. Вы можете использовать команду GetDirectionX для эмуляции ввода направления. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана акселерометром. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании акселерометра.
     *
     * @return float
     */
    function GetRawAccelX()
    {
    }

    /**
     *Если акселерометр существует, возвращает текущее значение акселерометра для направления Y в диапазоне от -1 до 1. Это соответствует экранной системе координат положительного бытия вниз. Если акселерометра не существует, то он всегда будет возвращать 0. Вы можете использовать команду GetDirectionY для эмуляции ввода направления. Если вы не использовали SetOrientationAllowed для выбора желаемой ориентации, то эта команда заблокирует устройство в текущей ориентации, чтобы предотвратить вращение экрана акселерометром. Вы должны использовать SetOrientationAllowed, если хотите включить вращение экрана при использовании акселерометра.
     *
     * @return float
     */
    function GetRawAccelY()
    {
    }

    /**
     *Возвращает маркер push-уведомления для этого устройства, он должен быть отправлен на ваш сервер, который отправляет уведомления, чтобы он мог отправлять уведомления на это устройство. Если PushNotificationSetup вернул 1, то вы должны продолжать вызывать эту команду до тех пор, пока она не вернет непустую строку. Если PushNotificationSetup вернул 0, то эта команда всегда будет возвращать пустую строку.  Пожалуйста, обратитесь к руководству по Push-уведомлениям Android для получения более подробной информации о том, как использовать токен устройства для отправки Push-уведомлений на это устройство.
     *
     * @return string
     */
    function GetPushNotificationToken()
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет датчик приближения, который в настоящее время поддерживается AGK, и 0, если нет.
     *
     * @return int
     */
    function GetProximitySensorExists()
    {
    }

    /**
     *Возвращает самую последнюю доступную широту.
     *
     * @return float
     */
    function GetRawGPSLatitude()
    {
    }

    /**
     *Возвращает количество полигонов, нарисованных последним кадром графического процессора.
     *
     * @return int
     */
    function GetPolygonsDrawn()
    {
    }

    /**
     *Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана. Если устройство имеет мышь, то это возвращает текущее положение X мыши. В противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет положение X самого последнего события касания. Если никаких событий не происходит, то это последняя позиция X, записанная сенсорным событием. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldX.
     *
     * @return float
     */
    function GetPointerX()
    {
    }

    /**
     *Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана. Если на устройстве есть мышь, то это вернет 1, если левая кнопка мыши в данный момент нажата, и 0, если нет. В противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет 1, если в данный момент нажимается одно или несколько сенсорных событий. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными.  Существует три команды для получения состояния нажатия указателя: GetPointerPressed возвращает 1 в момент нажатия указателя, а затем возвращает 0, GetPointerReleased возвращает 1 в момент отпускания указателя, а затем возвращает 0, GetPointerState возвращает 1 все время нахождения указателя в нажатом состоянии.
     *
     * @return int
     */
    function GetPointerState()
    {
    }

    /**
     *возвращает 1, если указанный точечный свет существует, и 0 в противном случае.
     *
     * @param int $lightID Идентификатор света для проверки.
     * @return int
     */
    function GetPointLightExists($lightID)
    {
    }

    /**
     *Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана. Если на устройстве есть мышь, то это вернет 1, если левая кнопка мыши отпущена, и 0, если нет. В противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет 1, если будет выпущено одно или несколько сенсорных событий. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными. Существует три команды для получения состояния нажатия указателя: GetPointerPressed возвращает 1 в момент нажатия указателя, а затем возвращает 0, GetPointerReleased возвращает 1 в момент отпускания указателя, а затем возвращает 0, GetPointerState возвращает 1 все время нахождения указателя в нажатом состоянии.
     *
     * @return int
     */
    function GetPointerReleased()
    {
    }

    /**
     *Возвращает оценку количества пикселей, которые были нарисованы на экране в последнем кадре. Как правило, чем ниже это значение, тем лучше производительность. Количество нарисованных пикселей может быть больше, чем количество пикселей на экране, так как перекрывающиеся спрайты могут рисовать один и тот же пиксель дважды.
     *
     * @return int
     */
    function GetPixelsDrawn()
    {
    }

    /**
     *Возвращает количество островов, обработанных решателем на последнем шаге
     *
     * @return int
     */
    function GetPhysicsIslandCount()
    {
    }

    /**
     *Возвращает количество секунд и долей секунд, затраченных на обновление физического моделирования.
     *
     * @return float
     */
    function GetPhysicsTime()
    {
    }

    /**
     *Возвращает количество миллисекунд, затраченных в решателе
     *
     * @return float
     */
    function GetPhysicsSolveTime()
    {
    }

    /**
     *Возвращает координату X точки столкновения от последнего вызова GetPhysicsCollision относительно смещения первого спрайта.
     *

     * @return float
     */
    function GetPhysicsCollisionX()
    {
    }

    /**
     *Возвращает координату Y точки столкновения от последнего вызова GetPhysicsCollision относительно смещения первого спрайта.
     *

     * @return float
     */
    function GetPhysicsCollisionY()
    {
    }

    /**
     *Возвращает координату Y точки столкновения из последнего вызова GetPhysicsCollision в мировых координатах.
     *

     * @return float
     */
    function GetPhysicsCollisionWorldY()
    {
    }

    /**
     *Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана. Если устройство имеет мышь, то это возвращает текущее положение мыши Y. В противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет положение Y самого последнего события касания. Если никаких событий не происходит, то это последняя позиция Y, записанная сенсорным событием. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными. Эта координата будет находиться в координатах вида, если вы смещаете порт вида, вы можете преобразовать его в мировые координаты с помощью ScreenToWorldY.
     *
     * @return float
     */
    function GetPointerY()
    {
    }

    /**
     *Возвращает 1, если два физических спрайта перекрываются, в противном случае он возвращает 0. Эта функция не делает никаких вычислений, она просто просматривает результаты последнего физического шага, чтобы определить, перекрываются ли спрайты в данный момент. Если эта функция возвращает true, вы можете получить точку столкновения с помощью GetPhysicsCollisionX и GetPhysicsCollisionY, если существует более одной точки столкновения, неизвестно, какая точка будет возвращена. Вы можете проверить список контактов спрайта, чтобы получить полный список контактных точек. На эту функцию влияют настройки групп и категорий.
     *
     * @param int $iSprite1 Идентификатор первого спрайта для проверки
     * @param int $iSprite2 Идентификатор второго спрайта для проверки
     * @return int
     */
    function GetPhysicsCollision($iSprite1, $iSprite2)
    {
    }

    /**
     *Возвращает координату X точки столкновения из последнего вызова GetPhysicsCollision в мировых координатах.
     *

     * @return float
     */
    function GetPhysicsCollisionWorldX()
    {
    }

    /**
     *Это эмулируемый метод ввода, который использует любые доступные входы устройства для создания указателя экрана. Если устройство имеет мышь, то это вернет 1, если левая кнопка мыши нажата, 0, если нет. В противном случае AGK проверит наличие сенсорного экрана и, если он будет найден, вернет 1, если существует одно или несколько событий касания. На устройствах, не имеющих ни мышей, ни сенсорных экранов, AGK попытается создать некоторую форму экранного указателя, управляемого аналоговыми стиками или подобными.  Существует три команды для получения состояния нажатия указателя: GetPointerPressed возвращает 1 в момент нажатия указателя, а затем возвращает 0, GetPointerReleased возвращает 1 в момент отпускания указателя, а затем возвращает 0, GetPointerState возвращает 1 все время нахождения указателя в нажатом состоянии.
     *
     * @return int
     */
    function GetPointerPressed()
    {
    }

    /**
     *Возвращает текущее положение Y излучателя, это точка, из которой будут появляться новые частицы. Невозможно получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesY($ID)
    {
    }

    /**
     *Возвращает текущее положение X излучателя, это точка, из которой будут появляться новые частицы. Невозможно получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesX($ID)
    {
    }

    /**
     *Возвращает 0, если данные частицы были установлены как невидимые с помощью SetParticlesVisible, или 1, если они в данный момент установлены как видимые (по умолчанию). Это не проверяет, находятся ли частицы в видимом окне просмотра.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function GetParticlesVisible($ID)
    {
    }

    /**
     *Возвращает текущий размер всех частиц в мировых координатах. Подробнее об установке размера частиц см. в разделе SetParticlesSize.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesSize($ID)
    {
    }

    /**
     *Возвращает 1, если излучатель испустил количество частиц, указанное в SetParticlesMax, и все испущенные частицы с тех пор умерли, в противном случае возвращает 0. Если максимальное значение равно -1, то оно всегда будет возвращать 0. Чтобы сбросить счетчик и заставить излучатель снова начать излучать, используйте ResetParticleCount.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function GetParticlesMaxReached($ID)
    {
    }

    /**
     *Возвращает текущую жизнь частиц в секундах. Невозможно получить текущую жизнь отдельных частиц. Это значение не зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesLife($ID)
    {
    }

    /**
     *Возвращает текущую частоту генерации частиц в частицах в секунду. Это значение не зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesFrequency($ID)
    {
    }

    /**
     *Возвращает 1, если излучатель частиц существует с заданным идентификатором, и 0, если нет.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function GetParticlesExists($ID)
    {
    }

    /**
     *Возвращает y-компоненту направления излучателя, которое является базовым направлением движения частиц при их создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения SetParticlesAngle.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesDirectionY($ID)
    {
    }

    /**
     *Возвращает X-компоненту направления излучателя, которое является базовым направлением движения частиц при их создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения GetParticlesAngle.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesDirectionX($ID)
    {
    }

    /**
     *Возвращает текущую глубину, на которой будут нарисованы все частицы. Это значение находится в диапазоне от 0 до 10000, причем 0 находится в передней части экрана.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function GetParticlesDepth($ID)
    {
    }

    /**
     *Возвращает текущий угол излучателя в радианах. Это значение представляет собой величину отклонения частицы от направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 2*PI означает, что частица может двигаться в любом направлении при испускании.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesAngleRad($ID)
    {
    }

    /**
     *Возвращает 1, если ваше настольное приложение теряет фокус. Вы можете активировать экран паузы, когда это произойдет, или позволить приложению продолжать работать в обычном режиме. Это относится только к настольным платформам, на мобильных платформах вы должны использовать GetResumed вместо этого.
     *
     * @return int
     */
    function GetPaused()
    {
    }

    /**
     *Возвращает текущий угол излучателя в градусах. Это значение представляет собой величину отклонения частицы от направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 360 означает, что частица может двигаться в любом направлении при испускании.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function GetParticlesAngle($ID)
    {
    }

    /**
     *Возвращает 0, если данные частицы были приостановлены с помощью SetParticlesActive, или 1, если они в данный момент обновляются как обычно (по умолчанию).
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function GetParticlesActive($ID)
    {
    }

    /**
     *Возвращает количество отдельных частиц, которые были нарисованы в последнем кадре с помощью метода quad. Чем выше это число, тем больше работы выполняет двигатель, обрабатывая частицы.
     *
     * @return int
     */
    function GetParticleDrawnQuadCount()
    {
    }

    /**
     *Начиная с версии 108 эта команда всегда будет возвращать 0, так как все частицы рисуются квадратиками. Вместо этого используйте GetParticleDrawnQuadCount.
     *
     * @return int
     */
    function GetParticleDrawnPointCount()
    {
    }

    /**
     *Возвращает текущую ориентацию устройства. Возвращаемые значения: 1 = портретный режим, 2 = портретный режим - поворот на 180 градусов, 3 = ландшафтный режим - 90 градусов против часовой стрелки, 4 = ландшафтный режим - 90 градусов по часовой стрелке
     *
     * @return int
     */
    function GetOrientation()
    {
    }

    /**
     *Заполняет outPosVec3 контактным положением. Возвращает false, если нет контакта. Сначала создайте вектор с помощью CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен результатами.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $outPosVec3 Идентификатор вектора положения, который должен быть заполнен. Сначала создайте этот вектор.
     * @return int
     */
    function GetObjects3DPhysicsContactPositionVector($objA, $objB, $outPosVec3)
    {
    }

    /**
     *Возвращает текущее Z-положение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectZ($objID)
    {
    }

    /**
     *Возвращает текущее положение X объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectX($objID)
    {
    }

    /**
     *Возвращает текущее Z-положение объекта в мировых координатах. Это учитывает родительские позиции в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое положение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldZ($objID)
    {
    }

    /**
     *Возвращает текущее положение объекта Y в мировых координатах. Это учитывает родительские позиции в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое положение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldY($objID)
    {
    }

    /**
     *Возвращает Z-компоненту текущего вращения объекта, преобразованную в кватернион в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldQuatZ($objID)
    {
    }

    /**
     *Возвращает Y-компоненту текущего вращения объекта, преобразованную в кватернион в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldQuatY($objID)
    {
    }

    /**
     *Возвращает текущее положение X объекта в мировых координатах. Это учитывает родительские позиции в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое положение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldX($objID)
    {
    }

    /**
     *Возвращает X-компоненту текущего вращения объекта, преобразованную в кватернион в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldQuatX($objID)
    {
    }

    /**
     *Возвращает W-компонент текущего вращения объекта, преобразованный в кватернион в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldQuatW($objID)
    {
    }

    /**
     *Возвращает Z-компоненту текущего вращения объекта, преобразованную в углы Эйлера в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldAngleZ($objID)
    {
    }

    /**
     *Возвращает Y-компоненту текущего вращения объекта, преобразованную в углы Эйлера в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldAngleY($objID)
    {
    }

    /**
     *Возвращает X-компоненту текущего вращения объекта, преобразованную в углы Эйлера в мировых координатах. Это учитывает родительские вращения в результате FixObjectToObject или FixObjectToBone и возвращает абсолютное мировое вращение объекта.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectWorldAngleX($objID)
    {
    }

    /**
     *Возвращает текущее положение объекта Y.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectY($objID)
    {
    }

    /**
     *Возвращает текущий режим прозрачности для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectTransparency($objID)
    {
    }

    /**
     *Возвращает имя текстуры, определенное в файле модели, из которого она была загружена, но текстурам не гарантируется наличие имен. Имена текстур находятся в диапазоне от 1 до GetObjectNumTextures включительно. Если вы вызываете эту команду из уровня 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $textureIndex Индекс текстуры для проверки, первая текстура находится в индексе 1.
     * @return string
     */
    function GetObjectTextureName($objID, $textureIndex)
    {
    }

    /**
     *Возвращает минимальный экстент объекта в направлении Z, это может быть объединено с GetObjectSizeMaxZ для определения размера объекта в направлении Z. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2 единицы в направлении Z. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной сетки, используйте GetObjectMeshSizeMinZ.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMinZ($objID)
    {
    }

    /**
     *Возвращает минимальный экстент объекта в направлении X, это может быть объединено с GetObjectSizeMaxY для определения размера объекта в направлении Y. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2 единицы в направлении Y. Эта команда берет границы всех сеток, составляющих этот объект, для проверки границ одной сетки используйте GetObjectMeshSizeMinY.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMinY($objID)
    {
    }

    /**
     *Возвращает минимальный экстент объекта в направлении X, это может быть объединено с GetObjectSizeMaxX для определения размера объекта в направлении X. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2 единицы в направлении X. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной сетки, используйте GetObjectMeshSizeMinX.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMinX($objID)
    {
    }

    /**
     *Возвращает максимальный экстент объекта в направлении Z, это может быть объединено с GetObjectSizeMinZ для определения размера объекта в направлении Z. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, то есть его размер составляет 2 единицы в направлении Z. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной сетки, используйте GetObjectMeshSizeMaxZ.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMaxZ($objID)
    {
    }

    /**
     *Возвращает максимальный экстент объекта в направлении X, это можно объединить с GetObjectSizeMinY для определения размера объекта в направлении Y. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, что означает, что его размер составляет 2 единицы в направлении Y. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной сетки, используйте GetObjectMeshSizeMaxY.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMaxY($objID)
    {
    }

    /**
     *Возвращает максимальный экстент объекта в направлении X, это может быть объединено с GetObjectSizeMinX для определения размера объекта в направлении X. Обратите внимание, что объект может быть смещен от центра, поэтому его минимальное значение может быть равно 10, а максимальное-12, то есть его размер составляет 2 единицы в направлении X. Эта команда берет границы всех сеток, составляющих этот объект, чтобы проверить границы одной сетки, используйте GetObjectMeshSizeMaxX.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectSizeMaxX($objID)
    {
    }

    /**
     *Возвращает 1, если объект в данный момент настроен на получение теней, и 0 в противном случае.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectReceiveShadowMode($objID)
    {
    }

    /**
     *Возвращает Z-компоненту точки столкновения для заданного индекса столкновения в последней проверке столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastZ($index)
    {
    }

    /**
     *Возвращает текущий режим видимости для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectVisible($objID)
    {
    }

    /**
     *Возвращает компонент Y точки столкновения для заданного индекса столкновения в последней проверке столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastY($index)
    {
    }

    /**
     *Возвращает компонент X точки столкновения для заданного индекса столкновения в последней проверке столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastX($index)
    {
    }

    /**
     *Возвращает Z-компоненту конечной точки покоя для скользящих столкновений. Это допустимо только для индекса 0 и после вызова ObjectSphereSlide. Поместите объект здесь, чтобы он выглядел так, как будто он скользил после столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastSlideZ($index)
    {
    }

    /**
     *Возвращает компонент Y конечной точки покоя для скользящих столкновений. Это допустимо только для индекса 0 и после вызова ObjectSphereSlide. Поместите объект здесь, чтобы он выглядел так, как будто он скользил после столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastSlideY($index)
    {
    }

    /**
     *Возвращает Z-компонент нормальной коллизии при последней проверке коллизии. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastNormalZ($index)
    {
    }

    /**
     *Возвращает компонент X конечной точки покоя для скользящих столкновений. Это допустимо только для индекса 0 и после вызова ObjectSphereSlide. Поместите объект здесь, чтобы он выглядел так, как будто он скользил после столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastSlideX($index)
    {
    }

    /**
     *Возвращает компонент Y нормальной коллизии при последней проверке коллизии. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastNormalY($index)
    {
    }

    /**
     *Возвращает попадание идентификатора объекта для данного индекса коллизии при последней проверке коллизии. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return int
     */
    function GetObjectRayCastHitID($index)
    {
    }

    /**
     *Возвращает расстояние между начальной точкой луча и точкой столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastDistance($index)
    {
    }

    /**
     *Возвращает Z-компоненту вектора отскока для последней проверки столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits. Расположите объект здесь так, чтобы он выглядел так, как будто отскочил после столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastBounceZ($index)
    {
    }

    /**
     *Возвращает компонент Y вектора отскока для последней проверки столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits. Расположите объект здесь так, чтобы он выглядел так, как будто отскочил после столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastBounceY($index)
    {
    }

    /**
     *Возвращает X-компоненту вектора отскока для последней проверки столкновения. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits. Расположите объект здесь так, чтобы он выглядел так, как будто отскочил после столкновения.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastBounceX($index)
    {
    }

    /**
     *Возвращает Z-компонент текущего вращения объекта, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectQuatZ($objID)
    {
    }

    /**
     *Возвращает компонент Y текущего вращения объекта, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectQuatY($objID)
    {
    }

    /**
     *Возвращает W-компонент текущего вращения объекта, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectQuatW($objID)
    {
    }

    /**
     *Возвращает количество коллизий, произошедших при последней проверке коллизий. В случае ObjectRayCast и ObjectSphereCast это будет 0 или 1. Для ObjectSphereSlide это может быть где-то между 0 и 4.
     *
     * @return int
     */
    function GetObjectRayCastNumHits()
    {
    }

    /**
     *Возвращает компонент X нормальной коллизии при последней проверке коллизии. Вы можете проверить количество допустимых индексов с помощью GetObjectRayCastNumHits.
     *
     * @param int $index Индекс столкновения проверить, начиная с индекса 0.
     * @return float
     */
    function GetObjectRayCastNormalX($index)
    {
    }

    /**
     *Возвращает количество ссылок на текстуру, найденных при загрузке объекта. Объект может иметь несколько ссылок на текстуру. Эта информация будет доступна только в том случае, если файл модели имеет настройку материала с ссылкой на диффузную текстуру.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectNumTextures($objID)
    {
    }

    /**
     *Возвращает количество сеток, принадлежащих этому объекту. Объект может иметь несколько сеток, обычно это происходит в случае мультиматериальных объектов, где объект разделен на несколько сеток, каждая из которых использует другую текстуру. Обратите внимание, что экземпляры объектов могут не иметь никаких сеток.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectNumMeshes($objID)
    {
    }

    /**
     *Получает количество костей, которые были загружены в результате загрузки этого объекта. Это происходит только в том случае, если объект был загружен с помощью LoadObjectWithChildren. Если объект имеет анимацию конечностей, как в DarkBasic Classic, то кости представляют иерархию конечностей, и каждая конечность загружается как дочерний объект, прикрепленный к кости. Если объект имеет взвешенную вершинную анимацию, то кости представляют скелет, а кожа загружается как единая сетка, хранящаяся в корневом объекте. Эти две формы анимации могут быть объединены, так что взвешенная вершинная костная структура может иметь объекты, прикрепленные к ее костям одновременно с деформацией кожной сетки.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectNumBones($objID)
    {
    }

    /**
     *Возвращает имя объекта, определенное в файле модели. Это полезно при использовании LoadObjectWithChildren для идентификации дочерних объектов, к которым можно получить доступ с помощью GetObjectChildID.  Если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return string
     */
    function GetObjectName($objID)
    {
    }

    /**
     *Возвращает компонент X текущего вращения объекта, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectQuatX($objID)
    {
    }

    /**
     *Возвращает минимальную протяженность сетки в направлении Y, это может быть объединено с GetObjectMeshSizeMaxY для определения размера сетки в направлении Y. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении Y.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMinY($objID, $meshIndex)
    {
    }

    /**
     *Возвращает количество дочерних объектов, которые были загружены в результате загрузки этого объекта. Например, объект анимированного персонажа из кости может иметь модель пистолета, прикрепленную к кости, представляющей его руку, эта модель пистолета будет загружена как отдельный объект и получит свой собственный идентификатор, которым вы можете манипулировать отдельно от основного объекта. Вы даже можете отсоединить пистолет от руки с помощью FixObjectToBone(ID,0), чтобы сделать его нормальным объектом, который не будет двигаться при движении персонажа. Однако он всегда будет оставаться в этом списке дочерних объектов для справки и будет удален, если DeleteObjectWithChildren вызывается для объекта character. Для тех из вас, кто знаком с DarkBasic, объекты, содержащие конечности в DarkBasic, будут загружены как дочерние объекты в AGK. Однако в дочерних объектах нет иерархии, у них не было бы собственных детей. Вместо этого в корневом объекте создается костная структура, представляющая иерархию конечностей, а дочерние объекты присоединяются к соответствующим костям.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectNumChildren($objID)
    {
    }

    /**
     *Возвращает количество анимаций, назначенных объекту в данный момент. Только объекты, загруженные с помощью LoadObjectWithChildren, получают назначенные им анимации.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectNumAnimations($objID)
    {
    }

    /**
     *Возвращает минимальный экстент сетки в направлении X, это можно объединить с GetObjectMeshSizeMaxX для определения размера сетки в направлении X. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении X.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMinX($objID, $meshIndex)
    {
    }

    /**
     *Возвращает максимальную протяженность сетки в направлении Z, это может быть объединено с GetObjectMeshSizeMinZ для определения размера сетки в направлении Z. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении Z.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMaxZ($objID, $meshIndex)
    {
    }

    /**
     *Возвращает максимальную протяженность сетки в направлении Y, это может быть объединено с GetObjectMeshSizeMinY для определения размера сетки в направлении Y. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении Y.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMaxY($objID, $meshIndex)
    {
    }

    /**
     *Возвращает максимальный экстент сетки в направлении X, это может быть объединено с GetObjectMeshSizeMinX для определения размера сетки в направлении X. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении X.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMaxX($objID, $meshIndex)
    {
    }

    /**
     *Возвращает исходный код вершинного шейдера, используемого в данный момент на этом объекте. Если вы не назначили шейдер для этой сетки, то он генерируется автоматически, и вы можете использовать эту команду, чтобы получить его исходный код, если хотите внести в него коррективы. Затем вы можете загрузить этот модифицированный источник шейдера с помощью LoadShader и назначить его SetObjectMeshShader. Обратите внимание, что изменение количества текстур или использование SetObjectLightMode обычно генерирует новый шейдер для обработки изменений, однако если вы использовали SetObjectMeshShader, то AGK больше не будет изменять ваш шейдер, предполагая, что вы сами учли эти изменения. Обратите внимание, что шейдеры, использующие освещение, будут иметь функции GetVSLighting() и GetPSLighting (), которые будут заполняться AGK во время выполнения в зависимости от того, сколько огней находится рядом с сеткой. Удаление этих функций из источника шейдера приведет к удалению всего освещения из сетки. Если вы вызываете эту команду из уровня 2, вы должны удалить строку, когда закончите с ней.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки, первая сетка находится в индексе 1.
     * @return string
     */
    function GetObjectMeshVSSource($objID, $meshIndex)
    {
    }

    /**
     *Возвращает минимальный экстент сетки в направлении Z, это может быть объединено с GetObjectMeshSizeMaxZ для определения размера сетки в направлении Z. Обратите внимание, что сетка может быть смещена от центра, поэтому ее минимальное значение может быть равно 10, а максимальное-12, что означает, что ее размер составляет 2 единицы в направлении Z.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки.
     * @return float
     */
    function GetObjectMeshSizeMinZ($objID, $meshIndex)
    {
    }

    /**
     *Возвращает исходный код пиксельного шейдера, используемого в данный момент на этом объекте. Если вы не назначили шейдер для этой сетки, то он генерируется автоматически, и вы можете использовать эту команду, чтобы получить его исходный код, если хотите внести в него коррективы. Затем вы можете загрузить этот модифицированный источник шейдера с помощью LoadShader и назначить его SetObjectMeshShader. Обратите внимание, что изменение количества текстур или использование SetObjectLightMode обычно генерирует новый шейдер для обработки изменений, однако если вы использовали SetObjectMeshShader, то AGK больше не будет изменять ваш шейдер, предполагая, что вы сами учли эти изменения. Обратите внимание, что шейдеры, использующие освещение, будут иметь функции GetVSLighting() и GetPSLighting (), которые будут заполняться AGK во время выполнения в зависимости от того, сколько огней находится рядом с сеткой. Удаление этих функций из источника шейдера приведет к удалению всего освещения из сетки. Если вы вызываете эту команду из уровня 2, вы должны удалить строку, когда закончите с ней.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки, первая сетка находится в индексе 1.
     * @return string
     */
    function GetObjectMeshPSSource($objID, $meshIndex)
    {
    }

    /**
     *Получает имя сетки, как определено в файле модели, из которого она была загружена, но сетки не гарантированно имеют имена. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes включительно. Если вы вызываете эту команду из уровня 2, вы должны удалить возвращенную строку с помощью agk::DeleteString, когда закончите с ней.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $meshIndex Индекс сетки для проверки, первая сетка находится в индексе 1.
     * @return string
     */
    function GetObjectMeshName($objID, $meshIndex)
    {
    }

    /**
     *Возвращает 1, если объект в данный момент находится в кадре анимации, или в начале, или в готовящейся к воспроизведению анимации. Это происходит только сразу после PlayObjectAnimation или SetObjectAnimationFrame, если вы указали время анимации больше 0. Это не происходит в любое другое время во время анимации.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectIsTweening($objID)
    {
    }

    /**
     *Возвращает 1 если объект в данный момент воспроизводит анимацию, это включает твин до начала анимации, но не твин до одного кадра. По сути, он возвращает 1, если объект должен воспроизводить анимацию. Если анимация настроена на цикл заданное количество раз или воспроизводится только один раз, то эта команда вернет 0, когда анимация будет закончена.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectIsAnimating($objID)
    {
    }

    /**
     *Если объект был создан с помощью CreateObjectFromHeightMap, то эта команда может быть использована для быстрого получения высоты объекта в определенном мировом положении. Это объясняет положение объекта и поворот Y, чтобы обеспечить высоту независимо от того, где находится объект. Если объект повернут под углом X или Z, то это приведет к неправильным значениям. Вы должны указать координаты X и Z в мировых единицах измерения, если точка лежит вне объекта, то будет возвращено 0.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param float $x X компонент позиции для проверки
     * @param float $z Z компонент позиции для проверки
     * @return float
     */
    function GetObjectHeightMapHeight($objID, $x, $z)
    {
    }

    /**
     *Возвращает 1, если AGK считает, что объект в данный момент находится на экране, и 0, если нет. Это оценка, и если вы сомневаетесь, предположим, что объект находится на экране. Таким образом, если эта команда возвращает 0, то объект определенно находится вне экрана, если она возвращает 1, то объект может быть или не быть на экране.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectInScreen($objID)
    {
    }

    /**
     *Возвращает 1, если объект существует с заданным идентификатором, и 0 в противном случае.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectExists($objID)
    {
    }

    /**
     *Возвращает текущий режим записи глубины для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectDepthWrite($objID)
    {
    }

    /**
     *Возвращает текущий режим чтения глубины для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectDepthReadMode($objID)
    {
    }

    /**
     *Возвращает текущее красное значение цвета этого объекта, заданное параметром SetObjectColor.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectColorRed($objID)
    {
    }

    /**
     *Возвращает текущее зеленое значение цвета этого объекта, заданное параметром SetObjectColor.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectColorGreen($objID)
    {
    }

    /**
     *Возвращает текущее синее значение цвета этого объекта, заданное параметром SetObjectColor.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectColorBlue($objID)
    {
    }

    /**
     *Возвращает идентификатор объекта для указанного дочернего объекта, который был загружен в результате этого объекта. Чтобы найти количество дочерних объектов, используйте GetObjectNumChildren. childIndex находится в диапазоне от 1 до количества детей включительно. Для тех из вас, кто знаком с DarkBasic, объекты, содержащие конечности в DarkBasic, будут загружены как дочерние объекты в AGK. Однако в дочерних объектах нет иерархии, у них не было бы собственных детей. Вместо этого в корневом объекте создается костная структура, представляющая иерархию конечностей, а дочерние объекты присоединяются к соответствующим костям.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $childIndex Индекс ребенка получить.
     * @return int
     */
    function GetObjectChildID($objID, $childIndex)
    {
    }

    /**
     *Возвращает 1, если объект в данный момент настроен на отбрасывание теней, и 0 в противном случае.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectCastShadowMode($objID)
    {
    }

    /**
     *Возвращает текущее Z - положение кости.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneZ($objID, $boneIndex)
    {
    }

    /**
     *Возвращает текущее положение кости по оси Y.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneY($objID, $boneIndex)
    {
    }

    /**
     *Возвращает текущее положение X кости.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneX($objID, $boneIndex)
    {
    }

    /**
     *Возвращает текущее Z - положение кости в мировых координатах.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldZ($objID, $boneIndex)
    {
    }

    /**
     *Возвращает текущее смещение глубины для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectDepthBias($objID)
    {
    }

    /**
     *Возвращает текущее положение кости по оси Y в мировых координатах.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldY($objID, $boneIndex)
    {
    }

    /**
     *Возвращает текущий режим отбраковки для этого объекта
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectCullMode($objID)
    {
    }

    /**
     *Возвращает Z-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldQuatZ($objID, $boneIndex)
    {
    }

    /**
     *Возвращает Y-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldQuatY($objID, $boneIndex)
    {
    }

    /**
     *Возвращает X-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldQuatX($objID, $boneIndex)
    {
    }

    /**
     *Возвращает W-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldQuatW($objID, $boneIndex)
    {
    }

    /**
     *Возвращает Z-компоненту текущего вращения кости, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldAngleZ($objID, $boneIndex)
    {
    }

    /**
     *Возвращает Y-компоненту текущего вращения кости, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldAngleY($objID, $boneIndex)
    {
    }

    /**
     *Возвращает X-компоненту текущего вращения кости в мировых координатах, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldAngleX($objID, $boneIndex)
    {
    }

    /**
     *Возвращает Z-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneQuatZ($objID, $boneIndex)
    {
    }

    /**
     *Возвращает Y-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneQuatY($objID, $boneIndex)
    {
    }

    /**
     *Возвращает X-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneQuatX($objID, $boneIndex)
    {
    }

    /**
     *Возвращает W-компонент текущего вращения кости, преобразованный в кватернион.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneQuatW($objID, $boneIndex)
    {
    }

    /**
     *Возвращает текущее положение кости X в мировых координатах.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneWorldX($objID, $boneIndex)
    {
    }

    /**
     *Получает индекс кости по ее имени. Имена загружаются из файла модели при использовании LoadObjectWithChildren, в противном случае кости не загружаются. Индексы будут находиться в диапазоне от 1 до num bones или 0, если они не найдены.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param string $name Имя кости, которую нужно найти.
     * @return int
     */
    function GetObjectBoneByName($objID, $name)
    {
    }

    /**
     *Возвращает Z-компоненту текущего вращения кости, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneAngleZ($objID, $boneIndex)
    {
    }

    /**
     *Возвращает Y-компоненту текущего вращения кости, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneAngleY($objID, $boneIndex)
    {
    }

    /**
     *Возвращает текущее время воспроизводимой анимации, или если анимация остановилась, то возвращается последнее время, использованное для интерполяции.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectAnimationTime($objID)
    {
    }

    /**
     *Возвращает X-компоненту текущего вращения кости, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return float
     */
    function GetObjectBoneAngleX($objID, $boneIndex)
    {
    }

    /**
     *Возвращает имя указанной анимации для данного объекта. Вы можете найти количество анимаций для этого объекта с помощью GetObjectNumAnimations. Индекс должен находиться в диапазоне от 1 до numAnimations включительно.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param int $index Индекс анимации для проверки, индексы начинаются с 1.
     * @return string
     */
    function GetObjectAnimationName($objID, $index)
    {
    }

    /**
     *Возвращает длительность указанной анимации в секундах.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @param string $animName Название проверяемой анимации, определяемое программой моделирования
     * @return float
     */
    function GetObjectAnimationDuration($objID, $animName)
    {
    }

    /**
     *Возвращает Z-компоненту текущего вращения объекта, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectAngleZ($objID)
    {
    }

    /**
     *Возвращает Y-компоненту текущего вращения объекта, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectAngleY($objID)
    {
    }

    /**
     *Возвращает X-компоненту текущего вращения объекта, преобразованную в углы Эйлера.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return float
     */
    function GetObjectAngleX($objID)
    {
    }

    /**
     *Возвращает текущее альфа-значение цвета этого объекта, заданное SetObjectColor или SetObjectAlpha.
     *
     * @param int $objID Идентификатор объекта для проверки.
     * @return int
     */
    function GetObjectAlpha($objID)
    {
    }

    /**
     *Возвращает имя кости. Если эта команда вызывается с уровня 2, то вы должны удалить возвращенную строку, когда закончите с ней.
     *
     * @param int $objID Идентификатор объекта, содержащего кость для проверки.
     * @param int $boneIndex Индекс кости нужно проверить.
     * @return string
     */
    function GetObjectBoneName($objID, $boneIndex)
    {
    }

    /**
     *Возвращает трение качения для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsRollingFriction($objID)
    {
    }

    /**
     *Возвращает текущее значение реституции для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsRestitution($objID)
    {
    }

    /**
     *Возвращает true, если есть еще один контакт для отчета.
     *
     * @return int
     */
    function GetObject3DPhysicsNextContact()
    {
    }

    /**
     *Возвращает максимальную линейную скорость для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsMaxLinearVelocity($objID)
    {
    }

    /**
     *Возвращает массу объектов
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsMass($objID)
    {
    }

    /**
     *Возвращает маску столкновения объектов. По умолчанию все физические объекты находятся в одной группе и не маскируются. Если вы используете группы столкновений и маски, вы должны использовать их для всех физических объектов.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function GetObject3DPhysicsMask($objID)
    {
    }

    /**
     *Возвращает X-компоненту вектора линейной скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsLinearVelocityZ($objID)
    {
    }

    /**
     *Возвращает X-компоненту вектора линейной скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsLinearVelocityY($objID)
    {
    }

    /**
     *Возвращает X-компоненту вектора линейной скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsLinearVelocityX($objID)
    {
    }

    /**
     *Возвращает линейный порог сна для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsLinearSleepingThreshold($objID)
    {
    }

    /**
     *Возвращает группу столкновений объектов. По умолчанию все физические объекты находятся в одной группе и не маскируются. Если вы используете группы столкновений и маски, вы должны использовать их для всех физических объектов.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function GetObject3DPhysicsGroup($objID)
    {
    }

    /**
     *Возвращает значение линейного демпфирования
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsLinearDamp($objID)
    {
    }

    /**
     *Возвращает трение для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsFriction($objID)
    {
    }

    /**
     *Возвращает true, если объект имел контакт на физическом шаге.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function GetObject3DPhysicsFirstContact($objID)
    {
    }

    /**
     *Возвращает положение контакта Y
     *
     * @return float
     */
    function GetObject3DPhysicsContactY()
    {
    }

    /**
     *Возвращает X положение контакта
     *
     * @return float
     */
    function GetObject3DPhysicsContactX()
    {
    }

    /**
     *Возвращает true, если есть контактный вектор, и заполняет вектор outPosVec3. Сначала создайте вектор с помощью CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен результатами.
     *
     * @param int $outPosVec3 Идентификатор вектора, который будет заполнен результатами.
     * @return int
     */
    function GetObject3DPhysicsContactVector($outPosVec3)
    {
    }

    /**
     *Возвращает идентификатор объекта второго объекта в контакте.
     *
     * @return int
     */
    function GetObject3DPhysicsContactObjectB()
    {
    }

    /**
     *Верните Z-компоненту вектора угловой скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsAngularVelocityZ($objID)
    {
    }

    /**
     *Верните Y-компоненту вектора угловой скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsAngularVelocityY($objID)
    {
    }

    /**
     *Верните X-компоненту вектора угловой скорости.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsAngularVelocityX($objID)
    {
    }

    /**
     *Возвращает порог углового сна для физического объекта.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsAngularSleepingThreshold($objID)
    {
    }

    /**
     *Возвращает значение углового демпфирования
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function GetObject3DPhysicsAngularDamp($objID)
    {
    }

    /**
     *Возвращает количество ядер логического процессора на устройстве
     *
     * @return int
     */
    function GetNumProcessors()
    {
    }

    /**
     *Возвращает количество камер, доступных для SetDeviceCameraToImage. В настоящее время работает только на Android, iOS и Windows
     *
     * @return int
     */
    function GetNumDeviceCameras()
    {
    }

    /**
     *Возвращает имя следующей папки, найденной в текущей папке, которая задается с помощью SetFolder. GetFirstFolder должен быть вызван первым, чтобы это сработало, любой вызов SetFolder или OpenToWrite потребует повторного запуска с GetFirstFolder. Возвращает пустую строку, если в текущей папке больше нет папок. Не включает в себя . или ..
     *
     * @return string
     */
    function GetNextFolder()
    {
    }

    /**
     *Возвращает имя следующего файла, найденного в текущей папке, который задается с помощью SetFolder. GetFirstFile должен быть вызван первым, чтобы это сработало, любой вызов SetFolder или OpenToWrite потребует повторного запуска с GetFirstFile. Возвращает пустую строку, если в текущей папке больше нет файлов.
     *
     * @return string
     */
    function GetNextFile()
    {
    }

    /**
     *Возвращает Z положение контакта
     *
     * @return float
     */
    function GetObject3DPhysicsContactZ()
    {
    }

    /**
     *Возвращает 1 если контакт существует, вы можете получить спрайты, вовлеченные в этот контакт, используя GetContactSpriteID1 и GetContactSpriteID2, вы можете перейти к следующему контакту, снова вызвав эту команду, когда контактов больше не будет, она вернет 0.
     *
     * @return int
     */
    function GetNextContact()
    {
    }

    /**
     *Возвращает IP-адрес, используемый сервером. Эта команда работает только на клиентах, так как сервер может получить свой собственный IP-адрес с помощью GetDeviceIP и GetDeviceIPv6.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return string
     */
    function GetNetworkServerIP($iNetID)
    {
    }

    /**
     *Возвращает идентификатор клиента клиента хоста. Это полезно, если вы используете сервер для обработки переменных настройки игры, таких как размер доски, длина игры и т. Д., поскольку только хост - клиент должен иметь копию этих переменных.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function GetNetworkServerID($iNetID)
    {
    }

    /**
     *Возвращает количество клиентов, подключенных к указанной сети. Хост считается клиентом, как и локальный клиент. Это означает, что в подключенной сети должно быть не менее 2 клиентов. Хост, ожидающий клиентов, возвращает 1, если он находится сам по себе. Клиент, пытающийся подключиться, возвращает 0 до тех пор, пока он не подключится и хост не примет клиента, предоставив ему уникальный идентификатор, затем он должен вернуть 2.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function GetNetworkNumClients($iNetID)
    {
    }

    /**
     *Возвращает идентификатор клиента следующего клиента в списке клиентов. Используйте эту функцию, чтобы продолжить просмотр списка клиентов, запущенных с помощью GetNetworkFirstClient. Очень важно, чтобы эта команда вызывалась до тех пор, пока она не вернет 0, так как фоновый сетевой код не может продолжаться до тех пор, пока он не узнает, что вы закончили работу со списком клиентов. Локальный клиент также будет возвращен в какой-то момент, который можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkMyClientID. Хост-клиент также будет возвращен в какой-то момент, который можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkServerID.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function GetNetworkNextClient($iNetID)
    {
    }

    /**
     *Каждому клиенту при подключении хост присваивает уникальный идентификатор. Эта функция возвращает идентификатор, который вам был назначен. Хост также присваивает себе идентификатор, который можно найти с помощью GetNetworkServerID.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function GetNetworkMyClientID($iNetID)
    {
    }

    /**
     *Получает одну строку из сообщения и перемещает указатель сообщения на следующий элемент сообщения. Сообщения должны создаваться и считываться в соответствии с известными форматами, например string, int, string, поскольку у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное целое число для указания идентификатора типа сообщения, который можно использовать для идентификации формата сообщения.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return string
     */
    function GetNetworkMessageString($iMsgID)
    {
    }

    /**
     *Получает одно целое число из сообщения и перемещает указатель сообщения к следующему элементу сообщения. Сообщения должны создаваться и считываться в соответствии с известными форматами, например string, int, string, поскольку у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное целое число для указания идентификатора типа сообщения, который можно использовать для идентификации формата сообщения.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return int
     */
    function GetNetworkMessageInteger($iMsgID)
    {
    }

    /**
     *Возвращает IP-адрес, отправивший это сообщение. Только применительно к сообщениям, полученным от UDP и широковещательных прослушивателей, сетевые сообщения будут возвращать пустую строку для этой функции. Он также вернет пустую строку для сообщений, созданных с помощью CreateNetworkMessage. Это может быть адрес IPv4 или IPv6.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return string
     */
    function GetNetworkMessageFromIP($iMsgID)
    {
    }

    /**
     *Возвращает идентификатор клиента, отправившего это сообщение. Применимо только к сообщениям, полученным из сетей, широковещательный прослушиватель и UDP-сообщения вернут 0 для этой функции. Он также вернет 0 для сообщений, созданных с помощью CreateNetworkMessage.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return int
     */
    function GetNetworkMessageFromClient($iMsgID)
    {
    }

    /**
     *Получает один байт без знака из сообщения и перемещает указатель сообщения на следующий элемент сообщения. Сообщения должны создаваться и считываться в соответствии с известными форматами, например string, int, string, поскольку у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное целое число для указания идентификатора типа сообщения, который можно использовать для идентификации формата сообщения.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return int
     */
    function GetNetworkMessageByte($iMsgID)
    {
    }

    /**
     *Проверьте сеть на наличие любых сообщений, отправленных этому клиенту. Если ничего не найдено, он возвращает 0. Если сообщение найдено, оно возвращает идентификатор сообщения, который вы можете использовать для его чтения. Вы должны удалить сообщение с помощью DeleteNetworkMessage, когда закончите его читать. Вы должны продолжать вызывать GetNetworkMessage до тех пор, пока он не вернет 0, чтобы убедиться, что вы получили все сообщения. Вы можете использовать команды чтения сообщений, чтобы узнать, какой идентификатор клиента отправил сообщение.
     *
     * @param int $iNetID Идентификатор сети для проверки сообщений.
     * @return int
     */
    function GetNetworkMessage($iNetID)
    {
    }

    /**
     *Возвращает 1, если сеть существует с заданным идентификатором, в противном случае она возвращает 0.
     *
     * @param int $iNetID Идентификатор сети для проверки
     * @return int
     */
    function GetNetworkExists($iNetID)
    {
    }

    /**
     *Возвращает идентификатор клиента первого клиента в списке клиентов. Используйте эту функцию, чтобы начать просмотр списка клиентов и продолжить работу с GetNetworkNextClient до тех пор, пока он не вернет 0. Очень важно, чтобы после вызова этой команды GetNetworkNextClient вызывался до тех пор, пока не вернет 0, так как фоновый сетевой код не может продолжать работу до тех пор, пока не будет известно, что вы закончили работу со списком клиентов. Локальный клиент также будет возвращен в какой-то момент, который можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkMyClientID. Хост-клиент также будет возвращен в какой-то момент, который можно обнаружить, сравнив возвращаемый идентификатор с GetNetworkServerID.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @return int
     */
    function GetNetworkFirstClient($iNetID)
    {
    }

    /**
     *Считывает один из локальных слотов данных, назначенных клиентскому набору, с помощью SetNetworkClientUserData.
     *
     * @param int $iNetID Идентификатор сети, из которой будет получено значение.
     * @param int $client Идентификатор клиента в сети, от которого требуется получить значение.
     * @param int $index Индекс (0-4) считываемого слота данных.
     * @return int
     */
    function GetNetworkClientUserData($iNetID, $client, $index)
    {
    }

    /**
     *Возвращает пинг между данным клиентом и хостом. Чтобы получить общее время передачи данных от одного клиента к другому, вы должны сложить два времени пинга для обоих клиентов вместе, поскольку все данные проходят через хост. Если вы используете идентификатор клиента хоста, он вернет 0, так как хост не имеет пинга для себя. Возвращаемое значение выражается в секундах как значение с плавающей запятой.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client Идентификатор клиента для проверки.
     * @return float
     */
    function GetNetworkClientPing($iNetID, $client)
    {
    }

    /**
     *Возвращает исходный порт, который был использован этим сообщением. Только применительно к сообщениям, полученным от UDP и широковещательных прослушивателей, сетевые сообщения вернут 0 для этой функции. Он также вернет 0 для сообщений, созданных с помощью CreateNetworkMessage. Это будет в диапазоне от 0 до 65535.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return int
     */
    function GetNetworkMessageFromPort($iMsgID)
    {
    }

    /**
     *Возвращает IP-адрес, используемый указанным клиентом. Эта команда работает только на сервере, так как клиенты не подключаются непосредственно друг к другу
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client идентификатор клиента для проверки.
     * @return string
     */
    function GetNetworkClientIP($iNetID, $client)
    {
    }

    /**
     *Получает один поплавок из сообщения и перемещает указатель сообщения к следующему элементу сообщения. Сообщения должны создаваться и считываться в соответствии с известными форматами, например string, int, string, поскольку у получателя нет непосредственного способа узнать формат сообщения. Вы можете использовать начальное целое число для указания идентификатора типа сообщения, который можно использовать для идентификации формата сообщения.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return float
     */
    function GetNetworkMessageFloat($iMsgID)
    {
    }

    /**
     *Получает копию переменной float удаленного клиента по имени. Также может быть использован для собственных переменных клиента, если ClientID равен GetNetworkMyClientID. Если переменная была установлена как переменная сброса, она вернется к 0 после чтения, это не повлияет на способность других клиентов считывать исходное значение. Каждый из них сбросит свою собственную копию. Если указанный клиент не установил переменную с заданным именем, то возвращается значение 0.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client Идентификатор клиента для проверки.
     * @param string $name Имя возвращаемой переменной.
     * @return float
     */
    function GetNetworkClientFloat($iNetID, $client, $name)
    {
    }

    /**
     *Проверяет, отключился ли указанный клиент. Отключенные клиенты не удаляются автоматически из списка клиентов, что позволяет вам правильно обрабатывать их очистку. Как только вы справитесь с этим клиентом, вы должны удалить его из списка клиентов, вызвав DeleteNetworkClient. Клиент может сохраняться в течение некоторого времени, пока фоновый сетевой код не начнет фактически удалять его, поэтому будьте готовы к тому, что этот клиент будет болтаться вокруг в течение нескольких кадров, объявляя, что он отключен, и убедитесь, что вы очистите его только один раз. Вы можете обнаружить это, установив одно из значений SetNetworkClientUserData, чтобы уведомить себя о том, что оно было обработано.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client идентификатор клиента для проверки.
     * @return int
     */
    function GetNetworkClientDisconnected($iNetID, $client)
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет встроенное устройство NFC, в противном случае возвращается 0. Эта команда еще не функционирует.
     *
     * @return int
     */
    function GetNFCExists()
    {
    }

    /**
     *Возвращает текущую позицию в музыкальном файле, между 0 для начала файла и GetMusicDurationOGG для конца файла.
     *
     * @param int $musicID Идентификатор музыкального файла для проверки
     * @return float
     */
    function GetMusicPositionOGG($musicID)
    {
    }

    /**
     *Возвращает количество секунд воспроизведения текущего музыкального файла. Если в данный момент музыка не воспроизводится, эта команда вернет 0.
     *
     * @return float
     */
    function GetMusicPosition()
    {
    }

    /**
     *Возвращает имя, которое клиент использовал для идентификации себя при подключении к хосту.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client идентификатор клиента для проверки.
     * @return string
     */
    function GetNetworkClientName($iNetID, $client)
    {
    }

    /**
     *Возвращает 1, если музыкальный файл воспроизводится в данный момент, и 0 в противном случае. Это будет продолжать возвращать 1, пока файл находится на паузе.
     *
     * @param int $musicID Идентификатор музыкального файла для проверки
     * @return int
     */
    function GetMusicPlayingOGG($musicID)
    {
    }

    /**
     *Возвращает идентификатор воспроизводимого в данный момент музыкального файла. Если музыка не воспроизводится, она возвращает 0.
     *
     * @return int
     */
    function GetMusicPlaying()
    {
    }

    /**
     *Получает копию целочисленной переменной удаленного клиента по имени. Также может быть использован для собственных переменных клиента, если ClientID равен GetNetworkMyClientID. Если переменная была установлена как переменная сброса, она вернется к 0 после чтения, это не повлияет на способность других клиентов считывать исходное значение. Каждый из них сбросит свою собственную копию. Если указанный клиент не установил переменную с заданным именем, то возвращается значение 0.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client Идентификатор клиента для проверки.
     * @param string $name Имя возвращаемой переменной.
     * @return int
     */
    function GetNetworkClientInteger($iNetID, $client, $name)
    {
    }

    /**
     *Возвращает количество раз, когда этот музыкальный файл был зациклен.
     *
     * @param int $musicID Идентификатор музыкального файла для проверки
     * @return int
     */
    function GetMusicLoopCountOGG($musicID)
    {
    }

    /**
     *Возвращает 1, если музыкальный файл существует с текущим идентификатором, и 0, если нет.
     *
     * @param int $iID Удостоверение личности для проверки.
     * @return int
     */
    function GetMusicExists($iID)
    {
    }

    /**
     *Возвращает 1, если музыкальный файл существует с указанным идентификатором, и 0 в противном случае.
     *
     * @param int $musicID Удостоверение личности для проверки
     * @return int
     */
    function GetMusicExistsOGG($musicID)
    {
    }

    /**
     *Возвращает длительность музыкального файла в секундах в виде значения с плавающей запятой
     *
     * @param int $musicID Идентификатор музыкального файла для проверки
     * @return float
     */
    function GetMusicDurationOGG($musicID)
    {
    }

    /**
     *Возвращает 1, если текущее устройство поддерживает мультитач, и 0, если нет.
     *
     * @return int
     */
    function GetMultiTouchExists()
    {
    }

    /**
     *Возвращает 1, если на текущем устройстве есть мышь, и 0, если нет.
     *
     * @return int
     */
    function GetMouseExists()
    {
    }

    /**
     *Возвращает месяц заданного значения времени unix (от 1 до 12). Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetMonthFromUnix($unixtime)
    {
    }

    /**
     *Возвращает минуты заданного значения времени unix (от 0 до 59). Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetMinutesFromUnix($unixtime)
    {
    }

    /**
     *Обеспечивает быстрый способ получить Z-позицию указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершины и расположения значений позиции.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexZ($memID, $vertexIndex)
    {
    }

    /**
     *Обеспечивает быстрый способ получения Y-позиции указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершины и расположения значений позиции.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexY($memID, $vertexIndex)
    {
    }

    /**
     *Обеспечивает быстрый способ получения X-позиции указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершины и расположения значений позиции.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexX($memID, $vertexIndex)
    {
    }

    /**
     *Обеспечивает быстрый способ получения значения V указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений UV.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexV($memID, $vertexIndex)
    {
    }

    /**
     *Обеспечивает быстрый способ получения значения U указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений UV.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexU($memID, $vertexIndex)
    {
    }

    /**
     *Предоставляет быстрый способ получить красное значение указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений цвета.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return int
     */
    function GetMeshMemblockVertexRed($memID, $vertexIndex)
    {
    }

    /**
     *Возвращает количество секунд, которое потребуется для воспроизведения данного музыкального файла от начала до конца. Для работы этой команды не должно быть никаких звуков, или данный идентификатор должен быть дорожкой, воспроизводимой в данный момент. Например, если вы попытаетесь получить продолжительность ID 2 и ID 1 в данный момент воспроизводится, то это не удастся, но если ID 2 в данный момент воспроизводится, то это будет успешно. Для файлов с переменной скоростью передачи битов эта команда вернет аппроксимацию.
     *
     * @param int $iID Идентификатор музыки для проверки.
     * @return float
     */
    function GetMusicDuration($iID)
    {
    }

    /**
     *Обеспечивает быстрый способ получить Z-компоненту нормали указанной вершины из memblock. Он использует атрибутивные данные из начала мемблока для определения смещения вершин и расположения нормальных значений.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexNormalZ($memID, $vertexIndex)
    {
    }

    /**
     *Обеспечивает быстрый способ получения Y-компонента нормали указанной вершины из memblock. Он использует атрибутивные данные из начала мемблока для определения смещения вершин и расположения нормальных значений.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexNormalY($memID, $vertexIndex)
    {
    }

    /**
     *Обеспечивает быстрый способ получения X-компонента нормали указанной вершины из memblock. Он использует атрибутивные данные из начала мемблока для определения смещения вершин и расположения нормальных значений.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return float
     */
    function GetMeshMemblockVertexNormalX($memID, $vertexIndex)
    {
    }

    /**
     *Предоставляет быстрый способ получить зеленое значение указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений цвета.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return int
     */
    function GetMeshMemblockVertexGreen($memID, $vertexIndex)
    {
    }

    /**
     *Обеспечивает быстрый способ получения альфа - значения указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений цвета.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return int
     */
    function GetMeshMemblockVertexAlpha($memID, $vertexIndex)
    {
    }

    /**
     *Получите количество миллисекунд с момента запуска приложения. Вызов этой команды внутренне вызовет системный вызов, чтобы получить количество прошедшего времени, поэтому он может меняться каждый раз, когда вы его вызываете.
     *
     * @return int
     */
    function GetMilliseconds()
    {
    }

    /**
     *Обеспечивает быстрый способ получения синего значения указанной вершины из memblock. Он использует атрибутивные данные из начала memblock для определения смещения вершин и расположения значений цвета.
     *
     * @param int $memID Идентификатор мемблока для проверки
     * @param int $vertexIndex Индекс вершины для проверки
     * @return int
     */
    function GetMeshMemblockVertexBlue($memID, $vertexIndex)
    {
    }

    /**
     *Возвращает размер данного memblock в байтах.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @return int
     */
    function GetMemblockSize($memID)
    {
    }

    /**
     *Возвращает короткое (2 байта) значение при заданном смещении. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 2, поскольку чтение коротких значений, не выровненных по 2-байтовым границам, влечет за собой снижение производительности оборудования. Короткие значения хранятся в формате little endian, поэтому запись короткого числа 23 со смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, а байт со смещением 1 как 0. Возвращаемое значение будет коротким со знаком между -32768 и 32767.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @return int
     */
    function GetMemblockShort($memID, $offset)
    {
    }

    /**
     *Хэширует memblock с помощью SHA1 и возвращает полученный хэш
     *
     * @param int $memID Идентификатор мемблока для хэширования
     * @return string
     */
    function GetMemblockSHA1($memID)
    {
    }

    /**
     *Возвращает значение int (4 байта) при заданном смещении. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку чтение целочисленных значений, не выровненных по 4-байтовым границам, влечет за собой снижение производительности оборудования. Значения Int хранятся в формате little endian, поэтому запись int 23 со смещением 0, а затем чтение его обратно в байтах вернет байт со смещением 0 как 23, байт со смещением 1 как 0, байт со смещением 2 как 0 и байт со смещением 3 как 0. Возвращаемое значение будет целым числом со знаком от -2,147,483,648 до 2,147,483,647.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @return int
     */
    function GetMemblockInt($memID, $offset)
    {
    }

    /**
     *Возвращает 1, если существует memblock с заданным идентификатором, и 0, если нет.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @return int
     */
    function GetMemblockExists($memID)
    {
    }

    /**
     *Возвращает значение байта с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Возвращаемое значение будет байтом со знаком от -128 до 127.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @return int
     */
    function GetMemblockByteSigned($memID, $offset)
    {
    }

    /**
     *Возвращает значение байта с заданным смещением. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Возвращаемое значение будет байтом без знака между 0 и 255.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @return int
     */
    function GetMemblockByte($memID, $offset)
    {
    }

    /**
     *Возвращает заданное количество байтов с заданным смещением и интерпретирует их как строку. Смещение плюс длина должны быть меньше размера memblock. Первое значение имеет смещение 0. Строка будет завершаться null, даже если в memblock не будет найден нулевой терминатор. Если нулевой терминатор возникает до достижения длины, то все байты все равно будут считаны, но только символы до первого нулевого терминатора будут доступны в AGK. Если вы используете уровень 2, вы должны удалить указатель, возвращаемый этой функцией.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @param int $length Количество байтов для чтения
     * @return string
     */
    function GetMemblockString($memID, $offset, $length)
    {
    }

    /**
     *Получает максимальную высоту, которую может иметь окно вашего приложения. Для платформ, поддерживающих оконный режим, таких как Windows и Mac, ваше приложение может достичь такого размера только в полноэкранном режиме, поскольку оконный режим имеет границу вокруг вашего приложения. Для приложений HTML5 это вернет размер текущего HTML-документа и не гарантирует работу, если приложение HTML5 работает в полноэкранном режиме. Лучшим названием для этой команды было бы GetMaxWindowHeight, но теперь она высечена в камне.
     *
     * @return int
     */
    function GetMaxDeviceHeight()
    {
    }

    /**
     *Возвращает количество спрайтов, которые внутренний менеджер спрайтов должен был отсортировать по их правильным позициям с момента последнего кадра. Спрайты нужно использовать только в том случае, если они меняют глубину или текстуру во время текущего кадра.
     *
     * @return int
     */
    function GetManagedSpriteSortedCount()
    {
    }

    /**
     *Хэширует memblock с помощью SHA256 и возвращает полученный хэш
     *
     * @param int $memID Идентификатор мемблока для хэширования
     * @return string
     */
    function GetMemblockSHA256($memID)
    {
    }

    /**
     *Возвращает количество спрайтов, которые фактически были отправлены для рендеринга в последний кадр графического процессора, и чем больше их будет нарисовано, тем медленнее будет работать приложение.
     *
     * @return int
     */
    function GetManagedSpriteDrawnCount()
    {
    }

    /**
     *Возвращает количество спрайтов, управляемых внутренним менеджером спрайтов. Он отвечает за обновление анимации спрайтов и вычисление того, какие спрайты видны и должны быть отправлены для рисования. Он также сортирует спрайты, когда это необходимо для правильного рисования прозрачности.  До тех пор, пока не будет отправлено слишком много спрайтов для рисования, менеджер спрайтов должен быть в состоянии обрабатывать несколько сотен спрайтов.
     *
     * @return int
     */
    function GetManagedSpriteCount()
    {
    }

    /**
     *Возвращает значение float (4 байта) при заданном смещении. Смещение должно быть меньше размера мемблока. Первое значение имеет смещение 0. Для достижения наилучшей производительности смещение должно быть кратно 4, поскольку чтение значений float, не выровненных по 4-байтовым границам, влечет за собой снижение производительности оборудования. Значения Float хранятся в формате IEEE 754, поэтому запись float и последующее чтение его обратно в байтах вернут различные компоненты формата float.
     *
     * @param int $memID Идентификатор мемблока для проверки.
     * @param int $offset Смещение от начала мемблока возвращаемого значения между 0 и размером.
     * @return float
     */
    function GetMemblockFloat($memID, $offset)
    {
    }

    /**
     *Возвращает количество вызовов OpenGL draw, используемых для рисования всех управляемых спрайтов. Как правило, чем меньше это число, тем лучше производительность. AGK пытается паковать спрайты в как можно меньшее количество вызовов рисования, он делает это, ища спрайты с одинаковой текстурой и рисуя их одновременно.
     *
     * @return int
     */
    function GetManagedSpriteDrawCalls()
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет датчик магнетизма, который в настоящее время поддерживается AGK, и 0, если нет.
     *
     * @return int
     */
    function GetMagneticSensorExists()
    {
    }

    /**
     *Возвращает дату и время отображения указанного уведомления. Возвращаемое время будет в формате unix timestamp, который измеряется количеством секунд с 1 января 1970 года. Если по указанному идентификатору уведомления не существует, то возвращается 0
     *
     * @param int $iID ИДЕНТИФИКАТОР уведомления для проверки
     * @return int
     */
    function GetLocalNotificationTime($iID)
    {
    }

    /**
     *Возвращает сообщение, которое будет отображаться указанное уведомление. Если по указанному идентификатору уведомления не существует, то будет возвращена пустая строка
     *
     * @param int $iID ИДЕНТИФИКАТОР уведомления для проверки
     * @return string
     */
    function GetLocalNotificationMessage($iID)
    {
    }

    /**
     *Возвращает 1, если уведомление с этим идентификатором ожидает отображения, в противном случае 0. Уведомления обновляются каждые 5 секунд, так что это может продолжать возвращать 1 вскоре после того, как уведомление сработало.
     *
     * @param int $iID ИДЕНТИФИКАТОР уведомления для проверки
     * @return int
     */
    function GetLocalNotificationExists($iID)
    {
    }

    /**
     *Получает максимальную ширину окна вашего приложения. Для платформ, поддерживающих оконный режим, таких как Windows и Mac, ваше приложение может достичь такого размера только в полноэкранном режиме, поскольку оконный режим имеет границу вокруг вашего приложения. Для приложений HTML5 это вернет размер текущего HTML-документа и не гарантирует работу, если приложение HTML5 работает в полноэкранном режиме. Лучшим названием для этой команды было бы GetMaxWindowWidth, но теперь она высечена в камне.
     *
     * @return int
     */
    function GetMaxDeviceWidth()
    {
    }

    /**
     *Возвращает количество изображений, загруженных в данный момент в приложение.
     *
     * @return int
     */
    function GetLoadedImages()
    {
    }

    /**
     *Возвращает 1, если данный год является високосным, в противном случае 0.
     *
     * @param int $year Год, чтобы проверить.
     * @return int
     */
    function GetLeapYear($year)
    {
    }

    /**
     *Возвращает значение unicode последнего ввода символа
     *
     * @return int
     */
    function GetLastChar()
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет полноразмерную клавиатуру, 2, если устройство имеет виртуальную клавиатуру или клавиатуру мобильного телефона, и 0, если клавиатура вообще отсутствует.
     *
     * @return int
     */
    function GetKeyboardExists()
    {
    }

    /**
     *Джойстик AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания ввода в стиле джойстика в диапазоне от -1 до 1. Если к системе подключен физический джойстик, то он будет использоваться,в противном случае,если будет найдена полноразмерная клавиатура,клавиши W, A, S, D будут использоваться в качестве четырех направлений для джойстика. Если ни того, ни другого не существует, то на экране будет создан виртуальный джойстик, которым можно управлять либо с помощью сенсорного экрана, либо с помощью мыши. Используемый виртуальный джойстик будет иметь индекс 1, если он уже существует, его значения будут введены в эту эмулируемую команду джойстика. Вы можете расположить этот виртуальный джойстик в выбранном вами положении на экране с помощью SetJoystickScreenPosition. Каждая платформа гарантированно имеет метод генерации значения AGK - Y.
     *
     * @return float
     */
    function GetJoystickY()
    {
    }

    /**
     *Джойстик AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания ввода в стиле джойстика в диапазоне от -1 до 1. Если к системе подключен физический джойстик, то он будет использоваться,в противном случае,если будет найдена полноразмерная клавиатура,клавиши W, A, S, D будут использоваться в качестве четырех направлений для джойстика. Если ни того, ни другого не существует, то на экране будет создан виртуальный джойстик, которым можно управлять либо с помощью сенсорного экрана, либо с помощью мыши. Используемый виртуальный джойстик будет иметь индекс 1, если он уже существует, его значения будут введены в эту эмулируемую команду джойстика. Вы можете расположить этот виртуальный джойстик в выбранном вами положении на экране с помощью SetJoystickScreenPosition. Каждая платформа гарантированно имеет метод генерации значения AGK джойстика X.
     *
     * @return float
     */
    function GetJoystickX()
    {
    }

    /**
     *Возвращает величину крутящего момента, приложенного к соединению на последнем временном шаге. Вы можете использовать это для обнаружения больших сил и удаления соединения, чтобы имитировать разрыв. Крутящий момент применяется к соединениям, которые вращаются, таким как вращающиеся соединения.
     *
     * @param int $iJointIndex Идентификатор сустава для проверки.
     * @return float
     */
    function GetJointReactionTorque($iJointIndex)
    {
    }

    /**
     *Возвращает величину силы, приложенной к соединению в направлении Y на последнем временном шаге. Вы можете использовать это для обнаружения больших сил и удаления соединения, чтобы имитировать разрыв.
     *
     * @param int $iJointIndex Идентификатор сустава для проверки.
     * @return float
     */
    function GetJointReactionForceY($iJointIndex)
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет датчик окружающего света, который в настоящее время поддерживается AGK, и 0, если нет.
     *
     * @return int
     */
    function GetLightSensorExists()
    {
    }

    /**
     *Возвращает величину силы, приложенной к соединению в направлении X на последнем временном шаге. Вы можете использовать это для обнаружения больших сил и удаления соединения, чтобы имитировать разрыв.
     *
     * @param int $iJointIndex Идентификатор сустава для проверки.
     * @return float
     */
    function GetJointReactionForceX($iJointIndex)
    {
    }

    /**
     *Возвращает строку, описывающую последнюю возникшую ошибку. Эта функция будет продолжать возвращать ту же строку до тех пор, пока не возникнет другая ошибка. Это не включает в себя предупреждения.
     *
     * @return string
     */
    function GetLastError()
    {
    }

    /**
     *Возвращает 1, если указанное соединение все еще существует, и 0 в противном случае. Стыки могут быть удалены системой.
     *
     * @param int $iJointIndex Идентификатор сустава для проверки.
     * @return int
     */
    function GetJointExists($iJointIndex)
    {
    }

    /**
     *Возвращает текущее состояние попытки активации содержимого. Значение 0 указывает на то, что процесс продолжается, в то время как 1 подтверждает, что процесс завершен. В настоящее время эта команда поддерживается только на iOS и Android.
     *
     * @return int
     */
    function GetInAppPurchaseState()
    {
    }

    /**
     *Возвращает 1, если устройство подключено к Интернету, и 0, если нет.
     *
     * @return int
     */
    function GetInternetState()
    {
    }

    /**
     *Возвращает подпись для последней покупки данного товара, это можно проверить по вашему открытому ключу, чтобы подтвердить, что покупка была действительной. Рекомендуется передать эту подпись серверу для выполнения проверки, чтобы ее нельзя было обойти.
     *
     * @param int $iID Например, ваш первый идентификатор продукта равен 0, ваш второй-1 и т. Д.
     * @return string
     */
    function GetInAppPurchaseSignature($iID)
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет по крайней мере один физический джойстик, доступный в качестве метода ввода. 0, если у него нет физических джойстиков джойстика. Если вы обнаружите, что платформа не имеет физических джойстиков, вы можете создать виртуальные джойстики, которые появляются на экране для использования сенсорными экранами или мышами с помощью AddVirtualJoystick. GetJoystickExists не учитывает виртуальные джойстики в своей проверке. На некоторых платформах обнаружение джойстика выполняется в фоновом потоке, который может не завершиться в течение некоторого времени после запуска вашего приложения, чтобы дождаться завершения потока, используйте CompleteRawJoystickDetection, чтобы убедиться, что все подключенные джойстики были найдены.
     *
     * @return int
     */
    function GetJoystickExists()
    {
    }

    /**
     *Возвращает текущую цену указанного в приложении продукта покупки в местной валюте, это будет строка с включенным символом валюты, где это возможно. После вызова InAppPurchaseSetup может потребоваться несколько секунд, чтобы эти данные стали доступными, поэтому, если вы получите пустую строку, повторите попытку позже. При вызове этого метода из уровня 2 вы должны удалить возвращаемую строку, когда закончите с ней.
     *
     * @param int $iID этот идентификатор соответствует идентификаторам продуктов которые были добавлены например ваш первый продукт
     * @return string
     */
    function GetInAppPurchaseLocalPrice($iID)
    {
    }

    /**
     *Возвращает описание для указанного продукта, как определено текущим магазином платформы. После вызова InAppPurchaseSetup может потребоваться несколько секунд, чтобы эти данные стали доступными, поэтому, если вы получите пустую строку, повторите попытку позже. При вызове этого метода из уровня 2 вы должны удалить возвращаемую строку, когда закончите с ней.
     *
     * @param int $iID этот идентификатор соответствует идентификаторам продуктов, которые были добавлены, например, ваш первый продукт
     * @return string
     */
    function GetInAppPurchaseDescription($iID)
    {
    }

    /**
     *Возвращает 1, если дополнительный контент был приобретен и поэтому доступен. Возвращает 0, если содержимое недоступно. В настоящее время эта команда поддерживается только на iOS и Android.
     *
     * @param int $iID этот идентификатор соответствует идентификаторам продуктов которые были добавлены например ваш первый продукт
     * @return int
     */
    function GetInAppPurchaseAvailable($iID)
    {
    }

    /**
     *Возвращает ширину изображения в пикселях. Даже если эта команда возвращает float, значение гарантированно будет целым числом.
     *
     * @param int $iImageIndex Идентификатор извлекаемого изображения.
     * @return float
     */
    function GetImageWidth($iImageIndex)
    {
    }

    /**
     *Возвращает объем памяти в мегабайтах, используемый в данный момент всеми загруженными изображениями (включая изображения, используемые шрифтами). Это может помочь отследить проблемы с памятью GPU, которые могут привести к сбою, если она закончится. Каждое загруженное изображение будет помещено в память графического процессора, даже если вы его не используете, поэтому загрузка слишком большого количества больших изображений может израсходовать всю память.
     *
     * @return float
     */
    function GetImageMemoryUsage()
    {
    }

    /**
     *Возвращает 1, если изображение существует, и 0, если нет.
     *
     * @param int $iImageIndex Идентификатор изображения для проверки
     * @return int
     */
    function GetImageExists($iImageIndex)
    {
    }

    /**
     *Возвращает часы заданного значения времени unix (от 0 до 23). Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetHoursFromUnix($unixtime)
    {
    }

    /**
     *Возвращает код состояния, который был возвращен с сервера в ответе. Вы должны дождаться, пока GetHTTPResponseReady вернет ненулевое значение, прежде чем проверять эту команду, иначе она вернет 0. Обычно код состояния равен 200, когда запрос был успешным
     *
     * @param int $iHTTP Идентификатор соединения для проверки.
     * @return int
     */
    function GetHTTPStatusCode($iHTTP)
    {
    }

    /**
     *Открывает файл изображения для извлечения значений ширины и высоты, а затем немедленно закрывает файл. Это намного быстрее, чем загрузка всего изображения. Это может быть полезно при использовании LoadImageResized, чтобы знать, насколько масштабировать изображение перед его загрузкой. И ширина, и высота будут возвращены в одном целочисленном значении, верхние 16 бит будут шириной, а нижние 16 бит-высотой. Вы можете извлечь эти значения в Tier 1, выполнив width = result >> 16 height = result && 0xFFFF
     *
     * @param string $filename Имя файла изображения для проверки
     * @return int
     */
    function GetImageSizeFromFile($filename)
    {
    }

    /**
     *Возвращает имя файла, используемого для загрузки этого образа. В tier 2 возвращаемая строка должна быть удалена, когда вы закончите с ней.
     *
     * @param int $imageID Идентификатор изображения для проверки.
     * @return string
     */
    function GetImageFilename($imageID)
    {
    }

    /**
     *Возвращает высоту изображения в пикселях. Даже если эта команда возвращает float, значение гарантированно будет целым числом.
     *
     * @param int $iImageIndex Идентификатор извлекаемого изображения.
     * @return float
     */
    function GetImageHeight($iImageIndex)
    {
    }

    /**
     *Возвращает 1, если запрос, ранее отправленный с помощью SendHTTPRequestASync, завершен. Вы можете получить ответ с помощью GetHTTPResponse. Возвращает 0, если запрос все еще выполняется, или -1, если запрос не удался.
     *
     * @param int $iHTTP Идентификатор соединения для проверки.
     * @return int
     */
    function GetHTTPResponseReady($iHTTP)
    {
    }

    /**
     *Возвращает 1, если загрузка файла, ранее начатая с помощью GetHTTPFile, завершена, в противном случае-0. Даже если это возвращает 1, чтобы сказать, что загрузка завершена, возможно, она не удалась, проверьте GetHTTPResponseReady на наличие отрицательных значений, прежде чем предполагать, что загрузка прошла успешно.
     *
     * @param int $iHTTP Идентификатор соединения для проверки.
     * @return int
     */
    function GetHTTPFileComplete($iHTTP)
    {
    }

    /**
     *Захватывает часть backbuffer и создает из нее новое изображение. Значения положения и размера должны быть указаны в координатах экрана. Возвращает идентификатор нового изображения, он должен быть удален, когда вы закончите с ним. Чтобы эффективно использовать эту команду, вы должны знать, как AGK обращается к заднему буферу. При вызове синхронизации AGK обновляет позиции всех объектов с помощью Update, затем рисует их все в задний буфер с помощью Render, не очищая его, а затем выводит задний буфер на экран с помощью Swap. Затем он очищает задний буфер и возвращается к вашему коду, так что если бы вы вызвали getImage сразу после синхронизации, то получили бы пустое изображение, заполненное текущим чистым цветом. Поэтому, если вы хотите захватить изображение текущей сцены полностью нарисованной, вы должны вызвать Render, а затем getImage, а затем ClearScreen, чтобы очистить задний буфер, чтобы синхронизация не перерисовывала все по полностью нарисованному буферу глубины. Если вы уже используете Update, Render и Swap вместо Sync, то вызовите getImage между Render и Swap. Это также позволяет вам делать такие вещи, как рисовать линии в заднем буфере, получать изображение результата и затем очищать его, чтобы он не влиял на то, что отображается на экране. Вызов getImage-это медленная команда, и не рекомендуется вызывать ее каждый кадр. Обратите внимание, что изображение, полученное этой командой, не гарантированно будет иметь ту же ширину и высоту, что и заданные этой командой, это происходит потому, что изображение создается из части экрана, которая имеет разный размер на разных устройствах. Например, при виртуальном разрешении 480х360 вы получите изображение во весь экран, вызвав эту команду с шириной 480 и высотой 360, но на iPod это даст изображение 480х360 пикселей, в то время как на iPad оно будет около 1024х768 пикселей. Это не должно влиять на то, как вы используете изображение, поскольку применение его к спрайту и установка размера спрайта на тот же 480x360 заставит спрайт заполнить экран в обоих случаях. Это просто означает, что на iPad у вас есть более качественное изображение для игры. Это также относится к командам рисования линий: рисование линии от 0,0 до 100,100, а затем получение изображения от 0,0 до 100,100 приведет к получению изображения диагональной линии на всех устройствах, но устройства с высоким разрешением экрана будут производить изображение более высокого качества, содержащее больше пикселей. Используйте GetImageWidth и GetImageHeight, если вам нужно знать фактический размер изображения, полученного в пикселях.
     *
     * @param int $imageID Номер изображения, которое будет содержать захваченное изображение
     * @param float $x Координата x верхнего левого угла поля для копирования
     * @param float $y Координата y верхнего левого угла поля для копирования
     * @param float $width Ширина коробки для копирования
     * @param float $height Высота коробки для копирования
     * @return void
     */
    function GetImage($imageID, $x, $y, $width, $height)
    {
    }

    /**
     *Захватывает часть backbuffer и создает из нее новое изображение. Значения положения и размера должны быть указаны в координатах экрана. Возвращает идентификатор нового изображения, он должен быть удален, когда вы закончите с ним. Чтобы эффективно использовать эту команду, вы должны знать, как AGK обращается к заднему буферу. При вызове синхронизации AGK обновляет позиции всех объектов с помощью Update, затем рисует их все в задний буфер с помощью Render, не очищая его, а затем выводит задний буфер на экран с помощью Swap. Затем он очищает задний буфер и возвращается к вашему коду, так что если бы вы вызвали getImage сразу после синхронизации, то получили бы пустое изображение, заполненное текущим чистым цветом. Поэтому, если вы хотите захватить изображение текущей сцены полностью нарисованной, вы должны вызвать Render, а затем getImage, а затем ClearScreen, чтобы очистить задний буфер, чтобы синхронизация не перерисовывала все по полностью нарисованному буферу глубины. Если вы уже используете Update, Render и Swap вместо Sync, то вызовите getImage между Render и Swap. Это также позволяет вам делать такие вещи, как рисовать линии в заднем буфере, получать изображение результата и затем очищать его, чтобы он не влиял на то, что отображается на экране. Вызов getImage-это медленная команда, и не рекомендуется вызывать ее каждый кадр. Обратите внимание, что изображение, полученное этой командой, не гарантированно будет иметь ту же ширину и высоту, что и заданные этой командой, это происходит потому, что изображение создается из части экрана, которая имеет разный размер на разных устройствах. Например, при виртуальном разрешении 480х360 вы получите изображение во весь экран, вызвав эту команду с шириной 480 и высотой 360, но на iPod это даст изображение 480х360 пикселей, в то время как на iPad оно будет около 1024х768 пикселей. Это не должно влиять на то, как вы используете изображение, поскольку применение его к спрайту и установка размера спрайта на тот же 480x360 заставит спрайт заполнить экран в обоих случаях. Это просто означает, что на iPad у вас есть более качественное изображение для игры. Это также относится к командам рисования линий: рисование линии от 0,0 до 100,100, а затем получение изображения от 0,0 до 100,100 приведет к получению изображения диагональной линии на всех устройствах, но устройства с высоким разрешением экрана будут производить изображение более высокого качества, содержащее больше пикселей. Используйте GetImageWidth и GetImageHeight, если вам нужно знать фактический размер изображения, полученного в пикселях.
     *
     * @param float $x Координата x верхнего левого угла поля для копирования
     * @param float $y Координата y верхнего левого угла поля для копирования
     * @param float $width Ширина коробки для копирования
     * @param float $height Высота коробки для копирования
     * @return int
     */
    function GetImage($x, $y, $width, $height)
    {
    }

    /**
     *Возвращает ход загрузки файла в виде плавающего значения от 0 до 100. Это не следует полагаться на то, чтобы работать, когда загрузка закончена, и на некоторых платформах может не дать точного представления о ходе загрузки. Используйте GetHTTPFileComplete или GetHTTPResponseReady, чтобы определить, завершена ли загрузка.
     *
     * @param int $iHTTP Идентификатор соединения для проверки.
     * @return float
     */
    function GetHTTPFileProgress($iHTTP)
    {
    }

    /**
     *Загружает HTTP - файл с сервера, указанного в SetHTTPHost, и сохраняет его в указанном месте. Также позволяет отправлять POST-данные на сервер, которые могут включать переменные или файловые данные, например "myvar=5&var2=test". Эта команда немедленно возвращается и продолжает загрузку файла в фоновом режиме. Вы можете проверить ход загрузки с помощью GetHTTPFileProgress и GetHTTPFileComplete. Затем файл будет находиться в указанном вами месте, готовый к использованию с AGK.
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после доменной части URL-адреса.
     * @param string $szLocalFile Место для сохранения в файл, это будет внутри папки записи для текущего устройства.
     * @param string $szPostData Необработанные данные post для отправки на сервер обратите внимание, что & и =
     * @return int
     */
    function GetHTTPFile($iHTTP, $szServerFile, $szLocalFile, $szPostData)
    {
    }

    /**
     *Загружает HTTP - файл с сервера, указанного в SetHTTPHost, и сохраняет его в указанном месте. Также позволяет отправлять POST-данные на сервер, которые могут включать переменные или файловые данные, например "myvar=5&var2=test". Эта команда немедленно возвращается и продолжает загрузку файла в фоновом режиме. Вы можете проверить ход загрузки с помощью GetHTTPFileProgress и GetHTTPFileComplete. Затем файл будет находиться в указанном вами месте, готовый к использованию с AGK.
     *
     * @param int $iHTTP Идентификатор используемого соединения.
     * @param string $szServerFile Файл, который нужно запросить с сервера, включает в себя все, что находится после доменной части URL-адреса.
     * @param string $szLocalFile Место для сохранения в файл, это будет внутри папки записи для текущего устройства.
     * @return int
     */
    function GetHTTPFile($iHTTP, $szServerFile, $szLocalFile)
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет гироскоп, который в настоящее время поддерживается AGK, и 0, если нет.
     *
     * @return int
     */
    function GetGyroSensorExists()
    {
    }

    /**
     *Возвращает уникальный идентификатор игрока, вошедшего в систему в данный момент. Если никто не вошел в систему или платформа не поддерживает команды GameCenter, то это вернет пустую строку. Если вы вызываете эту команду из уровня 2, то возвращаемая строка должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.
     *
     * @return string
     */
    function GetGameCenterPlayerID()
    {
    }

    /**
     *Возвращает отображаемое имя для текущего вошедшего в систему игрока. Если никто не вошел в систему или платформа не поддерживает команды GameCenter, то это вернет пустую строку. Если вы вызываете эту команду из уровня 2, то возвращенная строка должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.
     *
     * @return string
     */
    function GetGameCenterPlayerDisplayName()
    {
    }

    /**
     *Вернет 1, если пользователь вошел в Game Center или Google Play Games, и 0, если нет. Процесс входа в систему асинхронен, поэтому после вызова GameCenterLogin может потребоваться несколько секунд, чтобы эта команда вернула 1. Если пользователь не может войти в систему или GameCenter недоступен, то это вернет -1.
     *
     * @return int
     */
    function GetGameCenterLoggedIn()
    {
    }

    /**
     *Возвращает 1, если текущая платформа поддерживает Game Center или Google Play Games.
     *
     * @return int
     */
    function GetGameCenterExists()
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет GPS-приемник, который в настоящее время поддерживается AGK, и 0, если нет.
     *
     * @return int
     */
    function GetGPSSensorExists()
    {
    }

    /**
     *Возвращает 1, если есть предварительно загруженное и готовое к показу интерстициальное объявление Chartboost, в противном случае 0. Если это так, вы можете отобразить его с помощью ShowFullscreenAdvertChartboost. Реклама предварительно загружается, как только вы устанавливаете свои данные Chartboost, и после того, как каждая полноэкранная реклама отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают 0, то вы можете попробовать вызвать ShowFullscreenAdvertChartboost в любом случае, он ничего не покажет, так как ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны какие-либо новые объявления.
     *
     * @return int
     */
    function GetFullscreenAdvertLoadedChartboost()
    {
    }

    /**
     *Возвращает 1, если есть предварительно загруженная и готовая к показу реклама Amazon interstitial, в противном случае 0. Если это так, вы можете отобразить его с помощью ShowFullscreenAdvertAmazon. Реклама предварительно загружается, как только вы устанавливаете свои данные Amazon, и после того, как каждая полноэкранная реклама отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают 0, то вы можете попробовать вызвать ShowFullscreenAdvertAmazon в любом случае, он ничего не покажет, так как ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны какие-либо новые объявления.
     *
     * @return int
     */
    function GetFullscreenAdvertLoadedAmazon()
    {
    }

    /**
     *Возвращает 1, если есть предварительно загруженное и готовое к показу интерстициальное объявление AdMob, в противном случае 0. Если это так, вы можете отобразить его с помощью ShowFullscreenAdvertAdMob. Объявления предварительно загружаются, как только вы устанавливаете свои данные AdMob, и после того, как каждая полноэкранная реклама отклоняется пользователем. Если эта команда продолжает возвращать 0, то загрузка рекламы может быть неудачной из-за того, что у провайдера закончились объявления, и AGK прекратит попытки их загрузить. В этом случае вам следует обратиться к другим поставщикам рекламы. Если вы обнаружите, что все ваши поставщики рекламы возвращают 0, то вы можете попробовать вызвать ShowFullscreenAdvertAdMob в любом случае, он ничего не покажет, так как ничего не загружено, но он перезапустит процесс загрузки, чтобы увидеть, стали ли доступны какие-либо новые объявления.
     *
     * @return int
     */
    function GetFullscreenAdvertLoadedAdMob()
    {
    }

    /**
     *Получите время в секундах, потраченное на обработку и рендеринг последнего кадра. Обновляется только при вызове Sync или Swap. Это ограничение ограничено максимальным значением 0,2 секунды, чтобы предотвратить интерполяцию внутреннего кода на основе таймера с большими временными промежутками. Чтобы найти истинное время кадра, вы можете использовать команду Timer ().
     *
     * @return float
     */
    function GetFrameTime()
    {
    }

    /**
     *Возвращает ответ с сервера на предыдущий отправленный запрос SendHTTPRequestASync. Вы должны дождаться, пока GetHTTPResponseReady вернет 1, прежде чем вызывать эту команду. В tier 2 вы должны удалить возвращаемую строку с помощью agk::DeleteString, когда закончите ее использовать. Уровень 2 имеет дополнительную команду GetHTTPResponseReadyC, которая возвращает const char, который не нуждается в удалении.
     *
     * @param int $iHTTP Идентификатор соединения для проверки.
     * @return string
     */
    function GetHTTPResponse($iHTTP)
    {
    }

    /**
     *Возвращает количество папок в текущей папке. Не включает в себя . или ..
     *
     * @param int $mode 0 для подсчета только папок в папке чтения, 1 для подсчета только папки записи, 2 для подсчета обоих
     * @return int
     */
    function GetFolderCount($mode)
    {
    }

    /**
     *Возвращает количество папок в текущей папке. Не включает в себя . или ..
     *
     * @return int
     */
    function GetFolderCount()
    {
    }

    /**
     *Возвращает текущую папку, ранее заданную с помощью SetFolder. Возвращаемый путь всегда будет иметь косую черту в качестве конечного символа, за исключением случаев, когда в корневой папке будет возвращена пустая строка.
     *
     * @return string
     */
    function GetFolder()
    {
    }

    /**
     *Возвращает имя первой папки, найденной в текущей папке, которая задается с помощью SetFolder. Вы можете вызвать GetNextFolder, чтобы продолжить вниз по списку папок в текущей папке. Возвращает пустую строку, если в текущей папке нет папок. Не включает в себя . или .. Обратите внимание, что на Android существует известное ограничение, что любые папки в папке "активы" не могут быть найдены с помощью этой команды. Вы можете обойти эту проблему, используя MakeFolder для создания той же структуры папок в папке write, которую AGK затем может использовать для поиска файлов в папке assets с помощью GetFirstFile. По умолчанию эта команда объединит списки папок из папок чтения и записи в один список (mode=2), который можно изменить на только возвращаемые папки в папке чтения (mode=0) или только возвращаемые папки из папки записи (mode=1)
     *
     * @return string
     */
    function GetFirstFolder()
    {
    }

    /**
     *Возвращает имя первой папки, найденной в текущей папке, которая задается с помощью SetFolder. Вы можете вызвать GetNextFolder, чтобы продолжить вниз по списку папок в текущей папке. Возвращает пустую строку, если в текущей папке нет папок. Не включает в себя . или .. Обратите внимание, что на Android существует известное ограничение, что любые папки в папке "активы" не могут быть найдены с помощью этой команды. Вы можете обойти эту проблему, используя MakeFolder для создания той же структуры папок в папке write, которую AGK затем может использовать для поиска файлов в папке assets с помощью GetFirstFile. По умолчанию эта команда объединит списки папок из папок чтения и записи в один список (mode=2), который можно изменить на только возвращаемые папки в папке чтения (mode=0) или только возвращаемые папки из папки записи (mode=1)
     *
     * @param int $mode 0 для возврата только папок из папки чтения, 1 для возврата только папок из папки записи, 2 для обоих (по умолчанию)
     * @return string
     */
    function GetFirstFolder($mode)
    {
    }

    /**
     *Возвращает 1, если 3D fog в данный момент включен, в противном случае он возвращает 0.
     *
     * @return int
     */
    function GetFogMode()
    {
    }

    /**
     *Возвращает имя первого файла, найденного в текущей папке, который задается с помощью SetFolder. Вы можете вызвать GetNextFile, чтобы продолжить вниз по списку файлов в текущей папке. Возвращает пустую строку, если в текущей папке нет файлов. По умолчанию эта команда объединит списки файлов из папок чтения и записи в один список (mode=2) это может быть изменено на возврат только файлов из папки чтения (mode=0) или только файлов из папки записи (mode=1) Обратите внимание, что папка чтения не существует при использовании широковещательной передачи или отладки для запуска приложения, так как файлы копируются в папку записи проигрывателя AGK для этих режимов запуска. С другой стороны, папка записи начинается как пустая при запуске приложения непосредственно из IDE или при запуске конечного исполняемого файла приложения в папке проекта.
     *
     * @param int $mode 0 для возврата только файлов из папки чтения, 1 для возврата только файлов из папки записи, 2 для обоих (по умолчанию)
     * @return string
     */
    function GetFirstFile($mode)
    {
    }

    /**
     *Возвращает имя первого файла, найденного в текущей папке, который задается с помощью SetFolder. Вы можете вызвать GetNextFile, чтобы продолжить вниз по списку файлов в текущей папке. Возвращает пустую строку, если в текущей папке нет файлов. По умолчанию эта команда объединит списки файлов из папок чтения и записи в один список (mode=2) это может быть изменено на возврат только файлов из папки чтения (mode=0) или только файлов из папки записи (mode=1) Обратите внимание, что папка чтения не существует при использовании широковещательной передачи или отладки для запуска приложения, так как файлы копируются в папку записи проигрывателя AGK для этих режимов запуска. С другой стороны, папка записи начинается как пустая при запуске приложения непосредственно из IDE или при запуске конечного исполняемого файла приложения в папке проекта.
     *
     * @return string
     */
    function GetFirstFile()
    {
    }

    /**
     *Возвращает текущую позицию чтения в файле
     *
     * @param int $iFileID Идентификатор файла для проверки.
     * @return int
     */
    function GetFilePos($iFileID)
    {
    }

    /**
     *Возвращает размер открытого файла в байтах.
     *
     * @param int $iFileID Идентификатор файла для проверки.
     * @return int
     */
    function GetFileSize($iFileID)
    {
    }

    /**
     *Возвращает 1, если данный файл находится либо в каталоге ресурсов, либо в каталоге записи, назначенном приложению.
     *
     * @param string $szFile Имя файла для проверки.
     * @return int
     */
    function GetFileExists($szFile)
    {
    }

    /**
     *Возвращает количество файлов в текущей папке.
     *
     * @param int $mode 0 для подсчета только файлов в папке чтения, 1 для подсчета только папки записи, 2 для подсчета обоих
     * @return int
     */
    function GetFileCount($mode)
    {
    }

    /**
     *Возвращает количество файлов в текущей папке.
     *
     * @return int
     */
    function GetFileCount()
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return int
     */
    function GetFacebookDownloadState()
    {
    }

    /**
     *Возвращает 1, если шрифт был успешно загружен с заданным идентификатором.
     *
     * @param int $iFontID Идентификатор шрифта для проверки.
     * @return int
     */
    function GetFontExists($iFontID)
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return string
     */
    function GetFacebookDownloadFile()
    {
    }

    /**
     *Возвращает состояние любого файла расширения, используемого этой платформой, в настоящее время применимого только к Android. Возвращает -1, если во время загрузки произошла ошибка, 0, если файл расширения не используется на этой платформе, 1, если он должен существовать, но не существует (в этом случае вы вызываете функцию DownloadExpansionFile ()), 2, если он в данный момент загружается, и 3, если все завершено и файл существует.
     *
     * @return int
     */
    function GetExpansionFileState()
    {
    }

    /**
     *Проверяет ход загрузки, начатой с помощью DownloadExpansionFile, возвращает плавающее значение от 0 до 100 Используйте GetExpansionFileState, чтобы проверить, завершена ли загрузка.
     *
     * @return float
     */
    function GetExpansionFileProgress()
    {
    }

    /**
     *Циклически просматривает список всех контактов, обнаруженных на последнем шаге физики. Возвращает 1 если контакт существует, вы можете получить спрайты, участвующие в этом контакте, используя GetContactSpriteID1 и GetContactSpriteID2, вы можете перейти к следующему контакту с помощью GetNextContact. Возвращает 0, если контактов нет.
     *
     * @return int
     */
    function GetFirstContact()
    {
    }

    /**
     *Возвращает текущую позицию Y поля редактирования. Это верхний левый угол фактического поля ввода текста, любая граница будет простираться выше этой точки.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return float
     */
    function GetEditBoxY($index)
    {
    }

    /**
     *Возвращает 1, если с момента последнего вызова этой команды произошла ошибка. 0, если нет. Это не включает в себя предупреждения.
     *
     * @return int
     */
    function GetErrorOccurred()
    {
    }

    /**
     *Возвращает код ошибки самой последней ошибки, возникшей при загрузке файла расширения. Возможные ошибки включают в себя: 15 = Нелицензированный 16 = Неудачная выборка URL-адреса 17 = Полная SD-карта 18 = Отменена 19 = Неизвестная ошибка
     *
     * @return int
     */
    function GetExpansionFileError()
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return int
     */
    function GetFacebookLoggedIn()
    {
    }

    /**
     *Возвращает 1, если поле редактирования видно и может быть нажато, 0, если поле редактирования невидимо и не может быть изменено.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxVisible($index)
    {
    }

    /**
     *Возвращает текущую ширину поля редактирования. Это ширина фактического поля ввода текста, любая граница будет выходить за пределы этого значения.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return float
     */
    function GetEditBoxWidth($index)
    {
    }

    /**
     *Возвращает текст, отображаемый в данный момент в поле редактирования.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return string
     */
    function GetEditBoxText($index)
    {
    }

    /**
     *Возвращает количество строк текста, введенных пользователем в поле редактирования.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxLines($index)
    {
    }

    /**
     *Возвращает текущую высоту поля редактирования. Это высота фактического поля ввода текста, любая граница будет выходить за пределы этого значения.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return float
     */
    function GetEditBoxHeight($index)
    {
    }

    /**
     *Возвращает 1, если поле редактирования было нажато и принимает входные данные.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxHasFocus($index)
    {
    }

    /**
     *Возвращает текущую глубину поля редактирования, где 0 - передняя часть экрана, а 10000-задняя.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxDepth($index)
    {
    }

    /**
     *Возвращает курсор в заданную позицию в тексте, то есть позиция 0 находится слева от первого символа, позиция 1-слева от второго символа и так далее.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxCursorPosition($index)
    {
    }

    /**
     *Возвращает 1, если поле редактирования только что потеряло фокус, что означает, что текст, возможно, изменился и вряд ли изменится снова в краткосрочной перспективе.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxChanged($index)
    {
    }

    /**
     *Возвращает текущую позицию X поля редактирования. Это верхний левый угол фактического поля ввода текста, любая граница будет простираться влево от этой точки.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return float
     */
    function GetEditBoxX($index)
    {
    }

    /**
     *Возвращает 1, если поле редактирования включено и может быть нажато, 0, если поле редактирования отключено и не может быть изменено.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxActive($index)
    {
    }

    /**
     *Возвращает время, потраченное на замену backbuffer и (при необходимости) ожидание, пока GPU догонит готовый к следующему кадру.
     *
     * @return float
     */
    function GetDrawingTime()
    {
    }

    /**
     *Возвращает каталог, содержащий документы текущих пользователей. На Windows это будет что-то вроде "C:\Users\Me\My Документы", на iOS это будет просто каталог записи приложения. По умолчанию все приложения записываются в указанную системой папку настроек приложения, например "C:\Users\Me\AppData" в Windows", "/home/user/.config" в Linux и защищенная папка данных приложения на Android. Там, где это возможно, содержимое пути к документам видно пользователю, например, на Android 10, а ниже будет папка sdcard. iOS и Android 11 и выше не могут предоставить общедоступное место для записи, поэтому вместо этого будет возвращен каталог записи приложения, который не виден пользователю.
     *
     * @return string
     */
    function GetDocumentsPath()
    {
    }

    /**
     *Возвращает текущее соотношение сторон экрана. Это не соотношение сторон используемой системы координат, вместо этого это значение растягивает систему координат в нужную форму. Объяснение системы координат см. в разделе SetVirtualResolution.
     *
     * @return float
     */
    function GetDisplayAspect()
    {
    }

    /**
     *Возвращает текущее значение направления в направлении Y. Направление-это эмулируемое значение, которое будет использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.
     *
     * @return float
     */
    function GetDirectionY()
    {
    }

    /**
     *Возвращает 1, если существует поле редактирования с заданным идентификатором, и 0 в противном случае.
     *
     * @param int $index Идентификатор поля редактирования для проверки.
     * @return int
     */
    function GetEditBoxExists($index)
    {
    }

    /**
     *Возвращает текущее значение направления в направлении X. Направление-это эмулируемое значение, которое будет использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.
     *
     * @return float
     */
    function GetDirectionX()
    {
    }

    /**
     *Возвращает текущую скорость направления в виде абсолютного значения от 0 до 1,4, это используется с GetDirectionAngle для определения экстента направления. Направление-это эмулируемое значение, которое будет использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.
     *
     * @return float
     */
    function GetDirectionSpeed()
    {
    }

    /**
     *На Android это возвращает 0, если это приложение работает на устройстве Google, или 1, если оно работает на устройстве Amazon. На всех других платформах это возвращает 0.
     *
     * @return int
     */
    function GetDevicePlatform()
    {
    }

    /**
     *Возвращает строку, содержащую конкретную строку устройства, это будет отличаться для каждой платформы, например, в Windows она будет возвращать версию ОС "vista"," 7"," xp " и т. Д. На iOS он вернет имя устройства iOS "ipad1,1", "ipod2,1", "iphone1,2" и т. Д. Для Android он вернет модель устройства "nexus 7" и т. Д. Для Mac он вернет версию ОС "10.7", "10.8" и т. Д. Эта строка всегда будет строчной
     *
     * @return string
     */
    function GetDeviceType()
    {
    }

    /**
     *Возвращает количество секунд и долей секунд, затраченных на подготовку мира к рисованию. Это включает в себя вычисление того, что видно, преобразование спрайтов в их положение на экране и отправку вершин в графический процессор.
     *
     * @return float
     */
    function GetDrawingSetupTime()
    {
    }

    /**
     *Эта команда устарела, пожалуйста, используйте GetDeviceBaseName и GetDeviceType вместо этого. Возвращает строку, содержащую имя текущей платформы, например "windows". При работе с iOS возвращается больше информации,например,на iPad 1 "ios|iPad1,1" и на iPod 2-го поколения: "ios|iPod2, 1" и на iPhone 3G: "ios|iPhone1, 2". Первое число-это главный номер модели, второе - второстепенный номер модели.
     *

     * @return string
     */
    function GetDeviceName()
    {
    }

    /**
     *Возвращает тип сетевого подключения устройства к Интернету. Возвращает 0, если используется мобильное соединение, 1, если используется соединение Wi-Fi или Ethernet, или -1, если тип сети не может быть определен. В настоящее время реализовано только на iOS и Android, другие платформы вернут -1.
     *
     * @return int
     */
    function GetDeviceNetworkType()
    {
    }

    /**
     *Возвращает строку, содержащую язык текущего устройства в виде "en", "fr", "de" и т. Д.
     *

     * @return string
     */
    function GetDeviceLanguage()
    {
    }

    /**
     *Возвращает IPv6-адрес текущего устройства, который может быть использован другими устройствами для подключения к этому устройству. Чтобы получить IPv4-адрес, используйте вместо него GetDeviceIP.
     *
     * @return string
     */
    function GetDeviceIPv6()
    {
    }

    /**
     *Возвращает IPv4-адрес текущего устройства, который может быть использован другими устройствами для подключения к этому устройству. Чтобы получить IPv6-адрес, используйте вместо него GetDeviceIPv6.
     *
     * @return string
     */
    function GetDeviceIP()
    {
    }

    /**
     *Возвращает строку, которая может быть использована для идентификации этого устройства
     *
     * @return string
     */
    function GetDeviceID()
    {
    }

    /**
     *Возвращает текущий угол направления относительно x=0, y=-1 (вверх). Угол будет находиться в диапазоне 0-360. Направление-это эмулируемое значение, которое будет использовать акселерометр, если он доступен, или клавиши со стрелками клавиатуры, если нет.
     *
     * @return float
     */
    function GetDirectionAngle()
    {
    }

    /**
     *Возвращает высоту в пикселях backbuffer текущего устройства. Это значение изменится, если ориентация устройства изменится с книжной на альбомную, но только в том случае, если изменения ориентации разрешены.
     *
     * @return int
     */
    function GetDeviceHeight()
    {
    }

    /**
     *Возвращает ширину в пикселях backbuffer текущего устройства. Это значение изменится, если ориентация устройства изменится с книжной на альбомную, но только в том случае, если изменения ориентации разрешены.
     *
     * @return int
     */
    function GetDeviceWidth()
    {
    }

    /**
     *Получает точки на дюйм (также называемые Пикселями на дюйм) экрана устройства. Это работает только на iOS и Android, другие платформы вернут 0. В iOS это значение жестко закодировано устройством, поэтому, если будет выпущено новое устройство, для получения точного значения потребуется обновление AGK. Тем временем будет сформирована оценочная стоимость.
     *
     * @return int
     */
    function GetDeviceDPI()
    {
    }

    /**
     *Возвращает 1, если данный идентификатор камеры является задней камерой, 2, если это фронтальная камера, или 0, если это неизвестно.
     *
     * @param int $cameraID Идентификатор камеры устройства, которую вы хотите проверить
     * @return int
     */
    function GetDeviceCameraType($cameraID)
    {
    }

    /**
     *Возвращает строку, содержащую имя текущей платформы. Это будет относиться только к базовой платформе, то есть "windows", "ios", "android", "mac", "linux" или "html5". Используйте GetDeviceType, чтобы получить дополнительную информацию о конкретном устройстве. Эта строка всегда будет строчной.
     *
     * @return string
     */
    function GetDeviceBaseName()
    {
    }

    /**
     *Возвращает дни заданного значения времени unix (от 1 до 31). Время Unix представлено как количество секунд с 1 января 1970 года, оно также может быть отрицательным.
     *
     * @param int $unixtime Значение времени unix.
     * @return int
     */
    function GetDaysFromUnix($unixtime)
    {
    }

    /**
     *Возвращает целое число, представляющее текущий день недели в диапазоне 0-6 с 0 как воскресенье, 1 как понедельник и т. Д.
     *
     * @return int
     */
    function GetDayOfWeek()
    {
    }

    /**
     *Возвращает строку, представляющую текущее время в формате HH-MM-SS, например 15:23:04.
     *
     * @return string
     */
    function GetCurrentTime()
    {
    }

    /**
     *Возвращает ИДЕНТИФИКАТОР текущего активного поля редактирования, только одно поле редактирования может фокусироваться одновременно. Если в данный момент ни одно поле редактирования не имеет фокуса, оно возвращает 0.
     *
     * @return int
     */
    function GetCurrentEditBox()
    {
    }

    /**
     *Эта команда устарела и была заменена GetFolder.
     *
     * @return string
     */
    function GetCurrentDir()
    {
    }

    /**
     *Возвращает строку, представляющую текущую дату в формате ГГГГ-ММ-ДД, например 2012-01-09.
     *
     * @return string
     */
    function GetCurrentDate()
    {
    }

    /**
     *Возвращает положение X точки контакта в мировых координатах.
     *
     * @return float
     */
    function GetContactWorldX()
    {
    }

    /**
     *Возвращает идентификатор второго спрайта, участвующего в этом контакте. Если эта половина контакта находится с элементом, не связанным со спрайтом, то это вернет 0.
     *
     * @return int
     */
    function GetContactSpriteID2()
    {
    }

    /**
     *Возвращает идентификатор первого спрайта, участвующего в этом контакте. Если эта половина контакта находится с элементом, не связанным со спрайтом, то это вернет 0.
     *
     * @return int
     */
    function GetContactSpriteID1()
    {
    }

    /**
     *Возвращает текущий статус согласия пользователя, он возвращает одно из следующих значений: -2 = LoadConsentStatusAdMob еще не был вызван, вы должны вызвать его, прежде чем продолжить -1 = LoadConsentStatusAdMob находится в процессе загрузки статуса согласия пользователя, пожалуйста, подождите 0 = Пользователь еще не был спрошен, AdMob ads по умолчанию не будет использовать личную информацию, вызовите RequestConsentAdMob, чтобы запросить согласие пользователя 1 = Пользователь отказался от согласия, любые показанные объявления AdMob не будут использовать личную информацию 2 = Пользователь дал согласие, любые показанные объявления AdMob будут использовать личную информацию
     *
     * @return int
     */
    function GetConsentStatusAdMob()
    {
    }

    /**
     *Возвращает красный компонент составного значения цвета, созданного с помощью MakeColor
     *
     * @param int $color Значение цвета для разложения.
     * @return int
     */
    function GetColorRed($color)
    {
    }

    /**
     *Возвращает зеленый компонент составного значения цвета, созданного с помощью MakeColor
     *
     * @param int $color Значение цвета для разложения.
     * @return int
     */
    function GetColorGreen($color)
    {
    }

    /**
     *Возвращает синий компонент составного значения цвета, созданного с помощью MakeColor
     *
     * @param int $color Значение цвета для разложения.
     * @return int
     */
    function GetColorBlue($color)
    {
    }

    /**
     *Возвращает значение переменной облачных данных по имени. Если переменная не существует, то вместо нее будет возвращено значение по умолчанию, переданное по умолчанию. Если вы вызываете эту команду из уровня 2, то вы должны удалить возвращенную строку, когда закончите с ней, вызвав agk::DeleteString.
     *
     * @param string $varName Имя переменной, которую нужно проверить, должно быть меньше 64 байт
     * @param string $defaultValue Значение, возвращаемое, если переменная не существует
     * @return string
     */
    function GetCloudDataVariable($varName, $defaultValue)
    {
    }

    /**
     *Возвращает 1 если облачные данные изменились из-за того, что другое устройство изменило значение, оно будет оставаться 1 до тех пор, пока вы не вызовете GetCloudDataVariable. В противном случае возвращает 0. Это не станет 1, когда вы измените значение локально.
     *
     * @return int
     */
    function GetCloudDataChanged()
    {
    }

    /**
     *Возвращает 1, если команды облачных данных доступны для использования. Возвращает 0, если пользователь еще не решил, разрешить или заблокировать доступ, это будет предложено в SetupCloudData, если это применимо. Возвращает -1, если пользователь специально отказал в доступе. Возвращает значение -2, если пользователь не вошел в систему или на устройстве нет iCloud или Google Диска. Вы можете предложить пользователю войти в систему и включить их при первом запуске вашего приложения или когда он решит включить облачное резервное копирование в ваших собственных настройках приложения. Если эта команда возвращает -3 на Android, то данные Google cloud повреждены и должны быть очищены в настройках диска.
     *
     * @return int
     */
    function GetCloudDataAllowed()
    {
    }

    /**
     *Получает любой текст, который в данный момент хранится в буфере обмена устройства, текст остается в буфере обмена, поэтому он все еще может быть использован другими приложениями. Буфер обмена такой же, как и тот, который используется функцией копирования/вставки устройства.
     *
     * @return string
     */
    function GetClipboardText()
    {
    }

    /**
     *Возвращает ИДЕНТИФИКАТОР вновь выбранного изображения, выбранного с помощью ShowChooseImageScreen. Если это возвращает 0, то пользователь отменил процесс или вы еще не запустили его с помощью ShowChooseImageScreen. После того как вы вызвали эту команду для получения идентификатора изображения, она будет возвращать 0 до тех пор, пока ShowChooseImageScreen не будет вызван снова.
     *
     * @return int
     */
    function GetChosenImage()
    {
    }

    /**
     *Возвращает положение точки контакта Y в мировых координатах.
     *
     * @return float
     */
    function GetContactWorldY()
    {
    }

    /**
     *Возвращает текущую длину буфера символов без его изменения. Обратите внимание, что это длина в символах, а не в байтах, которая может отличаться, когда строка содержит символы юникода.
     *
     * @return int
     */
    function GetCharBufferLength()
    {
    }

    /**
     *Возвращает строку всех символов, нажатых с момента последнего вызова этой команды, после вызова которой буфер очищается. Это работает только на устройствах с физической клавиатурой. Буфер ограничен 1024 символами, после чего дополнительные символы будут проигнорированы. В Tier 2 строка кодируется в UTF-8 и должна быть удалена с помощью agk::DeleteString, когда вы закончите с ней.
     *
     * @return string
     */
    function GetCharBuffer()
    {
    }

    /**
     *Эта функция устарела, вместо нее используйте SetDeviceCameraToImage. Возвращает ИДЕНТИФИКАТОР только что захваченного изображения, созданного с помощью ShowImageCaptureScreen. Если это возвращает 0, то пользователь отменил процесс или вы еще не запустили его с помощью ShowImageCaptureScreen. После того как вы вызвали эту команду для получения идентификатора изображения, она будет возвращать 0 до тех пор, пока ShowImageCaptureScreen не будет вызван снова.
     *
     * @return int
     */
    function GetCapturedImage()
    {
    }

    /**
     *Возвращает текущее положение Z камеры.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraZ($cameraID)
    {
    }

    /**
     *Возвращает текущее положение X камеры.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraX($cameraID)
    {
    }

    /**
     *Возвращает текущее положение Y камеры.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraY($cameraID)
    {
    }

    /**
     *Возвращает текущее Z-положение камеры после всех преобразований, вызванных FixCameraToObject.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraWorldZ($cameraID)
    {
    }

    /**
     *Возвращает текущее положение Y камеры после всех преобразований, вызванных FixCameraToObject.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraWorldY($cameraID)
    {
    }

    /**
     *Возвращает текущее положение X камеры после всех преобразований, вызванных FixCameraToObject.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraWorldX($cameraID)
    {
    }

    /**
     *Возвращает Y-компоненту текущего вращения камеры, преобразованную в кватернион.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraQuatY($cameraID)
    {
    }

    /**
     *Возвращает Z-компоненту текущего вращения камеры, преобразованную в кватернион.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraQuatZ($cameraID)
    {
    }

    /**
     *Возвращает компонент X текущего вращения камеры, преобразованный в кватернион.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraQuatX($cameraID)
    {
    }

    /**
     *Возвращает текущее поле зрения для указанной камеры
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraFOV($cameraID)
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет камеру, и 0, если нет. На некоторых платформах эта команда перечисляет аппаратные устройства для проверки камеры, которая может быть медленной. Не рекомендуется называть это каждый кадр. В Windows эта команда успешно обнаружит новую камеру, подключенную во время работы приложения.
     *
     * @return int
     */
    function GetCameraExists()
    {
    }

    /**
     *Возвращает Y-компоненту текущего поворота камеры, преобразованную в углы Эйлера.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraAngleY($cameraID)
    {
    }

    /**
     *Возвращает Z-компоненту текущего поворота камеры, преобразованную в углы Эйлера.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraAngleZ($cameraID)
    {
    }

    /**
     *Возвращает X-компоненту текущего поворота камеры, преобразованную в углы Эйлера.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraAngleX($cameraID)
    {
    }

    /**
     *Эта функция возвращает 1, если указанная кнопка в данный момент удерживается нажатой. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут использоваться для команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5 соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая появится на экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа гарантированно имеет способ активации кнопок AGK.
     *
     * @param int $index Идентификатор кнопки, которую нужно проверить, должен находиться в диапазоне от 1 до 5 включительно.
     * @return int
     */
    function GetButtonState($index)
    {
    }

    /**
     *Эта функция возвращает 1, если указанная кнопка только что была нажата, а затем возвращает 0, когда кнопка удерживается нажатой. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут использоваться для команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5 соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая появится на экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа гарантированно имеет способ активации кнопок AGK.
     *
     * @param int $index Идентификатор кнопки, которую нужно проверить, должен находиться в диапазоне от 1 до 5 включительно.
     * @return int
     */
    function GetButtonPressed($index)
    {
    }

    /**
     *Эта функция возвращает 1, если указанная кнопка только что была отпущена, а затем возвращает 0, когда кнопка поднята. Кнопки AGK-это эмулируемый метод ввода, который использует любые доступные входы устройства для создания 5 кнопок. Если будет найден настоящий джойстик, то первые 5 кнопок из него будут использоваться для команд кнопки AGK. В противном случае AGK ищет полноразмерную клавиатуру и, если она будет найдена, будет использовать следующие клавиши в следующем порядке: E, R, Q, Control, чтобы представлять кнопки от 1 до 5 соответственно. Если ни джойстик, ни клавиатура не найдены, то создается виртуальная кнопка, которая появится на экране и может быть нажата либо с помощью сенсорного экрана, либо с помощью мыши. Каждая платформа гарантированно имеет способ активации кнопок AGK.
     *
     * @param int $index Идентификатор кнопки, которую нужно проверить, должен находиться в диапазоне от 1 до 5 включительно.
     * @return int
     */
    function GetButtonReleased($index)
    {
    }

    /**
     *Проверяет прослушиватель вещания на наличие любых передач. Возвращает 0, если ничего не было получено. Возвращает идентификатор сообщения если что-то было получено, вы можете получить доступ к содержимому этого сообщения с помощью команд сетевого сообщения. Сообщение должно быть удалено, когда вы закончите чтение.
     *
     * @param int $iID Идентификатор широковещательного слушателя для проверки.
     * @return int
     */
    function GetBroadcastMessage($iID)
    {
    }

    /**
     *Возвращает 1, если указанный идентификатор приложения все еще работает, и 0, если это не так.
     *
     * @param int $appID Идентификатор приложения для проверки, возвращенный из runApp()
     * @return int
     */
    function GetAppRunning($appID)
    {
    }

    /**
     *Возвращает имя exe-файла.
     *

     * @return string
     */
    function GetAppName()
    {
    }

    /**
     *На Android это возвращает имя пакета, используемое при экспорте приложения, например, для AGK Player это будет com.thegamecreators.agk_player2. В iOS он возвращает идентификатор пакета, используемый для приложения, например, для AGK Player это будет com.thegamecreators.agk2player. На всех других платформах это в настоящее время возвращает пустую строку. Если вы вызываете это из уровня 2, то возвращаемая строка должна быть удалена, когда она больше не нужна.
     *
     * @return string
     */
    function GetAppPackageName()
    {
    }

    /**
     *Возвращает 1, если указанное приложение установлено и включено на устройстве. Для Android это должно быть имя пакета приложения, например com.faceboook.катана для приложения Facebook. В настоящее время это работает только на Android
     *
     * @param string $packageName Имя пакета приложения для проверки
     * @return int
     */
    function GetAppInstalled($packageName)
    {
    }

    /**
     *Возвращает W-компонент текущего вращения камеры, преобразованный в кватернион.
     *
     * @param int $cameraID Идентификатор камеры для проверки, основная камера-ID 1.
     * @return float
     */
    function GetCameraQuatW($cameraID)
    {
    }

    /**
     *Возвращает 1, если текущее устройство имеет акселерометр, который в настоящее время поддерживается AGK, и 0, если нет.
     *
     * @return int
     */
    function GetAccelerometerExists()
    {
    }

    /**
     *Преобразует 2D-точку на экране в вектор, указывающий в 3D-мир. Вектор нормализуется на 1 единицу длины, чтобы расширить его в мир, просто умножьте его на желаемое расстояние.  Если камера использует ортогональную проекционную матрицу, то эта команда ведет себя несколько иначе, поскольку все точки на экране будут производить один и тот же вектор, направленный в сторону от камеры, но каждый из них исходит из другой точки в трехмерном пространстве. Это отличается от перспективной проекции, где все векторы начинаются в положении камеры и расходятся веером по мере удаления от камеры. Поэтому при использовании ортогональной проекционной матрицы эта команда вместо этого возвращает боковой ненормализованный вектор из положения камеры в точку в 3D-пространстве, с которой должен начинаться вектор. Затем это может быть объединено с вектором, который указывает в сторону от камеры, чтобы создать луч, брошенный в сцену.
     *
     * @param float $x X-компонент положения экрана.
     * @param float $y Компонент Y положения экрана.
     * @return float
     */
    function Get3DVectorYFromScreen($x, $y)
    {
    }

    /**
     *Возвращает общее количество физических объектов в мире.
     *
     * @return int
     */
    function Get3DPhysicsTotalObjects()
    {
    }

    /**
     *Возвращает общее количество суставов в физическом мире
     *
     * @return int
     */
    function Get3DPhysicsTotalJoints()
    {
    }

    /**
     *Возвращает общее количество попаданий луча по его длине.
     *
     * @param int $rayID Идентификатор луча, который возвращается вызовом Create3DPhysicsRay().
     * @return int
     */
    function Get3DPhysicsRayCastNumHits($rayID)
    {
    }

    /**
     *Возвращает расстояние вдоль луча до столкновения, где 1.0 = полная длина, 0.0 = начало.
     *
     * @param int $rayID Идентификатор луча
     * @return float
     */
    function Get3DPhysicsRayCastFraction($rayID)
    {
    }

    /**
     *Возвращает идентификатор объекта, пораженного лучом по индексу.
     *
     * @param int $rayID Идентификатор луча
     * @param float $fractionIndex значение, возвращаемое командой Get3DPhysicsRayCastFraction ().
     * @return int
     */
    function Get3DPhysicsRayCastObjectHit($rayID, $fractionIndex)
    {
    }

    /**
     *Заполняет переданный вектор значениями нормалей от луча. сначала создайте физический луч, а затем бросьте его перед вызовом Get3DPhysicsRayCastNormalVector().
     *
     * @param int $rayID Идентификатор луча, который возвращается вызовом Create3DPhysicsRay().
     * @param int $returnVec3ID Идентификатор вектора. Vector ID-это возвращаемое значение команды CreateVector3 ().
     * @return void
     */
    function Get3DPhysicsRayCastNormalVector($rayID, $returnVec3ID)
    {
    }

    /**
     *Преобразует 2D-точку на экране в вектор, указывающий в 3D-мир. Вектор нормализуется на 1 единицу длины, чтобы расширить его в мир, просто умножьте его на желаемое расстояние.  Если камера использует ортогональную проекционную матрицу, то эта команда ведет себя несколько иначе, поскольку все точки на экране будут производить один и тот же вектор, направленный в сторону от камеры, но каждый из них исходит из другой точки в трехмерном пространстве. Это отличается от перспективной проекции, где все векторы начинаются в положении камеры и расходятся веером по мере удаления от камеры. Поэтому при использовании ортогональной проекционной матрицы эта команда вместо этого возвращает боковой ненормализованный вектор из положения камеры в точку в 3D-пространстве, с которой должен начинаться вектор. Затем это может быть объединено с вектором, который указывает в сторону от камеры, чтобы создать луч, брошенный в сцену.
     *
     * @param float $x X-компонент положения экрана.
     * @param float $y Компонент Y положения экрана.
     * @return float
     */
    function Get3DVectorXFromScreen($x, $y)
    {
    }

    /**
     *Возвращает true, если есть контактный вектор, и заполняет вектор outVec3ID. Сначала создайте вектор с помощью CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен результатами.
     *
     * @param int $rayID Идентификатор луча
     * @param float $fractionIndex значение, возвращаемое командой Get3DPhysicsRayCastFraction ().
     * @param int $outVec3ID Идентификатор вектора, который будет заполнен позицией.
     * @return int
     */
    function Get3DPhysicsRayCastContactPosition($rayID, $fractionIndex, $outVec3ID)
    {
    }

    /**
     *Возвращает идентификатор объекта модели с ragdoll, который содержит переданный объект ragdoll bone.
     *
     * @param int $objID идентификатор объекта костной капсулы тряпичной куклы.
     * @return int
     */
    function Get3DPhysicsRagdollFromBoneObject($objID)
    {
    }

    /**
     *Преобразует 2D-точку на экране в вектор, указывающий в 3D-мир. Вектор нормализуется на 1 единицу длины, чтобы расширить его в мир, просто умножьте его на желаемое расстояние.  Если камера использует ортогональную проекционную матрицу, то эта команда ведет себя несколько иначе, поскольку все точки на экране будут производить один и тот же вектор, направленный в сторону от камеры, но каждый из них исходит из другой точки в трехмерном пространстве. Это отличается от перспективной проекции, где все векторы начинаются в положении камеры и расходятся веером по мере удаления от камеры. Поэтому при использовании ортогональной проекционной матрицы эта команда вместо этого возвращает боковой ненормализованный вектор из положения камеры в точку в 3D-пространстве, с которой должен начинаться вектор. Затем это может быть объединено с вектором, который указывает в сторону от камеры, чтобы создать луч, брошенный в сцену.
     *
     * @param float $x X-компонент положения экрана.
     * @param float $y Компонент Y положения экрана.
     * @return float
     */
    function Get3DVectorZFromScreen($x, $y)
    {
    }

    /**
     *Возвращает true, если для объекта существует тряпичная кукла.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function Get3DPhysicsRagdollExist($objID)
    {
    }

    /**
     *Возвращает угол поворота суставов X в градусах
     *
     * @param int $jointID Идентификатор сустава.
     * @return int
     */
    function Get3DPhysicsJointRotationVector($jointID)
    {
    }

    /**
     *Возвращает true, если существует ближайший контактный вектор, и заполняет вектор outVec3ID. Сначала создайте вектор с помощью CreateVector3 (), а затем передайте идентификатор. Вектор, который вы создали и передали, будет заполнен результатами.
     *
     * @param int $rayID Идентификатор луча
     * @param int $outVec3ID Идентификатор вектора, который будет заполнен позицией.
     * @return int
     */
    function Get3DPhysicsRayCastClosestContactPosition($rayID, $outVec3ID)
    {
    }

    /**
     *Возвращает идентификатор вектора
     *
     * @param int $jointID Идентификатор сустава
     * @return int
     */
    function Get3DPhysicsJointPositionVector($jointID)
    {
    }

    /**
     *Верните ближайший объект, пораженный лучом.
     *
     * @param int $rayID Идентификатор луча
     * @return int
     */
    function Get3DPhysicsRayCastClosestObjectHit($rayID)
    {
    }

    /**
     *Возвращает максимальный наклон в градусах.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function Get3DPhysicsCharacterControllerMaxSlope($objID)
    {
    }

    /**
     *Возвращает контроллер гравитации.
     *
     * @param int $objID идентификатор объекта
     * @return float
     */
    function Get3DPhysicsCharacterControllerGravity($objID)
    {
    }

    /**
     *Возвращает 1, если объект имеет контроллер, в противном случае 0.
     *
     * @param int $objID идентификатор объекта
     * @return int
     */
    function Get3DPhysicsCharacterControllerExists($objID)
    {
    }

    /**
     *Возвращает общее количество активных объектов в физическом мире.
     *
     * @return int
     */
    function Get3DPhysicsActiveObjects()
    {
    }

    /**
     *Возвращает текущее Z - положение излучателя, это точка, из которой будут появляться новые частицы. Невозможно получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesZ($ID)
    {
    }

    /**
     *Возвращает текущее положение X излучателя, это точка, из которой будут появляться новые частицы. Невозможно получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesX($ID)
    {
    }

    /**
     *Возвращает текущее положение Y излучателя, это точка, из которой будут появляться новые частицы. Невозможно получить положение отдельных частиц, они просто создаются, следуют по пути под влиянием сил, а затем исчезают.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesY($ID)
    {
    }

    /**
     *Возвращает 0, если данные частицы были установлены как невидимые с помощью Set3DParticlesVisible, или 1, если они в данный момент установлены как видимые (по умолчанию). Это не проверяет, находятся ли частицы в видимом окне просмотра.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function Get3DParticlesVisible($ID)
    {
    }

    /**
     *Возвращает текущий размер всех частиц в мировых координатах. Дополнительные сведения об установке размера частиц см. в разделе Set3DParticlesSize.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesSize($ID)
    {
    }

    /**
     *Возвращает 1, если излучатель испустил количество частиц, указанное в Set3DParticlesMax, и все испущенные частицы с тех пор умерли, в противном случае возвращает 0. Если максимальное значение равно -1, то оно всегда будет возвращать 0. Чтобы сбросить счетчик и заставить излучатель снова начать излучать, используйте Reset3DParticleCount.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function Get3DParticlesMaxReached($ID)
    {
    }

    /**
     *Возвращает текущую жизнь частиц в секундах. Невозможно получить текущую жизнь отдельных частиц. Это значение не зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesLife($ID)
    {
    }

    /**
     *Возвращает порог разрыва соединения.
     *
     * @param int $jointID Id соединения
     * @return int
     */
    function Get3DPhysicsJointEnabled($jointID)
    {
    }

    /**
     *Возвращает 1, если 3D-излучатель частиц существует с заданным идентификатором, и 0, если нет.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function Get3DParticlesExists($ID)
    {
    }

    /**
     *Возвращает z-компоненту направления излучателя, которое является базовым направлением движения частиц при их создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения Set3DParticlesDirection.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesDirectionZ($ID)
    {
    }

    /**
     *Возвращает y-компоненту направления излучателя, которое является базовым направлением движения частиц при их создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения Set3DParticlesDirection.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesDirectionY($ID)
    {
    }

    /**
     *Возвращает X-компоненту направления излучателя, которое является базовым направлением движения частиц при их создании. Частицы могут слегка изменять свое направление при излучении в зависимости от текущего значения Set3DParticlesDirection.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesDirectionX($ID)
    {
    }

    /**
     *Возвращает угол второго излучателя в градусах. Это значение представляет собой величину отклонения частицы от направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 360 означает, что частица может двигаться в любом направлении в этой плоскости при излучении.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesDirectionRange2($ID)
    {
    }

    /**
     *Возвращает 0, если данные частицы были приостановлены с помощью Set3DParticlesActive, или 1, если они в данный момент обновляются как обычно (по умолчанию).
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return int
     */
    function Get3DParticlesActive($ID)
    {
    }

    /**
     *Возвращает первый угол излучателя в градусах. Это значение представляет собой величину отклонения частицы от направления излучателя при излучении. Угол 0 означает, что отклонение отсутствует, а угол 360 означает, что частица может двигаться в любом направлении в этой плоскости при излучении.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesDirectionRange1($ID)
    {
    }

    /**
     *Отправляет счет на именованную доску лидеров, которая должна соответствовать идентификатору таблицы лидеров, присвоенному вашей доске в iTunes connect, Google Game Services или GameCircle.
     *
     * @param int $iScore Оценка для представления
     * @param string $szBoardID Название доски лидеров
     * @return void
     */
    function GameCenterSubmitScore($iScore, $szBoardID)
    {
    }

    /**
     *Изменение прогресса пользователей при достижении именованного достижения имя должно совпадать с идентификатором достижения, присвоенным этому достижению в iTunes connect, Google Game Services или GameCircle. Значения iPercentageComplete должны находиться в диапазоне от 0 до 100. Однако для инкрементных достижений это значение фактически является числом завершенных шагов и может находиться за пределами этого диапазона. Это значение будет перезаписывать текущий процент или выполненные шаги достижения.
     *
     * @param string $szAchievementID Название достижения
     * @param int $iPercentageComplete Пользователи продвигаются к получению этого достижения или количества выполненных шагов
     * @return void
     */
    function GameCenterSubmitAchievement($szAchievementID, $iPercentageComplete)
    {
    }

    /**
     *Показывает пользователю именованную таблицу лидеров, имя которой должно совпадать с идентификатором таблицы лидеров, присвоенным вашей доске в iTunes connect, Google Game Services или GameCircle.
     *
     * @param string $szBoardID Название доски лидеров
     * @return void
     */
    function GameCenterShowLeaderBoard($szBoardID)
    {
    }

    /**
     *Вызовите этот вызов один раз, чтобы настроить приложение для дальнейших команд Game Center.
     *
     * @return void
     */
    function GameCenterSetup()
    {
    }

    /**
     *Возвращает текущую частоту генерации частиц в частицах в секунду. Это значение не зависит от частоты кадров.
     *
     * @param int $ID Идентификатор излучателя для проверки.
     * @return float
     */
    function Get3DParticlesFrequency($ID)
    {
    }

    /**
     *Вызовите это один раз, чтобы войти в систему пользователя в Game Center (iOS) или Google Play Games (Android), если они вошли в систему до того, как это произойдет в фоновом режиме и не прерывает пользователя, в противном случае появится всплывающее окно с просьбой войти в систему и предоставить разрешение на продолжение.
     *
     * @return void
     */
    function GameCenterLogin()
    {
    }

    /**
     *Еще не функционирует
     *

     * @return void
     */
    function GameCenterAchievementsReset()
    {
    }

    /**
     *Показывает пользователю свои достижения и прогресс.
     *

     * @return void
     */
    function GameCenterAchievementsShow()
    {
    }

    /**
     *Вызовите эту функцию, чтобы вывести пользователя из Google Play Games. После этого вы можете снова вызвать GameCenterLogin. На Game Center (iOS) это никак не влияет, пользователь должен выйти из приложения Game Center.
     *
     * @return void
     */
    function GameCenterLogout()
    {
    }

    /**
     *Немедленно отправляет все ожидающие данные на удаленный хост. Если вы не вызовете этот вызов, то данные будут вечно ждать в буфере, пока вы не запишете в сокет более 1400 байт, после чего он автоматически будет сброшен. Каждый раз, когда вы вызываете эту команду, будет отправлен новый пакет, поэтому при отправке нескольких значений вы не должны вызывать его после каждого значения, так как это приведет к потере пропускной способности сети. Вы должны записать все значения, а затем сбросить их, чтобы они были отправлены вместе. Если нет данных, ожидающих отправки, эта команда ничего не делает. Возвращает 1, если сокет был успешно сброшен, 0, если сокет отключен.
     *
     * @param int $socketID Идентификатор сокета для проверки
     * @return int
     */
    function FlushSocket($socketID)
    {
    }

    /**
     *Округляет поплавок до следующего наименьшего целого числа. Это отличается от Trunc при использовании отрицательных чисел, Trunc( -1.6 ) равен -1, а Floor( -1.6 ) равен -2.
     *
     * @param float $a Значение для пола.
     * @return int
     */
    function Floor($a)
    {
    }

    /**
     *По умолчанию текстовые объекты создаются в мировых координатах, и SetViewOffset можно использовать для перемещения по всему миру. Используйте эту команду, чтобы вместо этого зафиксировать текст на экране, чтобы он перемещался вместе с видовым окном при перемещении видового окна. Вы все еще можете изменить положение текста, закрепленного на экране, это влияет только на то, что происходит при перемещении видового экрана.
     *
     * @param int $iTextIndex Идентификатор текста, который нужно изменить.
     * @param int $mode 1=экранный текст, 0=мировой текст
     * @return void
     */
    function FixTextToScreen($iTextIndex, $mode)
    {
    }

    /**
     *По умолчанию спрайты создаются в мировых координатах, и SetViewOffset можно использовать для перемещения по всему миру. Используйте эту команду, чтобы вместо этого зафиксировать спрайт на экране, чтобы он перемещался вместе с видовым окном при перемещении видового окна. Вы все еще можете изменить положение спрайта, который закреплен на экране, это влияет только на то, что происходит при перемещении видового экрана. Вы не должны использовать команды физики или столкновения для спрайтов, закрепленных на экране, так как их отладочные формы не будут выстраиваться в линию и будут мешать физическим спрайтам, не закрепленным на экране.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $mode 1=экранный спрайт, 0=мировой спрайт
     * @return void
     */
    function FixSpriteToScreen($iSpriteIndex, $mode)
    {
    }

    /**
     *Фиксирует указанный скелет на экране так, чтобы он не был затронут SetViewOffset
     *
     * @param int $iSkeleton Идентификатор скелета для изменения
     * @param int $mode 1 для фиксации на экране, 0 для нормального поведения (по умолчанию)
     * @return void
     */
    function FixSkeleton2DToScreen($iSkeleton, $mode)
    {
    }

    /**
     *Фиксация частиц на экране гарантирует, что они не будут затронуты прокруткой видового экрана.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param int $mode Используйте 1 для фиксации на экране. Используйте 0, чтобы позволить частицам быть затронутыми прокруткой.
     * @return void
     */
    function FixParticlesToScreen($ID, $mode)
    {
    }

    /**
     *Фиксирует объект к другому объекту, так что любое движение родителя также влияет на ребенка. Фиксируемый объект использует свое текущее положение, поворот и масштаб в качестве смещения по отношению к родительскому объекту. Например, если родитель был помещен в 10,5,0 и объект был закреплен на нем с текущей позицией 0,10,0, то ребенок теперь унаследует позицию родителя, объединит ее со своей собственной, и ребенок будет помещен в 10,15,0. То же самое относится к вращению и масштабированию, поэтому, если родитель был повернут вокруг оси Y, то и ребенок будет вращаться на ту же величину. Обратите внимание, что использование GetObjectY на дочернем объекте будет показывать только его локальное положение относительно родительского (в этом случае он вернет 10). Чтобы получить конечную мировую позицию ребенка, используйте GetObjectWorldY на нем, который в этом случае вернет 15. Нет предела количеству объектов, которые объект может зафиксировать на себе, и нет предела тому, чтобы объекты были зафиксированы на объектах, которые фиксированы на других объектах, просто не создавайте никаких циклов. Чтобы остановить фиксацию объекта к чему-либо, установите toObjID в 0, и он снова станет независимым.
     *
     * @param int $objID Идентификатор объекта для исправления.
     * @param int $toObjID Идентификатор объекта для его фиксации.
     * @return void
     */
    function FixObjectToObject($objID, $toObjID)
    {
    }

    /**
     *Аналогично FixObjectToObject, за исключением того, что родитель будет костью в другом объекте.
     *
     * @param int $objID Идентификатор объекта для исправления.
     * @param int $toObjID Идентификатор объекта для его фиксации.
     * @param int $toBoneIndex Указательный палец кости, чтобы зафиксировать его.
     * @return void
     */
    function FixObjectToBone($objID, $toObjID, $toBoneIndex)
    {
    }

    /**
     *По умолчанию спрайты и поля редактирования создаются в мировых координатах, а SetViewOffset можно использовать для перемещения по всему миру. Используйте эту команду, чтобы вместо этого зафиксировать поле редактирования на экране, чтобы оно перемещалось вместе с видовым окном при перемещении видового окна. Вы все еще можете изменить положение поля редактирования, закрепленного на экране, оно влияет только на то, что происходит при перемещении окна просмотра.
     *
     * @param int $index Идентификатор поля редактирования для изменения.
     * @param int $fix 0=двигаться при перемещении видового порта, 1=оставаться неподвижным на экране независимо от того, куда перемещается видовой порт.
     * @return void
     */
    function FixEditBoxToScreen($index, $fix)
    {
    }

    /**
     *Сбрасывает положение и вращение объекта на 0, сохраняя при этом вершины объекта там, где они находятся. Это можно использовать для изменения центра вращения объекта или настройки его ориентации по умолчанию, когда его вращение равно 0. Эта команда изменяет вершины сеток объекта, поэтому не рекомендуется вызывать ее каждый кадр, если только целевая платформа не является достаточно мощной, то есть Windows, Mac или Linux.
     *
     * @param int $objID Идентификатор объекта для изменения.
     * @return void
     */
    function FixObjectPivot($objID)
    {
    }

    /**
     *Запускает систему Firebase analytics и отслеживание некоторых автоматизированных событий. Дополнительные события можно отслеживать с помощью FirebaseLogEvent. Вы должны включить конфигурационный файл Google Services, созданный при настройке проекта Firebase, который можно добавить во время экспорта для Android или iOS. Если вы не укажете свой собственный конфигурационный файл google services во время экспорта, то все ваши данные отслеживания будут отправлены в наш проект AGK Firebase и проигнорированы. Аналогично, если вы используете эти команды во время трансляции, то данные отслеживания будут отправлены в проект AGK и проигнорированы.
     *
     * @return void
     */
    function FirebaseSetup()
    {
    }

    /**
     *Говорит Firebase записать событие, которое произошло в вашем приложении, например, разблокировку достижения. Они появятся на странице аналитики проекта Firebase. Обратите внимание, что имена событий не должны содержать тире или пробелы, иначе они не будут зарегистрированы.
     *
     * @param string $event_name Имя события для передачи в Firebase, некоторые из них зарезервированы для автоматических событий, например "first_open"
     * @return void
     */
    function FirebaseLogEvent($event_name)
    {
    }

    /**
     *Создает соединение шкива между двумя спрайтами. Это вторая половина двухкомандной установки. Из-за количества требуемых параметров вы должны сначала вызвать CreatePulleyJoint2 с начальным набором параметров для создания соединения. Эта команда возвращает идентификатор нового соединения.
     *
     * @param float $gnd1x Координата x первой наземной точки
     * @param float $gnd1y Координата y первой наземной точки
     * @param float $gnd2x Координата x второй точки заземления
     * @param float $gnd2y Координата y второй точки заземления
     * @param float $a1x Координата x первой опорной точки
     * @param float $a1y Координата y первой опорной точки
     * @param float $a2x Координата x второй опорной точки
     * @param float $a2y Координата y второй опорной точки
     * @return int
     */
    function FinishPulleyJoint($gnd1x, $gnd1y, $gnd2x, $gnd2y, $a1x, $a1y, $a2x, $a2y)
    {
    }

    /**
     *Возвращает индекс первого вхождения findStr в заданную строку, начиная с конца строки и двигаясь назад. Используйте начальное значение -1, чтобы начать с самого конца строки независимо от ее длины. Индекс 1-это первый символ в строке, возвращающий 0, если он не найден. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.
     *
     * @param string $str Строка для проверки
     * @param string $findStr Строка, которую нужно найти
     * @param int $ignoreCase 1-игнорировать регистр при поиске, 0
     * @param int $start Индекс для начала, первый символ находится в индексе 1, используйте минус 1, чтобы начать с самого конца
     * @return int
     */
    function FindStringReverse($str, $findStr, $ignoreCase, $start)
    {
    }

    /**
     *Возвращает индекс первого вхождения findStr в заданную строку, начиная с конца строки и двигаясь назад. Используйте начальное значение -1, чтобы начать с самого конца строки независимо от ее длины. Индекс 1-это первый символ в строке, возвращающий 0, если он не найден. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.
     *
     * @param string $str Строка для проверки
     * @param string $findStr Строка, которую нужно найти
     * @return int
     */
    function FindStringReverse($str, $findStr)
    {
    }

    /**
     *Прикрепляет указанный спрайт к заданному идентификатору скелета и кости. Идентификатор кости можно найти с помощью команды GetSkeleton2DBone. Когда спрайт прикреплен к кости скелета, его положение и вращение становятся относительно положения кости. Например, если положение спрайта равно 0,0, то он будет нарисован в том же положении, что и кость, но если положение равно 0,10, то спрайт будет нарисован над костью относительно кости, то есть если кость повернута влево на 90 градусов, то "выше" кости будет находиться слева от экрана в мировых координатах.  ZOrder может быть задан для рисования спрайта между двумя существующими спрайтами скелета, любое целочисленное значение является допустимым и соответствует текущему порядку спрайтов в скелете. Например, Z-порядок 0 всегда будет рисовать перед первым спрайтом в Z-порядке скелета, значение 1 всегда будет рисовать перед вторым спрайтом в скелете и так далее. Обратите внимание, что на это не влияют другие спрайты, которые вы прикрепили к скелету, он учитывает только те спрайты, которые изначально были загружены вместе со скелетом. Например, если вы прикрепили к скелету два новых спрайта с z-порядком, равным 1, то они оба будут нарисованы между первым и вторым спрайтами в исходном скелете. Любые спрайты, прикрепленные к скелету с использованием одного и того же значения zorder, будут нарисованы в том порядке, в котором они были прикреплены.  Пока этот спрайт прикреплен к скелету, он будет удален из обычных процедур рисования и нарисован только тогда, когда скелет виден. Вы все еще можете заставить спрайт рисовать, вызвав DrawSprite, но он не будет упорядочен с другими спрайтами в скелете.  Чтобы отделить спрайт от скелета, вызовите эту команду с 0 в качестве skeletonID, параметры bone ID и zorder в этом случае не имеют значения.
     *
     * @param int $spriteID Идентификатор спрайта для прикрепления
     * @param int $iSkeletonID Идентификатор скелета, к которому нужно прикрепиться
     * @param int $bone Идентификатор кости в скелете, к которой нужно прикрепиться
     * @param int $zorder ZOrder для размещения нового спрайта в порядке рисования скелета
     * @return void
     */
    function FixSpriteToSkeleton2D($spriteID, $iSkeletonID, $bone, $zorder)
    {
    }

    /**
     *Возвращает количество раз, когда findStr появляется в данной строке. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.
     *
     * @param string $str Строка для проверки
     * @param string $findStr Строка, которую нужно найти
     * @return int
     */
    function FindStringCount($str, $findStr)
    {
    }

    /**
     *Возвращает количество раз, когда findStr появляется в данной строке. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.
     *
     * @param string $str Строка для проверки
     * @param string $findStr Строка, которую нужно найти
     * @param int $ignoreCase 1-игнорировать регистр при поиске, 0
     * @param int $start Индекс, с которого нужно начать, первый символ находится в индексе 1
     * @return int
     */
    function FindStringCount($str, $findStr, $ignoreCase, $start)
    {
    }

    /**
     *Возвращает индекс первого вхождения findStr в заданную строку. Индекс 1-это первый символ в строке, возвращающий 0, если он не найден. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.
     *
     * @param string $str Строка для проверки
     * @param string $findStr Строка, которую нужно найти
     * @param int $ignoreCase 1-игнорировать регистр при поиске, 0
     * @param int $start Индекс, с которого нужно начать, первый символ находится в индексе 1
     * @return int
     */
    function FindString($str, $findStr, $ignoreCase, $start)
    {
    }

    /**
     *Возвращает индекс первого вхождения findStr в заданную строку. Индекс 1-это первый символ в строке, возвращающий 0, если он не найден. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру.
     *
     * @param string $str Строка для проверки
     * @param string $findStr Строка, которую нужно найти
     * @return int
     */
    function FindString($str, $findStr)
    {
    }

    /**
     *Заканчивает строительство тряпичной куклы. Вызовите эту команду, когда вы добавите все кости и суставы для вашей тряпичной куклы. Убедитесь, что вы сначала вызвали Create3DPhysicsRagDoll, прежде чем вызывать эту команду.
     *
     * @return void
     */
    function Finalize3DPhysicsRagDoll()
    {
    }

    /**
     *Возвращает 1, если данный файл был успешно открыт, и 0, если нет. Вы можете использовать GetErrorOccurred, чтобы проверить, было ли это результатом ошибки, и GetLastError, чтобы получить указанную ошибку.
     *
     * @param int $iFileID Идентификатор файла для проверки.
     * @return int
     */
    function FileIsOpen($iFileID)
    {
    }

    /**
     *Возвращает 1, если данный файл достиг конца своего потока данных, и 0 в противном случае. Используется только при чтении.
     *
     * @param int $iFileID Идентификатор файла для проверки.
     * @return int
     */
    function FileEOF($iFileID)
    {
    }

    /**
     *Эта команда в настоящее время не поддерживается
     *
     * @param string $szURL URL-адрес, который вам нравится.
     * @param int $iX x положение кнопки like.
     * @param int $iY y положение кнопки like.
     * @param int $iWidth ширина кнопки like.
     * @param int $iHeight высота кнопки like.
     * @return void
     */
    function FacebookShowLikeButton($szURL, $iX, $iY, $iWidth, $iHeight)
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @param string $szID ваш идентификатор приложения Facebook.
     * @return void
     */
    function FacebookSetup($szID)
    {
    }

    /**
     *Фиксирует камеру на объекте таким образом, что любое движение объекта также влияет на камеру. Камера использует свое текущее положение, поворот и масштаб в качестве смещения по отношению к объекту. Например, если объект был помещен в 10,5,0 и к нему была прикреплена камера с текущим положением 0,10,0, то камера теперь унаследует положение объекта, объединит его со своим собственным, и камера будет помещена в 10,15,0. То же самое относится к вращению и масштабированию, поэтому, если объект был повернут вокруг оси Y, то камера будет вращаться на ту же величину. Обратите внимание, что использование GetCameraY покажет только его локальное положение относительно родительского объекта (в этом случае он вернет 10). Чтобы получить конечное мировое положение камеры, используйте GetCameraWorldY, который в этом случае вернет 15. Нет предела количеству объектов или камер, которые объект может зафиксировать на себе, и нет предела тому, что объекты фиксируются на объектах, которые фиксируются на других объектах, просто не создавайте никаких петель. Чтобы остановить фиксацию камеры к чему-либо, установите ObjId в 0, и она снова станет независимой.
     *
     * @param int $cameraID Идентификатор камеры, которую нужно зафиксировать, должен быть равен 1
     * @param int $objID Идентификатор объекта для его фиксации.
     * @return void
     */
    function FixCameraToObject($cameraID, $objID)
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает. Вы можете использовать ShareText или ShareImage, чтобы дать пользователю возможность поделиться своей информацией.
     *

     * @return void
     */
    function FacebookPostOnMyWall($szLink, $szPicture, $szName, $szCaption, $szDescription)
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *

     * @return void
     */
    function FacebookPostOnFriendsWall($szID, $szLink, $szPicture, $szName, $szCaption, $szDescription)
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return string
     */
    function FacebookGetUserName()
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return string
     */
    function FacebookGetUserID()
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return int
     */
    function FacebookGetFriendsState()
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *

     * @return string
     */
    function FacebookGetFriendsName($iIndex)
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *

     * @return string
     */
    function FacebookGetFriendsID($iIndex)
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return int
     */
    function FacebookGetFriendsCount()
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return void
     */
    function FacebookLogout()
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return void
     */
    function FacebookLogin()
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return void
     */
    function FacebookGetFriends()
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *

     * @return void
     */
    function FacebookInviteFriend($szID, $szMessage)
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *
     * @return string
     */
    function FacebookGetAccessToken()
    {
    }

    /**
     *Facebook SDK был удален из AppGameKit, эта команда больше ничего не делает
     *

     * @return void
     */
    function FacebookDownloadFriendsPhoto($iIndex)
    {
    }

    /**
     *Facebook Facebook Facebook SDK Активирует отслеживание в SDK Facebook, это полезно, если вы используете рекламу Facebook, так как это будет связывать установки с рекламой, ранее увиденной и нажатой на Facebook. Обратите внимание, что в iOS эта функция требует IDFA (рекламный идентификатор), и вы должны объявить об этом, если отправляете приложение в Apple. Apple спросит, используете ли вы IDFA и для чего вы его используете. Для отслеживания установки с помощью рекламы Facebook вы ДОЛЖНЫ поставить галочки "Приписать установку этого приложения ранее показанной рекламе" и "Приписать действие, предпринятое в этом приложении, ранее показанной рекламе". Если вы также используете AdMob, Amazon Ads или Chartboost в своем приложении, вы также должны поставить галочку "Показывать рекламу в приложении". Эта команда не требует, чтобы пользователь входил в систему.
     *
     * @return void
     */
    function FacebookActivateAppTracking()
    {
    }

    /**
     *Эта команда в настоящее время не поддерживается
     *
     * @return void
     */
    function FacebookDestroyLikeButton()
    {
    }

    /**
     *Возвращает остаток от деления с плавающей запятой a/b.
     *
     * @param float $a Числитель.
     * @param float $b Знаменатель.
     * @return float
     */
    function FMod($a, $b)
    {
    }

    /**
     *Эта команда делает то же самое, что и ExtractZip, за исключением того, что она возвращается немедленно, а извлечение zip выполняется в потоке в фоновом режиме. Вы можете использовать GetZipExtractProgress и GetZipExtractComplete, чтобы проверить его прогресс. Если вы вызовете эту команду во время извлечения zip-файла, то ничего не произойдет. Если указанный почтовый индекс не имеет пароля, то используйте пустую строку.
     *
     * @param string $zipfilename Путь к zip-файлу для извлечения.
     * @param string $path Путь для размещения вновь извлеченных zip-файлов.
     * @param string $password Пароль, который был использован для создания zip-файла.
     * @return void
     */
    function ExtractZipASync($zipfilename, $path, $password)
    {
    }

    /**
     *Извлекает zip-файл в указанный каталог. Все папки, созданные внутри zip-файла, будут созданы в процессе извлечения. Если zip - файл защищен паролем, укажите пароль для его извлечения. Если вы укажете неправильный пароль, извлеченные файлы из zip-архива будут пусты. Локальный путь к файлу находится относительно текущего каталога, установленного с помощью SetFolder, если только вы не начинаете путь с прямой косой черты, и в этом случае путь будет относительно корня каталога записи на текущей платформе.
     *
     * @param string $zipfilename Путь к zip-файлу для извлечения.
     * @param string $path Путь для размещения вновь извлеченных zip-файлов.
     * @param string $password Пароль, который был использован для создания zip-файла.
     * @return void
     */
    function ExtractZip($zipfilename, $path, $password)
    {
    }

    /**
     *Извлекает zip-файл в указанный каталог. Все папки, созданные внутри zip-файла, будут созданы в процессе извлечения. Если zip - файл защищен паролем, укажите пароль для его извлечения. Если вы укажете неправильный пароль, извлеченные файлы из zip-архива будут пусты. Локальный путь к файлу находится относительно текущего каталога, установленного с помощью SetFolder, если только вы не начинаете путь с прямой косой черты, и в этом случае путь будет относительно корня каталога записи на текущей платформе.
     *
     * @param string $zipfilename Путь к zip-файлу для извлечения.
     * @param string $path Путь для размещения вновь извлеченных zip-файлов.
     * @return void
     */
    function ExtractZip($zipfilename, $path)
    {
    }

    /**
     *Задает, следует ли очищать буфер глубины при вызове Sync или Swap. По умолчанию это значение равно true. Отключать это не рекомендуется, так как все, что использует буфер глубины, будет появляться только в течение одного кадра, а затем, похоже, исчезнет. Эта функция может не иметь никакого влияния на мобильные устройства.
     *
     * @param int $clear Установите значение 1, чтобы очистить буфер глубины, и 0, чтобы не очистить его.
     * @return void
     */
    function EnableClearDepth($clear)
    {
    }

    /**
     *Кодирует данный текст в QR - код и возвращает новый идентификатор изображения, содержащий этот код. Вы можете выбрать количество исправлений ошибок, включенных в код, чтобы часть QR-кода была повреждена, но все еще была читабельной. Чем выше режим коррекции ошибок, тем больше вероятность того, что поврежденный или скрытый QR-код будет считан правильно, но более высокие режимы коррекции ошибок могут привести к увеличению QR-кода. Уровень 0 по-прежнему обеспечивает минимальный уровень исправления ошибок, а не никакой.
     *
     * @param string $text Текст для кодирования.
     * @param int $errormode Уровень исправления ошибок для включения в код от 0 (самый низкий) до 3 (самый высокий)
     * @return int
     */
    function EncodeQRCode($text, $errormode)
    {
    }

    /**
     *Задает, следует ли очищать буфер кадров при вызове Sync или Swap. По умолчанию это значение равно true. Единственная причина вызвать эту команду-это если у вас есть фоновый спрайт или набор спрайтов, которые полностью закрывают экран, так что цвет фона никогда не будет виден. В этих случаях некоторые графические процессоры могут извлечь выгоду из отключения четкого цвета. Обратите внимание, что во многих случаях последний нарисованный кадр останется на экране, однако это не гарантировано, и вы не должны создавать эффекты, которые полагаются на него, так как они могут не работать в будущем и не будут работать на мобильных устройствах. Для создания эффектов, сохраняющих содержимое предыдущего кадра, рекомендуется использовать SetRenderToImage для захвата выходных данных одного кадра, а затем нарисовать его в следующем кадре, то есть вы визуализируете все до изображения 1, затем в следующем кадре вы вставляете изображение 1 в фон новой цели рендеринга, а затем рисуете новый кадр. Например, нарисуйте все в кадре 1 к изображению 1, затем в кадре 2 вы нарисуете изображение 1 с полноэкранным четырехугольным объектом к изображению 2, а затем нарисуете все в кадре 2 к изображению 2. Затем вы можете поменять местами цели рендеринга так, чтобы в кадре 3 вы нарисовали изображение 2 с полноэкранным квадратом обратно в изображение 1, затем нарисуйте объекты в кадре 3 на изображение 1. Продолжайте чередовать изображение 1 и 2, чтобы в кадре 4 сначала было нарисовано изображение 1 с полноэкранным квадратом на изображение 2, а затем нарисуйте все в кадре 4 на изображение 2. Важно не продолжать рисовать все на одном и том же изображении, то есть рисовать кадр 1 на изображении 1, затем кадр 2 на изображении 1 и так далее, потому что мобильные устройства используют внутренний отложенный рендеринг, который будет держать все увеличивающийся список вещей, которые нужно нарисовать на изображении 1. Если изображение никогда не будет очищено, то производительность снизится.
     *
     * @param int $clear Установите значение 1, чтобы очистить буфер кадров, и 0, чтобы не очищать его.
     * @return void
     */
    function EnableClearColor($clear)
    {
    }

    /**
     *Сразу же рисует текст в backbuffer в его текущем положении, размере и повороте. Это полезно, если вы хотите настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться дважды в окончательном рендеринге.
     *
     * @param int $iTextIndex Идентификатор текста для рисования.
     * @return void
     */
    function DrawText($iTextIndex)
    {
    }

    /**
     *Немедленно рисует спрайт в backbuffer в его текущем положении, размере и вращении. Это полезно, если вы хотите настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться дважды в окончательном рендеринге.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для рисования.
     * @return void
     */
    function DrawSprite($iSpriteIndex)
    {
    }

    /**
     *Немедленно рисует объект к текущей цели рендеринга в его текущем положении, размере и повороте. Это полезно, если вы хотите нарисовать определенные объекты, такие как небесные ящики, перед любыми другими объектами. В этом случае обязательно сделайте объект невидимым для вызовов Render() или Sync (), иначе объект может появиться дважды.
     *
     * @param int $objID Идентификатор объекта для рисования.
     * @return void
     */
    function DrawObject($objID)
    {
    }

    /**
     *Немедленно притягивает излучатель частиц к обратному буферу в его текущем положении, размере и вращении. Это полезно, если вы хотите настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться дважды в окончательном рендеринге.
     *
     * @param int $ID Идентификатор излучателя для рисования.
     * @return void
     */
    function DrawParticles($ID)
    {
    }

    /**
     *Рисует 2D-прямоугольник из одной точки экрана в другую с выбранным цветом с помощью линий. Линии появляются над всеми другими чертежами, кроме команды Print, и могут использоваться с функцией getImage или SetRenderToImage для создания новых изображений. Координаты XY находятся в экранных координатах, поэтому команда SetViewOffset на них не влияет. Цвета могут быть созданы с помощью команды MakeColor или с помощью побитовых операторов типа so, mycolor = (blue
     *
     * @param float $x Компонент X в верхнем левом углу коробки.
     * @param float $y Компонент Y в верхнем левом углу коробки.
     * @param float $x2 Компонент X в правом нижнем углу коробки.
     * @param float $y2 Компонент Y в правом нижнем углу коробки.
     * @param int $color1 Цвет для использования в верхнем левом углу.
     * @param int $color2 Цвет для использования в правом верхнем углу.
     * @param int $color3 Цвет для использования в левом нижнем углу.
     * @param int $color4 Цвет для использования в правом нижнем углу.
     * @param int $filled 1, чтобы нарисовать заполненную коробку, 0, чтобы нарисовать пустую коробку.
     * @return void
     */
    function DrawBox($x, $y, $x2, $y2, $color1, $color2, $color3, $color4, $filled)
    {
    }

    /**
     *Рисует 2D-линию из одной точки экрана в другую с выбранным цветом. Линии появляются над всеми другими чертежами, кроме команды Print, и могут использоваться с функцией getImage для создания новых изображений. Координаты XY находятся в экранных координатах, поэтому команда SetViewOffset на них не влияет.
     *
     * @param float $x X-компонент начальной позиции линии.
     * @param float $y Компонент Y начального положения линии.
     * @param float $x2 X-составляющая конечного положения линии.
     * @param float $y2 Компонент Y конечного положения линии.
     * @param int $red Красная составляющая цвета линии.
     * @param int $green Зеленая составляющая цвета линии.
     * @param int $blue Синяя составляющая цвета линии.
     * @return void
     */
    function DrawLine($x, $y, $x2, $y2, $red, $green, $blue)
    {
    }

    /**
     *Рисует 2D-линию из одной точки экрана в другую с выбранным цветом. Линии появляются над всеми другими чертежами, кроме команды Print, и могут использоваться с функцией getImage для создания новых изображений. Координаты XY находятся в экранных координатах, поэтому команда SetViewOffset на них не влияет.
     *
     * @param float $x X-компонент начальной позиции линии.
     * @param float $y Компонент Y начального положения линии.
     * @param float $x2 X-составляющая конечного положения линии.
     * @param float $y2 Компонент Y конечного положения линии.
     * @param int $color1 Цвет, который будет использоваться в начале строки.
     * @param int $color2 Цвет, который нужно использовать в конце строки.
     * @return void
     */
    function DrawLine($x, $y, $x2, $y2, $color1, $color2)
    {
    }

    /**
     *Рисует 2D-эллипс с центром в координатах, заданных выбранным цветом или градиентом. 2D-фигуры появляются над всеми другими чертежами, кроме команды Print, и могут использоваться с функцией getImage для создания новых изображений. Координаты XY находятся в экранных координатах, поэтому команда SetViewOffset на них не влияет.
     *
     * @param float $x X-составляющая центра эллипса.
     * @param float $y Y-составляющая центра эллипса.
     * @param float $radiusx Радиус эллипса в направлении X.
     * @param float $radiusy Радиус эллипса в направлении Y.
     * @param int $color1 Цвет в верхней части эллипса.
     * @param int $color2 Цвет в нижней части эллипса.
     * @param int $filled 1=заполнено, 0=пусто.
     * @return void
     */
    function DrawEllipse($x, $y, $radiusx, $radiusy, $color1, $color2, $filled)
    {
    }

    /**
     *Запускает загрузку любого файла расширения, необходимого этой платформе и приложению, в настоящее время применимого только к Android. Если загрузка уже началась, это не имеет никакого эффекта. Вы можете использовать GetExpansionFileProgress для проверки хода загрузки и GetExpanionFileState для проверки ее завершения. После вызова этой команды вы должны дождаться, пока GetExpanionFileState вернет -1 (ошибка) или 3 (завершение) при отображении индикатора выполнения.
     *
     * @return void
     */
    function DownloadExpansionFile()
    {
    }

    /**
     *Немедленно притягивает частицы к backbuffer в его текущем положении, размере и вращении. Это полезно, если вы хотите настроить сцену для захвата getImage. Не забудьте использовать ClearScreen для очистки любого вашего собственного рисунка перед вызовом Sync или Render для фактического кадра, иначе ваш рисунок может появиться дважды в окончательном рендеринге.
     *
     * @param int $ID Идентификатор излучателя для рисования.
     * @return void
     */
    function Draw3DParticles($ID)
    {
    }

    /**
     *Останавливает любое воспроизводимое видео и удаляет любое загруженное видео из памяти.
     *
     * @return void
     */
    function DeleteVideo()
    {
    }

    /**
     *Удаляет виртуальную кнопку по заданному индексу. Никакие другие команды виртуальных кнопок не могут быть вызваны для этого индекса, если он не будет воссоздан с помощью AddVirtualButton.
     *
     * @param int $index Идентификатор виртуальной кнопки для удаления.
     * @return void
     */
    function DeleteVirtualButton($index)
    {
    }

    /**
     *Удаляет виртуальный джойстик и удаляет его с экрана. Никакие другие команды виртуального джойстика не могут быть вызваны на этом индексе, если он не воссоздан с помощью AddVirtualJoystick.
     *
     * @param int $index Идентификатор виртуального джойстика для удаления.
     * @return void
     */
    function DeleteVirtualJoystick($index)
    {
    }

    /**
     *Удаляет вектор
     *
     * @param int $vectorID Идентификатор вектора
     * @return void
     */
    function DeleteVector3($vectorID)
    {
    }

    /**
     *Удаляет цепочку и останавливает всех подростков, которые были связаны с ней. Любые подростки, которые были добавлены к нему, не затрагиваются и могут быть использованы в будущих цепочках.
     *
     * @param int $chainID Идентификатор удаляемой цепочки
     * @return void
     */
    function DeleteTweenChain($chainID)
    {
    }

    /**
     *Удалите заданный идентификатор анимации. Это может быть использовано для всех типов твинов, спрайтов, текста, объектов и т. Д.
     *
     * @param int $tweenID Идентификатор твина для удаления
     * @return void
     */
    function DeleteTween($tweenID)
    {
    }

    /**
     *Удаляет спрайт с заданным идентификатором.
     *
     * @param int $iSpriteIndex Идентификатор удаляемого спрайта
     * @return void
     */
    function DeleteSprite($iSpriteIndex)
    {
    }

    /**
     *Удалите звук по указанному номеру звука. Это также приведет к удалению всех экземпляров звука.
     *
     * @param int $iID Звуковой номер для удаления.
     * @return void
     */
    function DeleteSound($iID)
    {
    }

    /**
     *Останавливает прослушиватель сокета от получения соединений и освобождает идентификатор для повторного использования. Если какие-либо соединения все еще находятся в очереди и еще не собраны с помощью GetSocketListenerConnection, то они будут закрыты и удалены.
     *
     * @param int $listenerID Идентификатор прослушивателя для проверки
     * @return void
     */
    function DeleteSocketListener($listenerID)
    {
    }

    /**
     *Удаляет скелет с указанным идентификатором. Если в этом идентификаторе нет скелета, то ничего не происходит.
     *
     * @param int $iSkeleton Идентификатор скелета для удаления
     * @return void
     */
    function DeleteSkeleton2D($iSkeleton)
    {
    }

    /**
     *Удаляет идентификатор сокета, чтобы его можно было использовать снова. Если розетка в данный момент подключена, то сначала соединение закрывается.
     *
     * @param int $socketID Идентификатор сокета для удаления
     * @return void
     */
    function DeleteSocket($socketID)
    {
    }

    /**
     *Удаляет общую переменную по имени. Если переменная не существует, то это ничего не даст. Как только переменная будет удалена, LoadSharedVariable вернет значение по умолчанию для любых запросов на ее загрузку.
     *
     * @param string $varName Имя переменной для удаления
     * @return void
     */
    function DeleteSharedVariable($varName)
    {
    }

    /**
     *Удаляет указанный UDP-listenere и освобождает порт, который он использовал.
     *
     * @param int $listenerID Идентификатор прослушивателя для удаления
     * @return void
     */
    function DeleteUDPListener($listenerID)
    {
    }

    /**
     *Удаляет указанный точечный свет. Если точечный свет не существует, эта команда ничего не делает.
     *
     * @param int $lightID Идентификатор света, который нужно удалить.
     * @return void
     */
    function DeletePointLight($lightID)
    {
    }

    /**
     *Удаляет указанную глобальную силу.
     *
     * @param int $iForceIndex Идентификатор силы для удаления.
     * @return void
     */
    function DeletePhysicsForce($iForceIndex)
    {
    }

    /**
     *Удаляет текстовый объект.
     *
     * @param int $iTextIndex Идентификатор текстового объекта для удаления.
     * @return void
     */
    function DeleteText($iTextIndex)
    {
    }

    /**
     *Удаляет излучатель частиц и все его частицы. Если какие-либо частицы были в данный момент видны, они мгновенно исчезнут.
     *
     * @param int $ID Идентификатор излучателя для удаления.
     * @return void
     */
    function DeleteParticles($ID)
    {
    }

    /**
     *Удаляет объект с заданным идентификатором, если объект не существует, то эта команда ничего не делает. Эта команда также удаляет все дочерние объекты, которые были созданы при загрузке этого объекта, если вы не хотите их удалять, то вместо этого используйте DeleteObject. Если вы используете эту команду для объекта, который был загружен с помощью LoadObject, то он удаляет его как обычно.
     *
     * @param int $objID Идентификатор объекта для удаления.
     * @return void
     */
    function DeleteObjectWithChildren($objID)
    {
    }

    /**
     *Удаляет объект с заданным идентификатором, если объект не существует, то эта команда ничего не делает. Эта команда также удаляет все дочерние объекты, созданные при загрузке этого объекта, и все объекты, которые в данный момент прикреплены к этому объекту, из использования FixObjectToObject или FixObjectToBone.
     *
     * @param int $objID Идентификатор объекта для удаления.
     * @return void
     */
    function DeleteObjectTree($objID)
    {
    }

    /**
     *Удаляет объект с заданным идентификатором, если объект не существует, то эта команда ничего не делает. Обратите внимание, что если объект был загружен с помощью LoadObjectWithChildren, то все дочерние объекты, созданные в ходе этого процесса загрузки, не будут удалены этой командой. Вы можете использовать GetObjectChildID для получения и удаления этих объектов вручную или использовать DeleteObjectWithChildren для удаления всего, что было создано при загрузке этого объекта.
     *
     * @param int $objID Идентификатор удаляемого объекта.
     * @return void
     */
    function DeleteObject($objID)
    {
    }

    /**
     *Удаляет сетевое сообщение, это должно быть вызвано для сообщений, полученных от сетевых устройств, и сообщений, которые не были отправлены на сетевое устройство (если код решает отказаться от отправки сообщения). Сообщения, которые были созданы и отправлены, будут обработаны и удалены сетевым кодом и не должны быть удалены с помощью этой команды.
     *
     * @param int $iMsgID Идентификатор сообщения для чтения.
     * @return void
     */
    function DeleteNetworkMessage($iMsgID)
    {
    }

    /**
     *Удаляет отключенный клиент из списка клиентов. Если эта функция вызывается на клиенте, который не отключен, она вызовет ошибку и не повлияет на клиента. Не удаляет клиент сразу, фоновый код может занять несколько кадров, чтобы обойти его удаление. Вызов этой команды несколько раз на отключенном клиенте не должен вызывать проблем.
     *
     * @param int $iNetID Идентификатор сети для проверки.
     * @param int $client идентификатор клиента для удаления.
     * @return void
     */
    function DeleteNetworkClient($iNetID, $client)
    {
    }

    /**
     *Удаляет музыкальный файл и освобождает идентификатор для повторного использования.
     *
     * @param int $musicID Идентификатор музыкального файла для удаления
     * @return void
     */
    function DeleteMusicOGG($musicID)
    {
    }

    /**
     *Удаляет музыкальный файл из списка воспроизведения.
     *
     * @param int $iID Идентификатор музыки, которую нужно удалить.
     * @return void
     */
    function DeleteMusic($iID)
    {
    }

    /**
     *Удаляет memblock с заданным идентификатором. Если memblock не существует или уже был удален, то эта команда ничего не делает.
     *
     * @param int $memID Идентификатор удаляемого мемблока.
     * @return void
     */
    function DeleteMemblock($memID)
    {
    }

    /**
     *Удаляет шейдер и освобождает идентификатор. Шейдер в данный момент не должен быть назначен ни одному объекту, сетке, квадрату или спрайту, иначе он может вызвать сбой при попытке рисования.
     *
     * @param int $shaderID Идентификатор шейдера для удаления
     * @return void
     */
    function DeleteShader($shaderID)
    {
    }

    /**
     *Удалите изображение из глобального хранилища, используя его идентификатор.
     *
     * @param int $iImageIndex Идентификатор удаляемого изображения
     * @return void
     */
    function DeleteImage($iImageIndex)
    {
    }

    /**
     *Удаляет соединение и позволяет соединенным спрайтам снова свободно перемещаться. Стыки следует удалять перед спрайтами. Зубчатые соединения должны быть удалены до тех соединений, от которых они зависят. Удаление несуществующего соединения не приведет к ошибке.
     *
     * @param int $iJointIndex Идентификатор соединения для удаления.
     * @return void
     */
    function DeleteJoint($iJointIndex)
    {
    }

    /**
     *Удаляет шрифт с заданным идентификатором. Шрифт в настоящее время не должен использоваться никакими текстовыми объектами.
     *
     * @param int $iFontID Идентификатор шрифта для удаления.
     * @return void
     */
    function DeleteFont($iFontID)
    {
    }

    /**
     *Удаляет ранее созданное HTTP-соединение.
     *
     * @param int $iHTTP Идентификатор соединения для удаления.
     * @return void
     */
    function DeleteHTTPConnection($iHTTP)
    {
    }

    /**
     *Удаляет папку по текущему пути. По умолчанию это определяется командой SetFolder. Вы также можете использовать имя файла, начинающееся с "raw:", чтобы удалить папку в любом месте файловой системы, например DeleteFolder("raw:C:\Temp\MyFolder"). Для успешного выполнения этой команды папка должна быть пустой.
     *
     * @param string $szName Имя папки create.
     * @return void
     */
    function DeleteFolder($szName)
    {
    }

    /**
     *Удаляет широковещательный прослушиватель и освобождает порт для прослушивания на нем чего-то другого.
     *
     * @param int $iID Идентификатор прослушивателя широковещательной передачи для удаления.
     * @return void
     */
    function DeleteBroadcastListener($iID)
    {
    }

    /**
     *Удаляет любое поле редактирования с заданным идентификатором.
     *
     * @param int $index Идентификатор поля редактирования для удаления.
     * @return void
     */
    function DeleteEditBox($index)
    {
    }

    /**
     *Удаляет переменную с указанным именем и удаляет все данные, хранящиеся в облаке для этой переменной. Если переменная не существует, то это ничего не делает.
     *
     * @param string $varName Имя переменной, которую нужно удалить, должно быть меньше 64 байт
     * @return void
     */
    function DeleteCloudDataVariable($varName)
    {
    }

    /**
     *Удаляет все текстовые объекты, созданные с помощью CreateText. Это также сбрасывает идентификатор автотекста до 10000.
     *
     * @return void
     */
    function DeleteAllText()
    {
    }

    /**
     *Удаляет все спрайты, созданные с помощью CreateSprite, CreateDummySprite или LoadSprite. Это также сбрасывает идентификатор автоматического спрайта до 10000.
     *
     * @return void
     */
    function DeleteAllSprites()
    {
    }

    /**
     *Удаляет все объекты, созданные с идентификатором. Это также сбрасывает идентификатор автоматического объекта до 10000.
     *
     * @return void
     */
    function DeleteAllObjects()
    {
    }

    /**
     *Удаляет все изображения, загруженные LoadImage или LoadSubImage. Это также сбрасывает автоматический идентификатор изображения до 10000.
     *
     * @return void
     */
    function DeleteAllImages()
    {
    }

    /**
     *Удаляет весь мир 3D - физики.
     *
     * @return void
     */
    function Delete3DPhysicsWorld()
    {
    }

    /**
     *Удаляет статическую плоскость.
     *
     * @param int $planeID статический идентификатор плоскости
     * @return void
     */
    function Delete3DPhysicsStaticPlane($planeID)
    {
    }

    /**
     *Очищает ранее показанное объявление.
     *
     * @return void
     */
    function DeleteAdvert()
    {
    }

    /**
     *Удаляет физический луч и все связанные с ним данные.
     *
     * @param int $rayID Идентификатор луча для удаления.
     * @return void
     */
    function Delete3DPhysicsRay($rayID)
    {
    }

    /**
     *Удаляет тряпичную куклу для объекта.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Delete3DPhysicsRagdoll($objID)
    {
    }

    /**
     *Удаляет данный файл из папки записи. Пути к файлам должны быть относительными, а не абсолютными, вы не можете удалять файлы из папки приложения или из другого места на диске.
     *
     * @param string $szFile Имя файла для удаления.
     * @return void
     */
    function DeleteFile($szFile)
    {
    }

    /**
     *Удаляет физический стык
     *
     * @param int $jointID Id соединения
     * @return void
     */
    function Delete3DPhysicsJoint($jointID)
    {
    }

    /**
     *Удаляет контроллер для объекта.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Delete3DPhysicsCharacterController($objID)
    {
    }

    /**
     *Удаляет соединение кирки.
     *
     * @param int $jointID Id соединения
     * @return void
     */
    function Delete3DPhysicsPickJoint($jointID)
    {
    }

    /**
     *Удаляет 3D-излучатель частиц и все его частицы. Если какие-либо частицы были в данный момент видны, они мгновенно исчезнут.
     *
     * @param int $ID Идентификатор излучателя для удаления.
     * @return void
     */
    function Delete3DParticles($ID)
    {
    }

    /**
     *Попытка декодировать QR - код и вернуть строку, закодированную в нем. Возвращает пустую строку, если он не смог найти QR-код на изображении или не смог его декодировать. Несколько QR-кодов на изображении, скорее всего, приведут к сбою декодирования.
     *
     * @param int $image Идентификатором изображения, подлежащего декодированию, может быть изображение, снятое с камеры
     * @return string
     */
    function DecodeQRCode($image)
    {
    }

    /**
     *Показывает объекты капсулы, представляющие контроллер.
     *
     * @param int $objID идентификатор объекта
     * @param int $isDebug 1 = истина, 0 = ложь
     * @return void
     */
    function Debug3DPhysicsCharacterController($objID, $isDebug)
    {
    }

    /**
     *Вызовите цикл перед физикой шага. Рисует отладочное наложение 3D-физического мира. Примечание: Эта команда в настоящее время не работает, требуется возможность рисовать каркас в AGK.
     *
     * @return void
     */
    function Debug3DPhysicsWorld()
    {
    }

    /**
     *Создает zip-файл в указанном месте и открывает его готовым для добавления файлов. Файлы не могут быть прочитаны или извлечены из zip-файла с помощью этой команды. Используйте ExtractZip для извлечения файлов из него. Путь к файлу относится к текущему каталогу, установленному с помощью SetFolder, если только вы не начинаете путь с прямой косой черты, и в этом случае путь будет относительно корня каталога записи на текущей платформе.
     *
     * @param string $filename Имя файла и путь к этому новому zip-файлу.
     * @return int
     */
    function CreateZip($filename)
    {
    }

    /**
     *Создает zip-файл в указанном месте и открывает его готовым для добавления файлов. Файлы не могут быть прочитаны или извлечены из zip-файла с помощью этой команды. Используйте ExtractZip для извлечения файлов из него. Путь к файлу относится к текущему каталогу, установленному с помощью SetFolder, если только вы не начинаете путь с прямой косой черты, и в этом случае путь будет относительно корня каталога записи на текущей платформе.
     *
     * @param int $zipID Идентификатор, используемый для ссылки на этот zip-файл.
     * @param string $filename Имя файла и путь к этому новому zip-файлу.
     * @return void
     */
    function CreateZip($zipID, $filename)
    {
    }

    /**
     *Создает сварное соединение между двумя спрайтами. Сварное соединение пытается ограничить все относительные перемещения и вращения между двумя спрайтами. Укажите единственную опорную точку в мировых координатах со спрайтами, уже находящимися в нужных позициях. Соединение не является идеальным креплением, и при достаточно большом усилии спрайты могут сдвинуться с места. Точка привязки может быть смещена от центральных положений спрайта. Соединение может быть удалено системой, если какой-либо из спрайтов, которые он соединяет, будет удален.
     *
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return void
     */
    function CreateWeldJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $colConnected)
    {
    }

    /**
     *Создает сварное соединение между двумя спрайтами. Сварное соединение пытается ограничить все относительные перемещения и вращения между двумя спрайтами. Укажите единственную опорную точку в мировых координатах со спрайтами, уже находящимися в нужных позициях. Соединение не является идеальным креплением, и при достаточно большом усилии спрайты могут сдвинуться с места. Точка привязки может быть смещена от центральных положений спрайта. Соединение может быть удалено системой, если какой-либо из спрайтов, которые он соединяет, будет удален.
     *
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return int
     */
    function CreateWeldJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $colConnected)
    {
    }

    /**
     *Создает вектор и заполняет его переданными значениями. Возвращает идентификатор вектора
     *
     * @param float $x x компонент вектора
     * @param float $y Компонент y вектора
     * @param float $z z компонент вектора
     * @return int
     */
    function CreateVector3($x, $y, $z)
    {
    }

    /**
     *Создает вектор и заполняет его переданными значениями. Возвращает идентификатор вектора
     *
     * @return int
     */
    function CreateVector3()
    {
    }

    /**
     *Создает текстовую анимацию с заданной длительностью и возвращает для нее идентификатор. Эта анимация-всего лишь шаблон, который может быть применен к нескольким текстовым объектам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с текстовым твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param float $duration Продолжительность анимации в секундах
     * @return int
     */
    function CreateTweenText($duration)
    {
    }

    /**
     *Создает текстовую анимацию с заданной длительностью и возвращает для нее идентификатор. Эта анимация-всего лишь шаблон, который может быть применен к нескольким текстовым объектам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с текстовым твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return void
     */
    function CreateTweenText($tweenID, $duration)
    {
    }

    /**
     *Создает прослушиватель UDP, который будет получать UDP-пакеты по указанному IP-адресу и порту. Значение порта должно находиться в диапазоне от 1 до 65535, хотя значения ниже 1024, скорее всего, будут защищены операционной системой. Если порт уже занят, то эта команда завершится ошибкой и вернет 0. IP-адрес может быть адресом IPv4 или IPv6 и может использоваться для привязки к одному входящему сетевому соединению, когда устройство имеет более одного IP-адреса. Для привязки к любому IP-адресу используйте IP-адрес "anyip4" или "anyip6". Один прослушиватель UDP может прослушивать либо IPv4, либо IPv6-адрес, но не оба одновременно. Для прослушивания обоих вы должны создать два прослушивателя, один для IPv4 и один для IPv6, в этом случае они оба могут использовать один и тот же порт. Эта команда вернет идентификатор прослушивателя, который вы можете использовать для ссылки на него в будущих командах.
     *
     * @param int $listenerID Идентификатор, который будет использоваться для ссылки на этот прослушиватель в будущем.
     * @param string $ip Локальный IP-адрес для привязки.
     * @param int $port Локальный порт для привязки.
     * @return int
     */
    function CreateUDPListener($listenerID, $ip, $port)
    {
    }

    /**
     *Создает прослушиватель UDP, который будет получать UDP-пакеты по указанному IP-адресу и порту. Значение порта должно находиться в диапазоне от 1 до 65535, хотя значения ниже 1024, скорее всего, будут защищены операционной системой. Если порт уже занят, то эта команда завершится ошибкой и вернет 0. IP-адрес может быть адресом IPv4 или IPv6 и может использоваться для привязки к одному входящему сетевому соединению, когда устройство имеет более одного IP-адреса. Для привязки к любому IP-адресу используйте IP-адрес "anyip4" или "anyip6". Один прослушиватель UDP может прослушивать либо IPv4, либо IPv6-адрес, но не оба одновременно. Для прослушивания обоих вы должны создать два прослушивателя, один для IPv4 и один для IPv6, в этом случае они оба могут использовать один и тот же порт. Эта команда вернет идентификатор прослушивателя, который вы можете использовать для ссылки на него в будущих командах.
     *
     * @param string $ip Локальный IP-адрес для привязки.
     * @param int $port Локальный порт для привязки.
     * @return int
     */
    function CreateUDPListener($ip, $port)
    {
    }

    /**
     *Создает анимацию спрайта с заданной длительностью и возвращает для нее идентификатор. Эта анимация-просто шаблон, который может быть применен к нескольким спрайтам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с текстовым твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param float $duration Продолжительность анимации в секундах
     * @return int
     */
    function CreateTweenSprite($duration)
    {
    }

    /**
     *Создает анимацию спрайта с заданной длительностью и возвращает для нее идентификатор. Эта анимация-просто шаблон, который может быть применен к нескольким спрайтам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с текстовым твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return void
     */
    function CreateTweenSprite($tweenID, $duration)
    {
    }

    /**
     *Создает пользовательскую анимацию с заданной длительностью и возвращает для нее идентификатор. Эта анимация не связана ни с каким элементом, и ее значения можно считывать во время работы. Это делает его полезным для управления значениями, которые не покрываются ни одним из других шаблонов анимации. Все типы твинов используют одно и то же пространство идентификаторов, поэтому пользовательский твин с идентификатором 1 не может существовать одновременно со спрайтовым твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, до 4 значений с плавающей точкой и 4 целочисленных значений, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param float $duration Продолжительность анимации в секундах
     * @return int
     */
    function CreateTweenCustom($duration)
    {
    }

    /**
     *Создает пользовательскую анимацию с заданной длительностью и возвращает для нее идентификатор. Эта анимация не связана ни с каким элементом, и ее значения можно считывать во время работы. Это делает его полезным для управления значениями, которые не покрываются ни одним из других шаблонов анимации. Все типы твинов используют одно и то же пространство идентификаторов, поэтому пользовательский твин с идентификатором 1 не может существовать одновременно со спрайтовым твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, до 4 значений с плавающей точкой и 4 целочисленных значений, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return void
     */
    function CreateTweenCustom($tweenID, $duration)
    {
    }

    /**
     *Создает объект tween с заданной длительностью и возвращает для него ИДЕНТИФИКАТОР. Эта анимация-просто шаблон, который может быть применен к нескольким объектам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с объектным твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param float $duration Продолжительность анимации в секундах
     * @return int
     */
    function CreateTweenObject($duration)
    {
    }

    /**
     *Создает объект tween с заданной длительностью и возвращает для него ИДЕНТИФИКАТОР. Эта анимация-просто шаблон, который может быть применен к нескольким объектам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с объектным твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return void
     */
    function CreateTweenObject($tweenID, $duration)
    {
    }

    /**
     *Удаляет физическое тело из мира и удаляет его.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Delete3DPhysicsBody($objID)
    {
    }

    /**
     *Создает символ tween с заданной длительностью и возвращает для него ИДЕНТИФИКАТОР. Это может быть применено к отдельным символам текстового объекта. Эта анимация-всего лишь шаблон, который может быть применен к нескольким текстовым символам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с char-твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param float $duration Продолжительность анимации в секундах
     * @return int
     */
    function CreateTweenChar($duration)
    {
    }

    /**
     *Создает символ tween с заданной длительностью и возвращает для него ИДЕНТИФИКАТОР. Это может быть применено к отдельным символам текстового объекта. Эта анимация-всего лишь шаблон, который может быть применен к нескольким текстовым символам или цепочкам одновременно. Все типы твинов разделяют одно и то же пространство идентификаторов, поэтому спрайт-твин с идентификатором 1 не может существовать одновременно с char-твином с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return void
     */
    function CreateTweenChar($tweenID, $duration)
    {
    }

    /**
     *Создает анимацию камеры с заданной длительностью и возвращает для нее идентификатор. Эта анимация-всего лишь шаблон, который может быть применен к нескольким камерам или цепочкам одновременно. Все типы твинов используют одно и то же пространство идентификаторов, поэтому твин камеры с идентификатором 1 не может существовать одновременно с твином объекта с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param float $duration Продолжительность анимации в секундах
     * @return int
     */
    function CreateTweenCamera($duration)
    {
    }

    /**
     *Создает анимацию камеры с заданной длительностью и возвращает для нее идентификатор. Эта анимация-всего лишь шаблон, который может быть применен к нескольким камерам или цепочкам одновременно. Все типы твинов используют одно и то же пространство идентификаторов, поэтому твин камеры с идентификатором 1 не может существовать одновременно с твином объекта с идентификатором 1. Вы можете установить несколько параметров для этой анимации, таких как положение X и Угол, которые будут перемещаться от их начальных значений к конечным значениям в течение заданной продолжительности.
     *
     * @param int $tweenID Идентификатор твина
     * @param float $duration Продолжительность анимации в секундах
     * @return void
     */
    function CreateTweenCamera($tweenID, $duration)
    {
    }

    /**
     *Создает цепочку твинов, которую можно использовать для заказа подростков, чтобы они играли один за другим. Цепочка анимаций может содержать несколько спрайтов, символов, объектов и т. Д., Так что анимация камеры может быть запущена после завершения анимации спрайтов или наоборот. Несколько цепочек могут быть применены к одним и тем же спрайтам, объектам или другим объектам до тех пор, пока цепочки не изменяют один и тот же параметр одновременно. Например, если цепочка 1 начинается с изменения значения X спрайта и воспроизводится одновременно с цепочкой 2, которая также начинает изменять значение X того же спрайта, то одна цепочка перезапишет изменения другой. В противном случае несколько цепочек на одном и том же спрайте будут работать правильно.
     *
     * @return int
     */
    function CreateTweenChain()
    {
    }

    /**
     *Создает цепочку твинов, которую можно использовать для заказа подростков, чтобы они играли один за другим. Цепочка анимаций может содержать несколько спрайтов, символов, объектов и т. Д., Так что анимация камеры может быть запущена после завершения анимации спрайтов или наоборот. Несколько цепочек могут быть применены к одним и тем же спрайтам, объектам или другим объектам до тех пор, пока цепочки не изменяют один и тот же параметр одновременно. Например, если цепочка 1 начинается с изменения значения X спрайта и воспроизводится одновременно с цепочкой 2, которая также начинает изменять значение X того же спрайта, то одна цепочка перезапишет изменения другой. В противном случае несколько цепочек на одном и том же спрайте будут работать правильно.
     *
     * @param int $chainID Идентификатор цепочки
     * @return void
     */
    function CreateTweenChain($chainID)
    {
    }

    /**
     *Создает текстовый объект для отображения текста на экране с помощью пустого идентификатора, возвращает используемый идентификатор. По умолчанию текст рисуется на глубине 9 выше глубины спрайтов по умолчанию (10). Любые спрайты, установленные на глубину 8 или меньше, будут отображаться над текстом. Вы можете переопределить это с помощью SetTextDepth, чтобы установить свой собственный порядок розыгрыша.
     *
     * @param string $string Начальная строка, используемая в этом текстовом объекте, может быть пустой строкой.
     * @return int
     */
    function CreateText($string)
    {
    }

    /**
     *Создает текстовый объект для отображения текста на экране с помощью пустого идентификатора, возвращает используемый идентификатор. По умолчанию текст рисуется на глубине 9 выше глубины спрайтов по умолчанию (10). Любые спрайты, установленные на глубину 8 или меньше, будут отображаться над текстом. Вы можете переопределить это с помощью SetTextDepth, чтобы установить свой собственный порядок розыгрыша.
     *
     * @param int $iTextIndex Текстовый идентификатор, который будет использоваться для ссылки на этот текст позже (отдельно от идентификаторов изображений и спрайтов, поэтому может быть как спрайт 1, так и текст 1)
     * @param string $string Начальная строка, используемая в этом текстовом объекте, может быть пустой строкой.
     * @return void
     */
    function CreateText($iTextIndex, $string)
    {
    }

    /**
     *Приседает контроллер
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Crouch3DPhysicsCharacterController($objID)
    {
    }

    /**
     *Создает спрайт в пустом идентификаторе спрайта с изображением, используемым при рендеринге, и возвращает используемый идентификатор спрайта. По умолчанию спрайты создаются с глубиной 10, имеют размер, используя данное изображение в качестве направляющей, и позиционируются на 0,0, используя их верхний левый угол. Вы можете использовать идентификатор изображения 0 для создания пустого спрайта, нарисованного только цветом. Если назначенное изображение имеет альфа-пиксели, то спрайт создается с режимом прозрачности 1, в противном случае он использует режим прозрачности 0 (непрозрачный)
     *
     * @param int $iImageIndex Идентификатор изображения, которое будет использоваться при рисовании этого спрайта
     * @return int
     */
    function CreateSprite($iImageIndex)
    {
    }

    /**
     *Создает спрайт в пустом идентификаторе спрайта с изображением, используемым при рендеринге, и возвращает используемый идентификатор спрайта. По умолчанию спрайты создаются с глубиной 10, имеют размер, используя данное изображение в качестве направляющей, и позиционируются на 0,0, используя их верхний левый угол. Вы можете использовать идентификатор изображения 0 для создания пустого спрайта, нарисованного только цветом. Если назначенное изображение имеет альфа-пиксели, то спрайт создается с режимом прозрачности 1, в противном случае он использует режим прозрачности 0 (непрозрачный)
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который будет использоваться для ссылки на этот спрайт позже (отдельно от идентификаторов изображений, поэтому может быть как спрайт 1, так и изображение 1)
     * @param int $iImageIndex Идентификатор изображения, которое будет использоваться при рисовании этого спрайта
     * @return void
     */
    function CreateSprite($iSpriteIndex, $iImageIndex)
    {
    }

    /**
     *Создает звук из мемблока. Memblock должен существовать, это создает новый звук и возвращает идентификатор. Это не повлияет ни на какие уже воспроизводимые звуковые экземпляры, только на будущие. Memblock должен содержать допустимый OGG-файл, например загруженный CreateMemblockFromFile(memID, "sound.ogg")
     *
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return int
     */
    function CreateSoundFromOGGMemblock($memID)
    {
    }

    /**
     *Создает звук из мемблока. Memblock должен существовать, это создает новый звук и возвращает идентификатор. Это не повлияет ни на какие уже воспроизводимые звуковые экземпляры, только на будущие. Memblock должен содержать допустимый OGG-файл, например загруженный CreateMemblockFromFile(memID, "sound.ogg")
     *
     * @param int $soundID Идентификатор звука для создания или изменения.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return void
     */
    function CreateSoundFromOGGMemblock($soundID, $memID)
    {
    }

    /**
     *Создает прослушиватель сокетов, который прослушивает на указанном порту входящие соединения сокетов. Когда соединение происходит, оно будет удерживаться в очереди до тех пор, пока вы не получите его с помощью GetSocketListenerConnection. Если вы хотите отклонить соединение, вы должны получить его, а затем удалить. Прослушиватель будет продолжать принимать соединения до тех пор, пока он не будет удален. Если ваше устройство имеет несколько сетевых интерфейсов, то вы можете указать, какой из них будет прослушиваться с помощью параметра IP-адрес. Для прослушивания всех интерфейсов используйте пустую строку в качестве IP-адреса. Если устройство имеет оба адреса IPv4 и IPv6, то слушатель может слушать только один или другой, а не оба. Для прослушивания соединений IPv4 и IPv6 необходимо создать два прослушивателя: один для соединений IPv4 и один для соединений IPv6. Соединения из любого из них будут вести себя точно так же после того, как они будут подключены. Чтобы создать прослушиватель IPv6, передайте IPv6 IP-адрес CreateSocketListener или "anyip6" для прослушивания любого подходящего IPv6-адреса. Если вы передадите пустую строку или "anyip4" в качестве IP-адреса, то он будет прослушивать IPv4-соединения. Вы можете иметь несколько активных слушателей одновременно, но все они должны использовать разные порты или IP-адреса. При выборе номера порта следует избегать низких значений, так как они часто будут использоваться другими приложениями и сервисами. Если что-то уже прослушивает порт, то ваша попытка прослушать его потерпит неудачу. Возвращает 0, если он не смог начать прослушивание.
     *
     * @param int $listenerID Идентификатор, который будет использоваться для ссылки на этот прослушиватель в будущем
     * @param string $szIP IP-адрес интерфейса для прослушивания может быть IPv4 или IPv6, или "anyip4", или "anyip6"
     * @param int $port TCP-порт для прослушивания находится в диапазоне от 1025 до 65535
     * @return int
     */
    function CreateSocketListener($listenerID, $szIP, $port)
    {
    }

    /**
     *Создает прослушиватель сокетов, который прослушивает на указанном порту входящие соединения сокетов. Когда соединение происходит, оно будет удерживаться в очереди до тех пор, пока вы не получите его с помощью GetSocketListenerConnection. Если вы хотите отклонить соединение, вы должны получить его, а затем удалить. Прослушиватель будет продолжать принимать соединения до тех пор, пока он не будет удален. Если ваше устройство имеет несколько сетевых интерфейсов, то вы можете указать, какой из них будет прослушиваться с помощью параметра IP-адрес. Для прослушивания всех интерфейсов используйте пустую строку в качестве IP-адреса. Если устройство имеет оба адреса IPv4 и IPv6, то слушатель может слушать только один или другой, а не оба. Для прослушивания соединений IPv4 и IPv6 необходимо создать два прослушивателя: один для соединений IPv4 и один для соединений IPv6. Соединения из любого из них будут вести себя точно так же после того, как они будут подключены. Чтобы создать прослушиватель IPv6, передайте IPv6 IP-адрес CreateSocketListener или "anyip6" для прослушивания любого подходящего IPv6-адреса. Если вы передадите пустую строку или "anyip4" в качестве IP-адреса, то он будет прослушивать IPv4-соединения. Вы можете иметь несколько активных слушателей одновременно, но все они должны использовать разные порты или IP-адреса. При выборе номера порта следует избегать низких значений, так как они часто будут использоваться другими приложениями и сервисами. Если что-то уже прослушивает порт, то ваша попытка прослушать его потерпит неудачу. Возвращает 0, если он не смог начать прослушивание.
     *
     * @param string $szIP IP-адрес интерфейса для прослушивания может быть IPv4 или IPv6, или "anyip4", или "anyip6"
     * @param int $port TCP-порт для прослушивания находится в диапазоне от 1025 до 65535
     * @return int
     */
    function CreateSocketListener($szIP, $port)
    {
    }

    /**
     *Создает звук из мемблока. Memblock должен существовать, это создает новый звук и возвращает идентификатор. Это не повлияет ни на какие уже воспроизводимые звуковые экземпляры, только на будущие. Первые 2 байта memlbock хранят количество каналов (1 или 2 поддерживаемых), следующие 2 байта хранят биты на выборку (8 или 16 поддерживаемых), следующие 4 байта хранят выборки в секунду, например 44100. Следующие 4 байта-это количество кадров в звуковых данных, размер звуковых данных в байтах можно вычислить из этого с помощью формулы numFrames*(BitsPerSample/8)*channels. В 2-канальном звуке кадр содержит 2 сэмпла, по одному для каждого канала. В моно-звуке кадр содержит 1 образец. Остальная часть memblock-это необработанные звуковые данные, например, в 8-битном стереозвуке с 3 кадрами необработанные данные будут выглядеть так. смещение байта 0 = Кадр 1, смещение байта данных левого канала 1 = Кадр 1, смещение байта данных правого канала 2 = Кадр 2, смещение байта данных левого канала 3 = Кадр 2, смещение байта данных правого канала 4 = Кадр 3, смещение байта данных левого канала 5 = Кадр 3, данные правого канала Возвращают идентификатор нового звука.
     *
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return int
     */
    function CreateSoundFromMemblock($memID)
    {
    }

    /**
     *Создает звук из мемблока. Memblock должен существовать, это создает новый звук и возвращает идентификатор. Это не повлияет ни на какие уже воспроизводимые звуковые экземпляры, только на будущие. Первые 2 байта memlbock хранят количество каналов (1 или 2 поддерживаемых), следующие 2 байта хранят биты на выборку (8 или 16 поддерживаемых), следующие 4 байта хранят выборки в секунду, например 44100. Следующие 4 байта-это количество кадров в звуковых данных, размер звуковых данных в байтах можно вычислить из этого с помощью формулы numFrames*(BitsPerSample/8)*channels. В 2-канальном звуке кадр содержит 2 сэмпла, по одному для каждого канала. В моно-звуке кадр содержит 1 образец. Остальная часть memblock-это необработанные звуковые данные, например, в 8-битном стереозвуке с 3 кадрами необработанные данные будут выглядеть так. смещение байта 0 = Кадр 1, смещение байта данных левого канала 1 = Кадр 1, смещение байта данных правого канала 2 = Кадр 2, смещение байта данных левого канала 3 = Кадр 2, смещение байта данных правого канала 4 = Кадр 3, смещение байта данных левого канала 5 = Кадр 3, данные правого канала Возвращают идентификатор нового звука.
     *
     * @param int $soundID Идентификатор звука для создания или изменения.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return void
     */
    function CreateSoundFromMemblock($soundID, $memID)
    {
    }

    /**
     *Создает 2D-скелет, который можно использовать для анимации спрайтов с помощью костей. В настоящее время эта команда не очень полезна, так как существует не так много команд для настройки скелета. Вместо этого скелеты должны быть загружены с помощью LoadSkeleton2DFromSpineFile
     *
     * @return int
     */
    function CreateSkeleton2D()
    {
    }

    /**
     *Создает 2D-скелет, который можно использовать для анимации спрайтов с помощью костей. В настоящее время эта команда не очень полезна, так как существует не так много команд для настройки скелета. Вместо этого скелеты должны быть загружены с помощью LoadSkeleton2DFromSpineFile
     *
     * @param int $iSkeleton Идентификатор, используемый для ссылки на этот скелет
     * @return void
     */
    function CreateSkeleton2D($iSkeleton)
    {
    }

    /**
     *Создает соединение веревки между двумя спрайтами. Канатное соединение обеспечивает максимальное расстояние между спрайтами без каких-либо других ограничений. Это не мешает им сближаться. Укажите две опорные точки в мировых координатах с максимальной длиной, которую вы хотите разрешить, текущее положение спрайтов не влияет на инициализацию соединения. Опорные точки могут быть смещены от позиций спрайтов. Соединение может быть удалено системой, если какой-либо из спрайтов, которые он соединяет, будет удален.
     *
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки спрайта 1.
     * @param float $y Координата y якорной точки спрайта 1.
     * @param float $x2 Координата x опорной точки спрайта 2.
     * @param float $y2 Координата y опорной точки спрайта 2.
     * @param float $maxLength Максимальная длина, допустимая между опорными точками спрайта.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return int
     */
    function CreateRopeJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $x2, $y2, $maxLength, $colConnected)
    {
    }

    /**
     *Создает соединение веревки между двумя спрайтами. Канатное соединение обеспечивает максимальное расстояние между спрайтами без каких-либо других ограничений. Это не мешает им сближаться. Укажите две опорные точки в мировых координатах с максимальной длиной, которую вы хотите разрешить, текущее положение спрайтов не влияет на инициализацию соединения. Опорные точки могут быть смещены от позиций спрайтов. Соединение может быть удалено системой, если какой-либо из спрайтов, которые он соединяет, будет удален.
     *
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки спрайта 1.
     * @param float $y Координата y якорной точки спрайта 1.
     * @param float $x2 Координата x опорной точки спрайта 2.
     * @param float $y2 Координата y опорной точки спрайта 2.
     * @param float $maxLength Максимальная длина, допустимая между опорными точками спрайта.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return void
     */
    function CreateRopeJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $x2, $y2, $maxLength, $colConnected)
    {
    }

    /**
     *Создает революционное соединение между двумя спрайтами. Поворотное соединение позволяет спрайтам вращаться только вокруг заданной точки. Укажите единственную опорную точку в мировых координатах, где спрайты уже находятся в нужном относительном положении. Точка привязки может быть смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение поддерживает двигатели и ограничения.
     *
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return int
     */
    function CreateRevoluteJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $colConnected)
    {
    }

    /**
     *Создает революционное соединение между двумя спрайтами. Поворотное соединение позволяет спрайтам вращаться только вокруг заданной точки. Укажите единственную опорную точку в мировых координатах, где спрайты уже находятся в нужном относительном положении. Точка привязки может быть смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение поддерживает двигатели и ограничения.
     *
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return void
     */
    function CreateRevoluteJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $colConnected)
    {
    }

    /**
     *Создает соединение шкива между двумя спрайтами. Это первая половина двухкомандной установки. Из - за количества требуемых параметров вы должны вызвать FinishPulleyJoint с остальными параметрами для создания соединения. Эта команда ничего не возвращает, идентификатор соединения возвращается FinishPulleyJoint.
     *
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $ratio Соотношение между двумя сторонами шкива.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return void
     */
    function CreatePulleyJoint2($iSpriteIndex1, $iSpriteIndex2, $ratio, $colConnected)
    {
    }

    /**
     *Создает соединение шкива между двумя спрайтами. Опорные точки-это координаты мирового пространства, которые прикрепляют соединение к спрайту, опорные точки не обязательно должны находиться в центре спрайта или где-то рядом с ним, но эта точка станет новым центром вращения на то время, пока спрайт прикреплен к шкиву. Точки заземления находятся там, где трос шкива прикрепится к воображаемым шкивам и останется неподвижным в течение всего срока службы соединения, они не должны находиться в одном и том же месте. Значение коэффициента определяет передаточное отношение между двумя сторонами шкива, например, значение 2 будет означать, что спрайт 1 движется с удвоенной скоростью спрайта 2, но будет испытывать половину силы, приложенной к спрайту 2.
     *
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $gnd1x Координата x точки заземления для спрайта 1.
     * @param float $gnd1y Координата y точки заземления для спрайта 1.
     * @param float $gnd2x Координата x точки заземления для спрайта 2.
     * @param float $gnd2y Координата y точки заземления для спрайта 2.
     * @param float $a1x Координата x опорной точки для спрайта 1.
     * @param float $a1y Координата y опорной точки для спрайта 1.
     * @param float $a2x Координата x опорной точки для спрайта 2.
     * @param float $a2y Координата y опорной точки для спрайта 2.
     * @param float $ratio Соотношение между двумя сторонами шкива.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return void
     */
    function CreatePulleyJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $gnd1x, $gnd1y, $gnd2x, $gnd2y, $a1x, $a1y, $a2x, $a2y, $ratio, $colConnected)
    {
    }

    /**
     *Создает призматическое соединение между двумя спрайтами. Призматическое соединение позволяет спрайтам двигаться только вдоль заданной оси относительно друг друга. Его можно представить как поршень, на каждом конце которого спрайты не могут вращаться. Это похоже на линейное соединение, за исключением того, что предотвращается относительное вращение. Укажите единственную опорную точку в мировых координатах, чтобы спрайты уже находились в нужном относительном положении, на минимальном расстоянии поршня. С этого момента спрайтам будет позволено разделяться вдоль заданной оси и вращаться как единое целое, но не вращаться относительно друг друга. Точка привязки может быть смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение поддерживает двигатели и ограничения.
     *
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param float $vx Компонент x оси.
     * @param float $vy Компонент y оси.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return int
     */
    function CreatePrismaticJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $vx, $vy, $colConnected)
    {
    }

    /**
     *Создает призматическое соединение между двумя спрайтами. Призматическое соединение позволяет спрайтам двигаться только вдоль заданной оси относительно друг друга. Его можно представить как поршень, на каждом конце которого спрайты не могут вращаться. Это похоже на линейное соединение, за исключением того, что предотвращается относительное вращение. Укажите единственную опорную точку в мировых координатах, чтобы спрайты уже находились в нужном относительном положении, на минимальном расстоянии поршня. С этого момента спрайтам будет позволено разделяться вдоль заданной оси и вращаться как единое целое, но не вращаться относительно друг друга. Точка привязки может быть смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение поддерживает двигатели и ограничения.
     *
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param float $vx Компонент x оси.
     * @param float $vy Компонент y оси.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return void
     */
    function CreatePrismaticJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $vx, $vy, $colConnected)
    {
    }

    /**
     *Создает точечный свет, который светит одинаково во всех направлениях. Это влияет на все объекты, использующие внутренний шейдер по умолчанию с SetObjectLightMode равным 1. Если вы используете пользовательский шейдер, то AGK добавит функции освещения в ваш шейдер во время загрузки, если вы ссылаетесь на них, см. Руководство по шейдерам для получения дополнительной информации об этом. По умолчанию свет создается в режиме вершин, это быстрее, чем в пиксельном режиме, но более низкого качества. Чтобы изменить это, используйте SetPointLightMode. Значения цвета должны находиться в диапазоне 0-255, но не ограничиваться им. Значения больше 255 будут чрезмерно насыщать вещи, а значения меньше 0 будут отнимать свет.
     *
     * @param int $lightID Идентификатор источника света для ссылки на него в других командах.
     * @param float $x X-компонент положения света.
     * @param float $y Y-компонент положения света.
     * @param float $z Z-компонент положения света.
     * @param float $radius Диапазон, на который влияет свет.
     * @param int $red Красная составляющая светлого цвета.
     * @param int $green Зеленая составляющая светлого цвета.
     * @param int $blue Синяя составляющая светлого цвета.
     * @return void
     */
    function CreatePointLight($lightID, $x, $y, $z, $radius, $red, $green, $blue)
    {
    }

    /**
     *Создает глобальную силу, которая влияет на все физические спрайты. Можно настроить либо на привлечение, либо на отталкивание спрайтов из определенного места. Он возвращает идентификатор силы, который можно использовать для последующего изменения или удаления силы. Силы продолжают действовать до тех пор, пока они не будут удалены.
     *
     * @param float $x Положение x расположения силы в мировых координатах.
     * @param float $y Положение y расположения силы в мировых координатах.
     * @param float $power Сила силы в 1 единице от точки силы для затухающих сил или сила во все времена для не затухающих.
     * @param float $limit Применяется только к силам затухания, максимальная сила, которая будет применена к спрайту, используется, когда спрайт находится ближе 1 единицы.
     * @param float $range Диапазон, на который может действовать эта сила, спрайты больше этого расстояния от точки силы не ощущают никаких эффектов. меньше 0 означает бесконечный диапазон.
     * @param int $fade Установите значение 1, если сила должна быть слабее, когда спрайты находятся дальше от точки силы, и 0, если сила равна на всех расстояниях.
     * @return int
     */
    function CreatePhysicsForce($x, $y, $power, $limit, $range, $fade)
    {
    }

    /**
     *Создает излучатель частиц в свободном ID и в заданном месте в мировых координатах. Он возвращает идентификатор, используемый для создания излучателя. Излучатели частиц создают поток маленьких спрайтов, которые длятся фиксированное количество времени, прежде чем исчезнуть. Частицы могут подвергаться воздействию сил в течение своей жизни с помощью AddParticlesForce. Они также могут менять цвет с течением времени с помощью AddParticlesColorKeyFrame. Частицы не могут быть изменены по отдельности и вести себя как группа, используя одну и ту же текстуру и глубину. Это позволяет AGK рисовать их более эффективно, чем аналогичное количество обычных спрайтов.
     *
     * @param float $x Координата x для позиционирования этого излучателя.
     * @param float $y Координата y для позиционирования этого излучателя.
     * @return int
     */
    function CreateParticles($x, $y)
    {
    }

    /**
     *Создает излучатель частиц в свободном ID и в заданном месте в мировых координатах. Он возвращает идентификатор, используемый для создания излучателя. Излучатели частиц создают поток маленьких спрайтов, которые длятся фиксированное количество времени, прежде чем исчезнуть. Частицы могут подвергаться воздействию сил в течение своей жизни с помощью AddParticlesForce. Они также могут менять цвет с течением времени с помощью AddParticlesColorKeyFrame. Частицы не могут быть изменены по отдельности и вести себя как группа, используя одну и ту же текстуру и глубину. Это позволяет AGK рисовать их более эффективно, чем аналогичное количество обычных спрайтов.
     *
     * @param int $ID Идентификатор, используемый при ссылке на этот излучатель частиц.
     * @param float $x Координата x для позиционирования этого излучателя.
     * @param float $y Координата y для позиционирования этого излучателя.
     * @return void
     */
    function CreateParticles($ID, $x, $y)
    {
    }

    /**
     *Создает плоскость, которая заполнит весь экран и может быть использована для рендеринга полноэкранных шейдеров.
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @return void
     */
    function CreateObjectQuad($objID)
    {
    }

    /**
     *Создает плоскость, которая заполнит весь экран и может быть использована для рендеринга полноэкранных шейдеров.
     *
     * @return int
     */
    function CreateObjectQuad()
    {
    }

    /**
     *Создает трехмерную двустороннюю плоскость с заданными шириной (X) и высотой (Y). Плоскость создается в плоскости XY и не имеет размера в направлении Z.
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $width Ширина плоскости.
     * @param float $height Высота самолета.
     * @return void
     */
    function CreateObjectPlane($objID, $width, $height)
    {
    }

    /**
     *Создает трехмерную двустороннюю плоскость с заданными шириной (X) и высотой (Y). Плоскость создается в плоскости XY и не имеет размера в направлении Z.
     *
     * @param float $width Ширина плоскости.
     * @param float $height Высота самолета.
     * @return int
     */
    function CreateObjectPlane($width, $height)
    {
    }

    /**
     *Создает объект с одной сеткой, построенной из данного memblock. Любые последующие изменения в memblock не повлияют на сетку, вы должны вызвать SetObjectMeshFromMemblock, чтобы изменить существующую сетку. Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда должен быть кратен 4 по соображениям выравнивания, сама строка может иметь немного меньше символов, но всегда округляется до ближайшего кратного 4 для значения длины строки. например, строка длины 5 должна иметь значение длины строки 8. Обратите внимание, что строка из 4 символов имеет нулевой терминатор на конце, что делает ее длиной 5, поэтому, даже если она уже имеет кратное 4 символам значение длины, она должна использовать значение длины 8 из-за нулевого терминатора. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник.
     *
     * @param int $memID Индекс memblock, используемый для создания сетки объекта
     * @return int
     */
    function CreateObjectFromMeshMemblock($memID)
    {
    }

    /**
     *Создает объект с одной сеткой, построенной из данного memblock. Любые последующие изменения в memblock не повлияют на сетку, вы должны вызвать SetObjectMeshFromMemblock, чтобы изменить существующую сетку. Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда должен быть кратен 4 по соображениям выравнивания, сама строка может иметь немного меньше символов, но всегда округляется до ближайшего кратного 4 для значения длины строки. например, строка длины 5 должна иметь значение длины строки 8. Обратите внимание, что строка из 4 символов имеет нулевой терминатор на конце, что делает ее длиной 5, поэтому, даже если она уже имеет кратное 4 символам значение длины, она должна использовать значение длины 8 из-за нулевого терминатора. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник.
     *
     * @param int $objID Идентификатор создаваемого объекта
     * @param int $memID Индекс memblock, используемый для создания сетки объекта
     * @return void
     */
    function CreateObjectFromMeshMemblock($objID, $memID)
    {
    }

    /**
     *Создает пустое изображение, пригодное для рендеринга, и возвращает идентификатор для ссылки на него. Это можно использовать с SetRenderToImage для рисования вещей на изображениях. Вы можете создавать изображения RGBA для обычного рендеринга или изображения глубины для захвата буфера глубины на устройствах, которые его поддерживают. Вы также можете использовать mipmapping на этом изображении или нет, это переопределяет глобальную команду SetGenerateMipmaps() только для этого изображения, это связано с тем, что mipmaps на визуализированных изображениях могут быть хитом производительности, поэтому их не следует использовать без необходимости. Mip-карты должны быть необходимы только в том случае, если вы собираетесь использовать это изображение для текстурирования объектов в вашей сцене, если вы используете это изображение только для полноэкранных шейдеров, вы не должны использовать mip-карты на нем.
     *
     * @param int $width Ширина создаваемого изображения
     * @param int $height Высота создаваемого изображения
     * @param int $format 0=RGBA (32bit), 1=Глубина
     * @param int $mipmap 1 для использования mipmapping на этом изображении, 0 для его отключения
     * @return int
     */
    function CreateRenderImage($width, $height, $format, $mipmap)
    {
    }

    /**
     *Создает пустое изображение, пригодное для рендеринга, и возвращает идентификатор для ссылки на него. Это можно использовать с SetRenderToImage для рисования вещей на изображениях. Вы можете создавать изображения RGBA для обычного рендеринга или изображения глубины для захвата буфера глубины на устройствах, которые его поддерживают. Вы также можете использовать mipmapping на этом изображении или нет, это переопределяет глобальную команду SetGenerateMipmaps() только для этого изображения, это связано с тем, что mipmaps на визуализированных изображениях могут быть хитом производительности, поэтому их не следует использовать без необходимости. Mip-карты должны быть необходимы только в том случае, если вы собираетесь использовать это изображение для текстурирования объектов в вашей сцене, если вы используете это изображение только для полноэкранных шейдеров, вы не должны использовать mip-карты на нем.
     *
     * @param int $imageID Идентификатор изображения, используемый для этого изображения
     * @param int $width Ширина создаваемого изображения
     * @param int $height Высота создаваемого изображения
     * @param int $format 0=RGBA (32bit), 1=Глубина
     * @param int $mipmap 1 для использования mipmapping на этом изображении, 0 для его отключения
     * @return void
     */
    function CreateRenderImage($imageID, $width, $height, $format, $mipmap)
    {
    }

    /**
     *Создает 3D-цилиндр с заданным диаметром и высотой, а также необязательным количеством полигонов. Параметр segments определяет, сколько столбцов полигонов составляет цилиндр и должно быть не менее 3. Формула для вычисления общего числа полигонов, используемых в цилиндре, равна 3*сегментам. Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.
     *
     * @param float $height Высота цилиндра.
     * @param float $diameter Диаметр основания цилиндра.
     * @param int $segments Число столбцов многоугольников, составляющих цилиндр.
     * @return int
     */
    function CreateObjectCylinder($height, $diameter, $segments)
    {
    }

    /**
     *Создает 3D-цилиндр с заданным диаметром и высотой, а также необязательным количеством полигонов. Параметр segments определяет, сколько столбцов полигонов составляет цилиндр и должно быть не менее 3. Формула для вычисления общего числа полигонов, используемых в цилиндре, равна 3*сегментам. Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $height Высота цилиндра.
     * @param float $diameter Диаметр основания цилиндра.
     * @param int $segments Число столбцов многоугольников, составляющих цилиндр.
     * @return void
     */
    function CreateObjectCylinder($objID, $height, $diameter, $segments)
    {
    }

    /**
     *Создает объект из заданной карты высот, полезный для создания рельефа. Изображение должно быть PNG 8-битным в оттенках серого или RGB, если это RGB, то считывается только красный канал. В будущем может быть добавлена поддержка 16-битных оттенков серого. Объект будет иметь один УФ-канал с диапазоном от 0 до 1, отображенным на всю местность. Если вы хотите изменить это, то вы можете использовать SetObjectUVOffset и SetObjectUVScale или использовать шейдер, который умножает UV-координаты на заданную величину. Шейдер также можно использовать для создания нескольких УФ-каналов из этого одного канала, применяя к каждому из них различные масштабные коэффициенты. Для удаления артефактов шага рекомендуется использовать значение сглаживания 1, при необходимости корректируя его. Значение split позволяет создавать несколько сеток, которые могут повысить производительность, так как невидимые сетки не будут нарисованы. Значение разделения указывает, сколько сеток нужно создать вдоль каждого ребра, например, значение разделения 5 создаст в общей сложности 5x5 = 25 сеток. В отличие от других объектов, данные о столкновениях не генерируются по умолчанию на этом объекте, так как он может потреблять много памяти, используйте SetObjectCollisionMode, если вы хотите включить его. Для ландшафтов больше 1024x1024 это не рекомендуется на мобильных устройствах, и вы должны использовать GetObjectHeightMapHeight вместо этого, если это возможно. Включение физики для этого объекта будет использовать еще больше памяти и не рекомендуется на местности больше 1024x1024 на любой платформе.
     *
     * @param int $objID Идентификатор создаваемого объекта
     * @param string $szImageFile Имя файла изображения для использования в качестве карты высоты, предпочтительно PNG, также поддерживает JPEG
     * @param float $width Желаемая ширина нового объекта в направлении X
     * @param float $height Желаемая высота нового объекта в направлении Y
     * @param float $length Желаемая длина нового объекта в направлении Z
     * @param int $smoothing Величина сглаживания, применяемая к значениям высоты, 0=нет, 1=один проход, 2=два прохода и т. Д.
     * @param int $split 1=одна сетка, 2=четыре сетки, 3=девять сеток, 4=шестнадцать сеток и т. Д.
     * @return void
     */
    function CreateObjectFromHeightMap($objID, $szImageFile, $width, $height, $length, $smoothing, $split)
    {
    }

    /**
     *Создает объект из заданной карты высот, полезный для создания рельефа. Изображение должно быть PNG 8-битным в оттенках серого или RGB, если это RGB, то считывается только красный канал. В будущем может быть добавлена поддержка 16-битных оттенков серого. Объект будет иметь один УФ-канал с диапазоном от 0 до 1, отображенным на всю местность. Если вы хотите изменить это, то вы можете использовать SetObjectUVOffset и SetObjectUVScale или использовать шейдер, который умножает UV-координаты на заданную величину. Шейдер также можно использовать для создания нескольких УФ-каналов из этого одного канала, применяя к каждому из них различные масштабные коэффициенты. Для удаления артефактов шага рекомендуется использовать значение сглаживания 1, при необходимости корректируя его. Значение split позволяет создавать несколько сеток, которые могут повысить производительность, так как невидимые сетки не будут нарисованы. Значение разделения указывает, сколько сеток нужно создать вдоль каждого ребра, например, значение разделения 5 создаст в общей сложности 5x5 = 25 сеток. В отличие от других объектов, данные о столкновениях не генерируются по умолчанию на этом объекте, так как он может потреблять много памяти, используйте SetObjectCollisionMode, если вы хотите включить его. Для ландшафтов больше 1024x1024 это не рекомендуется на мобильных устройствах, и вы должны использовать GetObjectHeightMapHeight вместо этого, если это возможно. Включение физики для этого объекта будет использовать еще больше памяти и не рекомендуется на местности больше 1024x1024 на любой платформе.
     *
     * @param string $szImageFile Имя файла изображения для использования в качестве карты высоты, предпочтительно PNG, также поддерживает JPEG
     * @param float $width Желаемая ширина нового объекта в направлении X
     * @param float $height Желаемая высота нового объекта в направлении Y
     * @param float $length Желаемая длина нового объекта в направлении Z
     * @param int $smoothing Величина сглаживания, применяемая к значениям высоты, 0=нет, 1=один проход, 2=два прохода и т. Д.
     * @param int $split 1=одна сетка, 2=четыре сетки, 3=девять сеток, 4=шестнадцать сеток и т. Д.
     * @return int
     */
    function CreateObjectFromHeightMap($szImageFile, $width, $height, $length, $smoothing, $split)
    {
    }

    /**
     *Создает 3D-сферу с заданным диаметром и необязательным количеством полигонов. Параметр rows определяет, сколько рядов полигонов составляет сферу и должно быть не менее 2. Параметр columns определяет, сколько столбцов полигонов составляет сферу и должно быть не менее 3. Формула для расчета общего количества полигонов, используемых в сфере, равна 2*столбцам*(строкам-1)
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $diameter Диаметр сферы.
     * @param int $rows Число рядов многоугольников, составляющих сферу.
     * @param int $columns Число столбцов многоугольников, составляющих сферу.
     * @return void
     */
    function CreateObjectSphere($objID, $diameter, $rows, $columns)
    {
    }

    /**
     *Создает 3D-сферу с заданным диаметром и необязательным количеством полигонов. Параметр rows определяет, сколько рядов полигонов составляет сферу и должно быть не менее 2. Параметр columns определяет, сколько столбцов полигонов составляет сферу и должно быть не менее 3. Формула для расчета общего количества полигонов, используемых в сфере, равна 2*столбцам*(строкам-1)
     *
     * @param float $diameter Диаметр сферы.
     * @param int $rows Число рядов многоугольников, составляющих сферу.
     * @param int $columns Число столбцов многоугольников, составляющих сферу.
     * @return int
     */
    function CreateObjectSphere($diameter, $rows, $columns)
    {
    }

    /**
     *Создает 3D-конус с заданным диаметром и высотой, а также необязательное количество полигонов. Параметр segments определяет, сколько столбцов полигонов составляет конус и должно быть не менее 3. Формула для вычисления общего числа полигонов, используемых в конусе, равна 2*сегментам. Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.
     *
     * @param float $height Высота конуса.
     * @param float $diameter Диаметр основания конуса.
     * @param int $segments Количество столбцов многоугольников, составляющих конус.
     * @return int
     */
    function CreateObjectCone($height, $diameter, $segments)
    {
    }

    /**
     *Создает 3D-конус с заданным диаметром и высотой, а также необязательное количество полигонов. Параметр segments определяет, сколько столбцов полигонов составляет конус и должно быть не менее 3. Формула для вычисления общего числа полигонов, используемых в конусе, равна 2*сегментам. Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $height Высота конуса.
     * @param float $diameter Диаметр основания конуса.
     * @param int $segments Количество столбцов многоугольников, составляющих конус.
     * @return void
     */
    function CreateObjectCone($objID, $height, $diameter, $segments)
    {
    }

    /**
     *Создает примитив Капсулы.
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $diameter Диаметр капсулы.
     * @param float $height Высота капсулы
     * @param int $axis 0 = X, 1 = Y, Z = 2
     * @return void
     */
    function CreateObjectCapsule($objID, $diameter, $height, $axis)
    {
    }

    /**
     *Создает примитив Капсулы.
     *
     * @param float $diameter Диаметр капсулы.
     * @param float $height Высота капсулы
     * @param int $axis 0 = X, 1 = Y, Z = 2
     * @return int
     */
    function CreateObjectCapsule($diameter, $height, $axis)
    {
    }

    /**
     *Создает объект из заданной карты высот .raw или .dat, полезной для создания рельефа. Файл должен содержать необработанные 16-битные данные. Если вы используете расширение ".dat" в szFilename, он будет ожидать, что это 32-битная необработанная карта высоты GameGuru, и преобразует ее в 16-битную. Если файл не является картой высоты GameGuru, то вы должны изменить расширение на ".raw". Если вы конвертируете файл GameGuru height map (.dat), то rawWidth и rawHeight всегда должны быть равны 1024. Объект будет иметь один УФ-канал с диапазоном от 0 до 1, отображенным на всю местность. Если вы хотите изменить это, то вы можете использовать SetObjectUVOffset и SetObjectUVScale или использовать шейдер, который умножает UV-координаты на заданную величину. Шейдер также можно использовать для создания нескольких УФ-каналов из этого одного канала, применяя к каждому из них различные масштабные коэффициенты. Обычно при использовании 16-битных данных вам не нужно устанавливать значение сглаживания, но если оно еще не было сглажено, отрегулируйте его по мере необходимости. Значение split позволяет создавать несколько сеток, которые могут повысить производительность, так как невидимые сетки не будут нарисованы. Значение разделения указывает, сколько сеток нужно создать вдоль каждого ребра, например, значение разделения 5 создаст в общей сложности 5x5 = 25 сеток. В отличие от других объектов, данные о столкновениях не генерируются по умолчанию на этом объекте, так как он может потреблять много памяти, используйте SetObjectCollisionMode, если вы хотите включить его. Для ландшафтов больше 1024x1024 это не рекомендуется на мобильных устройствах, и вы должны использовать GetObjectHeightMapHeight вместо этого, если это возможно. Включение физики для этого объекта будет использовать еще больше памяти и не рекомендуется на местности больше 1024x1024 на любой платформе.
     *
     * @param string $szFilename Имя файла карты высот должно заканчиваться на .raw или .dat
     * @param float $width Желаемая ширина нового объекта в направлении X
     * @param float $height Желаемая высота нового объекта в направлении Y
     * @param float $length Желаемая длина нового объекта в направлении Z
     * @param int $smoothing Величина сглаживания, применяемая к значениям высоты, 0=нет, 1=один проход, 2=два прохода и т. Д.
     * @param int $split 1=одна сетка, 2=четыре сетки, 3=девять сеток, 4=шестнадцать сеток и т. Д.
     * @param int $rawWidth Ширина данных карты высот
     * @param int $rawHeight Высота данных карты высот
     * @return int
     */
    function CreateObjectFromRawHeightMap($szFilename, $width, $height, $length, $smoothing, $split, $rawWidth, $rawHeight)
    {
    }

    /**
     *Создает объект из заданной карты высот .raw или .dat, полезной для создания рельефа. Файл должен содержать необработанные 16-битные данные. Если вы используете расширение ".dat" в szFilename, он будет ожидать, что это 32-битная необработанная карта высоты GameGuru, и преобразует ее в 16-битную. Если файл не является картой высоты GameGuru, то вы должны изменить расширение на ".raw". Если вы конвертируете файл GameGuru height map (.dat), то rawWidth и rawHeight всегда должны быть равны 1024. Объект будет иметь один УФ-канал с диапазоном от 0 до 1, отображенным на всю местность. Если вы хотите изменить это, то вы можете использовать SetObjectUVOffset и SetObjectUVScale или использовать шейдер, который умножает UV-координаты на заданную величину. Шейдер также можно использовать для создания нескольких УФ-каналов из этого одного канала, применяя к каждому из них различные масштабные коэффициенты. Обычно при использовании 16-битных данных вам не нужно устанавливать значение сглаживания, но если оно еще не было сглажено, отрегулируйте его по мере необходимости. Значение split позволяет создавать несколько сеток, которые могут повысить производительность, так как невидимые сетки не будут нарисованы. Значение разделения указывает, сколько сеток нужно создать вдоль каждого ребра, например, значение разделения 5 создаст в общей сложности 5x5 = 25 сеток. В отличие от других объектов, данные о столкновениях не генерируются по умолчанию на этом объекте, так как он может потреблять много памяти, используйте SetObjectCollisionMode, если вы хотите включить его. Для ландшафтов больше 1024x1024 это не рекомендуется на мобильных устройствах, и вы должны использовать GetObjectHeightMapHeight вместо этого, если это возможно. Включение физики для этого объекта будет использовать еще больше памяти и не рекомендуется на местности больше 1024x1024 на любой платформе.
     *
     * @param int $objID Идентификатор создаваемого объекта
     * @param string $szFilename Имя файла карты высот должно заканчиваться на .raw или .dat
     * @param float $width Желаемая ширина нового объекта в направлении X
     * @param float $height Желаемая высота нового объекта в направлении Y
     * @param float $length Желаемая длина нового объекта в направлении Z
     * @param int $smoothing Величина сглаживания, применяемая к значениям высоты, 0=нет, 1=один проход, 2=два прохода и т. Д.
     * @param int $split 1=одна сетка, 2=четыре сетки, 3=девять сеток, 4=шестнадцать сеток и т. Д.
     * @param int $rawWidth Ширина данных карты высот
     * @param int $rawHeight Высота данных карты высот
     * @return void
     */
    function CreateObjectFromRawHeightMap($objID, $szFilename, $width, $height, $length, $smoothing, $split, $rawWidth, $rawHeight)
    {
    }

    /**
     *Создает 3D-окно с заданными шириной (X), высотой (Y) и длиной (Z). Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.
     *
     * @param float $width Размер объекта в направлении X.
     * @param float $height Размер объекта в направлении Y.
     * @param float $length Размер объекта в направлении Z.
     * @return int
     */
    function CreateObjectBox($width, $height, $length)
    {
    }

    /**
     *Создает 3D-окно с заданными шириной (X), высотой (Y) и длиной (Z). Возвращает идентификатор, который можно использовать для ссылки на этот объект в других командах.
     *
     * @param int $objID Идентификатор, используемый для нового объекта.
     * @param float $width Размер объекта в направлении X.
     * @param float $height Размер объекта в направлении Y.
     * @param float $length Размер объекта в направлении Z.
     * @return void
     */
    function CreateObjectBox($objID, $width, $height, $length)
    {
    }

    /**
     *Создает объект путем копирования одной сетки из другого объекта. Объект может содержать много сеток, и использование CloneObject скопирует их все. Используйте эту команду, если вы хотите скопировать только одну сетку. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes включительно.
     *
     * @param int $objID Идентификатор нового объекта
     * @param int $fromObjID Идентификатор объекта, содержащего сетку для копирования
     * @param int $meshIndex Индекс сетки для копирования
     * @return void
     */
    function CreateObjectFromObjectMesh($objID, $fromObjID, $meshIndex)
    {
    }

    /**
     *Создает объект путем копирования одной сетки из другого объекта. Объект может содержать много сеток, и использование CloneObject скопирует их все. Используйте эту команду, если вы хотите скопировать только одну сетку. Индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes включительно.
     *
     * @param int $fromObjID Идентификатор объекта, содержащего сетку для копирования
     * @param int $meshIndex Индекс сетки для копирования
     * @return int
     */
    function CreateObjectFromObjectMesh($fromObjID, $meshIndex)
    {
    }

    /**
     *Создает соединение мыши между точкой и спрайтом. Это обычно используется при перетаскивании фигуры указателем мыши и попытке переместить спрайт в заданную точку с помощью силы до максимального заданного значения. Укажите точку привязки в мировых координатах, которая будет выступать в качестве начальной точки удержания спрайта. Любое дальнейшее изменение в целевом положении будет пытаться переместить эту точку спрайта в новое место. Используйте SetJointMouseTarget для изменения местоположения целевой позиции.
     *
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex Идентификатор спрайта для перемещения.
     * @param float $x Координата x начальной точки привязки на спрайте.
     * @param float $y Координата y начальной точки привязки на спрайте.
     * @param float $maxForce Максимальное усилие, которое сустав может использовать для перемещения спрайта.
     * @return void
     */
    function CreateMouseJoint($iJointIndex, $iSpriteIndex, $x, $y, $maxForce)
    {
    }

    /**
     *Создает соединение мыши между точкой и спрайтом. Это обычно используется при перетаскивании фигуры указателем мыши и попытке переместить спрайт в заданную точку с помощью силы до максимального заданного значения. Укажите точку привязки в мировых координатах, которая будет выступать в качестве начальной точки удержания спрайта. Любое дальнейшее изменение в целевом положении будет пытаться переместить эту точку спрайта в новое место. Используйте SetJointMouseTarget для изменения местоположения целевой позиции.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для перемещения.
     * @param float $x Координата x начальной точки привязки на спрайте.
     * @param float $y Координата y начальной точки привязки на спрайте.
     * @param float $maxForce Максимальное усилие, которое сустав может использовать для перемещения спрайта.
     * @return int
     */
    function CreateMouseJoint($iSpriteIndex, $x, $y, $maxForce)
    {
    }

    /**
     *Создает сетевое сообщение, которое может быть отправлено на другое сетевое устройство. Он возвращает идентификатор, который можно использовать для взаимодействия с сообщением. Сообщения, созданные таким образом, могут быть только добавлены, а не прочитаны. После передачи в сеть идентификатор сообщения уничтожается и обрабатывается фоновым сетевым кодом.
     *

     * @return int
     */
    function CreateNetworkMessage()
    {
    }

    /**
     *Создает memblock из сетки объектов. Объект может содержать одну или несколько сеток, индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes включительно. Сетка копируется в memblock, поэтому любые изменения в memblock не влияют сразу на сетку, вы должны использовать одну из других команд, таких как SetObjectMeshFromMemblock, чтобы скопировать memblock обратно в сетку. Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда будет кратен 4, чтобы упростить проблемы выравнивания, сама строка может иметь немного меньше символов и быть дополнена нулевыми терминаторами, но прочитайте все указанные байты, и вы получите правильную строку длины. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник. Если вы планируете регулярно вносить изменения в сетку, вы должны сохранить memblock после использования SetObjectMeshFromMemblock вместо того, чтобы регенерировать его из объекта каждый раз, когда вы хотите внести изменения. Затем снова вызовите SetObjectMeshFromMemblock, когда вы хотите перенести свои новые изменения на объект.
     *
     * @param int $objID Идентификатор объекта, содержащего сетку для чтения
     * @param int $meshIndex Индекс сетки для копирования в memblock
     * @return int
     */
    function CreateMemblockFromObjectMesh($objID, $meshIndex)
    {
    }

    /**
     *Создает memblock из сетки объектов. Объект может содержать одну или несколько сеток, индексы сетки находятся в диапазоне от 1 до GetObjectNumMeshes включительно. Сетка копируется в memblock, поэтому любые изменения в memblock не влияют сразу на сетку, вы должны использовать одну из других команд, таких как SetObjectMeshFromMemblock, чтобы скопировать memblock обратно в сетку. Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда будет кратен 4, чтобы упростить проблемы выравнивания, сама строка может иметь немного меньше символов и быть дополнена нулевыми терминаторами, но прочитайте все указанные байты, и вы получите правильную строку длины. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник. Если вы планируете регулярно вносить изменения в сетку, вы должны сохранить memblock после использования SetObjectMeshFromMemblock вместо того, чтобы регенерировать его из объекта каждый раз, когда вы хотите внести изменения. Затем снова вызовите SetObjectMeshFromMemblock, когда вы хотите перенести свои новые изменения на объект.
     *
     * @param int $memID Идентификатор нового memblock
     * @param int $objID Идентификатор объекта, содержащего сетку для чтения
     * @param int $meshIndex Индекс сетки для копирования в memblock
     * @return void
     */
    function CreateMemblockFromObjectMesh($memID, $objID, $meshIndex)
    {
    }

    /**
     *Создает memblock из загруженного изображения, субизображения atlas не поддерживаются. Изображение должно существовать и не подвержено влиянию этой команды. Первые 4 байта memlbock хранят ширину изображения, следующие 4 байта хранят высоту изображения, следующие 4 байта хранят битовую глубину, в настоящее время это всегда будет 32. После этого необработанные данные изображения начинаются в формате RGBA, причем каждый компонент хранится в одном байте, поэтому каждый пиксель занимает 4 байта. Размер данных изображения может быть вычислен по ширине*высоте*4 байта (на данный момент битовая глубина может быть принята равной 32 битам = 4 байтам). Обратите внимание, что из-за малого формата endian чтение данных изображения с байтами вернет смещения 0=R, 1=G, 2=B, 3=A, но чтение их всех как одного целого числа приведет к значению с A как наиболее значимым байтом, за которым следует B, затем G, затем R как наименее значимый байт. Пиксельные данные начинаются в верхнем левом углу изображения и продолжаются слева направо, а затем сверху вниз, в результате чего изображение сохраняется в виде последовательности строк, заканчивающихся в правом нижнем углу. Возвращает идентификатор, который можно использовать для ссылки на этот memblock в других командах.
     *
     * @param int $imageID Идентификатор изображения для чтения.
     * @return int
     */
    function CreateMemblockFromImage($imageID)
    {
    }

    /**
     *Создает memblock из загруженного изображения, субизображения atlas не поддерживаются. Изображение должно существовать и не подвержено влиянию этой команды. Первые 4 байта memlbock хранят ширину изображения, следующие 4 байта хранят высоту изображения, следующие 4 байта хранят битовую глубину, в настоящее время это всегда будет 32. После этого необработанные данные изображения начинаются в формате RGBA, причем каждый компонент хранится в одном байте, поэтому каждый пиксель занимает 4 байта. Размер данных изображения может быть вычислен по ширине*высоте*4 байта (на данный момент битовая глубина может быть принята равной 32 битам = 4 байтам). Обратите внимание, что из-за малого формата endian чтение данных изображения с байтами вернет смещения 0=R, 1=G, 2=B, 3=A, но чтение их всех как одного целого числа приведет к значению с A как наиболее значимым байтом, за которым следует B, затем G, затем R как наименее значимый байт. Пиксельные данные начинаются в верхнем левом углу изображения и продолжаются слева направо, а затем сверху вниз, в результате чего изображение сохраняется в виде последовательности строк, заканчивающихся в правом нижнем углу. Возвращает идентификатор, который можно использовать для ссылки на этот memblock в других командах.
     *
     * @param int $memID Идентификатор создаваемого мемблока.
     * @param int $imageID Идентификатор изображения для чтения.
     * @return void
     */
    function CreateMemblockFromImage($memID, $imageID)
    {
    }

    /**
     *Создает memblock из файла без какой-либо обработки данных файла, memblock будет байт за байтом копией файла. Возвращает идентификатор, который может быть использован для ссылки на этот memblock позже. Вы можете использовать относительные пути в имени файла для чтения из вложенных папок или использовать SetFolder для первого просмотра. Вы можете использовать абсолютные пути, добавив косую черту в начало имени файла, в этом случае папка, установленная с помощью SetFolder, игнорируется. Например /media/file.txt будет читать его из папки media, даже если SetFolder был использован для перехода к /media/somefolder
     *
     * @param string $filename Имя файла для чтения, если он не существует, это не удастся.
     * @return int
     */
    function CreateMemblockFromFile($filename)
    {
    }

    /**
     *Создает memblock из файла без какой-либо обработки данных файла, memblock будет байт за байтом копией файла. Возвращает идентификатор, который может быть использован для ссылки на этот memblock позже. Вы можете использовать относительные пути в имени файла для чтения из вложенных папок или использовать SetFolder для первого просмотра. Вы можете использовать абсолютные пути, добавив косую черту в начало имени файла, в этом случае папка, установленная с помощью SetFolder, игнорируется. Например /media/file.txt будет читать его из папки media, даже если SetFolder был использован для перехода к /media/somefolder
     *
     * @param int $memID Идентификатор создаваемого мемблока.
     * @param string $filename Имя файла для чтения, если он не существует, это не удастся.
     * @return void
     */
    function CreateMemblockFromFile($memID, $filename)
    {
    }

    /**
     *Создает раздел памяти заданного размера для доступа на чтение или запись. Содержимое памяти не определено, пока вы не запишете в нее. Memblock не должен уже существовать с выбранным вами memID.
     *
     * @param int $memID Идентификатор мемблока, который вы хотите использовать.
     * @param int $size Размер мемблока в байтах. максимум 100 000 000.
     * @return void
     */
    function CreateMemblock($memID, $size)
    {
    }

    /**
     *Создает раздел памяти заданного размера для доступа на чтение или запись. Содержимое памяти не определено, пока вы не запишете в нее. Memblock не должен уже существовать с выбранным вами memID.
     *
     * @param int $size Размер мемблока в байтах. максимум 100 000 000.
     * @return int
     */
    function CreateMemblock($size)
    {
    }

    /**
     *Создает соединение линий между двумя спрайтами. Соединение линий позволяет спрайтам двигаться только вдоль заданной оси относительно друг друга, свободно вращаясь на обоих концах. Он похож на призматический шарнир, за исключением того, что допускается относительное вращение. Укажите единственную опорную точку в мировых координатах со спрайтами уже в нужном относительном положении, на минимальном расстоянии поршня. С этого момента спрайтам будет позволено разделиться вдоль заданной оси относительно друг друга. Точка привязки может быть смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение поддерживает двигатели и ограничения. Box2D переименовал это соединение в Колесное соединение, и теперь оно содержит пружинный компонент для имитации колеса автомобиля. Имя команды AGK останется прежним для обратной совместимости, однако функциональность может измениться
     *
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param float $vx Компонент x оси.
     * @param float $vy Компонент y оси.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return int
     */
    function CreateLineJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $vx, $vy, $colConnected)
    {
    }

    /**
     *Создает соединение линий между двумя спрайтами. Соединение линий позволяет спрайтам двигаться только вдоль заданной оси относительно друг друга, свободно вращаясь на обоих концах. Он похож на призматический шарнир, за исключением того, что допускается относительное вращение. Укажите единственную опорную точку в мировых координатах со спрайтами уже в нужном относительном положении, на минимальном расстоянии поршня. С этого момента спрайтам будет позволено разделиться вдоль заданной оси относительно друг друга. Точка привязки может быть смещена от центральных положений спрайта. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение поддерживает двигатели и ограничения. Box2D переименовал это соединение в Колесное соединение, и теперь оно содержит пружинный компонент для имитации колеса автомобиля. Имя команды AGK останется прежним для обратной совместимости, однако функциональность может измениться
     *
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки.
     * @param float $y Координата y опорной точки.
     * @param float $vx Компонент x оси.
     * @param float $vy Компонент y оси.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return void
     */
    function CreateLineJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $vx, $vy, $colConnected)
    {
    }

    /**
     *Создает изображение из memblock. Мемблок должен существовать, если образ существует, он будет перезаписан, если нет, то будет создан. Memblock должен содержать допустимый PNG-файл, например загруженный CreateMemblockFromFile(memID, "image.png")
     *
     * @param int $imageID Идентификатор создаваемого изображения.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return void
     */
    function CreateImageFromPNGMemblock($imageID, $memID)
    {
    }

    /**
     *Создает изображение из memblock. Мемблок должен существовать, если образ существует, он будет перезаписан, если нет, то будет создан. Memblock должен содержать допустимый PNG-файл, например загруженный CreateMemblockFromFile(memID, "image.png")
     *
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return int
     */
    function CreateImageFromPNGMemblock($memID)
    {
    }

    /**
     *Создает HTTP - соединение, готовое к использованию позже. Возвращает идентификатор, используемый для ссылки на него позже.
     *
     * @return int
     */
    function CreateHTTPConnection()
    {
    }

    /**
     *Создает изображение размером 1x1 пиксель заданного цвета. Это может быть использовано для текстурирования любого объекта или спрайта сплошным цветом.
     *
     * @param int $imageID Идентификатор изображения, используемый для этого изображения.
     * @param int $red Красная составляющая изображения (от 0 до 255)
     * @param int $green Зеленая составляющая изображения (от 0 до 255)
     * @param int $blue Синяя составляющая изображения (от 0 до 255)
     * @param int $alpha Альфа
     * @return void
     */
    function CreateImageColor($imageID, $red, $green, $blue, $alpha)
    {
    }

    /**
     *Создает изображение размером 1x1 пиксель заданного цвета. Это может быть использовано для текстурирования любого объекта или спрайта сплошным цветом.
     *
     * @param int $red Красная составляющая изображения (от 0 до 255)
     * @param int $green Зеленая составляющая изображения (от 0 до 255)
     * @param int $blue Синяя составляющая изображения (от 0 до 255)
     * @param int $alpha Альфа
     * @return int
     */
    function CreateImageColor($red, $green, $blue, $alpha)
    {
    }

    /**
     *Создает музыкальную сущность из мемблока. Мемблок должен существовать. Это создаст новый идентификатор музыки и вернет его memblock должен содержать допустимый файл OGG, например загруженный с CreateMemblockFromFile(memID, "music.ogg")
     *
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return int
     */
    function CreateMusicFromOGGMemblock($memID)
    {
    }

    /**
     *Создает музыкальную сущность из мемблока. Мемблок должен существовать. Это создаст новый идентификатор музыки и вернет его memblock должен содержать допустимый файл OGG, например загруженный с CreateMemblockFromFile(memID, "music.ogg")
     *
     * @param int $musicID Идентификатор создаваемой музыки.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return void
     */
    function CreateMusicFromOGGMemblock($musicID, $memID)
    {
    }

    /**
     *Создает memblock из загруженного звукового файла. Звуковой файл должен быть загружен с помощью LoadSound и не подвержен влиянию этой команды. Первые 2 байта memlbock хранят количество каналов (1 или 2 поддерживаемых), следующие 2 байта хранят биты на выборку (8 или 16 поддерживаемых), следующие 4 байта хранят выборки в секунду, например 44100. Следующие 4 байта-это количество кадров в звуковых данных, размер звуковых данных в байтах можно вычислить из этого с помощью формулы numFrames*(BitsPerSample/8)*channels. В 2-канальном звуке кадр содержит 2 сэмпла, по одному для каждого канала. В моно-звуке кадр содержит 1 образец. Остальная часть memblock-это необработанные звуковые данные, например, в 8-битном стереозвуке с 3 кадрами необработанные данные будут выглядеть так. смещение байта 0 = Кадр 1, смещение байта данных левого канала 1 = Кадр 1, Смещение байта данных правого канала 2 = Кадр 2, Смещение байта данных левого канала 3 = Кадр 2, смещение байта данных правого канала 4 = Кадр 3, смещение байта данных левого канала 5 = Кадр 3, данные правого канала Продолжительность звука может быть рассчитана по следующей формуле: numFrames/samplesPerSecond. Эта команда не работает с идентификаторами звуковых экземпляров, а только с идентификаторами звуковых файлов. Возвращает идентификатор, который может быть использован для ссылки на этот memblock в других командах.
     *
     * @param int $soundID Идентификатор звука для чтения.
     * @return int
     */
    function CreateMemblockFromSound($soundID)
    {
    }

    /**
     *Создает memblock из загруженного звукового файла. Звуковой файл должен быть загружен с помощью LoadSound и не подвержен влиянию этой команды. Первые 2 байта memlbock хранят количество каналов (1 или 2 поддерживаемых), следующие 2 байта хранят биты на выборку (8 или 16 поддерживаемых), следующие 4 байта хранят выборки в секунду, например 44100. Следующие 4 байта-это количество кадров в звуковых данных, размер звуковых данных в байтах можно вычислить из этого с помощью формулы numFrames*(BitsPerSample/8)*channels. В 2-канальном звуке кадр содержит 2 сэмпла, по одному для каждого канала. В моно-звуке кадр содержит 1 образец. Остальная часть memblock-это необработанные звуковые данные, например, в 8-битном стереозвуке с 3 кадрами необработанные данные будут выглядеть так. смещение байта 0 = Кадр 1, смещение байта данных левого канала 1 = Кадр 1, Смещение байта данных правого канала 2 = Кадр 2, Смещение байта данных левого канала 3 = Кадр 2, смещение байта данных правого канала 4 = Кадр 3, смещение байта данных левого канала 5 = Кадр 3, данные правого канала Продолжительность звука может быть рассчитана по следующей формуле: numFrames/samplesPerSecond. Эта команда не работает с идентификаторами звуковых экземпляров, а только с идентификаторами звуковых файлов. Возвращает идентификатор, который может быть использован для ссылки на этот memblock в других командах.
     *
     * @param int $memID Идентификатор создаваемого мемблока.
     * @param int $soundID Идентификатор звука для чтения.
     * @return void
     */
    function CreateMemblockFromSound($memID, $soundID)
    {
    }

    /**
     *Эта команда устарела, вместо нее следует использовать ShowFullscreenAdvertAdMob, ShowFullscreenAdvertChartboost или ShowFullscreenAdvertAmazon. Создает полноэкранную (интерстициальную) рекламу для получения дохода. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью одной из других команд, таких как SetAdMobDetails, SetChartboostDetails или SetAmazonAdDetails Не все платформы поддерживают всех поставщиков рекламы, поэтому установка как можно большего количества данных учетной записи позволит AGK выбрать подходящее объявление для этой платформы. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление было загружено при вызове этой команды, то оно будет отображаться немедленно, в противном случае эта команда ничего не сделает. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа для конкретного поставщика с помощью GetFullscreenAdvertLoadedAdMob, GetFullscreenAdvertLoadedChartboost или GetFullscreenAdvertLoadedAmazon. Ваше приложение будет приостановлено, когда появится объявление, и возобновится, когда оно будет отклонено.
     *
     * @return void
     */
    function CreateFullscreenAdvert()
    {
    }

    /**
     *Создает файл из memblock без какой-либо обработки данных memblock, файл будет байт за байтом копией данных memblock. Вы можете использовать относительные пути в имени файла для записи в подпапки или использовать SetFolder для просмотра там в первую очередь. Вы можете использовать абсолютные пути, добавив косую черту в начало имени файла, в этом случае папка, установленная с помощью SetFolder, игнорируется. Например /media/file.txt поместит его в папку media, даже если SetFolder был использован для перехода к /media/somefolder
     *
     * @param string $filename Имя создаваемого файла, если он уже существует, будет перезаписано.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return void
     */
    function CreateFileFromMemblock($filename, $memID)
    {
    }

    /**
     *Создайте поле редактирования, которое можно расположить в любом месте экрана. Он возвращает идентификатор, используемый для ссылки на это поле редактирования позже.
     *
     * @return int
     */
    function CreateEditBox()
    {
    }

    /**
     *Создайте поле редактирования, которое можно расположить в любом месте экрана. Он возвращает идентификатор, используемый для ссылки на это поле редактирования позже.
     *
     * @param int $index Идентификатор, используемый для этого поля редактирования.
     * @return void
     */
    function CreateEditBox($index)
    {
    }

    /**
     *Создает спрайт в заданном идентификаторе спрайта, возвращает используемый идентификатор спрайта. Фиктивные спрайты ведут себя как обычные спрайты, но не имеют никакого изображения или другого визуального аспекта. Они не будут нарисованы, даже если им присвоено изображение. Они полезны для добавления физических объектов в сцену без необходимости визуального сопровождения физической формы. При желании вы можете использовать команды физического контакта и обратной связи, чтобы выяснить, что поразило эти скрытые физические формы. Если вам не нужно знать, что попало в ваши скрытые фигуры, то вы можете добавить их все в один фиктивный спрайт, используя команды AddSpriteShape для лучшей производительности. SetSpriteShape не будет работать с фиктивными спрайтами, так как у них нет изображения для вычисления фигуры, фигуры должны быть определены вручную с помощью SetSpriteShapeBox, SetSpriteShapeCircle или SetSpriteShapePolygon. Фиктивные спрайты не будут обновлять свой сохраненный угол и положение с помощью последних версий физики, поэтому вызовы GetSpriteX, GetSpriteY или GetSpriteAngle вернут последнее заданное вами значение. Установка положения спрайта обновит физическое тело до заданного вами положения.
     *
     * @param int $iSpriteIndex Идентификатор, используемый для этого спрайта.
     * @return void
     */
    function CreateDummySprite($iSpriteIndex)
    {
    }

    /**
     *Создает спрайт в заданном идентификаторе спрайта, возвращает используемый идентификатор спрайта. Фиктивные спрайты ведут себя как обычные спрайты, но не имеют никакого изображения или другого визуального аспекта. Они не будут нарисованы, даже если им присвоено изображение. Они полезны для добавления физических объектов в сцену без необходимости визуального сопровождения физической формы. При желании вы можете использовать команды физического контакта и обратной связи, чтобы выяснить, что поразило эти скрытые физические формы. Если вам не нужно знать, что попало в ваши скрытые фигуры, то вы можете добавить их все в один фиктивный спрайт, используя команды AddSpriteShape для лучшей производительности. SetSpriteShape не будет работать с фиктивными спрайтами, так как у них нет изображения для вычисления фигуры, фигуры должны быть определены вручную с помощью SetSpriteShapeBox, SetSpriteShapeCircle или SetSpriteShapePolygon. Фиктивные спрайты не будут обновлять свой сохраненный угол и положение с помощью последних версий физики, поэтому вызовы GetSpriteX, GetSpriteY или GetSpriteAngle вернут последнее заданное вами значение. Установка положения спрайта обновит физическое тело до заданного вами положения.
     *

     * @return int
     */
    function CreateDummySprite()
    {
    }

    /**
     *Создает дистанционное соединение между двумя спрайтами. Дистанционное соединение удерживает спрайты на определенном расстоянии друг от друга, позволяя им свободно вращаться вокруг опорных точек. Укажите две опорные точки в мировых координатах, чтобы спрайты уже находились на нужном расстоянии друг от друга. Опорные точки могут быть смещены от позиций спрайтов. Соединение может быть удалено системой, если какой-либо из спрайтов, которые он соединяет, будет удален.
     *
     * @param int $iJointIndex Идентификатор, который будет использоваться для этого сустава.
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки спрайта 1.
     * @param float $y Координата y якорной точки спрайта 1.
     * @param float $x2 Координата x опорной точки спрайта 2.
     * @param float $y2 Координата y опорной точки спрайта 2.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return void
     */
    function CreateDistanceJoint($iJointIndex, $iSpriteIndex1, $iSpriteIndex2, $x, $y, $x2, $y2, $colConnected)
    {
    }

    /**
     *Создает дистанционное соединение между двумя спрайтами. Дистанционное соединение удерживает спрайты на определенном расстоянии друг от друга, позволяя им свободно вращаться вокруг опорных точек. Укажите две опорные точки в мировых координатах, чтобы спрайты уже находились на нужном расстоянии друг от друга. Опорные точки могут быть смещены от позиций спрайтов. Соединение может быть удалено системой, если какой-либо из спрайтов, которые он соединяет, будет удален.
     *
     * @param int $iSpriteIndex1 Идентификатор первого спрайта, который присоединится.
     * @param int $iSpriteIndex2 Идентификатор второго спрайта, к которому нужно присоединиться.
     * @param float $x Координата x опорной точки спрайта 1.
     * @param float $y Координата y якорной точки спрайта 1.
     * @param float $x2 Координата x опорной точки спрайта 2.
     * @param float $y2 Координата y опорной точки спрайта 2.
     * @param int $colConnected Установите, могут ли два спрайта, соединенные соединением, сталкиваться друг с другом, 0=нет, 1=да.
     * @return int
     */
    function CreateDistanceJoint($iSpriteIndex1, $iSpriteIndex2, $x, $y, $x2, $y2, $colConnected)
    {
    }

    /**
     *Широковещательные передачи являются специальными сетевыми коммуникациями, поскольку они не используют адрес назначения и вместо этого принимаются всеми устройствами в сети. Широковещательные пакеты не пересылаются маршрутизаторами, поэтому могут использоваться только в локальной сети или, точнее, в локальной подсети. Это может быть полезно для обнаружения устройств, поскольку одно устройство может отправить широковещательный пакет, содержащий его IP-адрес, а другое устройство может принять его, прочитать IP-адрес и подключиться обратно к первому устройству, чтобы создать двустороннее соединение. Сети AGK транслируются таким образом на порт 45631 и отправляют пакет, содержащий имя сети, которая была размещена другим устройством AGK. С помощью широковещательного прослушивателя вы можете получать эти сообщения, извлекать имена сетей и отображать их пользователю, чтобы он мог выбрать, к какой сети он хочет подключиться. Если устройство находится в сети IPv6, то эти правила немного меняются. CreateBroadcastListener должен быть вызван с многоадресным адресом, который начинается с ff, например ff02::1, и широковещательный прослушиватель будет принимать только пакеты, отправленные на этот многоадресный адрес. Если адрес не указан, то вещатель будет получать только широковещательные передачи IPv4. Если вы передадите адрес "anyip6", то широковещательный прослушиватель будет прослушивать многоадресный адрес AGK "FF02::41:474B", который используется для обнаружения именованной сети на порту 45631. Возвращает идентификатор, который можно использовать для взаимодействия с этим широковещательным слушателем.
     *
     * @param string $szIP Многоадресный IP-адрес для прослушивания применяется только к сетям IPv6, если оставить его пустым, то он будет прослушивать широковещательные передачи IPv4.
     * @param int $port Порт, на который транслируются сообщения, в случае сетей AGK это будет порт 45631.
     * @return int
     */
    function CreateBroadcastListener($szIP, $port)
    {
    }

    /**
     *Широковещательные передачи являются специальными сетевыми коммуникациями, поскольку они не используют адрес назначения и вместо этого принимаются всеми устройствами в сети. Широковещательные пакеты не пересылаются маршрутизаторами, поэтому могут использоваться только в локальной сети или, точнее, в локальной подсети. Это может быть полезно для обнаружения устройств, поскольку одно устройство может отправить широковещательный пакет, содержащий его IP-адрес, а другое устройство может принять его, прочитать IP-адрес и подключиться обратно к первому устройству, чтобы создать двустороннее соединение. Сети AGK транслируются таким образом на порт 45631 и отправляют пакет, содержащий имя сети, которая была размещена другим устройством AGK. С помощью широковещательного прослушивателя вы можете получать эти сообщения, извлекать имена сетей и отображать их пользователю, чтобы он мог выбрать, к какой сети он хочет подключиться. Если устройство находится в сети IPv6, то эти правила немного меняются. CreateBroadcastListener должен быть вызван с многоадресным адресом, который начинается с ff, например ff02::1, и широковещательный прослушиватель будет принимать только пакеты, отправленные на этот многоадресный адрес. Если адрес не указан, то вещатель будет получать только широковещательные передачи IPv4. Если вы передадите адрес "anyip6", то широковещательный прослушиватель будет прослушивать многоадресный адрес AGK "FF02::41:474B", который используется для обнаружения именованной сети на порту 45631. Возвращает идентификатор, который можно использовать для взаимодействия с этим широковещательным слушателем.
     *
     * @param int $port Порт, на который транслируются сообщения, в случае сетей AGK это будет порт 45631.
     * @return int
     */
    function CreateBroadcastListener($port)
    {
    }

    /**
     *Создает рекламу для получения дохода. Перед вызовом этой функции вы должны задать данные своего рекламного аккаунта с помощью одной из других команд, таких как SetAdMobDetails. Не все платформы поддерживают всех поставщиков рекламы, поэтому установка как можно большего количества реквизитов учетной записи позволит AGK выбрать подходящее объявление для этой платформы. Эта реклама обычно представляет собой баннер размером 320х50, отображаемый где-то на краю вашего приложения. Создание объявления, когда оно уже существует, заменит существующее объявление. Это расширенная версия команды CreateAdvert, которая принимает необязательные значения смещения для позиционирования объявления. Параметр type можно использовать для выбора размера баннера: 0=Banner(320x50), 1=LargeBanner, 2=MediumRectangle, 3=FullBanner, 4=Leaderboard, 5=SmartBanner, 6=FluidBanner
     *
     * @param int $type Размер создаваемого баннера
     * @param int $horz Горизонтальное положение объявления: 0=слева, 1=в центре, 2=справа
     * @param int $vert Вертикальное положение объявления, 0=верх, 1=центр, 2=низ
     * @param int $test Установите значение 1, чтобы получить неоплачиваемое тестовое объявление, и 0, чтобы получить реальное объявление.
     * @param float $offsetx когда horz равен 0 или 2 это значение смещает объявление от указанного края
     * @param float $offsety когда vert равен 0 или 2 это значение смещает объявление от указанного края
     * @return void
     */
    function CreateAdvertEx($type, $horz, $vert, $test, $offsetx, $offsety)
    {
    }

    /**
     *Создает изображение из memblock. Мемблок должен существовать, если образ существует, он будет перезаписан, если нет, то будет создан. Первые 4 байта memlbock хранят ширину изображения, следующие 4 байта хранят высоту изображения, следующие 4 байта хранят битовую глубину, в настоящее время это должно быть 32. После этого необработанные данные изображения начинаются в формате RGBA, причем каждый компонент хранится в одном байте, поэтому каждый пиксель занимает 4 байта. Размер данных изображения может быть вычислен по ширине*высоте*4 байта (на данный момент битовая глубина может быть принята равной 32 битам = 4 байтам). Обратите внимание, что из-за малого формата endian запись данных изображения байтами приведет к смещениям 0=R, 1=G, 2=B, 3=A, но запись их всех в виде одного целого числа будет интерпретироваться как значение с A как наиболее значимым байтом, за которым следует B, затем G, затем R как наименее значимый байт. Пиксельные данные начинаются в верхнем левом углу изображения и продолжаются слева направо, а затем сверху вниз, в результате чего изображение сохраняется в виде последовательности строк, заканчивающихся в правом нижнем углу. Эта команда использует большую пропускную способность графического процессора, поэтому не рекомендуется вызывать эту команду каждый кадр на больших изображениях.
     *
     * @param int $imageID Идентификатор создаваемого или изменяемого изображения.
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return void
     */
    function CreateImageFromMemblock($imageID, $memID)
    {
    }

    /**
     *Создает изображение из memblock. Мемблок должен существовать, если образ существует, он будет перезаписан, если нет, то будет создан. Первые 4 байта memlbock хранят ширину изображения, следующие 4 байта хранят высоту изображения, следующие 4 байта хранят битовую глубину, в настоящее время это должно быть 32. После этого необработанные данные изображения начинаются в формате RGBA, причем каждый компонент хранится в одном байте, поэтому каждый пиксель занимает 4 байта. Размер данных изображения может быть вычислен по ширине*высоте*4 байта (на данный момент битовая глубина может быть принята равной 32 битам = 4 байтам). Обратите внимание, что из-за малого формата endian запись данных изображения байтами приведет к смещениям 0=R, 1=G, 2=B, 3=A, но запись их всех в виде одного целого числа будет интерпретироваться как значение с A как наиболее значимым байтом, за которым следует B, затем G, затем R как наименее значимый байт. Пиксельные данные начинаются в верхнем левом углу изображения и продолжаются слева направо, а затем сверху вниз, в результате чего изображение сохраняется в виде последовательности строк, заканчивающихся в правом нижнем углу. Эта команда использует большую пропускную способность графического процессора, поэтому не рекомендуется вызывать эту команду каждый кадр на больших изображениях.
     *
     * @param int $memID Идентификатор считываемого memblock, memblock не зависит от этой команды.
     * @return int
     */
    function CreateImageFromMemblock($memID)
    {
    }

    /**
     *Создает рекламу для получения дохода. Перед вызовом этой функции вы должны задать данные своего рекламного аккаунта с помощью одной из других команд, таких как SetAdMobDetails. Не все платформы поддерживают всех поставщиков рекламы, поэтому установка как можно большего количества реквизитов учетной записи позволит AGK выбрать подходящее объявление для этой платформы. Эта реклама обычно представляет собой баннер размером 320х50, отображаемый где-то на краю вашего приложения. Создание объявления, когда оно уже существует, заменит существующее объявление. Параметр type можно использовать для выбора размера баннера: 0=Banner(320x50), 1=LargeBanner, 2=MediumRectangle, 3=FullBanner, 4=Leaderboard, 5=SmartBanner, 6=FluidBanner
     *
     * @param int $type Размер создаваемого баннера
     * @param int $horz Горизонтальное положение объявления, 0=слева, 1=в центре, 2=справа
     * @param int $vert Вертикальное положение объявления, 0=верх, 1=центр, 2=низ
     * @param int $test Установите значение 1, чтобы получить неоплачиваемое тестовое объявление, и 0, чтобы получить реальное объявление.
     * @return void
     */
    function CreateAdvert($type, $horz, $vert, $test)
    {
    }

    /**
     *Вы должны создать физический мир, прежде чем вызывать какие-либо другие физические команды. Create3DPhysicsWorld Создает физический мир, используя масштабный коэффициент по умолчанию 40. Эта функция создаст физический мир с другим масштабным коэффициентом. Масштаб-это не размер мира, это фактор, с помощью которого все передаваемые данные уменьшаются, чтобы преобразовать их в шкалу физики Пули для физических вычислений. Затем данные из Bullet масштабируются до того, как они будут переданы в AGK 3D world. Масштабный коэффициент по умолчанию будет правильным, если ваш средний размер символа составляет 72 единицы AGK. Тогда гравитация по умолчанию -10,0 метра в секунду на оси Y даст правильный визуальный результат. Решатель физики пуль имеет минимальный размер для объектов. Объекты ниже этого размера вызовут нестабильность в работе решателя. При масштабном коэффициенте по умолчанию 40 наименьший размер, который может обрабатывать решатель, составляет около 3,5 единиц AGK. Чтобы вычислить масштабный коэффициент, сначала определите рост вашего персонажа в метрах, символ высотой 72 единицы будет равен 1,8288 метра (или 6 футов). Затем разделите высоту персонажа в единицах на высоту символов в метрах, для этого примера масштабный коэффициент будет равен (72 / 1.8) = 40.
     *
     * @param float $scaleFactor Масштабный коэффициент по умолчанию равен 40.
     * @return void
     */
    function Create3DPhysicsWorld($scaleFactor)
    {
    }

    /**
     *Вы должны создать физический мир, прежде чем вызывать какие-либо другие физические команды. Create3DPhysicsWorld Создает физический мир, используя масштабный коэффициент по умолчанию 40. Эта функция создаст физический мир с другим масштабным коэффициентом. Масштаб-это не размер мира, это фактор, с помощью которого все передаваемые данные уменьшаются, чтобы преобразовать их в шкалу физики Пули для физических вычислений. Затем данные из Bullet масштабируются до того, как они будут переданы в AGK 3D world. Масштабный коэффициент по умолчанию будет правильным, если ваш средний размер символа составляет 72 единицы AGK. Тогда гравитация по умолчанию -10,0 метра в секунду на оси Y даст правильный визуальный результат. Решатель физики пуль имеет минимальный размер для объектов. Объекты ниже этого размера вызовут нестабильность в работе решателя. При масштабном коэффициенте по умолчанию 40 наименьший размер, который может обрабатывать решатель, составляет около 3,5 единиц AGK. Чтобы вычислить масштабный коэффициент, сначала определите рост вашего персонажа в метрах, символ высотой 72 единицы будет равен 1,8288 метра (или 6 футов). Затем разделите высоту персонажа в единицах на высоту символов в метрах, для этого примера масштабный коэффициент будет равен (72 / 1.8) = 40.
     *
     * @return void
     */
    function Create3DPhysicsWorld()
    {
    }

    /**
     *Создает статическую плоскость. Возвращает статический идентификатор плоскости
     *
     * @param float $normalX x значение вектора нормали.
     * @param float $normalY значение y вектора нормали.
     * @param float $normalZ z-значение вектора нормали.
     * @param float $offsetPosition Насколько самолет будет смещен от своего мирового положения.
     * @return int
     */
    function Create3DPhysicsStaticPlane($normalX, $normalY, $normalZ, $offsetPosition)
    {
    }

    /**
     *Удаляет существующее физическое тело и создает статическую форму столкновения треугольной сетки и физическое тело для объекта.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Create3DPhysicsStaticBody($objID)
    {
    }

    /**
     *Создает зубчатое соединение между двумя существующими соединениями. Зубчатое соединение позволяет внешнему виду двух существующих соединений быть зафиксированными вместе в идеальном трении. Спрайты, которые будут соединены, будут спрайтом 2 на обоих суставах, спрайт 1 на обоих суставах должен быть статическим спрайтом. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение должно быть удалено до того, как будут удалены все соединения, от которых оно зависит.
     *
     * @param int $iJoint1 Идентификатор первого соединения, к которому нужно присоединиться.
     * @param int $iJoint2 Идентификатор второго соединения для соединения.
     * @param float $ratio Передаточное число, используемое при перемещении одного шарнира от другого.
     * @return int
     */
    function CreateGearJoint($iJoint1, $iJoint2, $ratio)
    {
    }

    /**
     *Создает зубчатое соединение между двумя существующими соединениями. Зубчатое соединение позволяет внешнему виду двух существующих соединений быть зафиксированными вместе в идеальном трении. Спрайты, которые будут соединены, будут спрайтом 2 на обоих суставах, спрайт 1 на обоих суставах должен быть статическим спрайтом. Идентификатор соединения будет возвращен для ссылки на это соединение позже, соединение может быть удалено системой, если какой-либо из спрайтов, которые оно соединяет, будет удален. Это соединение должно быть удалено до того, как будут удалены все соединения, от которых оно зависит.
     *
     * @param int $iJointIndex Идентификационный номер зубчатого соединения.
     * @param int $iJoint1 Идентификатор первого соединения, к которому нужно присоединиться.
     * @param int $iJoint2 Идентификатор второго соединения для соединения.
     * @param float $ratio Передаточное число, используемое при перемещении одного шарнира от другого.
     * @return void
     */
    function CreateGearJoint($iJointIndex, $iJoint1, $iJoint2, $ratio)
    {
    }

    /**
     *Возвращает идентификатор созданного луча.
     *
     * @return int
     */
    function Create3DPhysicsRay()
    {
    }

    /**
     *Создает соединение ползунков между объектами a и b. Параметр rotationVec3 должен быть осью в виде (0,1,0) для вертикали, (1,0,0) для горизонтали вдоль оси X, (0,0,1) для горизонтали вдоль оси Z или любой их комбинации. Вектор вращения не нуждается в нормализации. Возвращает идентификатор соединения.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $positionVec3 векторный ИДЕНТИФИКАТОР
     * @param int $rotationVec3 векторный ИДЕНТИФИКАТОР
     * @return int
     */
    function Create3DPhysicsSliderJoint($objA, $objB, $positionVec3, $rotationVec3)
    {
    }

    /**
     *Начинается создание физической тряпичной куклы для объекта. Вы должны добавить по крайней мере одну кость к ragdoll, прежде чем вызывать Finalize3DPhysicsRagDoll(). Кости моделей должны иметь нулевое вращение в положении по умолчанию/первом кадре анимации.
     *
     * @param int $objID идентификатор объекта
     * @param float $objTotalWeight Общий вес в фунтах. Этот вес делится между костями тряпичной куклы в зависимости от объема костей.
     * @return void
     */
    function Create3DPhysicsRagDoll($objID, $objTotalWeight)
    {
    }

    /**
     *Возвращает идентификатор соединения
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора положения
     * @return int
     */
    function Create3DPhysicsPickJoint($objID, $positionVec3)
    {
    }

    /**
     *Удаляет существующее физическое тело и создает форму столкновения коробки и кинематическое физическое тело для объекта. Кинематическое тело может быть перемещено с помощью команд agk для позиционирования и вращения объектов. Примечание: Кинематическое тело может взаимодействовать только с динамическим телом и будет проходить через статическое тело.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Create3DPhysicsKinematicBody($objID)
    {
    }

    /**
     *Создает шарнирное соединение между объектами a и b. Параметр rotationVec3 должен быть осью в виде (0,1,0) для вертикали, (1,0,0) для горизонтали вдоль оси X, (0,0,1) для горизонтали вдоль оси Z или любой их комбинации. Вектор вращения не нуждается в нормализации. Возвращает идентификатор соединения.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $positionVec3 векторный ИДЕНТИФИКАТОР
     * @param int $rotationVec3 векторный ИДЕНТИФИКАТОР
     * @param int $disableCollisions 1 = коллизии будут отключены между связанными объектами, 0 коллизий будут включены между связанными объектами.
     * @return int
     */
    function Create3DPhysicsHingeJoint($objA, $objB, $positionVec3, $rotationVec3, $disableCollisions)
    {
    }

    /**
     *Создает фиксированное соединение между объектами a и b. Возвращает идентификатор соединения.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $positionVec3 векторный ИДЕНТИФИКАТОР
     * @return int
     */
    function Create3DPhysicsFixedJoint($objA, $objB, $positionVec3)
    {
    }

    /**
     *Создает 3D-физический контроллер символов для модели. Контроллер символов может быть создан на оси X, Y или Z. Например, стоящий символ будет находиться на оси Y. Лежащий персонаж может быть на X или Z. Если модель имеет смещение от начала координат, objOffsetVec3 необходим для выравнивания символьного контроллера с объектом. Если объект не обращен лицом вниз к положительной оси Z, используйте objOrientationVec3 для настройки. Шкала приседания регулирует размер капсулы приседания в соответствии с высотой вашей модели приседания.
     *
     * @param int $objID идентификатор объекта
     * @param int $axis 0 = Ось X, 1= ось Y, 2 = ось Z,
     * @param int $objOffsetVec3 Этот вектор составляет половину суммы, которую модель смещает от начала координат.
     * @param int $objOrientationVec3 Этот вектор используется для выравнивания вращения вашей модели с контроллером символов.
     * @param float $crouchScale Процентная величина для масштабирования скорченной капсулы в соответствии с согнутой моделью.
     * @return void
     */
    function Create3DPhysicsCharacterController($objID, $axis, $objOffsetVec3, $objOrientationVec3, $crouchScale)
    {
    }

    /**
     *Удаляет существующее физическое тело и создает динамическое тело для объекта с коробчатой формой столкновения и массой 5,0 В зависимости от размера объекта.
     *
     * @param int $objID идентификатор объекта
     * @return void
     */
    function Create3DPhysicsDynamicBody($objID)
    {
    }

    /**
     *Создает конусообразное скручивающее соединение между объектами а и в. Параметр rotationVec3 должен быть осью в виде (0,1,0) для вертикали, (1,0,0) для горизонтали вдоль оси X, (0,0,1) для горизонтали вдоль оси Z или любой их комбинации. Вектор вращения не нуждается в нормализации. Шарнир будет вращаться вдоль заданной оси и свободно вращаться внутри конуса вдоль этой оси. Пределы конуса можно задать с помощью Set3DPhysicsJointConeTwistLimits. Возвращает идентификатор соединения.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $positionVec3 векторный ИДЕНТИФИКАТОР
     * @param int $rotationVec3 векторный ИДЕНТИФИКАТОР
     * @param int $disableCollisions 1 = коллизии будут отключены между связанными объектами, 0 коллизий будут включены между связанными объектами.
     * @return int
     */
    function Create3DPhysicsConeTwistJoint($objA, $objB, $positionVec3, $rotationVec3, $disableCollisions)
    {
    }

    /**
     *Создает соединение 6 степеней свободы между объектами a и b. Возвращает идентификатор соединения.
     *
     * @param int $objA первый идентификатор объекта
     * @param int $objB второй идентификатор объекта
     * @param int $positionVec3 векторный ИДЕНТИФИКАТОР
     * @param float $rotationVec3 векторный ИДЕНТИФИКАТОР
     * @return int
     */
    function Create3DPhysics6DOFJoint($objA, $objB, $positionVec3, $rotationVec3)
    {
    }

    /**
     *Создает излучатель частиц с заданным идентификатором и заданным местоположением в мировых координатах. Излучатели частиц создают поток маленьких спрайтов, которые длятся фиксированное количество времени, прежде чем исчезнуть. Частицы могут подвергаться воздействию сил в течение своей жизни с помощью Add3DParticlesForce. Они также могут менять цвет с течением времени с помощью Add3DParticleColorKeyFrame. Частицы не могут быть изменены по отдельности и вести себя как группа, используя одну и ту же текстуру. Это позволяет AGK рисовать их более эффективно, чем аналогичное количество обычных объектов.
     *
     * @param float $x Координата x для позиционирования этого излучателя.
     * @param float $y Координата y для позиционирования этого излучателя.
     * @param float $z Координата z для позиционирования этого излучателя.
     * @return int
     */
    function Create3DParticles($x, $y, $z)
    {
    }

    /**
     *Создает излучатель частиц с заданным идентификатором и заданным местоположением в мировых координатах. Излучатели частиц создают поток маленьких спрайтов, которые длятся фиксированное количество времени, прежде чем исчезнуть. Частицы могут подвергаться воздействию сил в течение своей жизни с помощью Add3DParticlesForce. Они также могут менять цвет с течением времени с помощью Add3DParticleColorKeyFrame. Частицы не могут быть изменены по отдельности и вести себя как группа, используя одну и ту же текстуру. Это позволяет AGK рисовать их более эффективно, чем аналогичное количество обычных объектов.
     *
     * @param int $ID Идентификатор, используемый при ссылке на этот 3D-излучатель частиц.
     * @param float $x Координата x для позиционирования этого излучателя.
     * @param float $y Координата y для позиционирования этого излучателя.
     * @param float $z Координата z для позиционирования этого излучателя.
     * @return void
     */
    function Create3DParticles($ID, $x, $y, $z)
    {
    }

    /**
     *Подсчитывает количество токенов, разделенных указанным разделителем, например строка, содержащая "first:second:third", имеет три токена, разделенных ":". Аналогично CountStringTokens, за исключением того, что эта команда принимает только один символ в качестве разделителя и распознает пустые поля. Например, "first:second::fourth" имеет четыре токена, а третий-пустую строку.
     *
     * @param string $str Строка для проверки.
     * @param string $delimiter Символ, который ограничивает строку
     * @return int
     */
    function CountStringTokens2($str, $delimiter)
    {
    }

    /**
     *Возвращает количество дисков, доступных в данный момент на этих устройствах, применяется только к Windows. Другие платформы вернут 0.
     *
     * @return int
     */
    function CountWindowsDrives()
    {
    }

    /**
     *Подсчитывает количество токенов, разделенных заданным набором разделителей, например строка, содержащая "first:second:third", имеет три токена, разделенных ":" и "first:second;third", имеет три токена, разделенных разделителями ":;". Вы можете иметь несколько разделителей между каждым токеном, например "first:;second:third" является допустимым и имеет три токена. Эта команда полезна для разделения слов в предложении, которое может быть разделено как пробелом, так и пунктуацией.
     *
     * @param string $str Строка для проверки.
     * @param string $delimiters Набор символов, разделяющих строку
     * @return int
     */
    function CountStringTokens($str, $delimiters)
    {
    }

    /**
     *Возвращает косинус значения в радианах.
     *
     * @param float $a Значение, которое нужно передать в функцию косинуса.
     * @return float
     */
    function CosRad($a)
    {
    }

    /**
     *Возвращает косинус значения в градусах.
     *
     * @param float $a Значение, которое нужно передать в функцию косинуса.
     * @return float
     */
    function Cos($a)
    {
    }

    /**
     *Копирует часть данного изображения в новое изображение. Значения x, y, width, height выражены в пикселях и представляют собой часть изображения, которую вы хотите скопировать в новое изображение. Новое изображение будет иметь тот же размер, что и заданные значения ширины и высоты. Если изображение уже существует с заданным новым идентификатором, его необходимо удалить перед вызовом этой команды. Это медленная команда, и ее не следует вызывать каждый кадр.
     *
     * @param int $newImage Идентификатор создаваемого нового образа, этот образ не должен существовать
     * @param int $fromImage Идентификатор изображения для копирования
     * @param int $x Координата x верхнего левого угла поля для копирования
     * @param int $y Координата y верхнего левого угла поля для копирования
     * @param int $width Ширина коробки для копирования
     * @param int $height Высота коробки для копирования
     * @return void
     */
    function CopyImage($newImage, $fromImage, $x, $y, $width, $height)
    {
    }

    /**
     *Копирует часть данного изображения в новое изображение. Значения x, y, width, height выражены в пикселях и представляют собой часть изображения, которую вы хотите скопировать в новое изображение. Новое изображение будет иметь тот же размер, что и заданные значения ширины и высоты. Если изображение уже существует с заданным новым идентификатором, его необходимо удалить перед вызовом этой команды. Это медленная команда, и ее не следует вызывать каждый кадр.
     *
     * @param int $fromImage Идентификатор изображения для копирования
     * @param int $x Координата x верхнего левого угла поля для копирования
     * @param int $y Координата y верхнего левого угла поля для копирования
     * @param int $width Ширина коробки для копирования
     * @param int $height Высота коробки для копирования
     * @return int
     */
    function CopyImage($fromImage, $x, $y, $width, $height)
    {
    }

    /**
     *Создает сетевое сообщение, которое является копией существующего сообщения. Он возвращает идентификатор, который можно использовать для взаимодействия с сообщением. Сообщения, созданные таким образом, могут быть прочитаны с самого начала или добавлены, и источником сообщения может быть либо созданное вами сообщение, либо полученное вами. Новое сообщение становится полностью независимым от исходного сообщения и может быть отправлено с помощью SendNetworkMessage, не затрагивая оригинал.
     *
     * @param int $iFromMsgID Идентификатор сообщения для копирования
     * @return int
     */
    function CopyNetworkMessage($iFromMsgID)
    {
    }

    /**
     *Копирует часть одного мемблока в другой. Оба memblocks должны существовать и могут быть разных размеров.
     *
     * @param int $memSrcID Идентификатор memblock для копирования.
     * @param int $memDstID Идентификатор memblock для копирования.
     * @param int $srcOffset Смещение в исходном memblock для начала копирования.
     * @param int $dstOffset Смещение целевого мемблока для копирования.
     * @param int $size Количество байтов для копирования.
     * @return void
     */
    function CopyMemblock($memSrcID, $memDstID, $srcOffset, $dstOffset, $size)
    {
    }

    /**
     *Создает сокет и пытается подключиться к указанному IP-адресу. Это создаст TCP-соединение, которое затем можно будет использовать для отправки и получения данных. Эта команда немедленно вернется и подключится в фоновом режиме, вы должны использовать GetSocketConnected, чтобы проверить, успешно ли подключается сокет или нет. Вы должны указать значение тайм-аута, достаточное для подключения сокета, обычно 3000 миллисекунд-это хорошее значение, но для соединений с высокой задержкой может потребоваться больше времени. Если время ожидания соединения истекло, то эта команда вернет 0. Номер порта должен совпадать с портом прослушивания устройства, к которому вы подключаетесь. Это работает немного по-другому при экспорте в HTML5, он использует WebSocket, который отправляет заголовок стиля HTTP и требует ответа стиля HTTP для подключения.
     *
     * @param int $socketID Идентификатор, который будет использоваться для ссылки на этот сокет позже
     * @param string $szIP IP-адрес для подключения, это может быть IPv4 или IPv6
     * @param int $port TCP-порт для подключения в диапазоне от 1025 до 65535
     * @param int $timeout Время в миллисекундах ожидания перед прерыванием попытки подключения
     * @return int
     */
    function ConnectSocket($socketID, $szIP, $port, $timeout)
    {
    }

    /**
     *Создает сокет и пытается подключиться к указанному IP-адресу. Это создаст TCP-соединение, которое затем можно будет использовать для отправки и получения данных. Эта команда немедленно вернется и подключится в фоновом режиме, вы должны использовать GetSocketConnected, чтобы проверить, успешно ли подключается сокет или нет. Вы должны указать значение тайм-аута, достаточное для подключения сокета, обычно 3000 миллисекунд-это хорошее значение, но для соединений с высокой задержкой может потребоваться больше времени. Если время ожидания соединения истекло, то эта команда вернет 0. Номер порта должен совпадать с портом прослушивания устройства, к которому вы подключаетесь. Это работает немного по-другому при экспорте в HTML5, он использует WebSocket, который отправляет заголовок стиля HTTP и требует ответа стиля HTTP для подключения.
     *
     * @param string $szIP IP-адрес для подключения, это может быть IPv4 или IPv6
     * @param int $port TCP-порт для подключения в диапазоне от 1025 до 65535
     * @param int $timeout Время в миллисекундах ожидания перед прерыванием попытки подключения
     * @return int
     */
    function ConnectSocket($szIP, $port, $timeout)
    {
    }

    /**
     *Ждет завершения обнаружения физических джойстиков, в некоторых системах это может занять несколько секунд, поэтому запускается в отдельном потоке вдоль основного приложения. Если вы не используете ни одну из реальных команд джойстика (включая джойстик AGK), вы можете игнорировать эту команду и позволить обнаружению джойстика завершиться, когда ему заблагорассудится. Однако если вы хотите использовать команды джойстика в своем приложении, вы должны вызвать эту команду, чтобы убедиться, что общее количество подключенных джойстиков найдено. После этого первоначального процесса обнаружения подключение дополнительных джойстиков не будет обнаружено.
     *
     * @return void
     */
    function CompleteRawJoystickDetection()
    {
    }

    /**
     *Возвращает 1, если две строки равны друг другу, в противном случае возвращает 0. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру. Используйте параметр maxChars, чтобы указать максимальное количество символов для проверки, если строки совпадают после того, как было проверено много символов, то они считаются равными. Используйте значение -1 для проверки всех символов независимо от длины.
     *
     * @param string $str Первая строка для проверки
     * @param string $str2 Вторая строка для проверки
     * @return int
     */
    function CompareString($str, $str2)
    {
    }

    /**
     *Возвращает 1, если две строки равны друг другу, в противном случае возвращает 0. По умолчанию этот параметр не чувствителен к регистру, используйте параметр IgnoreCase для установки чувствительности к регистру. Используйте параметр maxChars, чтобы указать максимальное количество символов для проверки, если строки совпадают после того, как было проверено много символов, то они считаются равными. Используйте значение -1 для проверки всех символов независимо от длины.
     *
     * @param string $str Первая строка для проверки
     * @param string $str2 Вторая строка для проверки
     * @param int $ignoreCase 1-игнорировать регистр при сравнении, 0
     * @param int $maxChars Количество символов для проверки, минус 1 для всех
     * @return int
     */
    function CompareString($str, $str2, $ignoreCase, $maxChars)
    {
    }

    /**
     *Закрывает zip-файл, открытый с помощью CreateZip. Это завершает работу zip-файла и позволяет открыть его для извлечения.
     *
     * @param int $zipID Идентификатор zip-файла, который нужно закрыть.
     * @return void
     */
    function CloseZip($zipID)
    {
    }

    /**
     *Закрывает ранее открытую папку и освобождает список файлов, который был сгенерирован для нее. Фактические изменения файловой системы не производятся, то есть папка не удерживается открытой в файловой системе. Папка читается полностью во время OpenRawFolder, поэтому она не должна существовать в файловой системе после вызова этой команды.
     *
     * @param int $ID Идентификатор папки для закрытия
     * @return void
     */
    function CloseRawFolder($ID)
    {
    }

    /**
     *Отключается от указанной сети. Идентификатор освобождается и больше не может использоваться в других сетевых командах.
     *
     * @param int $iNetID Идентификатор сети, от которой требуется отключиться.
     * @return void
     */
    function CloseNetwork($iNetID)
    {
    }

    /**
     *Закрывает соединение с сервером, дальнейшие соединения могут быть созданы, если вы снова вызовете SetHTTPHost.
     *
     * @param int $iHTTP Идентификатор соединения для закрытия.
     * @return void
     */
    function CloseHTTPConnection($iHTTP)
    {
    }

    /**
     *Закрывает файл и очищает идентификатор, используемый для его создания, никакие другие команды файла не могут быть вызваны с этим идентификатором.
     *
     * @param int $iFileID Идентификатор файла для закрытия
     * @return void
     */
    function CloseFile($iFileID)
    {
    }

    /**
     *Клонирует спрайт в заданный идентификатор спрайта. Новый спрайт будет находиться точно в том же положении, что и оригинал. Любые физические значения или формы, присвоенные спрайту, не будут скопированы. Новый спрайт не будет настроен на физику.
     *
     * @param int $iSpriteIndex Идентификатор, который будет использоваться для нового спрайта.
     * @param int $iOtherSprite Идентификатор спрайта для копирования.
     * @return void
     */
    function CloneSprite($iSpriteIndex, $iOtherSprite)
    {
    }

    /**
     *Клонирует спрайт в заданный идентификатор спрайта. Новый спрайт будет находиться точно в том же положении, что и оригинал. Любые физические значения или формы, присвоенные спрайту, не будут скопированы. Новый спрайт не будет настроен на физику.
     *
     * @param int $iOtherSprite Идентификатор спрайта для копирования.
     * @return int
     */
    function CloneSprite($iOtherSprite)
    {
    }

    /**
     *Копирует объект в новый идентификатор, новый объект полностью отделен от исходного объекта. Клонирование экземпляра объекта приведет к созданию другого экземпляра, который совместно использует данные вершин с исходным объектом.
     *
     * @param int $newobjID Идентификатор нового объекта.
     * @param int $objID Идентификатор объекта для копирования.
     * @return void
     */
    function CloneObject($newobjID, $objID)
    {
    }

    /**
     *Копирует объект в новый идентификатор, новый объект полностью отделен от исходного объекта. Клонирование экземпляра объекта приведет к созданию другого экземпляра, который совместно использует данные вершин с исходным объектом.
     *
     * @param int $objID Идентификатор объекта для копирования.
     * @return int
     */
    function CloneObject($objID)
    {
    }

    /**
     *Очищает сохраненный в данный момент текст схемы URL - адреса, чтобы вы могли сигнализировать о том, что действовали в соответствии с ним. Это не обязательно, но может сделать ваш код проще, если вам не нужно помнить, что вы имели дело с событием схемы URL.
     *
     * @return void
     */
    function ClearURLSchemeText()
    {
    }

    /**
     *Опустошает цепочку всех подростков и останавливает тех, кто бежал. Любые подростки, которые были добавлены к нему, не затрагиваются и могут быть использованы в будущих цепочках.
     *
     * @param int $chainID Идентификатор цепочки твинов для очистки
     * @return void
     */
    function ClearTweenChain($chainID)
    {
    }

    /**
     *Удаляет все дополнительные фигуры, примененные к спрайту, и сохраняет только базовую фигуру в shapeID 1.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @return void
     */
    function ClearSpriteShapes($iSpriteIndex)
    {
    }

    /**
     *Удаляет все анимационные кадры из спрайта, возвращая его в один спрайт изображения. Если вы добавили изображения по отдельности в спрайт с помощью AddSpriteAnimationFrame, то изображение спрайта будет неопределенным, и рекомендуется назначить ему новое изображение.
     *
     * @param int $iSpriteIndex Идентификатор спрайта нужно очистить.
     * @return void
     */
    function ClearSpriteAnimationFrames($iSpriteIndex)
    {
    }

    /**
     *Очищает все модификаторы размера, которые были назначены эмиттеру, частицы будут поддерживать любой размер, который они в настоящее время имеют.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function ClearParticlesScales($ID)
    {
    }

    /**
     *Очищает все силы, назначенные этому излучателю. Все силы немедленно перестанут влиять на частицы.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function ClearParticlesForces($ID)
    {
    }

    /**
     *Очищает все цвета, которые были назначены излучателю, частицы будут поддерживать любой цвет, который они имеют в данный момент.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function ClearParticlesColors($ID)
    {
    }

    /**
     *Очищает все силы, назначенные этому излучателю. Все силы немедленно перестанут влиять на частицы.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function Clear3DParticlesForces($ID)
    {
    }

    /**
     *Очищает все модификаторы размера, которые были назначены эмиттеру, частицы будут поддерживать любой размер, который они в настоящее время имеют.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function Clear3DParticlesScales($ID)
    {
    }

    /**
     *Возвращает строку переданного значения Unicode.
     *
     * @param int $unicodevalue Строка для измерения длины
     * @return string
     */
    function Chr($unicodevalue)
    {
    }

    /**
     *Очищает все цвета, которые были назначены излучателю, частицы будут поддерживать любой цвет, который они имеют в данный момент.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @return void
     */
    function Clear3DParticlesColors($ID)
    {
    }

    /**
     *Удаляет все точечные огни.
     *
     * @return void
     */
    function ClearPointLights()
    {
    }

    /**
     *Очищает задний буфер и буфер глубины всего рисунка и заполняет его выбранным прозрачным цветом, установленным SetClearColor. Это не влияет на то, что видно на экране, если только Swap не вызывается для отображения заднего буфера на экран. Это позволяет вам нарисовать некоторые вещи в backbuffer, использовать getImage для хранения результата, а затем ClearScreen для рисования чего-то еще.
     *
     * @return void
     */
    function ClearScreen()
    {
    }

    /**
     *Предоставляет пользователю возможность выбрать файл, хранящийся на его текущей платформе (только для Windows/Mac), например фото или звуковой файл. Если пользователь отменит операцию, будет возвращена пустая строка, в противном случае файл будет скопирован в текущий каталог приложений и возвращено имя файла, чтобы его можно было использовать в вашем приложении. Вы можете указать дополнительный фильтр расширений, чтобы ограничить типы файлов, которые пользователь будет видеть при просмотре. Например, использование фильтра расширения "*.wav" ограничит пользователя выбором файлов .wav. Для нескольких расширений разделите их точкой с запятой, например "*.wav;*.mp3;*.png". Если эта команда используется в tier 2, возвращаемая строка должна быть удалена, когда вы закончите с ней, даже если это пустая строка. Нулевая строка не будет возвращена. Если вы установите returnFullPath равным 1, то файл не будет скопирован в папку записи, вместо этого вам будет возвращен полный путь, и вы можете загрузить его с помощью префикса "raw:" с обычными файловыми командами.
     *
     * @param string $ext Расширения, позволяющие
     * @return string
     */
    function ChooseRawFile($ext)
    {
    }

    /**
     *Предоставляет пользователю возможность выбрать файл, хранящийся на его текущей платформе (только для Windows/Mac), например фото или звуковой файл. Если пользователь отменит операцию, будет возвращена пустая строка, в противном случае файл будет скопирован в текущий каталог приложений и возвращено имя файла, чтобы его можно было использовать в вашем приложении. Вы можете указать дополнительный фильтр расширений, чтобы ограничить типы файлов, которые пользователь будет видеть при просмотре. Например, использование фильтра расширения "*.wav" ограничит пользователя выбором файлов .wav. Для нескольких расширений разделите их точкой с запятой, например "*.wav;*.mp3;*.png". Если эта команда используется в tier 2, возвращаемая строка должна быть удалена, когда вы закончите с ней, даже если это пустая строка. Нулевая строка не будет возвращена. Если вы установите returnFullPath равным 1, то файл не будет скопирован в папку записи, вместо этого вам будет возвращен полный путь, и вы можете загрузить его с помощью префикса "raw:" с обычными файловыми командами.
     *
     * @param string $ext Расширения, позволяющие
     * @param int $returnFullPath 1, чтобы вернуть полный путь, 0, чтобы скопировать его в папку записи и вернуть путь к папке записи
     * @return string
     */
    function ChooseRawFile($ext, $returnFullPath)
    {
    }

    /**
     *Только для Android все остальные платформы вернут 1 и ничего не сделают. Проверяет, предоставил ли пользователь вашему приложению указанное разрешение на использование определенных команд Android. Разрешения следующие: "writeExternal" - используется командами SaveSharedVariable и любыми путями "raw:", которые обращаются к SD-карте. "Location" - используется командами GPS "Camera" - используется командой SetDeviceCameraToImage "RecordAudio" - используется командой StartScreenRecording и для канала AR camera Эта команда вернет 0, если у вас нет разрешения и пользователя еще не спросили, вы должны вызвать requestPermission, если вам это нужно. Эта команда возвращает 1 если пользователь находится в процессе запроса разрешения, вы должны дождаться ответа, продолжая вызывать эту команду. Он вернет -1, если пользователь отклонил разрешение, или 2, если пользователь предоставил разрешение. Если пользователь отклоняет ваш запрос, вы можете спросить еще раз, но сначала вы должны объяснить, почему ваше приложение нуждается в нем, чтобы они могли сделать осознанный выбор. Если они все еще отвергают его, вы обычно не должны спрашивать в третий раз. После первой попытки Android предоставит пользователю возможность никогда не разрешать это разрешение. В этом случае эта команда всегда будет возвращать -1, а requestPermission ничего не сделает. Пользователю придется зайти в настройки приложения устройства, чтобы отменить это решение. Любое разрешение, не указанное здесь, не требует от вас запроса разрешения пользователя, оно будет автоматически предоставлено при установке, если ваше приложение этого требует. Все разрешения, которые использует ваше приложение, даже те, которые требуют запроса, должны быть указаны в диалоговом окне экспорта APK, установив соответствующие флажки.
     *
     * @param string $szPermission Разрешение на проверку
     * @return int
     */
    function CheckPermission($szPermission)
    {
    }

    /**
     *Округляет поплавок до следующего по величине целого числа. Это отличается от Trunc при использовании положительных чисел, Trunc( 1.6 ) равен 1, а Ceil( 1.6 ) равен 2.
     *
     * @param float $a Значение для округления.
     * @return int
     */
    function Ceil($a)
    {
    }

    /**
     *Останавливает любое асинхронное извлечение zip-файла, которое выполняется в данный момент, это может занять некоторое время, чтобы закончить текущий файл, а затем он остановится. Как только он завершится, GetZipExtractComplete вернет 1, а GetZipExtractProgress останется на том же значении, на котором он был в данный момент.
     *
     * @return void
     */
    function CancelZipExtract()
    {
    }

    /**
     *Отменяет уведомление, запланированное этим приложением
     *
     * @param int $iID ИДЕНТИФИКАТОР уведомления об отмене
     * @return void
     */
    function CancelLocalNotification($iID)
    {
    }

    /**
     *Очищает буфер глубины всех объектов. Это очистит буфер, даже если очистка глубины была отключена с помощью EnableClearDepth.
     *
     * @return void
     */
    function ClearDepthBuffer()
    {
    }

    /**
     *Пересчитывает COM на основе фигур, прикрепленных к спрайту, если вы переопределили COM, это вернет его обратно в местоположение, определенное AGK. Если COM сильно отличается от точки смещения, спрайт может показаться нестабильным, так как он будет вести себя как несбалансированный волчок.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @return void
     */
    function CalculateSpritePhysicsCOM($iSpriteIndex)
    {
    }

    /**
     *Кэширует полноэкранную видеорекламу награды для последующего отображения с помощью Chartboost. Перед вызовом этой функции вы должны установить данные своего рекламного аккаунта с помощью SetChartboostDetails. И iOS, и Android используют кэширование для предварительной загрузки рекламы перед ее отображением. Если объявление уже было кэшировано, то это ничего не даст. В отличие от AdMob, reward videos не будет автоматически запускать кэширование с помощью Chartboost, если вы не вызовете эту команду. Это связано с тем, что Chartboost использует одни и те же детали как для интерстициальных, так и для наградных видео, поэтому AGK не может заранее знать, какие именно вы используете. Поскольку видеореклама может использовать много мобильных данных, процесс их кэширования не будет запущен автоматически. Вам нужно сделать это только один раз, после того как видеореклама с вознаграждением будет показана, новая будет автоматически кэширована. Сбой в загрузке объявления может быть вызван тем, что у рекламодателя закончились объявления для показа пользователям в определенной стране. Вы можете проверить, ждет ли объявление показа с помощью GetRewardAdLoadedChartboost.
     *
     * @return void
     */
    function CacheRewardAdChartboost()
    {
    }

    /**
     *Преобразует целочисленное значение в строку, содержащую его двоичное представление. Например, Bin(7) вернет строку, содержащую "111". Если вы вызываете эту команду из уровня 2, эта строка должна быть удалена, когда вы закончите с ней.
     *
     * @param int $i Значение Inegert для преобразования в двоичную строку
     * @return string
     */
    function Bin($i)
    {
    }

    /**
     *Возвращает количество байтов в данной строке. Обратите внимание, что для строк, закодированных в UTF-8, это может быть не равно количеству символов в строке, так как каждый символ может использовать до 4 байт. Чтобы определить количество символов в строке, используйте команду Len.
     *
     * @param string $strin Строка для измерения длины
     * @return int
     */
    function ByteLen($strin)
    {
    }

    /**
     *Добавляет локальный файл в zip-файл. Переменная path-это путь к локальному файлу, переменная ZipPath-это путь, который будет использоваться внутри zip-файла, это единственный способ добавить папки в zip-файл (добавив файл с ZipPath, например "folder1/myfile.txt"). Локальный путь к файлу находится относительно текущего каталога, установленного с помощью SetFolder, если только вы не начинаете путь с прямой косой черты, и в этом случае путь будет относительно корня каталога записи на текущей платформе.
     *
     * @param int $zipID Идентификатор zip-файла для добавления.
     * @param string $path Путь к добавляемому файлу.
     * @param string $zipPath Путь к файлу внутри zip-файла.
     * @return void
     */
    function AddZipEntry($zipID, $path, $zipPath)
    {
    }

    /**
     *Преобразует одну символьную строку в значение Unicode, которое она представляет.
     *
     * @param string $strin Строковый символ для преобразования в значение Unicode
     * @return int
     */
    function Asc($strin)
    {
    }

    /**
     *Создает экранный джойстик, которым можно управлять с помощью сенсорного экрана, мыши или другого указательного устройства. Они отделены от физических джойстиков, так что у вас может быть виртуальный джойстик с идентификатором 1 и реальный джойстик с идентификатором 1. У вас может быть до 4 виртуальных джойстиков на экране одновременно. Если виртуальный джойстик находится на экране и при нажатии или касании джойстик захватит это событие, а GetRawMouseLeftState вернет 0 (вверх), и событие касания не будет сгенерировано для этого действия.
     *
     * @param int $index Идентификатор создаваемого виртуального джойстика должен находиться в диапазоне от 1 до 4.
     * @param float $x x-положение центра джойстика в экранных координатах.
     * @param float $y Положение y центра джойстика в экранных координатах.
     * @param float $size Диаметр джойстика в экранных координатах.
     * @return void
     */
    function AddVirtualJoystick($index, $x, $y, $size)
    {
    }

    /**
     *Применяет данный идентификатор анимации к заданному идентификатору текстового объекта с необязательной задержкой и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким текстовым объектам одновременно, просто вызовите эту команду снова с другим идентификатором текстового объекта. Текстовый объект не будет изменен до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на текстовом объекте, текст будет соответствующим образом корректировать свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param int $textID ИДЕНТИФИКАТОР текста для изменения
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainText($chainID, $tweenID, $textID, $delay)
    {
    }

    /**
     *Применяет данный идентификатор анимации к заданному идентификатору спрайта с необязательной задержкой и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким спрайтам одновременно, просто вызовите эту команду снова с другим идентификатором спрайта. Спрайт не будет изменен до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на спрайте, то спрайт соответствующим образом скорректирует свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param int $spriteID Идентификатор изменяемого спрайта
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainSprite($chainID, $tweenID, $spriteID, $delay)
    {
    }

    /**
     *Применяет данный идентификатор анимации к заданному идентификатору объекта с необязательной задержкой и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким объектам одновременно, просто вызовите эту команду снова с другим идентификатором объекта. Объект не будет изменен до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение длительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на объекте, объект соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param int $objectID ИДЕНТИФИКАТОР объекта для изменения
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainObject($chainID, $tweenID, $objectID, $delay)
    {
    }

    /**
     *Добавляет данный пользовательский идентификатор анимации в конец цепочки с необязательной задержкой. Анимация не начнется до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации, она соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainCustom($chainID, $tweenID, $delay)
    {
    }

    /**
     *Применяет заданный идентификатор анимации к заданному символу в текстовом объекте с необязательной задержкой и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким символам одновременно, просто вызовите эту команду снова с другим символом или текстовым идентификатором. Символ не будет изменен до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на символе, то символ соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param int $textID Идентификатор текстового объекта, содержащего символ
     * @param int $charID Индекс изменяемого символа, индексы начинаются с 0
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainChar($chainID, $tweenID, $textID, $charID, $delay)
    {
    }

    /**
     *Добавляет новую форму к спрайту в дополнение к уже имеющимся. Эти дополнительные фигуры применимы только к физическим спрайтам и должны быть добавлены после того, как спрайт был настроен на использование физики. Полигон определяется набором точек (от 2 до 12) относительно смещения текущего спрайта. Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено от этой точки. Точки определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой фигуры. Это приведет к пересчету значений массы и центра масс спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно изменить.
     * @param int $numPoints Количество точек, используемых в полигоне, не менее 2, не более 12.
     * @param int $index Индекс для точек, поэтому вы можете указать индекс 0, 1, 2 и т. Д.
     * @param float $x Положение X для указанной точки.
     * @param float $y Положение Y для указанной точки.
     * @return void
     */
    function AddSpriteShapePolygon($iSpriteIndex, $numPoints, $index, $x, $y)
    {
    }

    /**
     *Добавляет новую форму к спрайту в дополнение к уже имеющимся. Эти дополнительные фигуры применимы только к физическим спрайтам и должны быть добавлены после того, как спрайт был настроен на использование физики. Окружность определяется путем указания ее центральной точки относительно текущего смещения спрайта и радиуса. Например, если круг должен быть центрирован в точке смещения спрайта, он будет указан в позиции 0,0. Любое другое значение будет смещать круг от спрайта. Радиус определяется в координатах x, поскольку мировые координаты не обязательно представляют размер элементов на экране (например, 10 единиц в X могут быть не такими же видимыми размерами, как 10 единиц в Y). Это приведет к пересчету значений массы и центра масс спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата X центра окружности в спрайтовом пространстве.
     * @param float $y Координата Y центра окружности в спрайтовом пространстве.
     * @param float $radius Радиус окружности.
     * @return void
     */
    function AddSpriteShapeCircle($iSpriteIndex, $x, $y, $radius)
    {
    }

    /**
     *Добавляет новую форму к спрайту в дополнение к уже имеющимся. Фигуры могут быть добавлены, даже если спрайт не настроен на физику. Цепочка определяется набором точек (не менее 2) относительно смещения текущего спрайта. Например, точка 0,0 будет центрирована на точке смещения спрайта, любое другое значение будет смещено от этой точки. Цепи являются жесткими и могут быть использованы для создания полых вогнутых полигонов или 2D-ландшафтов. Установите параметр loop равным 1, чтобы соединить два конца цепочки вместе, создав полый многоугольник. Точки определяются по одной за раз, вызывая эту команду несколько раз, с индексом, начинающимся с 0. Как только индекс равен numPoints-1, фигура будет создана с использованием ранее определенных точек. Как только вы начнете определять точки, вы должны завершить процесс, достигнув index=numPoints-1, прежде чем определять точки для любой другой фигуры. Это приведет к пересчету значений массы и центра масс спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param int $numPoints Количество точек для использования в цепочке, минимум 2, максимум нет.
     * @param int $index Индекс точки для установки, если он равен numPoints-1, то будет создана фигура
     * @param int $loop 1=соедините это обратно с первой точкой, создавая петлю, 0=оставьте эту точку висеть на конце (по умолчанию)
     * @param float $x Положение X для указанной точки.
     * @param float $y Положение Y для указанной точки.
     * @return void
     */
    function AddSpriteShapeChain($iSpriteIndex, $numPoints, $index, $loop, $x, $y)
    {
    }

    /**
     *Создает экранную кнопку, которой можно управлять с помощью сенсорного экрана, мыши или другого указательного устройства. Они отделены от физических кнопок джойстика или клавиш клавиатуры, так что у вас может быть виртуальная кнопка с идентификатором 1 и реальная кнопка джойстика с идентификатором 1. У вас может быть до 100 виртуальных кнопок на экране одновременно. Если виртуальная кнопка находится на экране и нажата или тронута, то кнопка захватит это событие, а GetRawMouseLeftState вернет 0 (вверх), и событие касания не будет сгенерировано для этого действия.
     *
     * @param int $index Идентификатор виртуальной кнопки, которую нужно создать, должен находиться в диапазоне от 1 до 100.
     * @param float $x x-положение центра кнопки в координатах экрана.
     * @param float $y Положение y центра кнопки в координатах экрана.
     * @param float $size Диаметр кнопки в экранных координатах.
     * @return void
     */
    function AddVirtualButton($index, $x, $y, $size)
    {
    }

    /**
     *Добавляет новую форму к спрайту в дополнение к уже имеющимся. Эти дополнительные фигуры применимы только к физическим спрайтам и должны быть добавлены после того, как спрайт был настроен на использование физики. Поле определяется путем указания его верхних левых и нижних правых координат в пространстве спрайтов относительно его текущего смещения. Например, если текущее смещение спрайта равно 0,0, то верхний левый угол коробки будет равен 0,0, но если смещение спрайта равно середине спрайта (по умолчанию), то верхний левый угол будет равен-width/2,-height/2. Вы также можете указать угол смещения коробки относительно текущего поворота спрайта. Это приведет к пересчету значений массы и центра масс спрайта.
     *
     * @param int $iSpriteIndex Идентификатор спрайта для изменения.
     * @param float $x Координата X верхнего левого угла нового окна в пространстве спрайтов.
     * @param float $y Координата Y верхнего левого угла нового окна в пространстве спрайтов.
     * @param float $x2 Координата X в правом нижнем углу нового окна в пространстве спрайтов.
     * @param float $y2 Координата Y в правом нижнем углу нового окна в пространстве спрайтов.
     * @param float $angle Угол коробки в радианах.
     * @return void
     */
    function AddSpriteShapeBox($iSpriteIndex, $x, $y, $x2, $y2, $angle)
    {
    }

    /**
     *Добавляет изменение размера в определенный момент жизни частицы. Значения шкалы относительны к значению, заданному SetParticlesSize, поэтому шкала 2 означает удвоение ее нормального размера, а 0,5-половину ее нормального размера. Масштаб, добавленный со временем=1, сделает частицу равной заданному размеру, когда она была жива в течение 1 секунды. Частица постепенно преобразуется из своего текущего размера в следующий.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время, за которое частицы должны стать такого размера.
     * @param float $scale Масштаб относительно нормального размера частиц должен быть больше или равен 0.
     * @return void
     */
    function AddParticlesScaleKeyFrame($ID, $time, $scale)
    {
    }

    /**
     *Добавляет изображение в спрайт в качестве нового анимационного кадра. Индексы фреймов начинаются с 1 и постепенно увеличиваются. Это изображение может быть совместно использовано несколькими спрайтами либо в виде отдельных изображений, либо в виде анимационных кадров, а также может быть частью текстуры атласа. В качестве альтернативы, если у вас есть все ваши анимационные кадры на одном изображении, вы можете использовать более быстрый SetSpriteAnimation, который позволяет избежать изменений изображения во время рендеринга, изменяя UV-координаты для изменения кадра.
     *
     * @param int $iSpriteIndex Идентификатор спрайта, который нужно установить для анимации.
     * @param int $iImageIndex Идентификатор добавляемого изображения.
     * @return void
     */
    function AddSpriteAnimationFrame($iSpriteIndex, $iImageIndex)
    {
    }

    /**
     *Добавляет силу, которая будет действовать в данный момент в жизни каждой частицы. Например, сила, установленная для начала в момент времени 2 и окончания в момент времени 3, начнет воздействовать на частицы, когда они будут живы в течение 2 секунд. Он будет продолжать действовать на эти частицы до тех пор, пока они не оживут в течение 3 секунд. Влияние силы определяется величинами x и y, которые представляют ускорение в единицах в секунду. Например, сила с x=5 будет регулировать горизонтальную скорость частицы, добавляя 5 единиц за каждую секунду, когда сила активна, если сила активна только в течение 0,5 секунды, то частица будет двигаться на 2,5 единицы в секунду быстрее вправо. Несколько сил могут действовать на частицу одновременно, если их временные интервалы перекрываются.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $starttime Время в жизни частицы, в которое эта сила должна начать действовать.
     * @param float $endtime Время в жизни частицы, в которое эта сила должна прекратить свое действие.
     * @param float $x х-составляющая влияния силы на скорость частицы в единицах в секунду.
     * @param float $y y-составляющая влияния силы на скорость частицы в единицах в секунду.
     * @return void
     */
    function AddParticlesForce($ID, $starttime, $endtime, $x, $y)
    {
    }

    /**
     *Добавляет изменение цвета в определенный момент жизни частицы. Например, цвет, добавленный со временем=1, сделает частицу равной данному цвету, когда она была жива в течение 1 секунды. Если цветовая интерполяция включена с помощью SetParticlesColorInterpolation, частица постепенно преобразуется из своего текущего цвета в следующий. Например, если вы добавите три цвета: красный, когда время=1, зеленый, когда время=2, и синий, когда время=3, то частица начнет свою жизнь как красный (поскольку это ближайший цвет) и останется полностью красной, пока ей не исполнится 1 секунда. Когда частице от 1 до 2 секунд, она будет постепенно меняться с красного на зеленый, пока ей не исполнится 2 секунды, в этот момент она полностью зеленая. Когда частице от 2 до 3 секунд, она будет постепенно меняться от зеленого до синего, пока ей не исполнится 3 секунды, в этот момент она полностью синяя. Частица останется полностью синей до конца своей жизни, так как никакие другие цвета не были добавлены.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время, когда частицы должны стать такого цвета.
     * @param int $red Красная составляющая нового цвета.
     * @param int $green Зеленая составляющая нового цвета.
     * @param int $blue Синий компонент нового цвета.
     * @param int $alpha Альфа-компонент нового цвета.
     * @return void
     */
    function AddParticlesColorKeyFrame($ID, $time, $red, $green, $blue, $alpha)
    {
    }

    /**
     *Добавляет форму столкновения сфер к составной форме. Сначала установите форму объектов в составную форму столкновения с помощью SetObjectShapeCompound().
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора вектора с мировым положением для центра фигуры.
     * @param float $diameter размер формы сферы
     * @return void
     */
    function AddObjectShapeSphere($objID, $positionVec3, $diameter)
    {
    }

    /**
     *Добавляет форму столкновения цилиндров к сложной форме. Сначала установите форму объектов в составную форму столкновения с помощью SetObjectShapeCompound().
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора вектора с мировым положением для центра фигуры.
     * @param int $rotationVec3 Вектор ID вектора с мировым вращением фигуры.
     * @param int $sizeVec3 Идентификатор вектора вектора с размером фигуры.
     * @param int $axis 0 = ось X, 1 = ось Y, 2 = ось Z.
     * @return void
     */
    function AddObjectShapeCylinder($objID, $positionVec3, $rotationVec3, $sizeVec3, $axis)
    {
    }

    /**
     *Добавляет форму столкновения конуса к сложной форме. Сначала установите форму объектов в составную форму столкновения с помощью SetObjectShapeCompound().
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора вектора с мировым положением для центра фигуры.
     * @param int $rotationVec3 Вектор ID вектора с мировым вращением фигуры.
     * @param int $sizeVec3 Идентификатор вектора вектора с размером фигуры.
     * @param int $axis 0 = ось X, 1 = ось Y, 2 = ось Z.
     * @return void
     */
    function AddObjectShapeCone($objID, $positionVec3, $rotationVec3, $sizeVec3, $axis)
    {
    }

    /**
     *Добавляет форму столкновения капсул к сложной форме. Сначала установите форму объектов в составную форму столкновения с помощью SetObjectShapeCompound().
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора вектора с мировым положением для центра фигуры.
     * @param int $rotationVec3 Вектор ID вектора с мировым вращением фигуры.
     * @param int $sizeVec3 Идентификатор вектора вектора с размером фигуры.
     * @param int $axis 0 = ось X, 1 = ось Y, 2 = ось Z.
     * @return void
     */
    function AddObjectShapeCapsule($objID, $positionVec3, $rotationVec3, $sizeVec3, $axis)
    {
    }

    /**
     *Применяет данный идентификатор анимации к данному идентификатору камеры с дополнительной задержкой и добавляет его в конец цепочки. Анимация может быть добавлена к нескольким камерам одновременно, просто вызовите эту команду еще раз с другим идентификатором камеры. Камера не будет изменена до тех пор, пока все предыдущие подростки в этой цепочке не закончат и время задержки не пройдет, после чего анимация начнется с начальных значений и будет двигаться к конечным значениям в течение всей продолжительности анимации. Если конечное значение анимации изменяется во время воспроизведения анимации на камере, камера соответствующим образом настраивает свою интерполяцию. Изменение продолжительности во время игры не определено и не совместимо с цепочками.
     *
     * @param int $chainID ИДЕНТИФИКАТОР цепочки для добавления
     * @param int $tweenID Идентификатор твина для добавления
     * @param int $cameraID Идентификатор камеры для изменения
     * @param float $delay Количество секунд ожидания перед воспроизведением этой анимации при ее срабатывании
     * @return void
     */
    function AddTweenChainCamera($chainID, $tweenID, $cameraID, $delay)
    {
    }

    /**
     *Добавляет форму столкновения коробок к составной форме. Сначала установите форму объектов в составную форму столкновения с помощью SetObjectShapeCompound().
     *
     * @param int $objID идентификатор объекта
     * @param int $positionVec3 Идентификатор вектора вектора с мировым положением для центра фигуры.
     * @param int $rotationVec3 Вектор ID вектора с мировым вращением фигуры.
     * @param int $sizeVec3 Идентификатор вектора вектора с размером фигуры.
     * @return void
     */
    function AddObjectShapeBox($objID, $positionVec3, $rotationVec3, $sizeVec3)
    {
    }

    /**
     *Добавляет новую сетку к объекту, построенному из данного memblock. Первые 4 байта memblock представляют количество вершин в сетке. Вторые 4 байта представляют количество индексов в сетке, это может быть 0, и в этом случае каждые три вершины представляют собой многоугольник, и никакие вершины не могут быть общими. Если число индексов больше 0, то каждые три индекса представляют собой многоугольник, и вершины могут быть разделены между многоугольниками. Индексы начинаются с 0, поэтому индекс 0 ссылается на первую вершину в списке. Третьи 4 байта представляют количество атрибутов на вершину, например, позиция, нормали и УФ-данные-все это потенциальные атрибуты, поэтому вершина, содержащая все три, будет иметь 3 атрибута. Вершина должна иметь атрибут позиции, все остальное необязательно. Четвертые 4 байта представляют размер одной вершины в байтах, это можно вычислить по атрибутивным данным, но дано для удобства. Пятые 4 байта смещены для начала вершинных данных, так что вы можете легко добраться до них. Шестые 4 байта смещены для начала индексных данных, будут равны 0, если индексов нет. После этих 6 значений, начиная со смещения 24, идут данные атрибута вершины. Данные атрибута вершины описывают, как выкладываются данные вершины, например, если они имеют нормали, УФ-данные и т. Д. Для каждого атрибута существует 1 байт типа данных, 1 байт количества компонентов, 1 байт флага нормализации, 1 байт длины строки и X байт строковых данных для имени атрибута. Тип данных будет равен 0 для поплавков (используется почти для всего, например, позиции, нормалей и т. Д.) или 1 для беззнаковых байтов (используется для цветов вершин). Количество компонентов-это количество значений на атрибут, например, позиция имеет 3 компонента, x,y,z, UV - данные имеют 2 компонента, а цвета вершин-4 компонента. Обратите внимание, что любой тип данных unsigned byte должен иметь 4 компонента, даже если некоторые из них не используются. Флаг normalize используется только для типов данных unsigned byte и преобразует значения в диапазоне 0-255 в 0.0-1.0 для использования в шейдере. Обычно флаг нормализации будет равен 1 для атрибутов цвета и 0 для всего остального. Байт длины строки всегда должен быть кратен 4 по соображениям выравнивания, сама строка может иметь немного меньше символов, но всегда округляется до ближайшего кратного 4 для значения длины строки. например, строка длины 5 должна иметь значение длины строки 8. Обратите внимание, что строка из 4 символов имеет нулевой терминатор на конце, что делает ее длиной 5, поэтому, даже если она уже имеет кратное 4 символам значение длины, она должна использовать значение длины 8 из-за нулевого терминатора. Строка имени атрибута будет использоваться шейдером для распознавания данных вершин, имена атрибутов, распознаваемые AGK, - "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights" и "boneindices", однако вы можете добавлять атрибуты с любым именем, которое вам нравится, пока вы пишете соответствующий шейдер с теми же именами. Если вы не используете свой собственный шейдер и вместо этого полагаетесь на AGK для рисования объекта, то вы должны придерживаться приведенных выше имен атрибутов. За атрибутивными данными следуют необработанные вершинные данные, которые обычно начинаются с атрибута "позиция". Это будет 4-байтовый поплавок для позиции X, 4-байтовый поплавок для позиции Y и 4-байтовый поплавок для позиции Z. Это продолжается для каждого атрибута, указанного в атрибутивных данных. Обратите внимание, что цветовые данные всегда будут иметь в общей сложности 4 байта, по 1 байту без знака для каждого цветового канала. Вы можете получить доступ к отдельным вершинам, используя размер вершины, указанный выше, и индекс вершины, например so offset=vertexDataOffset+(vertexIndex*vertexSize). Наконец, это данные индекса, если таковые имеются. Каждый индекс представляет собой 4-байтовое целое число, которое ссылается на вершину в данных вершин. Каждые три индекса представляют собой многоугольник.
     *
     * @param int $objID Идентификатор объекта для изменения
     * @param int $memID Индекс memblock, который будет использоваться для создания новой сетки
     * @return void
     */
    function AddObjectMeshFromMemblock($objID, $memID)
    {
    }

    /**
     *Добавляет строку к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных CreateNetworkMessage, или для сообщений, полученных из сети.
     *
     * @param int $iMsgID Идентификатор сообщения для изменения.
     * @param string $value Строка для добавления в сообщение.
     * @return void
     */
    function AddNetworkMessageString($iMsgID, $value)
    {
    }

    /**
     *Добавляет поплавок к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных CreateNetworkMessage, или для сообщений, полученных из сети.
     *
     * @param int $iMsgID Идентификатор сообщения для изменения.
     * @param float $value Значение, которое нужно добавить к сообщению.
     * @return void
     */
    function AddNetworkMessageFloat($iMsgID, $value)
    {
    }

    /**
     *Добавляет байт без знака к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных CreateNetworkMessage, или для сообщений, полученных из сети.
     *
     * @param int $iMsgID Идентификатор сообщения для изменения.
     * @param int $value Значение, которое нужно добавить к сообщению.
     * @return void
     */
    function AddNetworkMessageByte($iMsgID, $value)
    {
    }

    /**
     *Добавляет указанный заголовок ко всем будущим запросам. Если заголовок уже существует, то его значение будет перезаписано новым значением. Если заголовок является стандартным заголовком, который обычно присутствует, то его значение будет перезаписано значением, которое вы даете. Если заголовок является стандартным заголовком, который обычно присутствует, а значение, которое вы даете, является пустой строкой, то стандартный заголовок будет удален. Не добавляйте двоеточие ни в одно из полей, оно будет добавлено автоматически между ними. Обратите внимание, что эта команда не работает в версии HTML5.
     *
     * @param int $iHTTP Идентификатор соединения для изменения.
     * @param string $headerName Имя устанавливаемого заголовка, например "Content-Type"
     * @param string $headerValue Новое значение для заголовка
     * @return void
     */
    function AddHTTPHeader($iHTTP, $headerName, $headerValue)
    {
    }

    /**
     *Добавляет целое число к ранее созданному сетевому сообщению. Это может быть вызвано для сообщений, созданных CreateNetworkMessage, или для сообщений, полученных из сети.
     *
     * @param int $iMsgID Идентификатор сообщения для изменения.
     * @param int $value Значение, которое нужно добавить к сообщению.
     * @return void
     */
    function AddNetworkMessageInteger($iMsgID, $value)
    {
    }

    /**
     *Добавляет силу, которая будет действовать в данный момент в жизни каждой частицы. Например, сила, установленная для начала в момент времени 2 и окончания в момент времени 3, начнет воздействовать на частицы, когда они будут живы в течение 2 секунд. Он будет продолжать действовать на эти частицы до тех пор, пока они не оживут в течение 3 секунд. Влияние силы определяется величинами x, y и z, которые представляют ускорение в единицах в секунду. Например, сила с x=5 будет регулировать горизонтальную скорость частицы, добавляя 5 единиц за каждую секунду, когда сила активна, если сила активна только в течение 0,5 секунды, то частица будет двигаться на 2,5 единицы в секунду быстрее в направлении X. Несколько сил могут действовать на частицу одновременно, если их временные интервалы перекрываются.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $starttime Время в жизни частицы, в которое эта сила должна начать действовать.
     * @param float $endtime Время в жизни частицы, в которое эта сила должна прекратить свое действие.
     * @param float $x х-составляющая влияния силы на скорость частицы в единицах в секунду.
     * @param float $y y-составляющая влияния силы на скорость частицы в единицах в секунду.
     * @param float $z z-составляющая влияния силы на скорость частицы в единицах в секунду.
     * @return void
     */
    function Add3DParticlesForce($ID, $starttime, $endtime, $x, $y, $z)
    {
    }

    /**
     *Добавляет изменение цвета в определенный момент жизни частицы. Например, цвет, добавленный со временем=1, сделает частицу равной данному цвету, когда она была жива в течение 1 секунды. Если цветовая интерполяция включена с помощью Set3DParticlesColorInterpolation, частица постепенно преобразуется из своего текущего цвета в следующий. Например, если вы добавите три цвета: красный, когда время=1, зеленый, когда время=2, и синий, когда время=3, то частица начнет свою жизнь как красный (поскольку это ближайший цвет) и останется полностью красной, пока ей не исполнится 1 секунда. Когда частице от 1 до 2 секунд, она будет постепенно меняться с красного на зеленый, пока ей не исполнится 2 секунды, в этот момент она полностью зеленая. Когда частице от 2 до 3 секунд, она будет постепенно меняться от зеленого до синего, пока ей не исполнится 3 секунды, в этот момент она полностью синяя. Частица останется полностью синей до конца своей жизни, так как никакие другие цвета не были добавлены.
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время, когда частицы должны стать такого цвета.
     * @param int $red Красная составляющая нового цвета.
     * @param int $green Зеленая составляющая нового цвета.
     * @param int $blue Синий компонент нового цвета.
     * @param int $alpha Альфа-компонент нового цвета.
     * @return void
     */
    function Add3DParticlesColorKeyFrame($ID, $time, $red, $green, $blue, $alpha)
    {
    }

    /**
     *Попытка подключения к смарт-часам, подключенным к текущему устройству. Он будет пытаться поддерживать это соединение в течение всего срока службы приложения, например, если часы непарные, а затем отремонтированы, то ваше приложение автоматически подключится к часам. Таким образом, вам нужно только один раз вызвать эту команду в начале вашего приложения.  В настоящее время работает только на iOS. Чтобы создать приложение watch, вам нужно будет использовать Tier 2 project interpreter_ios и добавить в него приложение watch.
     *
     * @param string $szReserved Зарезервированная для будущего использования, должна быть пустой строкой
     * @return void
     */
    function ActivateSmartWatch($szReserved)
    {
    }

    /**
     *Возвращает абсолютное значение, то есть положительную версию числа.
     *
     * @param float $a Значение для преобразования.
     * @return float
     */
    function Abs($a)
    {
    }

    /**
     *Возвращает арктангенс значения в радианах в диапазоне от pi/2 до pi/2.
     *
     * @param float $a Значение, передаваемое в функцию арктангенса.
     * @return float
     */
    function ATanRad($a)
    {
    }

    /**
     *Создает костную капсулу тряпичной куклы между начальным и конечным расположением костей объектов. Возвращает идентификатор кости рэгдолла. Если эта команда не сможет создать кость, она вернет значение -1.
     *
     * @param int $startBoneID объекты bone ID
     * @param int $endBoneID объекты bone ID
     * @param float $diameter размер капсулы, которая будет костью тряпичной куклы.
     * @param int $collisionGroup группа столкновений, к которой принадлежит и этот физический объект.
     * @param int $collisionMask группы столкновений, которые вы хотите замаскировать от столкновения.
     * @return int
     */
    function Add3DPhysicsRagDollBone($startBoneID, $endBoneID, $diameter, $collisionGroup, $collisionMask)
    {
    }

    /**
     *Добавляет изменение размера в определенный момент жизни частицы. Значения шкалы относятся к значению, заданному Set3DParticlesSize, поэтому шкала 2 означает удвоение ее нормального размера, а 0,5-половину ее нормального размера. Масштаб, добавленный со временем=1, заставит частицу постепенно трансформироваться в заданную, пока она не будет жива в течение 1 секунды, когда она будет соответствовать заданному размеру. Затем частица постепенно преобразуется из этого размера в следующий (если следующий размер существует).
     *
     * @param int $ID Идентификатор излучателя для изменения.
     * @param float $time Время, за которое частицы должны стать такого размера.
     * @param float $scale Масштаб относительно нормального размера частиц должен быть больше или равен 0.
     * @return void
     */
    function Add3DParticlesScaleKeyFrame($ID, $time, $scale)
    {
    }

    /**
     *Возвращает угол в градусах между x=0 y=-1 (вверх) и заданным вектором по часовой стрелке. Возвращает значение от 0 до 360. Эта команда является собственностью AGK и полезна в 2D-ситуациях. Если вы ищете эквивалент atan2 в C++, используйте вместо этого команду AGK ATan2.
     *
     * @param float $x X компонент вектора для проверки
     * @param float $y Компонент y вектора для проверки
     * @return float
     */
    function ATanFull($x, $y)
    {
    }

    /**
     *Возвращает угол вектора x,y в радианах в диапазоне от pi до pi. Это точно соответствует функции C++ atan2.
     *
     * @param float $y Значение y для передачи в atan2
     * @param float $x Значение x для передачи в atan2
     * @return float
     */
    function ATan2Rad($y, $x)
    {
    }

    /**
     *Возвращает арктангенс значения в градусах в диапазоне от -90 до 90.
     *
     * @param float $a Значение, передаваемое в функцию арктангенса.
     * @return float
     */
    function ATan($a)
    {
    }

    /**
     *Возвращает арксин значения в градусах.
     *
     * @param float $a Значение, передаваемое в функцию arcsine.
     * @return float
     */
    function ASin($a)
    {
    }

    /**
     *Доступно только на iOS и Android. Эта команда настраивает функции AR устройства, если они доступны. Используйте команду ARGetStatus, чтобы проверить, было ли это успешно. Эта команда должна быть вызвана перед любыми другими командами AR, если установка не удалась, вы можете вызвать эту команду снова, чтобы попытаться выполнить установку снова.  Настройка AR возьмет на себя управление 3D-камерой, включая проекционную матрицу, поэтому любые изменения, внесенные вами в положение камеры, поворот, FOV, будут перезаписаны системой AR при вызове рендеринга или синхронизации. Однако вы все еще можете управлять ближними и дальними значениями камеры с помощью SetCameraRange, который будет сохраняться в системе AR.  При использовании AR и размещении или калибровке 3D - объектов система координат 1 единица AGK равна 1 метру.
     *
     * @return void
     */
    function ARSetup()
    {
    }

    /**
     *Устанавливает режим обнаружения плоскости для AR, по умолчанию он включен. Обнаруженные самолеты можно обнаружить с помощью команды ARGetPlanes.
     *
     * @param int $mode 1=Включить обнаружение плоскости, 0=Выключить обнаружение плоскости
     * @return void
     */
    function ARSetPlaneDetectionMode($mode)
    {
    }

    /**
     *Устанавливает режим оценки освещенности для AR, по умолчанию он включен. Это попытка выработать окружающий свет в реальном мире, чтобы вы могли правильно освещать свои виртуальные объекты.
     *
     * @param int $mode 1=Включить оценку освещенности, 0=Выключить оценку освещенности
     * @return void
     */
    function ARSetLightEstimationMode($mode)
    {
    }

    /**
     *Возвращает угол в радианах между x=0 y=-1 (вверх) и заданным вектором по часовой стрелке. Возвращает значение от 0 до 2*PI. Эта команда является собственностью AGK и полезна в 2D-ситуациях. Если вы ищете эквивалент atan2 в C++, используйте вместо этого команду AGK ATan2Rad.
     *
     * @param float $x X компонент вектора для проверки
     * @param float $y Компонент y вектора для проверки
     * @return float
     */
    function ATanFullRad($x, $y)
    {
    }

    /**
     *Очищает ресурсы, используемые во время тестирования хитов, это должно быть вызвано, когда вы закончите проверку результатов теста хитов. Если вы не вызовете его, то он будет вызван автоматически, когда вы выполните еще один тест попадания или уничтожите сеанс AR.
     *
     * @return void
     */
    function ARHitTestFinish()
    {
    }

    /**
     *Бросает луч в реальный мир и обнаруживает любые попадания с самолетов или точек слежения, обнаруженных в мире. Возвращает количество обнаруженных хитов, хиты будут упорядочены с ближайшим первым. Координаты должны находиться в пространстве экрана, например значения, возвращаемые из GetPointerX и GetPointerY. Когда вы закончите проверку результатов этого теста попадания, вы должны вызвать ARHitTestFinish, чтобы освободить все использованные ресурсы. Если нет, то это будет сделано автоматически при следующем вызове ARHitTest.
     *
     * @param float $screenX Компонент X координаты экрана
     * @param float $screenY Компонент Y координаты экрана
     * @return int
     */
    function ARHitTest($screenX, $screenY)
    {
    }

    /**
     *Возвращает угол вектора x,y в градусах в диапазоне от -180 до 180. Это точно соответствует функции C++ atan2 с градусами.
     *
     * @param float $y Значение y для передачи в atan2
     * @param float $x Значение x для передачи в atan2
     * @return float
     */
    function ATan2($y, $x)
    {
    }

    /**
     *Возвращает арксин значения в радианах.
     *
     * @param float $a Значение, передаваемое в функцию arcsine.
     * @return float
     */
    function ASinRad($a)
    {
    }

    /**
     *Очищает все ресурсы, используемые при вызове ARGetPlanes, вы должны вызвать его, когда закончите проверку результатов. Если нет, то он будет вызван автоматически при следующем вызове ARGetPlanes или уничтожении сеанса AR.
     *
     * @return void
     */
    function ARGetPlanesFinish()
    {
    }

    /**
     *Запрашивает сеанс AR для всех самолетов, отслеживаемых в настоящее время в мире, они обнаруживаются с течением времени, если включен режим ARSetPlaneDetectionMode. Возвращает количество найденных плоскостей. Это может быть использовано для отображения обнаруженных плоскостей пользователю путем создания некоторых плоских объектов с помощью CreateObjectPlane и размещения их в заданном положении, с заданным поворотом и размером. Когда вы закончите проверку результатов, вам следует вызвать ARGetPlanesFinish, чтобы очистить все ресурсы, используемые при проверке.
     *
     * @param int $reserved зарезервировано для будущего использования, должно быть 0
     * @return int
     */
    function ARGetPlanes($reserved)
    {
    }

    /**
     *Возвращает Z-компоненту центра данной плоскости. Эта точка может со временем смещаться относительно реальной картины мира, поэтому ее следует регулярно проверять и обновлять, если вы используете ее для отображения видимого представления плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneZ($index)
    {
    }

    /**
     *Возвращает Y-компоненту центра данной плоскости. Эта точка может со временем смещаться относительно реальной картины мира, поэтому ее следует регулярно проверять и обновлять, если вы используете ее для отображения видимого представления плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneY($index)
    {
    }

    /**
     *Возвращает Z-компоненту размера данной плоскости. Это может быть использовано для масштабирования 3D-объекта в соответствии с визуальным представлением обнаруженной плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneSizeZ($index)
    {
    }

    /**
     *Возвращает компонент X размера данной плоскости. Это может быть использовано для масштабирования 3D-объекта в соответствии с визуальным представлением обнаруженной плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneSizeX($index)
    {
    }

    /**
     *Возвращает Z-компоненту вращения данной плоскости. Это может быть использовано для поворота 3D-объекта в соответствии с визуальным представлением обнаруженной плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneAngleZ($index)
    {
    }

    /**
     *Возвращает Y-компоненту вращения данной плоскости. Это может быть использовано для поворота 3D-объекта в соответствии с визуальным представлением обнаруженной плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneAngleY($index)
    {
    }

    /**
     *Возвращает X-компоненту вращения данной плоскости. Это может быть использовано для поворота 3D-объекта в соответствии с визуальным представлением обнаруженной плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneAngleX($index)
    {
    }

    /**
     *Возвращает текущее состояние процесса настройки AR. 0=ARSetup еще не вызван, -1=AR недоступен на этом устройстве или установка не удалась, -2=Пользователь отклонил установку ARCore, 1=ARCore install in progress, 2=AR setup successful.
     *
     * @return int
     */
    function ARGetStatus()
    {
    }

    /**
     *Возвращает расчетное значение освещенности для текущего кадра, это будет значение от 0.0 до 1.0. Лучше всего использовать это значение для установки цвета окружающего света с помощью SetAmbientColor со значением 1.0, соответствующим значению цвета 255,255,255.
     *
     * @return float
     */
    function ARGetLightEstimate()
    {
    }

    /**
     *Возвращает Z-компоненту заданного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Эта точка должна использоваться только в течение короткого времени, например, для отображения эффекта частицы, так как она будет дрейфовать относительно реального мира. Если вы планируете использовать эту 3D-точку для позиционирования долгоживущего объекта в мире, то вместо этого вы должны создать якорь из этого результата теста попадания, чтобы он не дрейфовал.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestZ($index)
    {
    }

    /**
     *Возвращает компонент Y данного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Эта точка должна использоваться только в течение короткого времени, например, для отображения эффекта частицы, так как она будет дрейфовать относительно реального мира. Если вы планируете использовать эту 3D-точку для позиционирования долгоживущего объекта в мире, то вам следует создать якорь из этого результата теста попадания, чтобы он не дрейфовал.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestY($index)
    {
    }

    /**
     *Возвращает тип обнаруженной поверхности: 1=плоскость, обычно горизонтальная, 0=точка, обычно стена или другой объект, -1=неизвестно.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return int
     */
    function ARGetHitTestType($index)
    {
    }

    /**
     *Возвращает X-компоненту центра данной плоскости. Эта точка может со временем смещаться относительно реальной картины мира, поэтому ее следует регулярно проверять и обновлять, если вы используете ее для отображения видимого представления плоскости.
     *
     * @param int $index Индекс самолета для проверки, начиная с индекса 1
     * @return float
     */
    function ARGetPlaneX($index)
    {
    }

    /**
     *Возвращает Z-компоненту нормали данного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Для плоскостей на земле нормаль будет указывать прямо вверх в трехмерном пространстве, для точек, обнаруженных на стенах или других объектах, нормаль будет указывать в сторону от обнаруженной поверхности.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestNormalZ($index)
    {
    }

    /**
     *Возвращает Y-компоненту нормали данного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Для плоскостей на земле нормаль будет указывать прямо вверх в трехмерном пространстве, для точек, обнаруженных на стенах или других объектах, нормаль будет указывать в сторону от обнаруженной поверхности.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestNormalY($index)
    {
    }

    /**
     *Прикрепляет объект к якорю таким же образом, как работает FixObjectToObject. Положение и вращение объекта будут добавлены к положению и вращению якоря. Так, например, объект в положении 0,0,0 будет находиться непосредственно над положением якоря, тогда как если бы объект имел положение 0,2,0, то объект был бы расположен на 2 метра выше положения якоря. Нет ограничений на количество объектов, которые могут быть прикреплены к якорю, и объекты все еще могут быть прикреплены к объекту, прикрепленному к якорю. Например, объект 1 может быть закреплен на якоре, а объект 2-на объекте 1. Чтобы удалить объект из якоря, вызовите эту команду с идентификатором якоря 0. Затем объект будет помещен в мир в его заданном положении, например, положение 0,0,0 поместит его в начало мира.
     *
     * @param int $objID Идентификатор объекта для фиксации на якоре
     * @param int $anchorID Идентификатор якоря для использования
     * @return void
     */
    function ARFixObjectToAnchor($objID, $anchorID)
    {
    }

    /**
     *Возвращает текущее состояние отслеживания данного якоря. 0=остановлено, 1=приостановлено, 2=отслеживается, -1=не знаю. Якоря могут перестать отслеживать, если камера теряет связь с миром, это может произойти, если камера не видит достаточно объектов, чтобы понять, как движется сцена. Например, глядя на пустую стену. Когда якорь останавливается или приостанавливает отслеживание, он сохраняет свое текущее положение и вращение, но это больше не коррелирует с мировым положением, которое он отслеживал, поэтому якорь может казаться дрейфующим относительно мира. Когда якорь возобновит слежение, он должен вернуться в свое правильное мировое положение.
     *
     * @param int $anchorID Идентификатор якоря для проверки
     * @return int
     */
    function ARGetAnchorStatus($anchorID)
    {
    }

    /**
     *Удаляет указанный якорь и освобождает все ресурсы, которые он использовал. Если какие-либо объекты были прикреплены к якорю при его удалении, то они вернутся в непривязанное состояние и будут помещены в мировые координаты
     *
     * @param int $anchorID Идентификатор якоря для удаления
     * @return void
     */
    function ARDeleteAnchor($anchorID)
    {
    }

    /**
     *Возвращает компонент X данного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Эта точка должна использоваться только в течение короткого времени, например, для отображения эффекта частицы, так как она будет дрейфовать относительно реального мира. Если вы планируете использовать эту 3D-точку для позиционирования долгоживущего объекта в мире, то вместо этого вы должны создать якорь из этого результата теста попадания, чтобы он не дрейфовал.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestX($index)
    {
    }

    /**
     *Возвращает X-компоненту нормали данного результата теста попадания в 3D-пространстве. Результаты теста на попадание упорядочиваются с ближайшим первым, начиная с индекса 1. Для плоскостей на земле нормаль будет указывать прямо вверх в трехмерном пространстве, для точек, обнаруженных на стенах или других объектах, нормаль будет указывать в сторону от обнаруженной поверхности.
     *
     * @param int $index Индекс попадания результата теста проверить, начиная с индекса 1.
     * @return float
     */
    function ARGetHitTestNormalX($index)
    {
    }

    /**
     *You must call this command if you want the AR camera feed to be drawn to the screen. If you do not then the camera will still track as if it were moving around the real world but the camera feed will not be seen inside the app. This may be useful if you want to render a purely virtual reality but still use the AR camera tracking functionality. The best time to call this command is just before calling Render or Sync.
     *
     * @return void
     */
    function ARDrawBackground()
    {
    }

    /**
     *Destroys the AR session and any resources allocated during setup. After you can not call any AR commands, except ARGetStatus and ARSetup. You may call ARSetup to recreate an AR session. There is no limit on the number of times you can create and destroy the AR session.  Currently on Android this command may take up to 5 seconds, apparently this will be improved ina future version of Google's ARCore.
     *
     * @return void
     */
    function ARDestroy()
    {
    }
}
